# Гайд по контрактному программированию

## Философия контрактного программирования

**Принцип**: Код материализует контракты, а не наоборот.

Сначала проектируем контракты (что гарантирует компонент), затем реализуем код.

## Типы контрактов

### 1. Системные контракты

Гарантии системы в целом:
- Что система делает в целом
- Как взаимодействуют подсистемы
- Какая модель консистентности
- Как обрабатываются ошибки

### 2. Компонентные контракты

Гарантии конкретного компонента:
- Основная ответственность компонента
- Интерфейс компонента
- Стратегия реализации

### 3. Формальные контракты

Технические гарантии:
- **@requires** - предусловия
- **@ensures** - постусловия
- **@invariant** - инварианты
- **@modifies** - что изменяется
- **@throws** - исключения

### 4. Бизнесовые контракты

Обоснование зачем:
- Почему нужен контракт
- Какую ценность дает
- Что произойдет при нарушении

## Декомпозиция контрактов

### Процесс проектирования

```
Задача
  ↓
Системный контракт (что должна делать система)
  ↓
Компонентные контракты (какие компоненты нужны)
  ↓
Формальные контракты (детальные гарантии)
  ↓
Бизнесовое обоснование (зачем нужны)
  ↓
Реализация (код)
```

## Пример декомпозиции

### Задача: Добавить функцию сохранения настроек

**Шаг 1: Системный контракт**
```
@system_contract: Система сохраняет настройки пользователя между сессиями
```

**Шаг 2: Компонентный контракт**
```
@component_contract: StorageManager предоставляет метод saveSetting(key, value)
```

**Шаг 3: Формальные контракты**
```
@requires: key непустая строка, value сериализуем
@ensures: Настройка сохранена, генерируется событие 'settings:saved'
@invariant: Структура settings в localStorage всегда валидна
```

**Шаг 4: Бизнесовое обоснование**
```
@why_ensures: Событие позволяет UI обновляться автоматически
@stakeholder_value: Пользователь видит сохраненные настройки после перезагрузки
```

**Шаг 5: Реализация**
```javascript
saveSetting(key, value) {
  // Код реализации
}
```

## Валидация контрактов

### Проверка предусловий (@requires)

```javascript
saveSetting(key, value) {
  // Проверяем @requires
  if (!key || typeof key !== 'string') {
    throw new Error('Key must be a non-empty string');
  }
  
  if (typeof value === 'undefined') {
    throw new Error('Value cannot be undefined');
  }
  
  // Реализация
}
```

### Гарантия постусловий (@ensures)

```javascript
saveSetting(key, value) {
  // ... сохранение ...
  
  // Гарантируем @ensures
  this.eventBus.emit('settings:saved', { key, value });
  
  return true; // Гарантируем успешное сохранение
}
```

### Поддержка инвариантов (@invariant)

```javascript
saveSetting(key, value) {
  const data = this.load();
  
  // Поддерживаем @invariant: структура всегда валидна
  if (!data.settings) {
    data.settings = {};
  }
  
  data.settings[key] = value;
  this.save(data);
}
```

## Важные принципы

1. **Контракты важнее кода** - сначала контракт, потом реализация
2. **Явные контракты** - все гарантии должны быть явными
3. **Проверка контрактов** - код должен проверять @requires
4. **Гарантия выполнения** - код должен выполнять @ensures
5. **Бизнесовое обоснование** - каждый контракт должен иметь @why_*

## Частые ошибки

❌ **Отсутствие проверки @requires**
```javascript
// Неправильно
saveSetting(key, value) {
  data.settings[key] = value; // Нет проверки key
}
```

✅ **Правильно**
```javascript
saveSetting(key, value) {
  if (!key || typeof key !== 'string') {
    throw new Error('Invalid key');
  }
  // ...
}
```

❌ **Контракт не соответствует коду**
```javascript
// @ensures: Событие генерируется всегда
// Но в коде:
if (success) {
  this.eventBus.emit('saved'); // Только при успехе
}
```

✅ **Правильно**
```javascript
// @ensures: Событие генерируется при успешном сохранении
if (success) {
  this.eventBus.emit('saved');
}
```
