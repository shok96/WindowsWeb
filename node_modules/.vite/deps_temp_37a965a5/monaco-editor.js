import "./chunk-ZN7FLMUV.js";
import {
  $,
  AccessibilitySignal,
  Action,
  Action2,
  ActionBar,
  ActionViewItem,
  AsyncIterableProducer,
  BugIndicatingError,
  Button,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CachedFunction,
  CancelSnoozeInlineCompletion,
  CancellationError,
  CancellationToken,
  CancellationTokenSource,
  CancellationTokenSource2,
  CaseSensitiveToggle,
  CharacterSet,
  ClickAction,
  ClipboardEventUtils,
  CodeEditorWidget,
  Codicon,
  Color,
  Command,
  CommandsRegistry,
  CompletionItemKinds,
  ContextKeyEqualsExpr,
  ContextKeyExpr,
  CopyOptions,
  CoreEditingCommands,
  CountBadge,
  CursorColumns,
  CursorMoveCommands,
  CursorState,
  DataTransfers,
  DataUri,
  DebugLocation,
  DebugNameData,
  DeferredPromise,
  Delayer,
  DenseKeyProvider,
  DerivedWithSetter,
  DiffEditorWidget,
  Dimension,
  Disposable,
  DisposableCancellationTokenSource,
  DisposableStore,
  DocumentHighlightKind,
  DocumentPasteTriggerKind,
  DomEmitter,
  DomScrollableElement,
  DynamicCssRules,
  EDITOR_FONT_DEFAULTS,
  EditDeltaInfo,
  EditOperation,
  EditSources,
  EditorAction,
  EditorAction2,
  EditorCommand,
  EditorContextKeys,
  EditorFontLigatures,
  EditorMouseEvent,
  EditorOptions,
  EditorState,
  EditorStateCancellationTokenSource,
  EditorZoom,
  Emitter,
  Emitter2,
  EnterOperation,
  Event,
  EventHelper,
  EventType,
  EventType2,
  Extensions,
  Extensions2,
  FindInput,
  FoldingRangeKind,
  FormattingEdit,
  FuzzyScore,
  FuzzyScoreOptions,
  Gesture,
  GlobalPointerMoveMonitor,
  GlyphMarginLane,
  GlyphRasterizer,
  GoToLineNLS,
  HC_BLACK_THEME_NAME,
  HC_LIGHT_THEME_NAME,
  HSVA,
  HideUnchangedRegionsFeature,
  HighlightedLabel,
  HistoryInputBox,
  HoverAction,
  HoverVerbosityAction,
  HoverWidget,
  IAccessibilityService,
  IAccessibilitySignalService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IDataChannelService,
  IDialogService,
  IEditorProgressService,
  IEditorWorkerService,
  IEnvironmentService,
  IHoverService,
  IInlineCompletionsService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  ILanguageFeatureDebounceService,
  ILanguageFeaturesService,
  ILanguageService,
  ILayoutService,
  IListService,
  ILogService,
  ILoggerService,
  IMarkerData,
  IMarkerDecorationsService,
  IMarkerService,
  IMenuService,
  IModelService,
  INotificationService,
  IOpenerService,
  IProgressService,
  IQuickInputService,
  ISemanticTokensStylingService,
  IStandaloneThemeService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IWorkspaceContextService,
  IWorkspaceTrustManagementService,
  IconLabel,
  IdGenerator,
  InMemoryClipboardMetadataManager,
  IndentAction,
  InjectedTextCursorStops,
  InlayHintKind,
  InlineCompletionDisplayLocationKind,
  InlineCompletionEndOfLifeReasonKind,
  InlineCompletionTriggerKind,
  InlineDecoration,
  InputFocusedContext,
  InspectTokensNLS,
  InvisibleCharacters,
  IsWebContext,
  IsWindowsContext,
  ItemActivation,
  Iterable,
  KeyChord,
  KeyCode,
  KeyCodeChord,
  KeyDownAction,
  KeyMod,
  KeybindingLabel,
  KeybindingsRegistry,
  LRUCache,
  LanguageAgnosticBracketTokens,
  Lazy,
  LcsDiff,
  LineDecoration,
  LineRange,
  LineSource,
  LineTokens,
  LinkedList,
  List,
  LogLevel,
  MarkdownRenderer,
  MarkdownString,
  MarkerSeverity,
  MarkerSeverity2,
  MarkerTag,
  MenuEntryActionViewItem,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  MenuWorkbenchToolBar,
  Mimes,
  ModelDecorationInjectedTextOptions,
  ModelDecorationOptions,
  ModifierKeyEmitter,
  MoveOperations,
  MultiCommand,
  MultiEditorAction,
  MutableDisposable,
  NativeEditContextRegistry,
  NewSymbolNameTag,
  NewSymbolNameTriggerKind,
  NullState,
  OS,
  OffsetRange,
  OrthogonalEdge,
  OverviewRulerLane,
  PLAINTEXT_LANGUAGE_ID,
  PauseableEmitter,
  Permutation,
  PixelRatio,
  Point,
  Position,
  Position2,
  PositionOffsetTransformerBase,
  ProcessedIndentRulesSupport,
  Progress,
  ProviderId,
  QuickCommandNLS,
  QuickHelpNLS,
  QuickOutlineNLS,
  RGBA,
  Range,
  Range2,
  RangeMapping,
  RawContextKey,
  RefCountedDisposable,
  RegexToggle,
  Registry,
  RenderLineInput,
  RenderOptions,
  ReplaceCommand,
  ReplaceCommandThatPreservesSelection,
  ReplaceCommandThatSelectsText,
  ResourceMap,
  ResourceTextEdit,
  RunOnceScheduler,
  Sash,
  Schemas,
  ScrollableElement,
  SearchParams,
  SelectedSuggestionInfo,
  Selection,
  Selection2,
  SelectionDirection,
  Separator,
  Severity,
  ShiftCommand,
  ShowLightbulbIconMode,
  SignatureHelpTriggerKind,
  Sizing,
  SnoozeInlineCompletion,
  SplitView,
  StableEditorScrollState,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StopWatch,
  StringBuilder,
  StringEdit,
  StringReplacement,
  StringText,
  SubmenuAction,
  SubmenuItemAction,
  SymbolKinds,
  TabFocus,
  TernarySearchTree,
  TextBufferTokenizer,
  TextEdit,
  TextLength,
  TextModel,
  TextModelCancellationTokenSource,
  TextModelText,
  TextOnlyMenuEntryActionViewItem,
  TextReplacement,
  ThemeIcon,
  TimeoutTimer,
  Toggle,
  ToggleHighContrastNLS,
  Token,
  TokenArray,
  TokenMetadata,
  TokenizationRegistry,
  TypeOperations,
  URI,
  USUAL_WORD_SEPARATORS,
  UnicodeTextModelHighlighter,
  Uri,
  VSBuffer,
  VS_DARK_THEME_NAME,
  VS_LIGHT_THEME_NAME,
  ViewGpuContext,
  WORKSPACE_EXTENSION,
  WholeWordsToggle,
  Widget,
  WillSaveStateReason,
  WindowIdleValue,
  WordOperations,
  WordPartOperations,
  WorkbenchAsyncDataTree,
  WorkbenchHoverDelegate,
  WorkbenchListFocusContextKey,
  WorkbenchToolBar,
  WorkbenchTreeElementCanCollapse,
  WorkbenchTreeElementCanExpand,
  activeContrastBorder,
  addDisposableListener,
  addStandardDisposableGenericMouseDownListener,
  addStandardDisposableListener,
  alert,
  anyScore,
  append,
  appendRemoveOnDispose,
  applyEditsToRanges,
  applyFontInfo,
  asArray,
  asCssVariable,
  asCssVariableWithDefault,
  assert,
  assertFn,
  assertNever,
  assertReturnsDefined,
  assertType,
  asyncTransaction,
  autorun,
  autorunDelta,
  autorunWithStore,
  basename,
  basename2,
  basenameOrAuthority,
  binarySearch,
  binarySearch2,
  bindContextKey,
  booleanComparator,
  buttonBackground,
  buttonForeground,
  buttonSecondaryBackground,
  buttonSecondaryForeground,
  canLog,
  cancelOnDispose,
  checkAdjacentItems,
  clamp,
  clearNode,
  coalesce,
  combinedDisposable,
  commonPrefixLength,
  commonSuffixLength,
  compare,
  compareBy,
  compareIgnoreCase,
  compareUndefinedSmallest,
  computeIndentLevel,
  constObservable,
  containsRTL,
  containsUppercaseCharacter,
  contrastBorder,
  countEOL,
  createActionViewItem,
  createCSSRule,
  createCancelableAsyncIterableProducer,
  createCancelablePromise,
  createCommandUri,
  createDecorator,
  createHotClass,
  createInstantHoverDelegate,
  createMatches,
  createSingleCallFunction,
  createStyleSheetFromObservable,
  createTrustedTypesPolicy,
  darken,
  debouncedObservable,
  deepClone,
  defaultCountBadgeStyles,
  defaultGenerator,
  defaultInputBoxStyles,
  defaultKeybindingLabelStyles,
  defaultListStyles,
  defaultToggleStyles,
  derived,
  derivedDisposable,
  derivedHandleChanges,
  derivedObservableWithCache,
  derivedOpts,
  descriptionForeground,
  diffInserted,
  diffInsertedLine,
  diffRemoved,
  dirname,
  dirname2,
  disposableObservableValue,
  disposableTimeout,
  dispose,
  distinct,
  editor,
  editorActionListForeground,
  editorActiveLinkForeground,
  editorBackground,
  editorConfigurationBaseNode,
  editorErrorBorder,
  editorErrorForeground,
  editorFindMatchForeground,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindMatchHighlightForeground,
  editorFindRangeHighlightBorder,
  editorForeground,
  editorHoverBackground,
  editorHoverBorder,
  editorHoverForeground,
  editorInfoBorder,
  editorInfoForeground,
  editorInlayHintBackground,
  editorInlayHintForeground,
  editorInlayHintParameterBackground,
  editorInlayHintParameterForeground,
  editorInlayHintTypeBackground,
  editorInlayHintTypeForeground,
  editorSelectionBackground,
  editorSelectionHighlight,
  editorWarningBorder,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editor_api_exports,
  ensureNonNullable,
  equals,
  equalsIfDefined,
  escapeRegExpCharacters,
  extUri,
  extname,
  findFirstIdxMonotonousOrArrLen,
  findFirstMax,
  findFirstMin,
  findLast,
  findLastMax,
  first,
  firstNonWhitespaceIndex,
  foreground,
  format,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider,
  fuzzyScore,
  fuzzyScoreGracefulAggressive,
  generateUuid,
  getActionBarActions,
  getActiveDocument,
  getActiveElement,
  getActiveWindow,
  getAriaLabelForSymbol,
  getBaseLayerHoverDelegate,
  getClientArea,
  getCodeEditor,
  getColumnOfNodeOffset,
  getComputedStyle,
  getDefaultHoverDelegate,
  getDomNodePagePosition,
  getEnterAction,
  getFlatActionBarActions,
  getGoodIndentForLine,
  getHoverAccessibleViewHint,
  getIndentMetadata,
  getLeadingWhitespace,
  getListStyles,
  getMapForWordSeparators,
  getOnTypeFormattingEdits,
  getShadowRoot,
  getStandardTokenTypeAtPosition,
  getTopLeftOffset,
  getTotalHeight,
  getTotalWidth,
  getWindow,
  ghostTextForeground,
  groupBy,
  groupByMap,
  h,
  hasDriveLetter,
  hash,
  hide,
  iconForeground,
  illegalArgument,
  inUntrustedWorkspace,
  indentOfLine,
  init_actions,
  init_actions2,
  init_arrays,
  init_arraysFind,
  init_assert,
  init_async,
  init_brackets,
  init_browser,
  init_buffer,
  init_cache,
  init_cancellation,
  init_characterClassifier,
  init_codeEditorService,
  init_codicons,
  init_collections,
  init_color,
  init_colorRegistry,
  init_colorUtils,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_contextkey,
  init_cursorColumns,
  init_date,
  init_debugLocation,
  init_debugName,
  init_deps,
  init_derivedImpl,
  init_dom,
  init_editorColorRegistry,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorState,
  init_editorWorker,
  init_encodedTokenAttributes,
  init_environment,
  init_eolCounter,
  init_equals,
  init_errors,
  init_event,
  init_extensions,
  init_extpath,
  init_filters,
  init_functional,
  init_hash,
  init_hideUnchangedRegionsFeature,
  init_htmlContent,
  init_iconLabels,
  init_iconLabels2,
  init_indentation,
  init_instantiation,
  init_iterator,
  init_keyCodes,
  init_keybindings,
  init_keybindingsRegistry,
  init_keyboardEvent,
  init_language,
  init_languageConfiguration,
  init_languageConfigurationRegistry,
  init_languageFeatureDebounce,
  init_languageFeatures,
  init_languages,
  init_lazy,
  init_length,
  init_lifecycle,
  init_lineRange,
  init_lineTokens,
  init_linkedList,
  init_log,
  init_map,
  init_mime,
  init_model,
  init_model2,
  init_modesRegistry,
  init_mouseEvent,
  init_network,
  init_nls,
  init_nullTokenize,
  init_numbers,
  init_objects,
  init_observable,
  init_observableCodeEditor,
  init_offsetRange,
  init_parser,
  init_path,
  init_platform,
  init_platform2,
  init_point,
  init_position,
  init_range,
  init_resolverService,
  init_resources,
  init_selection,
  init_smallImmutableSet,
  init_standaloneStrings,
  init_standaloneTheme,
  init_stopwatch,
  init_stringBuilder,
  init_strings,
  init_telemetry,
  init_textLength,
  init_textModel,
  init_textModelEditSource,
  init_textModelSearch,
  init_themables,
  init_theme,
  init_themeService,
  init_tokenizer,
  init_transaction,
  init_types,
  init_uri,
  init_utils,
  init_utils2,
  init_uuid,
  init_window,
  init_wordCharacterClassifier,
  init_wordHelper,
  inputActiveOptionBackground,
  inputActiveOptionBorder,
  inputActiveOptionForeground,
  inputBackground,
  inputBorder,
  inputForeground,
  isActiveElement,
  isAncestor,
  isBasicASCII,
  isCancellationError,
  isCodeEditor,
  isDark,
  isDefined,
  isDiffEditor,
  isDisposable,
  isEmptyMarkdownString,
  isEmptyWorkspaceIdentifier,
  isEqual,
  isFalsyOrEmpty,
  isFalsyOrWhitespace,
  isFirefox,
  isFunction,
  isHTMLElement,
  isHighContrast,
  isHighSurrogate,
  isHotReloadEnabled,
  isIMenuItem,
  isIOS,
  isLinux,
  isLittleEndian,
  isLocalizedString,
  isLocationLink,
  isLowSurrogate,
  isLowerAsciiLetter,
  isMacintosh,
  isMarkdownString,
  isModelDecorationInComment,
  isModelDecorationInString,
  isModelDecorationVisible,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isSingleFolderWorkspaceIdentifier,
  isStandaloneEditorWorkspace,
  isString,
  isUndefined,
  isUpperAsciiLetter,
  isWeb,
  isWindows,
  itemEquals,
  itemsEquals,
  joinPath,
  language,
  languages,
  lastNonWhitespaceIndex,
  lengthAdd,
  lengthGetColumnCountIfZeroLineCount,
  lengthZero,
  lineRangeMappingFromRangeMappings,
  linesDiffComputers,
  listFocusHighlightForeground,
  listHighlightForeground,
  localize,
  localize2,
  mainWindow,
  mapFindFirst,
  mapObservableArrayCached,
  matchesContiguousSubString,
  matchesPrefix,
  matchesScheme,
  matchesSomeScheme,
  matchesSubString,
  matchesWords,
  minimapFindMatch,
  minimapSelectionOccurrenceHighlight,
  mixin,
  n,
  nativeHoverDelegate,
  noBreakWhitespace,
  normalizeIndentation,
  nullTokenize,
  nullTokenizeEncoded,
  numberComparator,
  observableCodeEditor,
  observableConfigValue,
  observableFromEvent,
  observableFromEventOpts,
  observableSignal,
  observableSignalFromEvent,
  observableValue,
  onUnexpectedError,
  onUnexpectedExternalError,
  oneOf,
  openLinkFromMarkdown,
  or,
  originalFSPath,
  overviewRulerFindMatchForeground,
  overviewRulerRangeHighlight,
  overviewRulerSelectionHighlightForeground,
  parseDocument,
  prefixedUuid,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickSelect,
  raceCancellation,
  raceCancellationError,
  rangeIsSingleLine,
  readHotReloadableExport,
  recomputeInitiallyAndOnChange,
  recordChangesLazy,
  registerAction2,
  registerColor,
  registerEditorAction,
  registerEditorCommand,
  registerEditorContribution,
  registerEditorFeature,
  registerIcon,
  registerInstantiatedEditorAction,
  registerModelAndPositionCommand,
  registerMultiEditorAction,
  registerSingleton,
  registerThemingParticipant,
  relativePath,
  removeCSSRulesContainingSelector,
  renderIcon,
  renderLabelWithIcons,
  renderLines,
  renderMarkdown,
  renderViewLine,
  reset,
  reverseOrder,
  runAtThisOrScheduleAtNextAnimationFrame,
  runOnChange,
  runOnChangeWithCancellationToken,
  runOnChangeWithStore,
  runWhenWindowIdle,
  safeIntl,
  score,
  scrollbarShadow,
  sep,
  setVisibility,
  severity_default,
  shouldSynchronizeModel,
  show,
  size,
  splitLines,
  status,
  strictEquals,
  stripIcons,
  structuralEquals,
  subtransaction,
  sum,
  themeColorFromId,
  timeout,
  toDisposable,
  toMultilineTokens2,
  toWorkspaceIdentifier,
  trackFocus,
  transaction,
  transparent,
  trim,
  unicodeHighlightConfigKeys,
  unthemedKeybindingLabelOptions,
  upcast,
  waitForState,
  widgetBorder,
  widgetClose,
  widgetShadow,
  withSelection
} from "./chunk-GZKFHFVC.js";
import {
  __commonJS,
  __esm,
  __export,
  __toESM
} from "./chunk-ZKAWKZG5.js";

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js
var __decorate43, __param43, TreeElement, OutlineElement, OutlineGroup, OutlineModel, IOutlineModelService, OutlineModelService;
var init_outlineModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_iterator();
    init_map();
    init_position();
    init_range();
    init_languageFeatureDebounce();
    init_instantiation();
    init_extensions();
    init_model();
    init_lifecycle();
    init_languageFeatures();
    __decorate43 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param43 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    TreeElement = class {
      remove() {
        this.parent?.children.delete(this.id);
      }
      static findId(candidate, container) {
        let candidateId;
        if (typeof candidate === "string") {
          candidateId = `${container.id}/${candidate}`;
        } else {
          candidateId = `${container.id}/${candidate.name}`;
          if (container.children.get(candidateId) !== void 0) {
            candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
          }
        }
        let id = candidateId;
        for (let i2 = 0; container.children.get(id) !== void 0; i2++) {
          id = `${candidateId}_${i2}`;
        }
        return id;
      }
      static empty(element) {
        return element.children.size === 0;
      }
    };
    OutlineElement = class extends TreeElement {
      constructor(id, parent, symbol) {
        super();
        this.id = id;
        this.parent = parent;
        this.symbol = symbol;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    OutlineGroup = class extends TreeElement {
      constructor(id, parent, label, order) {
        super();
        this.id = id;
        this.parent = parent;
        this.label = label;
        this.order = order;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    OutlineModel = class _OutlineModel extends TreeElement {
      static create(registry, textModel, token) {
        const cts = new CancellationTokenSource(token);
        const result = new _OutlineModel(textModel.uri);
        const provider = registry.ordered(textModel);
        const promises = provider.map((provider2, index) => {
          const id = TreeElement.findId(`provider_${index}`, result);
          const group = new OutlineGroup(id, result, provider2.displayName ?? "Unknown Outline Provider", index);
          return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
            for (const info of result2 || []) {
              _OutlineModel._makeOutlineElement(info, group);
            }
            return group;
          }, (err) => {
            onUnexpectedExternalError(err);
            return group;
          }).then((group2) => {
            if (!TreeElement.empty(group2)) {
              result._groups.set(id, group2);
            } else {
              group2.remove();
            }
          });
        });
        const listener = registry.onDidChange(() => {
          const newProvider = registry.ordered(textModel);
          if (!equals(newProvider, provider)) {
            cts.cancel();
          }
        });
        return Promise.all(promises).then(() => {
          if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
            return _OutlineModel.create(registry, textModel, token);
          } else {
            return result._compact();
          }
        }).finally(() => {
          cts.dispose();
          listener.dispose();
          cts.dispose();
        });
      }
      static _makeOutlineElement(info, container) {
        const id = TreeElement.findId(info, container);
        const res = new OutlineElement(id, container, info);
        if (info.children) {
          for (const childInfo of info.children) {
            _OutlineModel._makeOutlineElement(childInfo, res);
          }
        }
        container.children.set(res.id, res);
      }
      constructor(uri) {
        super();
        this.uri = uri;
        this.id = "root";
        this.parent = void 0;
        this._groups = /* @__PURE__ */ new Map();
        this.children = /* @__PURE__ */ new Map();
        this.id = "root";
        this.parent = void 0;
      }
      _compact() {
        let count = 0;
        for (const [key, group] of this._groups) {
          if (group.children.size === 0) {
            this._groups.delete(key);
          } else {
            count += 1;
          }
        }
        if (count !== 1) {
          this.children = this._groups;
        } else {
          const group = Iterable.first(this._groups.values());
          for (const [, child] of group.children) {
            child.parent = this;
            this.children.set(child.id, child);
          }
        }
        return this;
      }
      getTopLevelSymbols() {
        const roots = [];
        for (const child of this.children.values()) {
          if (child instanceof OutlineElement) {
            roots.push(child.symbol);
          } else {
            roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
          }
        }
        return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
      }
      asListOfDocumentSymbols() {
        const roots = this.getTopLevelSymbols();
        const bucket = [];
        _OutlineModel._flattenDocumentSymbols(bucket, roots, "");
        return bucket.sort((a, b) => Position.compare(Range.getStartPosition(a.range), Range.getStartPosition(b.range)) || Position.compare(Range.getEndPosition(b.range), Range.getEndPosition(a.range)));
      }
      static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
        for (const entry of entries) {
          bucket.push({
            kind: entry.kind,
            tags: entry.tags,
            name: entry.name,
            detail: entry.detail,
            containerName: entry.containerName || overrideContainerLabel,
            range: entry.range,
            selectionRange: entry.selectionRange,
            children: void 0
            // we flatten it...
          });
          if (entry.children) {
            _OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
          }
        }
      }
    };
    IOutlineModelService = createDecorator("IOutlineModelService");
    OutlineModelService = class OutlineModelService2 {
      constructor(_languageFeaturesService, debounces, modelService) {
        this._languageFeaturesService = _languageFeaturesService;
        this._disposables = new DisposableStore();
        this._cache = new LRUCache(15, 0.7);
        this._debounceInformation = debounces.for(_languageFeaturesService.documentSymbolProvider, "DocumentSymbols", { min: 350 });
        this._disposables.add(modelService.onModelRemoved((textModel) => {
          this._cache.delete(textModel.id);
        }));
      }
      dispose() {
        this._disposables.dispose();
      }
      async getOrCreate(textModel, token) {
        const registry = this._languageFeaturesService.documentSymbolProvider;
        const provider = registry.ordered(textModel);
        let data = this._cache.get(textModel.id);
        if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {
          const source = new CancellationTokenSource();
          data = {
            versionId: textModel.getVersionId(),
            provider,
            promiseCnt: 0,
            source,
            promise: OutlineModel.create(registry, textModel, source.token),
            model: void 0
          };
          this._cache.set(textModel.id, data);
          const now = Date.now();
          data.promise.then((outlineModel) => {
            data.model = outlineModel;
            this._debounceInformation.update(textModel, Date.now() - now);
          }).catch((_err) => {
            this._cache.delete(textModel.id);
          });
        }
        if (data.model) {
          return data.model;
        }
        data.promiseCnt += 1;
        const listener = token.onCancellationRequested(() => {
          if (--data.promiseCnt === 0) {
            data.source.cancel();
            this._cache.delete(textModel.id);
          }
        });
        try {
          return await data.promise;
        } finally {
          listener.dispose();
        }
      }
    };
    OutlineModelService = __decorate43([
      __param43(0, ILanguageFeaturesService),
      __param43(1, ILanguageFeatureDebounceService),
      __param43(2, IModelService)
    ], OutlineModelService);
    registerSingleton(
      IOutlineModelService,
      OutlineModelService,
      1
      /* InstantiationType.Delayed */
    );
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js
var InPlaceReplaceCommand;
var init_inPlaceReplaceCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js"() {
    init_selection();
    InPlaceReplaceCommand = class {
      constructor(editRange, originalSelection, text) {
        this._editRange = editRange;
        this._originalSelection = originalSelection;
        this._text = text;
      }
      getEditOperations(model, builder) {
        builder.addTrackedEditOperation(this._editRange, this._text);
      }
      computeCursorState(model, helper) {
        const inverseEditOperations = helper.getInverseEditOperations();
        const srcRange = inverseEditOperations[0].range;
        if (!this._originalSelection.isEmpty()) {
          return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
        }
        return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.css";
var require_inPlaceReplace = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js"(exports) {
    init_async();
    init_errors();
    init_editorState();
    init_editorExtensions();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_textModel();
    init_editorWorker();
    init_nls();
    init_inPlaceReplaceCommand();
    var __decorate116 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param116 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var InPlaceReplaceController_1;
    var _a75;
    var InPlaceReplaceController = (_a75 = class {
      static get(editor2) {
        return editor2.getContribution(InPlaceReplaceController_1.ID);
      }
      constructor(editor2, editorWorkerService) {
        this.editor = editor2;
        this.editorWorkerService = editorWorkerService;
        this.decorations = this.editor.createDecorationsCollection();
      }
      dispose() {
      }
      run(source, up) {
        this.currentRequest?.cancel();
        const editorSelection = this.editor.getSelection();
        const model = this.editor.getModel();
        if (!model || !editorSelection) {
          return void 0;
        }
        let selection = editorSelection;
        if (selection.startLineNumber !== selection.endLineNumber) {
          return void 0;
        }
        const state = new EditorState(
          this.editor,
          1 | 4
          /* CodeEditorStateFlag.Position */
        );
        const modelURI = model.uri;
        if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
          return Promise.resolve(void 0);
        }
        this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
        return this.currentRequest.then((result) => {
          if (!result || !result.range || !result.value) {
            return;
          }
          if (!state.validate(this.editor)) {
            return;
          }
          const editRange = Range.lift(result.range);
          let highlightRange = result.range;
          const diff = result.value.length - (selection.endColumn - selection.startColumn);
          highlightRange = {
            startLineNumber: highlightRange.startLineNumber,
            startColumn: highlightRange.startColumn,
            endLineNumber: highlightRange.endLineNumber,
            endColumn: highlightRange.startColumn + result.value.length
          };
          if (diff > 1) {
            selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
          }
          const command = new InPlaceReplaceCommand(editRange, selection, result.value);
          this.editor.pushUndoStop();
          this.editor.executeCommand(source, command);
          this.editor.pushUndoStop();
          this.decorations.set([{
            range: highlightRange,
            options: InPlaceReplaceController_1.DECORATION
          }]);
          this.decorationRemover?.cancel();
          this.decorationRemover = timeout(350);
          this.decorationRemover.then(() => this.decorations.clear()).catch(onUnexpectedError);
        }).catch(onUnexpectedError);
      }
    }, InPlaceReplaceController_1 = _a75, _a75.ID = "editor.contrib.inPlaceReplaceController", _a75.DECORATION = ModelDecorationOptions.register({
      description: "in-place-replace",
      className: "valueSetReplacement"
    }), _a75);
    InPlaceReplaceController = InPlaceReplaceController_1 = __decorate116([
      __param116(1, IEditorWorkerService)
    ], InPlaceReplaceController);
    var InPlaceReplaceUp = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.up",
          label: localize2(1230, "Replace with Previous Value"),
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 87,
            weight: 100
            /* KeybindingWeight.EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, false);
      }
    };
    var InPlaceReplaceDown = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.down",
          label: localize2(1231, "Replace with Next Value"),
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 89,
            weight: 100
            /* KeybindingWeight.EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, true);
      }
    };
    registerEditorContribution(
      InPlaceReplaceController.ID,
      InPlaceReplaceController,
      4
      /* EditorContributionInstantiation.Lazy */
    );
    registerEditorAction(InPlaceReplaceUp);
    registerEditorAction(InPlaceReplaceDown);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/diffEditorBreadcrumbs/browser/contribution.js
var require_contribution = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/diffEditorBreadcrumbs/browser/contribution.js"(exports) {
    init_arrays();
    init_observable();
    init_hideUnchangedRegionsFeature();
    init_utils2();
    init_languageFeatures();
    init_outlineModel();
    init_lifecycle();
    init_event();
    var __decorate116 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param116 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var DiffEditorBreadcrumbsSource = class DiffEditorBreadcrumbsSource extends Disposable {
      constructor(_textModel, _languageFeaturesService, _outlineModelService) {
        super();
        this._textModel = _textModel;
        this._languageFeaturesService = _languageFeaturesService;
        this._outlineModelService = _outlineModelService;
        this._currentModel = observableValue(this, void 0);
        const documentSymbolProviderChanged = observableSignalFromEvent("documentSymbolProvider.onDidChange", this._languageFeaturesService.documentSymbolProvider.onDidChange);
        const textModelChanged = observableSignalFromEvent("_textModel.onDidChangeContent", Event.debounce((e) => this._textModel.onDidChangeContent(e), () => void 0, 100));
        this._register(autorunWithStore(async (reader, store) => {
          documentSymbolProviderChanged.read(reader);
          textModelChanged.read(reader);
          const src = store.add(new DisposableCancellationTokenSource());
          const model = await this._outlineModelService.getOrCreate(this._textModel, src.token);
          if (store.isDisposed) {
            return;
          }
          this._currentModel.set(model, void 0);
        }));
      }
      getBreadcrumbItems(startRange, reader) {
        const m = this._currentModel.read(reader);
        if (!m) {
          return [];
        }
        const symbols = m.asListOfDocumentSymbols().filter((s) => startRange.contains(s.range.startLineNumber) && !startRange.contains(s.range.endLineNumber));
        symbols.sort(reverseOrder(compareBy((s) => s.range.endLineNumber - s.range.startLineNumber, numberComparator)));
        return symbols.map((s) => ({ name: s.name, kind: s.kind, startLineNumber: s.range.startLineNumber }));
      }
    };
    DiffEditorBreadcrumbsSource = __decorate116([
      __param116(1, ILanguageFeaturesService),
      __param116(2, IOutlineModelService)
    ], DiffEditorBreadcrumbsSource);
    HideUnchangedRegionsFeature.setBreadcrumbsSourceFactory((textModel, instantiationService) => {
      return instantiationService.createInstance(DiffEditorBreadcrumbsSource, textModel);
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.css";
var require_inspectTokens = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js"(exports) {
    init_dom();
    init_color();
    init_lifecycle();
    init_editorExtensions();
    init_languages();
    init_encodedTokenAttributes();
    init_nullTokenize();
    init_language();
    init_standaloneTheme();
    init_standaloneStrings();
    var __decorate116 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param116 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var InspectTokensController_1;
    var _a75;
    var InspectTokensController = (_a75 = class extends Disposable {
      static get(editor2) {
        return editor2.getContribution(InspectTokensController_1.ID);
      }
      constructor(editor2, standaloneColorService, languageService) {
        super();
        this._editor = editor2;
        this._languageService = languageService;
        this._widget = null;
        this._register(this._editor.onDidChangeModel((e) => this.stop()));
        this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
        this._register(TokenizationRegistry.onDidChange((e) => this.stop()));
        this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
      }
      dispose() {
        this.stop();
        super.dispose();
      }
      launch() {
        if (this._widget) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        this._widget = new InspectTokensWidget(this._editor, this._languageService);
      }
      stop() {
        if (this._widget) {
          this._widget.dispose();
          this._widget = null;
        }
      }
    }, InspectTokensController_1 = _a75, _a75.ID = "editor.contrib.inspectTokens", _a75);
    InspectTokensController = InspectTokensController_1 = __decorate116([
      __param116(1, IStandaloneThemeService),
      __param116(2, ILanguageService)
    ], InspectTokensController);
    var InspectTokens = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inspectTokens",
          label: InspectTokensNLS.inspectTokensAction,
          alias: "Developer: Inspect Tokens",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        const controller = InspectTokensController.get(editor2);
        controller?.launch();
      }
    };
    function renderTokenText(tokenText) {
      let result = "";
      for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
        const charCode = tokenText.charCodeAt(charIndex);
        switch (charCode) {
          case 9:
            result += "→";
            break;
          case 32:
            result += "·";
            break;
          default:
            result += String.fromCharCode(charCode);
        }
      }
      return result;
    }
    function getSafeTokenizationSupport(languageIdCodec, languageId) {
      const tokenizationSupport = TokenizationRegistry.get(languageId);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      const encodedLanguageId = languageIdCodec.encodeLanguageId(languageId);
      return {
        getInitialState: () => NullState,
        tokenize: (line, hasEOL, state) => nullTokenize(languageId, state),
        tokenizeEncoded: (line, hasEOL, state) => nullTokenizeEncoded(encodedLanguageId, state)
      };
    }
    var _InspectTokensWidget = class _InspectTokensWidget extends Disposable {
      constructor(editor2, languageService) {
        super();
        this.allowEditorOverflow = true;
        this._editor = editor2;
        this._languageService = languageService;
        this._model = this._editor.getModel();
        this._domNode = document.createElement("div");
        this._domNode.className = "tokens-inspect-widget";
        this._tokenizationSupport = getSafeTokenizationSupport(this._languageService.languageIdCodec, this._model.getLanguageId());
        this._compute(this._editor.getPosition());
        this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));
        this._editor.addContentWidget(this);
      }
      dispose() {
        this._editor.removeContentWidget(this);
        super.dispose();
      }
      getId() {
        return _InspectTokensWidget._ID;
      }
      _compute(position) {
        const data = this._getTokensAtLine(position.lineNumber);
        let token1Index = 0;
        for (let i2 = data.tokens1.length - 1; i2 >= 0; i2--) {
          const t = data.tokens1[i2];
          if (position.column - 1 >= t.offset) {
            token1Index = i2;
            break;
          }
        }
        let token2Index = 0;
        for (let i2 = data.tokens2.length >>> 1; i2 >= 0; i2--) {
          if (position.column - 1 >= data.tokens2[i2 << 1]) {
            token2Index = i2;
            break;
          }
        }
        const lineContent = this._model.getLineContent(position.lineNumber);
        let tokenText = "";
        if (token1Index < data.tokens1.length) {
          const tokenStartIndex = data.tokens1[token1Index].offset;
          const tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
          tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
        }
        reset(this._domNode, $("h2.tm-token", void 0, renderTokenText(tokenText), $("span.tm-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
        append(this._domNode, $("hr.tokens-inspect-separator", { "style": "clear:both" }));
        const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;
        append(this._domNode, $("table.tm-metadata-table", void 0, $("tbody", void 0, $("tr", void 0, $("td.tm-metadata-key", void 0, "language"), $("td.tm-metadata-value", void 0, `${metadata ? metadata.languageId : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "token type"), $("td.tm-metadata-value", void 0, `${metadata ? this._tokenTypeToString(metadata.tokenType) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "font style"), $("td.tm-metadata-value", void 0, `${metadata ? this._fontStyleToString(metadata.fontStyle) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "foreground"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "background"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : "-?-"}`)))));
        append(this._domNode, $("hr.tokens-inspect-separator"));
        if (token1Index < data.tokens1.length) {
          append(this._domNode, $("span.tm-token-type", void 0, data.tokens1[token1Index].type));
        }
        this._editor.layoutContentWidget(this);
      }
      _decodeMetadata(metadata) {
        const colorMap = TokenizationRegistry.getColorMap();
        const languageId = TokenMetadata.getLanguageId(metadata);
        const tokenType = TokenMetadata.getTokenType(metadata);
        const fontStyle = TokenMetadata.getFontStyle(metadata);
        const foreground2 = TokenMetadata.getForeground(metadata);
        const background = TokenMetadata.getBackground(metadata);
        return {
          languageId: this._languageService.languageIdCodec.decodeLanguageId(languageId),
          tokenType,
          fontStyle,
          foreground: colorMap[foreground2],
          background: colorMap[background]
        };
      }
      _tokenTypeToString(tokenType) {
        switch (tokenType) {
          case 0:
            return "Other";
          case 1:
            return "Comment";
          case 2:
            return "String";
          case 3:
            return "RegEx";
          default:
            return "??";
        }
      }
      _fontStyleToString(fontStyle) {
        let r = "";
        if (fontStyle & 1) {
          r += "italic ";
        }
        if (fontStyle & 2) {
          r += "bold ";
        }
        if (fontStyle & 4) {
          r += "underline ";
        }
        if (fontStyle & 8) {
          r += "strikethrough ";
        }
        if (r.length === 0) {
          r = "---";
        }
        return r;
      }
      _getTokensAtLine(lineNumber) {
        const stateBeforeLine = this._getStateBeforeLine(lineNumber);
        const tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), true, stateBeforeLine);
        const tokenizationResult2 = this._tokenizationSupport.tokenizeEncoded(this._model.getLineContent(lineNumber), true, stateBeforeLine);
        return {
          startState: stateBeforeLine,
          tokens1: tokenizationResult1.tokens,
          tokens2: tokenizationResult2.tokens,
          endState: tokenizationResult1.endState
        };
      }
      _getStateBeforeLine(lineNumber) {
        let state = this._tokenizationSupport.getInitialState();
        for (let i2 = 1; i2 < lineNumber; i2++) {
          const tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i2), true, state);
          state = tokenizationResult.endState;
        }
        return state;
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return {
          position: this._editor.getPosition(),
          preference: [
            2,
            1
            /* ContentWidgetPositionPreference.ABOVE */
          ]
        };
      }
    };
    _InspectTokensWidget._ID = "editor.contrib.inspectTokensWidget";
    var InspectTokensWidget = _InspectTokensWidget;
    registerEditorContribution(
      InspectTokensController.ID,
      InspectTokensController,
      4
      /* EditorContributionInstantiation.Lazy */
    );
    registerEditorAction(InspectTokens);
  }
});

// node_modules/monaco-editor/esm/vs/editor/edcore.main.js
var edcore_main_exports = {};
__export(edcore_main_exports, {
  CancellationTokenSource: () => CancellationTokenSource2,
  Emitter: () => Emitter2,
  KeyCode: () => KeyCode,
  KeyMod: () => KeyMod,
  MarkerSeverity: () => MarkerSeverity2,
  MarkerTag: () => MarkerTag,
  Position: () => Position2,
  Range: () => Range2,
  Selection: () => Selection2,
  SelectionDirection: () => SelectionDirection,
  Token: () => Token,
  Uri: () => Uri,
  editor: () => editor,
  languages: () => languages
});

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditor.contribution.js
init_codicons();

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/commands.js
init_dom();
init_codicons();
init_editorExtensions();
init_codeEditorService();
init_editorContextKeys();
init_nls();
init_actions2();
init_configuration();
init_contextkey();
var ToggleCollapseUnchangedRegions = class extends Action2 {
  constructor() {
    super({
      id: "diffEditor.toggleCollapseUnchangedRegions",
      title: localize2(82, "Toggle Collapse Unchanged Regions"),
      icon: Codicon.map,
      toggled: ContextKeyExpr.has("config.diffEditor.hideUnchangedRegions.enabled"),
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      menu: {
        when: ContextKeyExpr.has("isInDiffEditor"),
        id: MenuId.EditorTitle,
        order: 22,
        group: "navigation"
      }
    });
  }
  run(accessor, ...args) {
    const configurationService = accessor.get(IConfigurationService);
    const newValue = !configurationService.getValue("diffEditor.hideUnchangedRegions.enabled");
    configurationService.updateValue("diffEditor.hideUnchangedRegions.enabled", newValue);
  }
};
var ToggleShowMovedCodeBlocks = class extends Action2 {
  constructor() {
    super({
      id: "diffEditor.toggleShowMovedCodeBlocks",
      title: localize2(83, "Toggle Show Moved Code Blocks"),
      precondition: ContextKeyExpr.has("isInDiffEditor")
    });
  }
  run(accessor, ...args) {
    const configurationService = accessor.get(IConfigurationService);
    const newValue = !configurationService.getValue("diffEditor.experimental.showMoves");
    configurationService.updateValue("diffEditor.experimental.showMoves", newValue);
  }
};
var ToggleUseInlineViewWhenSpaceIsLimited = class extends Action2 {
  constructor() {
    super({
      id: "diffEditor.toggleUseInlineViewWhenSpaceIsLimited",
      title: localize2(84, "Toggle Use Inline View When Space Is Limited"),
      precondition: ContextKeyExpr.has("isInDiffEditor")
    });
  }
  run(accessor, ...args) {
    const configurationService = accessor.get(IConfigurationService);
    const newValue = !configurationService.getValue("diffEditor.useInlineViewWhenSpaceIsLimited");
    configurationService.updateValue("diffEditor.useInlineViewWhenSpaceIsLimited", newValue);
  }
};
var diffEditorCategory = localize2(85, "Diff Editor");
var SwitchSide = class extends EditorAction2 {
  constructor() {
    super({
      id: "diffEditor.switchSide",
      title: localize2(86, "Switch Side"),
      icon: Codicon.arrowSwap,
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      f1: true,
      category: diffEditorCategory
    });
  }
  runEditorCommand(accessor, editor2, arg) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor instanceof DiffEditorWidget) {
      if (arg && arg.dryRun) {
        return { destinationSelection: diffEditor.mapToOtherSide().destinationSelection };
      } else {
        diffEditor.switchSide();
      }
    }
    return void 0;
  }
};
var ExitCompareMove = class extends EditorAction2 {
  constructor() {
    super({
      id: "diffEditor.exitCompareMove",
      title: localize2(87, "Exit Compare Move"),
      icon: Codicon.close,
      precondition: EditorContextKeys.comparingMovedCode,
      f1: false,
      category: diffEditorCategory,
      keybinding: {
        weight: 1e4,
        primary: 9
      }
    });
  }
  runEditorCommand(accessor, editor2, ...args) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor instanceof DiffEditorWidget) {
      diffEditor.exitCompareMove();
    }
  }
};
var CollapseAllUnchangedRegions = class extends EditorAction2 {
  constructor() {
    super({
      id: "diffEditor.collapseAllUnchangedRegions",
      title: localize2(88, "Collapse All Unchanged Regions"),
      icon: Codicon.fold,
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      f1: true,
      category: diffEditorCategory
    });
  }
  runEditorCommand(accessor, editor2, ...args) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor instanceof DiffEditorWidget) {
      diffEditor.collapseAllUnchangedRegions();
    }
  }
};
var ShowAllUnchangedRegions = class extends EditorAction2 {
  constructor() {
    super({
      id: "diffEditor.showAllUnchangedRegions",
      title: localize2(89, "Show All Unchanged Regions"),
      icon: Codicon.unfold,
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      f1: true,
      category: diffEditorCategory
    });
  }
  runEditorCommand(accessor, editor2, ...args) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor instanceof DiffEditorWidget) {
      diffEditor.showAllUnchangedRegions();
    }
  }
};
var RevertHunkOrSelection = class extends Action2 {
  constructor() {
    super({
      id: "diffEditor.revert",
      title: localize2(90, "Revert"),
      f1: true,
      category: diffEditorCategory,
      precondition: ContextKeyExpr.has("isInDiffEditor")
    });
  }
  run(accessor, arg) {
    return arg ? this.runViaToolbarContext(accessor, arg) : this.runViaCursorOrSelection(accessor);
  }
  runViaCursorOrSelection(accessor) {
    const diffEditor = findFocusedDiffEditor(accessor);
    if (diffEditor instanceof DiffEditorWidget) {
      diffEditor.revertFocusedRangeMappings();
    }
    return void 0;
  }
  runViaToolbarContext(accessor, arg) {
    const diffEditor = findDiffEditor(accessor, arg.originalUri, arg.modifiedUri);
    if (diffEditor instanceof DiffEditorWidget) {
      diffEditor.revertRangeMappings(arg.mapping.innerChanges ?? []);
    }
    return void 0;
  }
};
var accessibleDiffViewerCategory = localize2(91, "Accessible Diff Viewer");
var _AccessibleDiffViewerNext = class _AccessibleDiffViewerNext extends Action2 {
  constructor() {
    super({
      id: _AccessibleDiffViewerNext.id,
      title: localize2(92, "Go to Next Difference"),
      category: accessibleDiffViewerCategory,
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      keybinding: {
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: true
    });
  }
  run(accessor) {
    const diffEditor = findFocusedDiffEditor(accessor);
    diffEditor?.accessibleDiffViewerNext();
  }
};
_AccessibleDiffViewerNext.id = "editor.action.accessibleDiffViewer.next";
var AccessibleDiffViewerNext = _AccessibleDiffViewerNext;
var _AccessibleDiffViewerPrev = class _AccessibleDiffViewerPrev extends Action2 {
  constructor() {
    super({
      id: _AccessibleDiffViewerPrev.id,
      title: localize2(93, "Go to Previous Difference"),
      category: accessibleDiffViewerCategory,
      precondition: ContextKeyExpr.has("isInDiffEditor"),
      keybinding: {
        primary: 1024 | 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      f1: true
    });
  }
  run(accessor) {
    const diffEditor = findFocusedDiffEditor(accessor);
    diffEditor?.accessibleDiffViewerPrev();
  }
};
_AccessibleDiffViewerPrev.id = "editor.action.accessibleDiffViewer.prev";
var AccessibleDiffViewerPrev = _AccessibleDiffViewerPrev;
function findDiffEditor(accessor, originalUri, modifiedUri) {
  const codeEditorService = accessor.get(ICodeEditorService);
  const diffEditors = codeEditorService.listDiffEditors();
  return diffEditors.find((diffEditor) => {
    const modified = diffEditor.getModifiedEditor();
    const original = diffEditor.getOriginalEditor();
    return modified && modified.getModel()?.uri.toString() === modifiedUri.toString() && original && original.getModel()?.uri.toString() === originalUri.toString();
  }) || null;
}
function findFocusedDiffEditor(accessor) {
  const codeEditorService = accessor.get(ICodeEditorService);
  const diffEditors = codeEditorService.listDiffEditors();
  const activeElement = getActiveElement();
  if (activeElement) {
    for (const d of diffEditors) {
      const container = d.getContainerDomNode();
      if (container.contains(activeElement)) {
        return d;
      }
    }
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditor.contribution.js
init_editorContextKeys();
init_nls();
init_actions2();
init_commands();
init_contextkey();
registerAction2(ToggleCollapseUnchangedRegions);
registerAction2(ToggleShowMovedCodeBlocks);
registerAction2(ToggleUseInlineViewWhenSpaceIsLimited);
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: new ToggleUseInlineViewWhenSpaceIsLimited().desc.id,
    title: localize(116, "Use Inline View When Space Is Limited"),
    toggled: ContextKeyExpr.has("config.diffEditor.useInlineViewWhenSpaceIsLimited"),
    precondition: ContextKeyExpr.has("isInDiffEditor")
  },
  order: 11,
  group: "1_diff",
  when: ContextKeyExpr.and(EditorContextKeys.diffEditorRenderSideBySideInlineBreakpointReached, ContextKeyExpr.has("isInDiffEditor"))
});
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: new ToggleShowMovedCodeBlocks().desc.id,
    title: localize(117, "Show Moved Code Blocks"),
    icon: Codicon.move,
    toggled: ContextKeyEqualsExpr.create("config.diffEditor.experimental.showMoves", true),
    precondition: ContextKeyExpr.has("isInDiffEditor")
  },
  order: 10,
  group: "1_diff",
  when: ContextKeyExpr.has("isInDiffEditor")
});
registerAction2(RevertHunkOrSelection);
for (const ctx of [
  { icon: Codicon.arrowRight, key: EditorContextKeys.diffEditorInlineMode.toNegated() },
  { icon: Codicon.discard, key: EditorContextKeys.diffEditorInlineMode }
]) {
  MenuRegistry.appendMenuItem(MenuId.DiffEditorHunkToolbar, {
    command: {
      id: new RevertHunkOrSelection().desc.id,
      title: localize(118, "Revert Block"),
      icon: ctx.icon
    },
    when: ContextKeyExpr.and(EditorContextKeys.diffEditorModifiedWritable, ctx.key),
    order: 5,
    group: "primary"
  });
  MenuRegistry.appendMenuItem(MenuId.DiffEditorSelectionToolbar, {
    command: {
      id: new RevertHunkOrSelection().desc.id,
      title: localize(119, "Revert Selection"),
      icon: ctx.icon
    },
    when: ContextKeyExpr.and(EditorContextKeys.diffEditorModifiedWritable, ctx.key),
    order: 5,
    group: "primary"
  });
}
registerAction2(SwitchSide);
registerAction2(ExitCompareMove);
registerAction2(CollapseAllUnchangedRegions);
registerAction2(ShowAllUnchangedRegions);
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
  command: {
    id: AccessibleDiffViewerNext.id,
    title: localize(120, "Open Accessible Diff Viewer"),
    precondition: ContextKeyExpr.has("isInDiffEditor")
  },
  order: 10,
  group: "2_diff",
  when: ContextKeyExpr.and(EditorContextKeys.accessibleDiffViewerVisible.negate(), ContextKeyExpr.has("isInDiffEditor"))
});
CommandsRegistry.registerCommandAlias("editor.action.diffReview.next", AccessibleDiffViewerNext.id);
registerAction2(AccessibleDiffViewerNext);
CommandsRegistry.registerCommandAlias("editor.action.diffReview.prev", AccessibleDiffViewerPrev.id);
registerAction2(AccessibleDiffViewerPrev);

// node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.js
init_htmlContent();
init_keyCodes();
init_editorExtensions();
init_selection();
init_editorContextKeys();
init_nls();
init_contextkey();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.css";
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SelectionAnchorController_1;
var SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
var _a;
var SelectionAnchorController = (_a = class {
  static get(editor2) {
    return editor2.getContribution(SelectionAnchorController_1.ID);
  }
  constructor(editor2, contextKeyService) {
    this.editor = editor2;
    this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
    this.modelChangeListener = editor2.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const position = this.editor.getPosition();
      this.editor.changeDecorations((accessor) => {
        if (this.decorationId) {
          accessor.removeDecoration(this.decorationId);
        }
        this.decorationId = accessor.addDecoration(Selection.fromPositions(position, position), {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new MarkdownString().appendText(localize(794, "Selection Anchor")),
          className: "selection-anchor"
        });
      });
      this.selectionAnchorSetContextKey.set(!!this.decorationId);
      alert(localize(795, "Anchor set at {0}:{1}", position.lineNumber, position.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
      if (anchorPosition) {
        this.editor.setPosition(anchorPosition.getStartPosition());
      }
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const start = this.editor.getModel().getDecorationRange(this.decorationId);
      if (start) {
        const end = this.editor.getPosition();
        this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
        this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      const decorationId = this.decorationId;
      this.editor.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
        this.decorationId = void 0;
      });
      this.selectionAnchorSetContextKey.set(false);
    }
  }
  dispose() {
    this.cancelSelectionAnchor();
    this.modelChangeListener.dispose();
  }
}, SelectionAnchorController_1 = _a, _a.ID = "editor.contrib.selectionAnchorController", _a);
SelectionAnchorController = SelectionAnchorController_1 = __decorate([
  __param(1, IContextKeyService)
], SelectionAnchorController);
var SetSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: localize2(796, "Set Selection Anchor"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 32
          /* KeyCode.KeyB */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(_accessor, editor2) {
    SelectionAnchorController.get(editor2)?.setSelectionAnchor();
  }
};
var GoToSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: localize2(797, "Go to Selection Anchor"),
      precondition: SelectionAnchorSet
    });
  }
  async run(_accessor, editor2) {
    SelectionAnchorController.get(editor2)?.goToSelectionAnchor();
  }
};
var SelectFromAnchorToCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: localize2(798, "Select from Anchor to Cursor"),
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 41
          /* KeyCode.KeyK */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(_accessor, editor2) {
    SelectionAnchorController.get(editor2)?.selectFromAnchorToCursor();
  }
};
var CancelSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: localize2(799, "Cancel Selection Anchor"),
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(_accessor, editor2) {
    SelectionAnchorController.get(editor2)?.cancelSelectionAnchor();
  }
};
registerEditorContribution(
  SelectionAnchorController.ID,
  SelectionAnchorController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);

// node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.js
init_async();
init_lifecycle();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_editorContextKeys();
init_model2();
init_textModel();
init_nls();
init_actions2();
init_colorRegistry();
init_themeService();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.css";
var overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", "#A0A0A0", localize(800, "Overview ruler marker color for matching brackets."));
var JumpToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: localize2(802, "Go to Bracket"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 93,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    BracketMatchingController.get(editor2)?.jumpToBracket();
  }
};
var SelectToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: localize2(803, "Select to Bracket"),
      precondition: void 0,
      metadata: {
        description: localize2(804, "Select the text inside and including the brackets or curly braces"),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "selectBrackets": {
                type: "boolean",
                default: true
              }
            }
          }
        }]
      }
    });
  }
  run(accessor, editor2, args) {
    let selectBrackets = true;
    if (args && args.selectBrackets === false) {
      selectBrackets = false;
    }
    BracketMatchingController.get(editor2)?.selectToBracket(selectBrackets);
  }
};
var RemoveBracketsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeBrackets",
      label: localize2(805, "Remove Brackets"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 1,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    BracketMatchingController.get(editor2)?.removeBrackets(this.id);
  }
};
var BracketsData = class {
  constructor(position, brackets, options) {
    this.position = position;
    this.brackets = brackets;
    this.options = options;
  }
};
var _BracketMatchingController = class _BracketMatchingController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_BracketMatchingController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._lastBracketsData = [];
    this._lastVersionId = 0;
    this._decorations = this._editor.createDecorationsCollection();
    this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
    this._matchBrackets = this._editor.getOption(
      80
      /* EditorOption.matchBrackets */
    );
    this._updateBracketsSoon.schedule();
    this._register(editor2.onDidChangeCursorPosition((e) => {
      if (this._matchBrackets === "never") {
        return;
      }
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelLanguageConfiguration((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        80
        /* EditorOption.matchBrackets */
      )) {
        this._matchBrackets = this._editor.getOption(
          80
          /* EditorOption.matchBrackets */
        );
        this._decorations.clear();
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._updateBracketsSoon.schedule();
      }
    }));
    this._register(editor2.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = this._editor.getSelections().map((selection) => {
      const position = selection.getStartPosition();
      const brackets = model.bracketPairs.matchBracket(position);
      let newCursorPosition = null;
      if (brackets) {
        if (brackets[0].containsPosition(position) && !brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[1].getStartPosition();
        } else if (brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[0].getStartPosition();
        }
      } else {
        const enclosingBrackets = model.bracketPairs.findEnclosingBrackets(position);
        if (enclosingBrackets) {
          newCursorPosition = enclosingBrackets[1].getStartPosition();
        } else {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            newCursorPosition = nextBracket.range.getStartPosition();
          }
        }
      }
      if (newCursorPosition) {
        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
      }
      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
    });
    this._editor.setSelections(newSelections);
    this._editor.revealRange(newSelections[0]);
  }
  selectToBracket(selectBrackets) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = [];
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getStartPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
        if (!brackets) {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            brackets = model.bracketPairs.matchBracket(nextBracket.range.getStartPosition());
          }
        }
      }
      let selectFrom = null;
      let selectTo = null;
      if (brackets) {
        brackets.sort(Range.compareRangesUsingStarts);
        const [open, close] = brackets;
        selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
        selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
        if (close.containsPosition(position)) {
          const tmp = selectFrom;
          selectFrom = selectTo;
          selectTo = tmp;
        }
      }
      if (selectFrom && selectTo) {
        newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
      }
    });
    if (newSelections.length > 0) {
      this._editor.setSelections(newSelections);
      this._editor.revealRange(newSelections[0]);
    }
  }
  removeBrackets(editSource) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
      }
      if (brackets) {
        this._editor.pushUndoStop();
        this._editor.executeEdits(editSource, [
          { range: brackets[0], text: "" },
          { range: brackets[1], text: "" }
        ]);
        this._editor.pushUndoStop();
      }
    });
  }
  _updateBrackets() {
    if (this._matchBrackets === "never") {
      return;
    }
    this._recomputeBrackets();
    const newDecorations = [];
    let newDecorationsLen = 0;
    for (const bracketData of this._lastBracketsData) {
      const brackets = bracketData.brackets;
      if (brackets) {
        newDecorations[newDecorationsLen++] = { range: brackets[0], options: bracketData.options };
        newDecorations[newDecorationsLen++] = { range: brackets[1], options: bracketData.options };
      }
    }
    this._decorations.set(newDecorations);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const selections = this._editor.getSelections();
    if (selections.length > 100) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const model = this._editor.getModel();
    const versionId = model.getVersionId();
    let previousData = [];
    if (this._lastVersionId === versionId) {
      previousData = this._lastBracketsData;
    }
    const positions = [];
    let positionsLen = 0;
    for (let i2 = 0, len = selections.length; i2 < len; i2++) {
      const selection = selections[i2];
      if (selection.isEmpty()) {
        positions[positionsLen++] = selection.getStartPosition();
      }
    }
    if (positions.length > 1) {
      positions.sort(Position.compare);
    }
    const newData = [];
    let newDataLen = 0;
    let previousIndex = 0;
    const previousLen = previousData.length;
    for (let i2 = 0, len = positions.length; i2 < len; i2++) {
      const position = positions[i2];
      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
        previousIndex++;
      }
      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
        newData[newDataLen++] = previousData[previousIndex];
      } else {
        let brackets = model.bracketPairs.matchBracket(
          position,
          20
          /* give at most 20ms to compute */
        );
        let options = _BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        if (!brackets && this._matchBrackets === "always") {
          brackets = model.bracketPairs.findEnclosingBrackets(
            position,
            20
            /* give at most 20ms to compute */
          );
          options = _BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
        }
        newData[newDataLen++] = new BracketsData(position, brackets, options);
      }
    }
    this._lastBracketsData = newData;
    this._lastVersionId = versionId;
  }
};
_BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
_BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: themeColorFromId(overviewRulerBracketMatchForeground),
    position: OverviewRulerLane.Center
  }
});
_BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
var BracketMatchingController = _BracketMatchingController;
registerEditorContribution(
  BracketMatchingController.ID,
  BracketMatchingController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerEditorAction(RemoveBracketsAction);
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: localize(801, "Go to &&Bracket")
  },
  order: 2
});

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
init_editorExtensions();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/moveCaretCommand.js
init_range();
init_selection();
var MoveCaretCommand = class {
  constructor(selection, isMovingLeft) {
    this._selection = selection;
    this._isMovingLeft = isMovingLeft;
  }
  getEditOperations(model, builder) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
      return;
    }
    const lineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    const endColumn = this._selection.endColumn;
    if (this._isMovingLeft && startColumn === 1) {
      return;
    }
    if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
      return;
    }
    if (this._isMovingLeft) {
      const rangeBefore = new Range(lineNumber, startColumn - 1, lineNumber, startColumn);
      const charBefore = model.getValueInRange(rangeBefore);
      builder.addEditOperation(rangeBefore, null);
      builder.addEditOperation(new Range(lineNumber, endColumn, lineNumber, endColumn), charBefore);
    } else {
      const rangeAfter = new Range(lineNumber, endColumn, lineNumber, endColumn + 1);
      const charAfter = model.getValueInRange(rangeAfter);
      builder.addEditOperation(rangeAfter, null);
      builder.addEditOperation(new Range(lineNumber, startColumn, lineNumber, startColumn), charAfter);
    }
  }
  computeCursorState(model, helper) {
    if (this._isMovingLeft) {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
    } else {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
init_nls();
var MoveCaretAction = class extends EditorAction {
  constructor(left, opts) {
    super(opts);
    this.left = left;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new MoveCaretCommand(selection, this.left));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var MoveCaretLeftAction = class extends MoveCaretAction {
  constructor() {
    super(true, {
      id: "editor.action.moveCarretLeftAction",
      label: localize2(806, "Move Selected Text Left"),
      precondition: EditorContextKeys.writable
    });
  }
};
var MoveCaretRightAction = class extends MoveCaretAction {
  constructor() {
    super(false, {
      id: "editor.action.moveCarretRightAction",
      label: localize2(807, "Move Selected Text Right"),
      precondition: EditorContextKeys.writable
    });
  }
};
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/transpose.js
init_editorExtensions();
init_range();
init_editorContextKeys();
init_nls();
var TransposeLettersAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: localize2(808, "Transpose Letters"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 50
          /* KeyCode.KeyT */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      if (!selection.isEmpty()) {
        continue;
      }
      const lineNumber = selection.startLineNumber;
      const column = selection.startColumn;
      const lastColumn = model.getLineMaxColumn(lineNumber);
      if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
        continue;
      }
      const endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
      const middlePosition = MoveOperations.leftPosition(model, endPosition);
      const beginPosition = MoveOperations.leftPosition(model, middlePosition);
      const leftChar = model.getValueInRange(Range.fromPositions(beginPosition, middlePosition));
      const rightChar = model.getValueInRange(Range.fromPositions(middlePosition, endPosition));
      const replaceRange = Range.fromPositions(beginPosition, endPosition);
      commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
    }
    if (commands.length > 0) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, commands);
      editor2.pushUndoStop();
    }
  }
};
registerEditorAction(TransposeLettersAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/browser/clipboard.js
init_browser();
init_dom();
init_platform();
init_stopwatch();
init_nls();
init_actions2();
init_contextkey();
init_log();

// node_modules/monaco-editor/esm/vs/platform/product/common/productService.js
init_instantiation();
var IProductService = createDecorator("productService");

// node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/browser/clipboard.js
init_telemetry();
init_editorExtensions();
init_codeEditorService();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_dom();
init_arrays();
init_async();
init_cancellation();

// node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js
init_arrays();
init_iterator();
init_uuid();
function createStringDataTransferItem(stringOrPromise, id) {
  return {
    id,
    asString: async () => stringOrPromise,
    asFile: () => void 0,
    value: typeof stringOrPromise === "string" ? stringOrPromise : void 0
  };
}
function createFileDataTransferItem(fileName, uri, data, id) {
  const file = { id: generateUuid(), name: fileName, uri, data };
  return {
    id,
    asString: async () => "",
    asFile: () => file,
    value: void 0
  };
}
var VSDataTransfer = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  get size() {
    let size2 = 0;
    for (const _ of this._entries) {
      size2++;
    }
    return size2;
  }
  has(mimeType) {
    return this._entries.has(this.toKey(mimeType));
  }
  matches(pattern) {
    const mimes = [...this._entries.keys()];
    if (Iterable.some(this, ([_, item]) => item.asFile())) {
      mimes.push("files");
    }
    return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);
  }
  get(mimeType) {
    return this._entries.get(this.toKey(mimeType))?.[0];
  }
  /**
   * Add a new entry to this data transfer.
   *
   * This does not replace existing entries for `mimeType`.
   */
  append(mimeType, value) {
    const existing = this._entries.get(mimeType);
    if (existing) {
      existing.push(value);
    } else {
      this._entries.set(this.toKey(mimeType), [value]);
    }
  }
  /**
   * Set the entry for a given mime type.
   *
   * This replaces all existing entries for `mimeType`.
   */
  replace(mimeType, value) {
    this._entries.set(this.toKey(mimeType), [value]);
  }
  /**
   * Remove all entries for `mimeType`.
   */
  delete(mimeType) {
    this._entries.delete(this.toKey(mimeType));
  }
  /**
   * Iterate over all `[mime, item]` pairs in this data transfer.
   *
   * There may be multiple entries for each mime type.
   */
  *[Symbol.iterator]() {
    for (const [mine, items] of this._entries) {
      for (const item of items) {
        yield [mine, item];
      }
    }
  }
  toKey(mimeType) {
    return normalizeMimeType(mimeType);
  }
};
function normalizeMimeType(mimeType) {
  return mimeType.toLowerCase();
}
function matchesMimeType(pattern, mimeTypes) {
  return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));
}
function matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {
  if (normalizedPattern === "*/*") {
    return normalizedMimeTypes.length > 0;
  }
  if (normalizedMimeTypes.includes(normalizedPattern)) {
    return true;
  }
  const wildcard = normalizedPattern.match(/^([a-z]+)\/([a-z]+|\*)$/i);
  if (!wildcard) {
    return false;
  }
  const [_, type, subtype] = wildcard;
  if (subtype === "*") {
    return normalizedMimeTypes.some((mime) => mime.startsWith(type + "/"));
  }
  return false;
}
var UriList = Object.freeze({
  // http://amundsen.com/hypermedia/urilist/
  create: (entries) => {
    return distinct(entries.map((x) => x.toString())).join("\r\n");
  },
  split: (str) => {
    return str.split("\r\n");
  },
  parse: (str) => {
    return UriList.split(str).filter((value) => !value.startsWith("#"));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_errors();

// node_modules/monaco-editor/esm/vs/base/common/hierarchicalKind.js
var _HierarchicalKind = class _HierarchicalKind {
  constructor(value) {
    this.value = value;
  }
  equals(other) {
    return this.value === other.value;
  }
  contains(other) {
    return this.equals(other) || this.value === "" || other.value.startsWith(this.value + _HierarchicalKind.sep);
  }
  intersects(other) {
    return this.contains(other) || other.contains(this);
  }
  append(...parts) {
    return new _HierarchicalKind((this.value ? [this.value, ...parts] : parts).join(_HierarchicalKind.sep));
  }
};
_HierarchicalKind.sep = ".";
_HierarchicalKind.None = new _HierarchicalKind("@@none@@");
_HierarchicalKind.Empty = new _HierarchicalKind("");
var HierarchicalKind = _HierarchicalKind;

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_lifecycle();
init_mime();
init_platform();
init_types();
init_uuid();
init_nls();
init_commands();
init_configuration();
init_contextkey();
init_instantiation();
init_log();

// node_modules/monaco-editor/esm/vs/editor/browser/dataTransfer.js
init_mime();
init_uri();

// node_modules/monaco-editor/esm/vs/platform/dnd/browser/dnd.js
init_platform();
init_platform2();
var CodeDataTransfers = {
  EDITORS: "CodeEditors",
  FILES: "CodeFiles",
  SYMBOLS: "application/vnd.code.symbols",
  MARKERS: "application/vnd.code.diagnostics",
  NOTEBOOK_CELL_OUTPUT: "notebook-cell-output",
  SCM_HISTORY_ITEM: "scm-history-item"
};
var DragAndDropContributionRegistry = class {
};
var Extensions3 = {
  DragAndDropContribution: "workbench.contributions.dragAndDrop"
};
Registry.add(Extensions3.DragAndDropContribution, new DragAndDropContributionRegistry());
var _LocalSelectionTransfer = class _LocalSelectionTransfer {
  constructor() {
  }
  static getInstance() {
    return _LocalSelectionTransfer.INSTANCE;
  }
  hasData(proto) {
    return proto && proto === this.proto;
  }
  getData(proto) {
    if (this.hasData(proto)) {
      return this.data;
    }
    return void 0;
  }
};
_LocalSelectionTransfer.INSTANCE = new _LocalSelectionTransfer();
var LocalSelectionTransfer = _LocalSelectionTransfer;
function getPathForFile(file) {
  if (isNative && typeof globalThis.vscode?.webUtils?.getPathForFile === "function") {
    return globalThis.vscode.webUtils.getPathForFile(file);
  }
  return void 0;
}

// node_modules/monaco-editor/esm/vs/editor/browser/dataTransfer.js
function toVSDataTransfer(dataTransfer) {
  const vsDataTransfer = new VSDataTransfer();
  for (const item of dataTransfer.items) {
    const type = item.type;
    if (item.kind === "string") {
      const asStringValue = new Promise((resolve) => item.getAsString(resolve));
      vsDataTransfer.append(type, createStringDataTransferItem(asStringValue));
    } else if (item.kind === "file") {
      const file = item.getAsFile();
      if (file) {
        vsDataTransfer.append(type, createFileDataTransferItemFromFile(file));
      }
    }
  }
  return vsDataTransfer;
}
function createFileDataTransferItemFromFile(file) {
  const path = getPathForFile(file);
  const uri = path ? URI.parse(path) : void 0;
  return createFileDataTransferItem(file.name, uri, async () => {
    return new Uint8Array(await file.arrayBuffer());
  });
}
var INTERNAL_DND_MIME_TYPES = Object.freeze([
  CodeDataTransfers.EDITORS,
  CodeDataTransfers.FILES,
  DataTransfers.RESOURCES,
  DataTransfers.INTERNAL_URI_LIST
]);
function toExternalVSDataTransfer(sourceDataTransfer, overwriteUriList = false) {
  const vsDataTransfer = toVSDataTransfer(sourceDataTransfer);
  const uriList = vsDataTransfer.get(DataTransfers.INTERNAL_URI_LIST);
  if (uriList) {
    vsDataTransfer.replace(Mimes.uriList, uriList);
  } else {
    if (overwriteUriList || !vsDataTransfer.has(Mimes.uriList)) {
      const editorData = [];
      for (const item of sourceDataTransfer.items) {
        const file = item.getAsFile();
        if (file) {
          const path = getPathForFile(file);
          try {
            if (path) {
              editorData.push(URI.file(path).toString());
            } else {
              editorData.push(URI.parse(file.name, true).toString());
            }
          } catch {
          }
        }
      }
      if (editorData.length) {
        vsDataTransfer.replace(Mimes.uriList, createStringDataTransferItem(UriList.create(editorData)));
      }
    }
  }
  for (const internal of INTERNAL_DND_MIME_TYPES) {
    vsDataTransfer.delete(internal);
  }
  return vsDataTransfer;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
init_range();
init_languages();
init_languageFeatures();
init_editorState();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineProgress/browser/inlineProgress.js
init_dom();
init_async();
init_codicons();
init_lifecycle();
init_strings();
init_themables();
init_range();
init_textModel();
init_instantiation();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/inlineProgress/browser/inlineProgressWidget.css";
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var inlineProgressDecoration = ModelDecorationOptions.register({
  description: "inline-progress-widget",
  stickiness: 1,
  showIfCollapsed: true,
  after: {
    content: noBreakWhitespace,
    inlineClassName: "inline-editor-progress-decoration",
    inlineClassNameAffectsLetterSpacing: true
  }
});
var _InlineProgressWidget = class _InlineProgressWidget extends Disposable {
  constructor(typeId, editor2, range, title, delegate) {
    super();
    this.typeId = typeId;
    this.editor = editor2;
    this.range = range;
    this.delegate = delegate;
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this.create(title);
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
  }
  create(title) {
    this.domNode = $(".inline-progress-widget");
    this.domNode.role = "button";
    this.domNode.title = title;
    const iconElement = $("span.icon");
    this.domNode.append(iconElement);
    iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.loading), "codicon-modifier-spin");
    const updateSize = () => {
      const lineHeight = this.editor.getOption(
        75
        /* EditorOption.lineHeight */
      );
      this.domNode.style.height = `${lineHeight}px`;
      this.domNode.style.width = `${Math.ceil(0.8 * lineHeight)}px`;
    };
    updateSize();
    this._register(this.editor.onDidChangeConfiguration((c) => {
      if (c.hasChanged(
        61
        /* EditorOption.fontSize */
      ) || c.hasChanged(
        75
        /* EditorOption.lineHeight */
      )) {
        updateSize();
      }
    }));
    this._register(addDisposableListener(this.domNode, EventType.CLICK, (e) => {
      this.delegate.cancel();
    }));
  }
  getId() {
    return _InlineProgressWidget.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn },
      preference: [
        0
        /* ContentWidgetPositionPreference.EXACT */
      ]
    };
  }
  dispose() {
    super.dispose();
    this.editor.removeContentWidget(this);
  }
};
_InlineProgressWidget.baseId = "editor.widget.inlineProgressWidget";
var InlineProgressWidget = _InlineProgressWidget;
var InlineProgressManager = class InlineProgressManager2 extends Disposable {
  constructor(id, _editor, _instantiationService) {
    super();
    this.id = id;
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._showDelay = 500;
    this._showPromise = this._register(new MutableDisposable());
    this._currentWidget = this._register(new MutableDisposable());
    this._operationIdPool = 0;
    this._currentDecorations = _editor.createDecorationsCollection();
  }
  dispose() {
    super.dispose();
    this._currentDecorations.clear();
  }
  async showWhile(position, title, promise, delegate, delayOverride) {
    const operationId = this._operationIdPool++;
    this._currentOperation = operationId;
    this.clear();
    this._showPromise.value = disposableTimeout(() => {
      const range = Range.fromPositions(position);
      const decorationIds = this._currentDecorations.set([{
        range,
        options: inlineProgressDecoration
      }]);
      if (decorationIds.length > 0) {
        this._currentWidget.value = this._instantiationService.createInstance(InlineProgressWidget, this.id, this._editor, range, title, delegate);
      }
    }, delayOverride ?? this._showDelay);
    try {
      return await promise;
    } finally {
      if (this._currentOperation === operationId) {
        this.clear();
        this._currentOperation = void 0;
      }
    }
  }
  clear() {
    this._showPromise.clear();
    this._currentDecorations.clear();
    this._currentWidget.clear();
  }
};
InlineProgressManager = __decorate2([
  __param2(2, IInstantiationService)
], InlineProgressManager);

// node_modules/monaco-editor/esm/vs/editor/contrib/message/browser/messageController.js
init_event();
init_htmlContent();
init_lifecycle();
init_editorExtensions();
init_range();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/message/browser/messageController.css";
init_nls();
init_contextkey();
init_dom();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageController_1;
var _a2;
var MessageController = (_a2 = class {
  static get(editor2) {
    return editor2.getContribution(MessageController_1.ID);
  }
  constructor(editor2, contextKeyService, _openerService) {
    this._openerService = _openerService;
    this._messageWidget = new MutableDisposable();
    this._messageListeners = new DisposableStore();
    this._mouseOverMessage = false;
    this._editor = editor2;
    this._visible = MessageController_1.MESSAGE_VISIBLE.bindTo(contextKeyService);
  }
  dispose() {
    this._messageListeners.dispose();
    this._messageWidget.dispose();
    this._visible.reset();
  }
  showMessage(message, position) {
    alert(isMarkdownString(message) ? message.value : message);
    this._visible.set(true);
    this._messageWidget.clear();
    this._messageListeners.clear();
    if (isMarkdownString(message)) {
      const renderedMessage = this._messageListeners.add(renderMarkdown(message, {
        actionHandler: (url, mdStr) => {
          this.closeMessage();
          openLinkFromMarkdown(this._openerService, url, mdStr.isTrusted);
        }
      }));
      this._messageWidget.value = new MessageWidget(this._editor, position, renderedMessage.element);
    } else {
      this._messageWidget.value = new MessageWidget(this._editor, position, message);
    }
    this._messageListeners.add(Event.debounce(this._editor.onDidBlurEditorText, (last, event) => event, 0)(() => {
      if (this._mouseOverMessage) {
        return;
      }
      if (this._messageWidget.value && isAncestor(getActiveElement(), this._messageWidget.value.getDomNode())) {
        return;
      }
      this.closeMessage();
    }));
    this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
    this._messageListeners.add(addDisposableListener(this._messageWidget.value.getDomNode(), EventType.MOUSE_ENTER, () => this._mouseOverMessage = true, true));
    this._messageListeners.add(addDisposableListener(this._messageWidget.value.getDomNode(), EventType.MOUSE_LEAVE, () => this._mouseOverMessage = false, true));
    let bounds;
    this._messageListeners.add(this._editor.onMouseMove((e) => {
      if (!e.target.position) {
        return;
      }
      if (!bounds) {
        bounds = new Range(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
      } else if (!bounds.containsPosition(e.target.position)) {
        this.closeMessage();
      }
    }));
  }
  closeMessage() {
    this._visible.reset();
    this._messageListeners.clear();
    if (this._messageWidget.value) {
      this._messageListeners.add(MessageWidget.fadeOut(this._messageWidget.value));
    }
  }
}, MessageController_1 = _a2, _a2.ID = "editor.contrib.messageController", _a2.MESSAGE_VISIBLE = new RawContextKey("messageVisible", false, localize(1277, "Whether the editor is currently showing an inline message")), _a2);
MessageController = MessageController_1 = __decorate3([
  __param3(1, IContextKeyService),
  __param3(2, IOpenerService)
], MessageController);
var MessageCommand = EditorCommand.bindToContribution(MessageController.get);
registerEditorCommand(new MessageCommand({
  id: "leaveEditorMessage",
  precondition: MessageController.MESSAGE_VISIBLE,
  handler: (c) => c.closeMessage(),
  kbOpts: {
    weight: 100 + 30,
    primary: 9
    /* KeyCode.Escape */
  }
}));
var MessageWidget = class {
  static fadeOut(messageWidget) {
    const dispose2 = () => {
      messageWidget.dispose();
      clearTimeout(handle);
      messageWidget.getDomNode().removeEventListener("animationend", dispose2);
    };
    const handle = setTimeout(dispose2, 110);
    messageWidget.getDomNode().addEventListener("animationend", dispose2);
    messageWidget.getDomNode().classList.add("fadeOut");
    return { dispose: dispose2 };
  }
  constructor(editor2, { lineNumber, column }, text) {
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._editor = editor2;
    this._editor.revealLinesInCenterIfOutsideViewport(
      lineNumber,
      lineNumber,
      0
      /* ScrollType.Smooth */
    );
    this._position = { lineNumber, column };
    this._domNode = document.createElement("div");
    this._domNode.classList.add("monaco-editor-overlaymessage");
    this._domNode.style.marginLeft = "-6px";
    const anchorTop = document.createElement("div");
    anchorTop.classList.add("anchor", "top");
    this._domNode.appendChild(anchorTop);
    const message = document.createElement("div");
    if (typeof text === "string") {
      message.classList.add("message");
      message.textContent = text;
    } else {
      text.classList.add("message");
      message.appendChild(text);
    }
    this._domNode.appendChild(message);
    const anchorBottom = document.createElement("div");
    anchorBottom.classList.add("anchor", "below");
    this._domNode.appendChild(anchorBottom);
    this._editor.addContentWidget(this);
    this._domNode.classList.add("fadeIn");
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._position,
      preference: [
        1,
        2
      ],
      positionAffinity: 1
    };
  }
  afterRender(position) {
    this._domNode.classList.toggle(
      "below",
      position === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
};
registerEditorContribution(
  MessageController.ID,
  MessageController,
  4
  /* EditorContributionInstantiation.Lazy */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/defaultProviders.js
init_arrays();
init_lifecycle();
init_mime();
init_network();
init_resources();
init_uri();
init_nls();
init_languages();
init_languageFeatures();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SimplePasteAndDropProvider = class {
  constructor(kind) {
    this.copyMimeTypes = [];
    this.kind = kind;
    this.providedDropEditKinds = [this.kind];
    this.providedPasteEditKinds = [this.kind];
  }
  async provideDocumentPasteEdits(_model, _ranges, dataTransfer, context, token) {
    const edit = await this.getEdit(dataTransfer, token);
    if (!edit) {
      return void 0;
    }
    return {
      edits: [{ insertText: edit.insertText, title: edit.title, kind: edit.kind, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo }],
      dispose() {
      }
    };
  }
  async provideDocumentDropEdits(_model, _position, dataTransfer, token) {
    const edit = await this.getEdit(dataTransfer, token);
    if (!edit) {
      return;
    }
    return {
      edits: [{ insertText: edit.insertText, title: edit.title, kind: edit.kind, handledMimeType: edit.handledMimeType, yieldTo: edit.yieldTo }],
      dispose() {
      }
    };
  }
};
var _DefaultTextPasteOrDropEditProvider = class _DefaultTextPasteOrDropEditProvider extends SimplePasteAndDropProvider {
  constructor() {
    super(HierarchicalKind.Empty.append("text", "plain"));
    this.id = _DefaultTextPasteOrDropEditProvider.id;
    this.dropMimeTypes = [Mimes.text];
    this.pasteMimeTypes = [Mimes.text];
  }
  async getEdit(dataTransfer, _token) {
    const textEntry = dataTransfer.get(Mimes.text);
    if (!textEntry) {
      return;
    }
    if (dataTransfer.has(Mimes.uriList)) {
      return;
    }
    const insertText = await textEntry.asString();
    return {
      handledMimeType: Mimes.text,
      title: localize(921, "Insert Plain Text"),
      insertText,
      kind: this.kind
    };
  }
};
_DefaultTextPasteOrDropEditProvider.id = "text";
var DefaultTextPasteOrDropEditProvider = _DefaultTextPasteOrDropEditProvider;
var PathProvider = class extends SimplePasteAndDropProvider {
  constructor() {
    super(HierarchicalKind.Empty.append("uri", "path", "absolute"));
    this.dropMimeTypes = [Mimes.uriList];
    this.pasteMimeTypes = [Mimes.uriList];
  }
  async getEdit(dataTransfer, token) {
    const entries = await extractUriList(dataTransfer);
    if (!entries.length || token.isCancellationRequested) {
      return;
    }
    let uriCount = 0;
    const insertText = entries.map(({ uri, originalText }) => {
      if (uri.scheme === Schemas.file) {
        return uri.fsPath;
      } else {
        uriCount++;
        return originalText;
      }
    }).join(" ");
    let label;
    if (uriCount > 0) {
      label = entries.length > 1 ? localize(922, "Insert Uris") : localize(923, "Insert Uri");
    } else {
      label = entries.length > 1 ? localize(924, "Insert Paths") : localize(925, "Insert Path");
    }
    return {
      handledMimeType: Mimes.uriList,
      insertText,
      title: label,
      kind: this.kind
    };
  }
};
var RelativePathProvider = class RelativePathProvider2 extends SimplePasteAndDropProvider {
  constructor(_workspaceContextService) {
    super(HierarchicalKind.Empty.append("uri", "path", "relative"));
    this._workspaceContextService = _workspaceContextService;
    this.dropMimeTypes = [Mimes.uriList];
    this.pasteMimeTypes = [Mimes.uriList];
  }
  async getEdit(dataTransfer, token) {
    const entries = await extractUriList(dataTransfer);
    if (!entries.length || token.isCancellationRequested) {
      return;
    }
    const relativeUris = coalesce(entries.map(({ uri }) => {
      const root = this._workspaceContextService.getWorkspaceFolder(uri);
      return root ? relativePath(root.uri, uri) : void 0;
    }));
    if (!relativeUris.length) {
      return;
    }
    return {
      handledMimeType: Mimes.uriList,
      insertText: relativeUris.join(" "),
      title: entries.length > 1 ? localize(926, "Insert Relative Paths") : localize(927, "Insert Relative Path"),
      kind: this.kind
    };
  }
};
RelativePathProvider = __decorate4([
  __param4(0, IWorkspaceContextService)
], RelativePathProvider);
var PasteHtmlProvider = class {
  constructor() {
    this.kind = new HierarchicalKind("html");
    this.providedPasteEditKinds = [this.kind];
    this.copyMimeTypes = [];
    this.pasteMimeTypes = ["text/html"];
    this._yieldTo = [{ mimeType: Mimes.text }];
  }
  async provideDocumentPasteEdits(_model, _ranges, dataTransfer, context, token) {
    if (context.triggerKind !== DocumentPasteTriggerKind.PasteAs && !context.only?.contains(this.kind)) {
      return;
    }
    const entry = dataTransfer.get("text/html");
    const htmlText = await entry?.asString();
    if (!htmlText || token.isCancellationRequested) {
      return;
    }
    return {
      dispose() {
      },
      edits: [{
        insertText: htmlText,
        yieldTo: this._yieldTo,
        title: localize(928, "Insert HTML"),
        kind: this.kind
      }]
    };
  }
};
async function extractUriList(dataTransfer) {
  const urlListEntry = dataTransfer.get(Mimes.uriList);
  if (!urlListEntry) {
    return [];
  }
  const strUriList = await urlListEntry.asString();
  const entries = [];
  for (const entry of UriList.parse(strUriList)) {
    try {
      entries.push({ uri: URI.parse(entry), originalText: entry });
    } catch {
    }
  }
  return entries;
}
var genericLanguageSelector = { scheme: "*", hasAccessToAllModels: true };
var DefaultDropProvidersFeature = class DefaultDropProvidersFeature2 extends Disposable {
  constructor(languageFeaturesService, workspaceContextService) {
    super();
    this._register(languageFeaturesService.documentDropEditProvider.register(genericLanguageSelector, new DefaultTextPasteOrDropEditProvider()));
    this._register(languageFeaturesService.documentDropEditProvider.register(genericLanguageSelector, new PathProvider()));
    this._register(languageFeaturesService.documentDropEditProvider.register(genericLanguageSelector, new RelativePathProvider(workspaceContextService)));
  }
};
DefaultDropProvidersFeature = __decorate4([
  __param4(0, ILanguageFeaturesService),
  __param4(1, IWorkspaceContextService)
], DefaultDropProvidersFeature);
var DefaultPasteProvidersFeature = class DefaultPasteProvidersFeature2 extends Disposable {
  constructor(languageFeaturesService, workspaceContextService) {
    super();
    this._register(languageFeaturesService.documentPasteEditProvider.register(genericLanguageSelector, new DefaultTextPasteOrDropEditProvider()));
    this._register(languageFeaturesService.documentPasteEditProvider.register(genericLanguageSelector, new PathProvider()));
    this._register(languageFeaturesService.documentPasteEditProvider.register(genericLanguageSelector, new RelativePathProvider(workspaceContextService)));
    this._register(languageFeaturesService.documentPasteEditProvider.register(genericLanguageSelector, new PasteHtmlProvider()));
  }
};
DefaultPasteProvidersFeature = __decorate4([
  __param4(0, ILanguageFeaturesService),
  __param4(1, IWorkspaceContextService)
], DefaultPasteProvidersFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js
var _Scanner = class _Scanner {
  constructor() {
    this.value = "";
    this.pos = 0;
  }
  static isDigitCharacter(ch) {
    return ch >= 48 && ch <= 57;
  }
  static isVariableCharacter(ch) {
    return ch === 95 || ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return { type: 14, pos: this.pos, len: 0 };
    }
    const pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type;
    type = _Scanner._table[ch];
    if (typeof type === "number") {
      this.pos += 1;
      return { type, pos, len: 1 };
    }
    if (_Scanner.isDigitCharacter(ch)) {
      type = 8;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (_Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type, pos, len };
    }
    if (_Scanner.isVariableCharacter(ch)) {
      type = 9;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type, pos, len };
    }
    type = 10;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
    this.pos += len;
    return { type, pos, len };
  }
};
_Scanner._table = {
  [
    36
    /* CharCode.DollarSign */
  ]: 0,
  [
    58
    /* CharCode.Colon */
  ]: 1,
  [
    44
    /* CharCode.Comma */
  ]: 2,
  [
    123
    /* CharCode.OpenCurlyBrace */
  ]: 3,
  [
    125
    /* CharCode.CloseCurlyBrace */
  ]: 4,
  [
    92
    /* CharCode.Backslash */
  ]: 5,
  [
    47
    /* CharCode.Slash */
  ]: 6,
  [
    124
    /* CharCode.Pipe */
  ]: 7,
  [
    43
    /* CharCode.Plus */
  ]: 11,
  [
    45
    /* CharCode.Dash */
  ]: 12,
  [
    63
    /* CharCode.QuestionMark */
  ]: 13
};
var Scanner = _Scanner;
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const { parent } = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    })(others, parent);
  }
  get children() {
    return this._children;
  }
  get rightMostDescendant() {
    if (this._children.length > 0) {
      return this._children[this._children.length - 1].rightMostDescendant;
    }
    return this;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
var Text = class _Text extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new _Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
};
var Placeholder = class _Placeholder extends TransformableMarker {
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  constructor(index) {
    super();
    this.index = index;
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  clone() {
    const ret = new _Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var Choice = class _Choice extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    const ret = new _Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
var Transform = class _Transform extends Marker {
  constructor() {
    super(...arguments);
    this.regexp = new RegExp("");
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  clone() {
    const ret = new _Transform();
    ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var FormatString = class _FormatString extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (this.shorthandName === "camelcase") {
      return !value ? "" : this._toCamelCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word) => {
      return word.charAt(0).toUpperCase() + word.substr(1);
    }).join("");
  }
  _toCamelCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word, index) => {
      if (index === 0) {
        return word.charAt(0).toLowerCase() + word.substr(1);
      }
      return word.charAt(0).toUpperCase() + word.substr(1);
    }).join("");
  }
  clone() {
    const ret = new _FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
var Variable = class _Variable extends TransformableMarker {
  constructor(name) {
    super();
    this.name = name;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text(value)];
      return true;
    }
    return false;
  }
  clone() {
    const ret = new _Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class _TextmateSnippet extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      const all = [];
      let last;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last = !last || last.index < candidate.index ? candidate : last;
        }
        return true;
      });
      this._placeholders = { all, last };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all } = this.placeholderInfo;
    return all;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    const ret = [];
    let { parent } = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret.push(parent);
      }
      parent = parent.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  clone() {
    const ret = new _TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
    this._token = { type: 14, pos: 0, len: 0 };
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    const snippet = new TextmateSnippet();
    this.parseFragment(value, snippet);
    this.ensureFinalTabstop(snippet, enforceFinalTabstop ?? false, insertFinalTabstop ?? false);
    return snippet;
  }
  parseFragment(value, snippet) {
    const offset = snippet.children.length;
    this._scanner.text(value);
    this._token = this._scanner.next();
    while (this._parse(snippet)) {
    }
    const placeholderDefaultValues = /* @__PURE__ */ new Map();
    const incompletePlaceholders = [];
    snippet.walk((marker) => {
      if (marker instanceof Placeholder) {
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    const fillInIncompletePlaceholder = (placeholder, stack2) => {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (!defaultValues) {
        return;
      }
      const clone = new Placeholder(placeholder.index);
      clone.transform = placeholder.transform;
      for (const child of defaultValues) {
        const newChild = child.clone();
        clone.appendChild(newChild);
        if (newChild instanceof Placeholder && placeholderDefaultValues.has(newChild.index) && !stack2.has(newChild.index)) {
          stack2.add(newChild.index);
          fillInIncompletePlaceholder(newChild, stack2);
          stack2.delete(newChild.index);
        }
      }
      snippet.replace(placeholder, [clone]);
    };
    const stack = /* @__PURE__ */ new Set();
    for (const placeholder of incompletePlaceholders) {
      fillInIncompletePlaceholder(placeholder, stack);
    }
    return snippet.children.slice(offset);
  }
  ensureFinalTabstop(snippet, enforceFinalTabstop, insertFinalTabstop) {
    if (enforceFinalTabstop || insertFinalTabstop && snippet.placeholders.length > 0) {
      const finalTabstop = snippet.placeholders.find((p) => p.index === 0);
      if (!finalTabstop) {
        snippet.appendChild(new Placeholder(0));
      }
    }
  }
  _accept(type, value) {
    if (type === void 0 || this._token.type === type) {
      const ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type) {
    const start = this._token;
    while (this._token.type !== type) {
      if (this._token.type === 14) {
        return false;
      } else if (this._token.type === 5) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 && nextToken.type !== 4 && nextToken.type !== 5) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  // \$, \\, \} -> just text
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5, true)) {
      value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
      marker.appendChild(new Text(value));
      return true;
    }
    return false;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match = this._accept(
      0
      /* TokenType.Dollar */
    ) && (value = this._accept(9, true) || this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
    return true;
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match = this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (index = this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(
      1
      /* TokenType.Colon */
    )) {
      while (true) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        )) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(
      7
      /* TokenType.Pipe */
    )) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(
            2
            /* TokenType.Comma */
          )) {
            continue;
          }
          if (this._accept(
            7
            /* TokenType.Pipe */
          )) {
            placeholder.appendChild(choice);
            if (this._accept(
              4
              /* TokenType.CurlyClose */
            )) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(
      6
      /* TokenType.Forwardslash */
    )) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(
      4
      /* TokenType.CurlyClose */
    )) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values = [];
    while (true) {
      if (this._token.type === 2 || this._token.type === 7) {
        break;
      }
      let value;
      if (value = this._accept(5, true)) {
        value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values.push(value);
    }
    if (values.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text(values.join("")));
    return true;
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(parent) {
    let name;
    const token = this._token;
    const match = this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (name = this._accept(9, true));
    if (!match) {
      return this._backTo(token);
    }
    const variable = new Variable(name);
    if (this._accept(
      1
      /* TokenType.Colon */
    )) {
      while (true) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        )) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text("${" + name + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(
      6
      /* TokenType.Forwardslash */
    )) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(
      4
      /* TokenType.CurlyClose */
    )) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    const transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(
        6
        /* TokenType.Forwardslash */
      )) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(6, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(
        6
        /* TokenType.Forwardslash */
      )) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(5, true) || this._accept(6, true) || escaped;
        transform.appendChild(new Text(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(
        4
        /* TokenType.CurlyClose */
      )) {
        break;
      }
      if (this._token.type !== 14) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(
      0
      /* TokenType.Dollar */
    )) {
      return false;
    }
    let complex = false;
    if (this._accept(
      3
      /* TokenType.CurlyOpen */
    )) {
      complex = true;
    }
    const index = this._accept(8, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(
      4
      /* TokenType.CurlyClose */
    )) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(
      1
      /* TokenType.Colon */
    )) {
      this._backTo(token);
      return false;
    }
    if (this._accept(
      6
      /* TokenType.Forwardslash */
    )) {
      const shorthand = this._accept(9, true);
      if (!shorthand || !this._accept(
        4
        /* TokenType.CurlyClose */
      )) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(
      11
      /* TokenType.Plus */
    )) {
      const ifValue = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(
      12
      /* TokenType.Dash */
    )) {
      const elseValue = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(
      13
      /* TokenType.QuestionMark */
    )) {
      const ifValue = this._until(
        1
        /* TokenType.Colon */
      );
      if (ifValue) {
        const elseValue = this._until(
          4
          /* TokenType.CurlyClose */
        );
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      const elseValue = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14) {
      marker.appendChild(new Text(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/edit.js
function createCombinedWorkspaceEdit(uri, ranges, edit) {
  if (typeof edit.insertText === "string" ? edit.insertText === "" : edit.insertText.snippet === "") {
    return {
      edits: edit.additionalEdit?.edits ?? []
    };
  }
  return {
    edits: [
      ...ranges.map((range) => new ResourceTextEdit(uri, { range, text: typeof edit.insertText === "string" ? SnippetParser.escape(edit.insertText) + "$0" : edit.insertText.snippet, insertAsSnippet: true })),
      ...edit.additionalEdit?.edits ?? []
    ]
  };
}
function sortEditsByYieldTo(edits) {
  function yieldsTo(yTo, other) {
    if ("mimeType" in yTo) {
      return yTo.mimeType === other.handledMimeType;
    }
    return !!other.kind && yTo.kind.contains(other.kind);
  }
  const yieldsToMap = /* @__PURE__ */ new Map();
  for (const edit of edits) {
    for (const yTo of edit.yieldTo ?? []) {
      for (const other of edits) {
        if (other === edit) {
          continue;
        }
        if (yieldsTo(yTo, other)) {
          let arr = yieldsToMap.get(edit);
          if (!arr) {
            arr = [];
            yieldsToMap.set(edit, arr);
          }
          arr.push(other);
        }
      }
    }
  }
  if (!yieldsToMap.size) {
    return Array.from(edits);
  }
  const visited = /* @__PURE__ */ new Set();
  const tempStack = [];
  function visit(nodes) {
    if (!nodes.length) {
      return [];
    }
    const node = nodes[0];
    if (tempStack.includes(node)) {
      console.warn("Yield to cycle detected", node);
      return nodes;
    }
    if (visited.has(node)) {
      return visit(nodes.slice(1));
    }
    let pre = [];
    const yTo = yieldsToMap.get(node);
    if (yTo) {
      tempStack.push(node);
      pre = visit(yTo);
      tempStack.pop();
    }
    visited.add(node);
    return [...pre, node, ...visit(nodes.slice(1))];
  }
  return visit(Array.from(edits));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js
init_dom();
init_async();
init_codicons();

// node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
init_arrays();
init_types();
init_nls();
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return localize(29, "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  if (exception.code === "ERR_UNC_HOST_NOT_ALLOWED") {
    return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;
  }
  if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") {
    return localize(30, "A system error occurred ({0})", exception.message);
  }
  return exception.message || localize(31, "An unknown error occurred. Please consult the log for more details.");
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return localize(32, "An unknown error occurred. Please consult the log for more details.");
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return localize(33, "{0} ({1} errors in total)", msg, errors.length);
    }
    return msg;
  }
  if (isString(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return localize(34, "An unknown error occurred. Please consult the log for more details.");
}

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js
init_errors();
init_event();
init_lifecycle();
init_themables();
init_nls();

// node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionWidget.js
init_dom();
init_lifecycle();
init_nls();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionWidget.css";

// node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionList.js
init_dom();
init_cancellation();
init_codicons();
init_lifecycle();
init_platform();
init_themables();
init_nls();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionWidget.css";
init_colorRegistry();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var acceptSelectedActionCommand = "acceptSelectedCodeAction";
var previewSelectedActionCommand = "previewSelectedCodeAction";
var HeaderRenderer = class {
  get templateId() {
    return "header";
  }
  renderTemplate(container) {
    container.classList.add("group-header");
    const text = document.createElement("span");
    container.append(text);
    return { container, text };
  }
  renderElement(element, _index, templateData) {
    templateData.text.textContent = element.group?.title ?? element.label ?? "";
  }
  disposeTemplate(_templateData) {
  }
};
var SeparatorRenderer = class {
  get templateId() {
    return "separator";
  }
  renderTemplate(container) {
    container.classList.add("separator");
    const text = document.createElement("span");
    container.append(text);
    return { container, text };
  }
  renderElement(element, _index, templateData) {
    templateData.text.textContent = element.label ?? "";
  }
  disposeTemplate(_templateData) {
  }
};
var ActionItemRenderer = class ActionItemRenderer2 {
  get templateId() {
    return "action";
  }
  constructor(_supportsPreview, _keybindingService) {
    this._supportsPreview = _supportsPreview;
    this._keybindingService = _keybindingService;
  }
  renderTemplate(container) {
    container.classList.add(this.templateId);
    const icon = document.createElement("div");
    icon.className = "icon";
    container.append(icon);
    const text = document.createElement("span");
    text.className = "title";
    container.append(text);
    const description = document.createElement("span");
    description.className = "description";
    container.append(description);
    const keybinding = new KeybindingLabel(container, OS);
    return { container, icon, text, description, keybinding };
  }
  renderElement(element, _index, data) {
    if (element.group?.icon) {
      data.icon.className = ThemeIcon.asClassName(element.group.icon);
      if (element.group.icon.color) {
        data.icon.style.color = asCssVariable(element.group.icon.color.id);
      }
    } else {
      data.icon.className = ThemeIcon.asClassName(Codicon.lightBulb);
      data.icon.style.color = "var(--vscode-editorLightBulb-foreground)";
    }
    if (!element.item || !element.label) {
      return;
    }
    setVisibility(!element.hideIcon, data.icon);
    data.text.textContent = stripNewlines(element.label);
    if (element.keybinding) {
      data.description.textContent = element.keybinding.getLabel();
      data.description.style.display = "inline";
      data.description.style.letterSpacing = "0.5px";
    } else if (element.description) {
      data.description.textContent = stripNewlines(element.description);
      data.description.style.display = "inline";
    } else {
      data.description.textContent = "";
      data.description.style.display = "none";
    }
    const actionTitle = this._keybindingService.lookupKeybinding(acceptSelectedActionCommand)?.getLabel();
    const previewTitle = this._keybindingService.lookupKeybinding(previewSelectedActionCommand)?.getLabel();
    data.container.classList.toggle("option-disabled", element.disabled);
    if (element.tooltip) {
      data.container.title = element.tooltip;
    } else if (element.disabled) {
      data.container.title = element.label;
    } else if (actionTitle && previewTitle) {
      if (this._supportsPreview && element.canPreview) {
        data.container.title = localize(1638, "{0} to Apply, {1} to Preview", actionTitle, previewTitle);
      } else {
        data.container.title = localize(1639, "{0} to Apply", actionTitle);
      }
    } else {
      data.container.title = "";
    }
  }
  disposeTemplate(templateData) {
    templateData.keybinding.dispose();
  }
};
ActionItemRenderer = __decorate5([
  __param5(1, IKeybindingService)
], ActionItemRenderer);
var AcceptSelectedEvent = class extends UIEvent {
  constructor() {
    super("acceptSelectedAction");
  }
};
var PreviewSelectedEvent = class extends UIEvent {
  constructor() {
    super("previewSelectedAction");
  }
};
function getKeyboardNavigationLabel(item) {
  if (item.kind === "action") {
    return item.label;
  }
  return void 0;
}
var ActionList = class ActionList2 extends Disposable {
  constructor(user, preview, items, _delegate, accessibilityProvider, _contextViewService, _keybindingService, _layoutService) {
    super();
    this._delegate = _delegate;
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._layoutService = _layoutService;
    this._actionLineHeight = 28;
    this._headerLineHeight = 28;
    this._separatorLineHeight = 8;
    this.cts = this._register(new CancellationTokenSource());
    this.domNode = document.createElement("div");
    this.domNode.classList.add("actionList");
    const virtualDelegate = {
      getHeight: (element) => {
        switch (element.kind) {
          case "header":
            return this._headerLineHeight;
          case "separator":
            return this._separatorLineHeight;
          default:
            return this._actionLineHeight;
        }
      },
      getTemplateId: (element) => element.kind
    };
    this._list = this._register(new List(user, this.domNode, virtualDelegate, [
      new ActionItemRenderer(preview, this._keybindingService),
      new HeaderRenderer(),
      new SeparatorRenderer()
    ], {
      keyboardSupport: false,
      typeNavigationEnabled: true,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel },
      accessibilityProvider: {
        getAriaLabel: (element) => {
          if (element.kind === "action") {
            let label = element.label ? stripNewlines(element?.label) : "";
            if (element.description) {
              label = label + ", " + stripNewlines(element.description);
            }
            if (element.disabled) {
              label = localize(1640, "{0}, Disabled Reason: {1}", label, element.disabled);
            }
            return label;
          }
          return null;
        },
        getWidgetAriaLabel: () => localize(1641, "Action Widget"),
        getRole: (e) => {
          switch (e.kind) {
            case "action":
              return "option";
            case "separator":
              return "separator";
            default:
              return "separator";
          }
        },
        getWidgetRole: () => "listbox",
        ...accessibilityProvider
      }
    }));
    this._list.style(defaultListStyles);
    this._register(this._list.onMouseClick((e) => this.onListClick(e)));
    this._register(this._list.onMouseOver((e) => this.onListHover(e)));
    this._register(this._list.onDidChangeFocus(() => this.onFocus()));
    this._register(this._list.onDidChangeSelection((e) => this.onListSelection(e)));
    this._allMenuItems = items;
    this._list.splice(0, this._list.length, this._allMenuItems);
    if (this._list.length) {
      this.focusNext();
    }
  }
  focusCondition(element) {
    return !element.disabled && element.kind === "action";
  }
  hide(didCancel) {
    this._delegate.onHide(didCancel);
    this.cts.cancel();
    this._contextViewService.hideContextView();
  }
  layout(minWidth) {
    const numHeaders = this._allMenuItems.filter((item) => item.kind === "header").length;
    const numSeparators = this._allMenuItems.filter((item) => item.kind === "separator").length;
    const itemsHeight = this._allMenuItems.length * this._actionLineHeight;
    const heightWithHeaders = itemsHeight + numHeaders * this._headerLineHeight - numHeaders * this._actionLineHeight;
    const heightWithSeparators = heightWithHeaders + numSeparators * this._separatorLineHeight - numSeparators * this._actionLineHeight;
    this._list.layout(heightWithSeparators);
    let maxWidth = minWidth;
    if (this._allMenuItems.length >= 50) {
      maxWidth = 380;
    } else {
      const itemWidths = this._allMenuItems.map((_, index) => {
        const element = this.domNode.ownerDocument.getElementById(this._list.getElementID(index));
        if (element) {
          element.style.width = "auto";
          const width = element.getBoundingClientRect().width;
          element.style.width = "";
          return width;
        }
        return 0;
      });
      maxWidth = Math.max(...itemWidths, minWidth);
    }
    const maxVhPrecentage = 0.7;
    const height = Math.min(heightWithSeparators, this._layoutService.getContainer(getWindow(this.domNode)).clientHeight * maxVhPrecentage);
    this._list.layout(height, maxWidth);
    this.domNode.style.height = `${height}px`;
    this._list.domFocus();
    return maxWidth;
  }
  focusPrevious() {
    this._list.focusPrevious(1, true, void 0, this.focusCondition);
  }
  focusNext() {
    this._list.focusNext(1, true, void 0, this.focusCondition);
  }
  acceptSelected(preview) {
    const focused = this._list.getFocus();
    if (focused.length === 0) {
      return;
    }
    const focusIndex = focused[0];
    const element = this._list.element(focusIndex);
    if (!this.focusCondition(element)) {
      return;
    }
    const event = preview ? new PreviewSelectedEvent() : new AcceptSelectedEvent();
    this._list.setSelection([focusIndex], event);
  }
  onListSelection(e) {
    if (!e.elements.length) {
      return;
    }
    const element = e.elements[0];
    if (element.item && this.focusCondition(element)) {
      this._delegate.onSelect(element.item, e.browserEvent instanceof PreviewSelectedEvent);
    } else {
      this._list.setSelection([]);
    }
  }
  onFocus() {
    const focused = this._list.getFocus();
    if (focused.length === 0) {
      return;
    }
    const focusIndex = focused[0];
    const element = this._list.element(focusIndex);
    this._delegate.onFocus?.(element.item);
  }
  async onListHover(e) {
    const element = e.element;
    if (element && element.item && this.focusCondition(element)) {
      if (this._delegate.onHover && !element.disabled && element.kind === "action") {
        const result = await this._delegate.onHover(element.item, this.cts.token);
        element.canPreview = result ? result.canPreview : void 0;
      }
      if (e.index) {
        this._list.splice(e.index, 1, [element]);
      }
    }
    this._list.setFocus(typeof e.index === "number" ? [e.index] : []);
  }
  onListClick(e) {
    if (e.element && this.focusCondition(e.element)) {
      this._list.setFocus([]);
    }
  }
};
ActionList = __decorate5([
  __param5(5, IContextViewService),
  __param5(6, IKeybindingService),
  __param5(7, ILayoutService)
], ActionList);
function stripNewlines(str) {
  return str.replace(/\r\n|\r|\n/g, " ");
}

// node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionWidget.js
init_actions2();
init_contextkey();
init_extensions();
init_instantiation();
init_colorRegistry();
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
registerColor("actionBar.toggledBackground", inputActiveOptionBackground, localize(1642, "Background color for toggled action items in action bar."));
var ActionWidgetContextKeys = {
  Visible: new RawContextKey("codeActionMenuVisible", false, localize(1643, "Whether the action widget list is visible"))
};
var IActionWidgetService = createDecorator("actionWidgetService");
var ActionWidgetService = class ActionWidgetService2 extends Disposable {
  get isVisible() {
    return ActionWidgetContextKeys.Visible.getValue(this._contextKeyService) || false;
  }
  constructor(_contextViewService, _contextKeyService, _instantiationService) {
    super();
    this._contextViewService = _contextViewService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._list = this._register(new MutableDisposable());
  }
  show(user, supportsPreview, items, delegate, anchor, container, actionBarActions, accessibilityProvider) {
    const visibleContext = ActionWidgetContextKeys.Visible.bindTo(this._contextKeyService);
    const list = this._instantiationService.createInstance(ActionList, user, supportsPreview, items, delegate, accessibilityProvider);
    this._contextViewService.showContextView({
      getAnchor: () => anchor,
      render: (container2) => {
        visibleContext.set(true);
        return this._renderWidget(container2, list, actionBarActions ?? []);
      },
      onHide: (didCancel) => {
        visibleContext.reset();
        this._onWidgetClosed(didCancel);
      }
    }, container, false);
  }
  acceptSelected(preview) {
    this._list.value?.acceptSelected(preview);
  }
  focusPrevious() {
    this._list?.value?.focusPrevious();
  }
  focusNext() {
    this._list?.value?.focusNext();
  }
  hide(didCancel) {
    this._list.value?.hide(didCancel);
    this._list.clear();
  }
  _renderWidget(element, list, actionBarActions) {
    const widget = document.createElement("div");
    widget.classList.add("action-widget");
    element.appendChild(widget);
    this._list.value = list;
    if (this._list.value) {
      widget.appendChild(this._list.value.domNode);
    } else {
      throw new Error("List has no value");
    }
    const renderDisposables = new DisposableStore();
    const menuBlock = document.createElement("div");
    const block = element.appendChild(menuBlock);
    block.classList.add("context-view-block");
    renderDisposables.add(addDisposableListener(block, EventType.MOUSE_DOWN, (e) => e.stopPropagation()));
    const pointerBlockDiv = document.createElement("div");
    const pointerBlock = element.appendChild(pointerBlockDiv);
    pointerBlock.classList.add("context-view-pointerBlock");
    renderDisposables.add(addDisposableListener(pointerBlock, EventType.POINTER_MOVE, () => pointerBlock.remove()));
    renderDisposables.add(addDisposableListener(pointerBlock, EventType.MOUSE_DOWN, () => pointerBlock.remove()));
    let actionBarWidth = 0;
    if (actionBarActions.length) {
      const actionBar2 = this._createActionBar(".action-widget-action-bar", actionBarActions);
      if (actionBar2) {
        widget.appendChild(actionBar2.getContainer().parentElement);
        renderDisposables.add(actionBar2);
        actionBarWidth = actionBar2.getContainer().offsetWidth;
      }
    }
    const width = this._list.value?.layout(actionBarWidth);
    widget.style.width = `${width}px`;
    const focusTracker = renderDisposables.add(trackFocus(element));
    renderDisposables.add(focusTracker.onDidBlur(() => this.hide(true)));
    return renderDisposables;
  }
  _createActionBar(className, actions) {
    if (!actions.length) {
      return void 0;
    }
    const container = $(className);
    const actionBar2 = new ActionBar(container);
    actionBar2.push(actions, { icon: false, label: true });
    return actionBar2;
  }
  _onWidgetClosed(didCancel) {
    this._list.value?.hide(didCancel);
  }
};
ActionWidgetService = __decorate6([
  __param6(0, IContextViewService),
  __param6(1, IContextKeyService),
  __param6(2, IInstantiationService)
], ActionWidgetService);
registerSingleton(
  IActionWidgetService,
  ActionWidgetService,
  1
  /* InstantiationType.Delayed */
);
var weight = 100 + 1e3;
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "hideCodeActionWidget",
      title: localize2(1644, "Hide action widget"),
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 9,
        secondary: [
          1024 | 9
          /* KeyCode.Escape */
        ]
      }
    });
  }
  run(accessor) {
    accessor.get(IActionWidgetService).hide(true);
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "selectPrevCodeAction",
      title: localize2(1645, "Select previous action"),
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 16,
        secondary: [
          2048 | 16
          /* KeyCode.UpArrow */
        ],
        mac: { primary: 16, secondary: [
          2048 | 16,
          256 | 46
          /* KeyCode.KeyP */
        ] }
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.focusPrevious();
    }
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "selectNextCodeAction",
      title: localize2(1646, "Select next action"),
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 18,
        secondary: [
          2048 | 18
          /* KeyCode.DownArrow */
        ],
        mac: { primary: 18, secondary: [
          2048 | 18,
          256 | 44
          /* KeyCode.KeyN */
        ] }
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.focusNext();
    }
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: acceptSelectedActionCommand,
      title: localize2(1647, "Accept selected action"),
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 3,
        secondary: [
          2048 | 89
          /* KeyCode.Period */
        ]
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.acceptSelected();
    }
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: previewSelectedActionCommand,
      title: localize2(1648, "Preview selected action"),
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 2048 | 3
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.acceptSelected(true);
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.js
init_contextkey();
init_instantiation();
init_editorState();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/postEditWidget.css";
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var PostEditWidget_1;
var _a3;
var PostEditWidget = (_a3 = class extends Disposable {
  constructor(typeId, editor2, visibleContext, showCommand, range, edits, onSelectNewEdit, additionalActions, contextKeyService, _keybindingService, _actionWidgetService) {
    super();
    this.typeId = typeId;
    this.editor = editor2;
    this.showCommand = showCommand;
    this.range = range;
    this.edits = edits;
    this.onSelectNewEdit = onSelectNewEdit;
    this.additionalActions = additionalActions;
    this._keybindingService = _keybindingService;
    this._actionWidgetService = _actionWidgetService;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = true;
    this.create();
    this.visibleContext = visibleContext.bindTo(contextKeyService);
    this.visibleContext.set(true);
    this._register(toDisposable(() => this.visibleContext.reset()));
    this.editor.addContentWidget(this);
    this.editor.layoutContentWidget(this);
    this._register(toDisposable((() => this.editor.removeContentWidget(this))));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      this.dispose();
    }));
    this._register(Event.runAndSubscribe(_keybindingService.onDidUpdateKeybindings, () => {
      this._updateButtonTitle();
    }));
  }
  _updateButtonTitle() {
    const binding = this._keybindingService.lookupKeybinding(this.showCommand.id)?.getLabel();
    this.button.element.title = this.showCommand.label + (binding ? ` (${binding})` : "");
  }
  create() {
    this.domNode = $(".post-edit-widget");
    this.button = this._register(new Button(this.domNode, {
      supportIcons: true
    }));
    this.button.label = "$(insert)";
    this._register(addDisposableListener(this.domNode, EventType.CLICK, () => this.showSelector()));
  }
  getId() {
    return PostEditWidget_1.baseId + "." + this.typeId;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.range.getEndPosition(),
      preference: [
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    };
  }
  showSelector() {
    const pos = getDomNodePagePosition(this.button.element);
    const anchor = { x: pos.left + pos.width, y: pos.top + pos.height };
    this._actionWidgetService.show("postEditWidget", false, this.edits.allEdits.map((edit, i2) => {
      return {
        kind: "action",
        item: edit,
        label: edit.title,
        disabled: false,
        canPreview: false,
        group: { title: "", icon: ThemeIcon.fromId(i2 === this.edits.activeEditIndex ? Codicon.check.id : Codicon.blank.id) }
      };
    }), {
      onHide: () => {
        this.editor.focus();
      },
      onSelect: (item) => {
        this._actionWidgetService.hide(false);
        const i2 = this.edits.allEdits.findIndex((edit) => edit === item);
        if (i2 !== this.edits.activeEditIndex) {
          return this.onSelectNewEdit(i2);
        }
      }
    }, anchor, this.editor.getDomNode() ?? void 0, this.additionalActions);
  }
}, PostEditWidget_1 = _a3, _a3.baseId = "editor.widget.postEditWidget", _a3);
PostEditWidget = PostEditWidget_1 = __decorate7([
  __param7(8, IContextKeyService),
  __param7(9, IKeybindingService),
  __param7(10, IActionWidgetService)
], PostEditWidget);
var PostEditWidgetManager = class PostEditWidgetManager2 extends Disposable {
  constructor(_id, _editor, _visibleContext, _showCommand, _getAdditionalActions, _instantiationService, _bulkEditService, _notificationService) {
    super();
    this._id = _id;
    this._editor = _editor;
    this._visibleContext = _visibleContext;
    this._showCommand = _showCommand;
    this._getAdditionalActions = _getAdditionalActions;
    this._instantiationService = _instantiationService;
    this._bulkEditService = _bulkEditService;
    this._notificationService = _notificationService;
    this._currentWidget = this._register(new MutableDisposable());
    this._register(Event.any(_editor.onDidChangeModel, _editor.onDidChangeModelContent)(() => this.clear()));
  }
  async applyEditAndShowIfNeeded(ranges, edits, canShowWidget, resolve, token) {
    if (!ranges.length || !this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const edit = edits.allEdits.at(edits.activeEditIndex);
    if (!edit) {
      return;
    }
    const onDidSelectEdit = async (newEditIndex) => {
      const model2 = this._editor.getModel();
      if (!model2) {
        return;
      }
      await model2.undo();
      this.applyEditAndShowIfNeeded(ranges, { activeEditIndex: newEditIndex, allEdits: edits.allEdits }, canShowWidget, resolve, token);
    };
    const handleError = (e, message) => {
      if (isCancellationError(e)) {
        return;
      }
      this._notificationService.error(message);
      if (canShowWidget) {
        this.show(ranges[0], edits, onDidSelectEdit);
      }
    };
    const editorStateCts = new EditorStateCancellationTokenSource(this._editor, 1 | 2, void 0, token);
    let resolvedEdit;
    try {
      resolvedEdit = await raceCancellationError(resolve(edit, editorStateCts.token), editorStateCts.token);
    } catch (e) {
      return handleError(e, localize(932, "Error resolving edit '{0}':\n{1}", edit.title, toErrorMessage(e)));
    } finally {
      editorStateCts.dispose();
    }
    if (token.isCancellationRequested) {
      return;
    }
    const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, ranges, resolvedEdit);
    const primaryRange = ranges[0];
    const editTrackingDecoration = model.deltaDecorations([], [{
      range: primaryRange,
      options: {
        description: "paste-line-suffix",
        stickiness: 0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      }
    }]);
    this._editor.focus();
    let editResult;
    let editRange;
    try {
      editResult = await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor, token });
      editRange = model.getDecorationRange(editTrackingDecoration[0]);
    } catch (e) {
      return handleError(e, localize(933, "Error applying edit '{0}':\n{1}", edit.title, toErrorMessage(e)));
    } finally {
      model.deltaDecorations(editTrackingDecoration, []);
    }
    if (token.isCancellationRequested) {
      return;
    }
    if (canShowWidget && editResult.isApplied && edits.allEdits.length > 1) {
      this.show(editRange ?? primaryRange, edits, onDidSelectEdit);
    }
  }
  show(range, edits, onDidSelectEdit) {
    this.clear();
    if (this._editor.hasModel()) {
      this._currentWidget.value = this._instantiationService.createInstance(PostEditWidget, this._id, this._editor, this._visibleContext, this._showCommand, range, edits, onDidSelectEdit, this._getAdditionalActions());
    }
  }
  clear() {
    this._currentWidget.clear();
  }
  tryShowSelector() {
    this._currentWidget.value?.showSelector();
  }
};
PostEditWidgetManager = __decorate7([
  __param7(5, IInstantiationService),
  __param7(6, IBulkEditService),
  __param7(7, INotificationService)
], PostEditWidgetManager);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteController.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CopyPasteController_1;
var changePasteTypeCommandId = "editor.changePasteType";
var pasteAsPreferenceConfig = "editor.pasteAs.preferences";
var pasteWidgetVisibleCtx = new RawContextKey("pasteWidgetVisible", false, localize(912, "Whether the paste widget is showing"));
var vscodeClipboardMime = "application/vnd.code.copymetadata";
var _a4;
var CopyPasteController = (_a4 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CopyPasteController_1.ID);
  }
  constructor(editor2, instantiationService, _logService, _bulkEditService, _clipboardService, _commandService, _configService, _languageFeaturesService, _quickInputService, _progressService) {
    super();
    this._logService = _logService;
    this._bulkEditService = _bulkEditService;
    this._clipboardService = _clipboardService;
    this._commandService = _commandService;
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._quickInputService = _quickInputService;
    this._progressService = _progressService;
    this._editor = editor2;
    const container = editor2.getContainerDomNode();
    this._register(addDisposableListener(container, "copy", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "cut", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "paste", (e) => this.handlePaste(e), true));
    this._pasteProgressManager = this._register(new InlineProgressManager("pasteIntoEditor", editor2, instantiationService));
    this._postPasteWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, "pasteIntoEditor", editor2, pasteWidgetVisibleCtx, { id: changePasteTypeCommandId, label: localize(913, "Show paste options...") }, () => CopyPasteController_1._configureDefaultAction ? [CopyPasteController_1._configureDefaultAction] : []));
  }
  changePasteType() {
    this._postPasteWidgetManager.tryShowSelector();
  }
  async pasteAs(preferred) {
    this._logService.trace("CopyPasteController.pasteAs");
    this._editor.focus();
    try {
      this._logService.trace("Before calling editor.action.clipboardPasteAction");
      this._pasteAsActionContext = { preferred };
      await this._commandService.executeCommand("editor.action.clipboardPasteAction");
    } finally {
      this._pasteAsActionContext = void 0;
    }
  }
  clearWidgets() {
    this._postPasteWidgetManager.clear();
  }
  isPasteAsEnabled() {
    return this._editor.getOption(
      97
      /* EditorOption.pasteAs */
    ).enabled;
  }
  async finishedPaste() {
    await this._currentPasteOperation;
  }
  handleCopy(e) {
    let id = null;
    if (e.clipboardData) {
      const [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);
      const storedMetadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);
      id = storedMetadata?.id || null;
      this._logService.trace("CopyPasteController#handleCopy for id : ", id, " with text.length : ", text.length);
    } else {
      this._logService.trace("CopyPasteController#handleCopy");
    }
    if (!this._editor.hasTextFocus()) {
      return;
    }
    this._clipboardService.clearInternalState?.();
    if (!e.clipboardData || !this.isPasteAsEnabled()) {
      return;
    }
    const model = this._editor.getModel();
    const selections = this._editor.getSelections();
    if (!model || !selections?.length) {
      return;
    }
    const enableEmptySelectionClipboard = this._editor.getOption(
      45
      /* EditorOption.emptySelectionClipboard */
    );
    let ranges = selections;
    const wasFromEmptySelection = selections.length === 1 && selections[0].isEmpty();
    if (wasFromEmptySelection) {
      if (!enableEmptySelectionClipboard) {
        return;
      }
      ranges = [new Range(ranges[0].startLineNumber, 1, ranges[0].startLineNumber, 1 + model.getLineLength(ranges[0].startLineNumber))];
    }
    const toCopy = this._editor._getViewModel()?.getPlainTextToCopy(selections, enableEmptySelectionClipboard, isWindows);
    const multicursorText = Array.isArray(toCopy) ? toCopy : null;
    const defaultPastePayload = {
      multicursorText,
      pasteOnNewLine: wasFromEmptySelection,
      mode: null
    };
    const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((x) => !!x.prepareDocumentPaste);
    if (!providers.length) {
      this.setCopyMetadata(e.clipboardData, { defaultPastePayload });
      return;
    }
    const dataTransfer = toVSDataTransfer(e.clipboardData);
    const providerCopyMimeTypes = providers.flatMap((x) => x.copyMimeTypes ?? []);
    const handle = id ?? generateUuid();
    this.setCopyMetadata(e.clipboardData, {
      id: handle,
      providerCopyMimeTypes,
      defaultPastePayload
    });
    const operations = providers.map((provider) => {
      return {
        providerMimeTypes: provider.copyMimeTypes,
        operation: createCancelablePromise((token) => provider.prepareDocumentPaste(model, ranges, dataTransfer, token).catch((err) => {
          console.error(err);
          return void 0;
        }))
      };
    });
    CopyPasteController_1._currentCopyOperation?.operations.forEach((entry) => entry.operation.cancel());
    CopyPasteController_1._currentCopyOperation = { handle, operations };
  }
  async handlePaste(e) {
    if (e.clipboardData) {
      const [text, metadata2] = ClipboardEventUtils.getTextData(e.clipboardData);
      const metadataComputed = metadata2 || InMemoryClipboardMetadataManager.INSTANCE.get(text);
      this._logService.trace("CopyPasteController#handlePaste for id : ", metadataComputed?.id);
    } else {
      this._logService.trace("CopyPasteController#handlePaste");
    }
    if (!e.clipboardData || !this._editor.hasTextFocus()) {
      return;
    }
    MessageController.get(this._editor)?.closeMessage();
    this._currentPasteOperation?.cancel();
    this._currentPasteOperation = void 0;
    const model = this._editor.getModel();
    const selections = this._editor.getSelections();
    if (!selections?.length || !model) {
      return;
    }
    if (this._editor.getOption(
      104
      /* EditorOption.readOnly */
    ) || !this.isPasteAsEnabled() && !this._pasteAsActionContext) {
      return;
    }
    const metadata = this.fetchCopyMetadata(e);
    this._logService.trace("CopyPasteController#handlePaste with metadata : ", metadata?.id, " and text.length : ", e.clipboardData.getData("text/plain").length);
    const dataTransfer = toExternalVSDataTransfer(e.clipboardData);
    dataTransfer.delete(vscodeClipboardMime);
    const fileTypes = Array.from(e.clipboardData.files).map((file) => file.type);
    const allPotentialMimeTypes = [
      ...e.clipboardData.types,
      ...fileTypes,
      ...metadata?.providerCopyMimeTypes ?? [],
      // TODO: always adds `uri-list` because this get set if there are resources in the system clipboard.
      // However we can only check the system clipboard async. For this early check, just add it in.
      // We filter providers again once we have the final dataTransfer we will use.
      Mimes.uriList
    ];
    const allProviders = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((provider) => {
      const preference = this._pasteAsActionContext?.preferred;
      if (preference) {
        if (!this.providerMatchesPreference(provider, preference)) {
          return false;
        }
      }
      return provider.pasteMimeTypes?.some((type) => matchesMimeType(type, allPotentialMimeTypes));
    });
    if (!allProviders.length) {
      if (this._pasteAsActionContext?.preferred) {
        this.showPasteAsNoEditMessage(selections, this._pasteAsActionContext.preferred);
        e.preventDefault();
        e.stopImmediatePropagation();
      }
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
    if (this._pasteAsActionContext) {
      this.showPasteAsPick(this._pasteAsActionContext.preferred, allProviders, selections, dataTransfer, metadata);
    } else {
      this.doPasteInline(allProviders, selections, dataTransfer, metadata, e);
    }
  }
  showPasteAsNoEditMessage(selections, preference) {
    const kindLabel = "only" in preference ? preference.only.value : "preferences" in preference ? preference.preferences.length ? preference.preferences.map((preference2) => preference2.value).join(", ") : localize(914, "empty") : preference.providerId;
    MessageController.get(this._editor)?.showMessage(localize(915, "No paste edits for '{0}' found", kindLabel), selections[0].getStartPosition());
  }
  doPasteInline(allProviders, selections, dataTransfer, metadata, clipboardEvent) {
    this._logService.trace("CopyPasteController#doPasteInline");
    const editor2 = this._editor;
    if (!editor2.hasModel()) {
      return;
    }
    const editorStateCts = new EditorStateCancellationTokenSource(editor2, 1 | 2, void 0);
    const p = createCancelablePromise(async (pToken) => {
      const editor3 = this._editor;
      if (!editor3.hasModel()) {
        return;
      }
      const model = editor3.getModel();
      const disposables = new DisposableStore();
      const cts = disposables.add(new CancellationTokenSource(pToken));
      disposables.add(editorStateCts.token.onCancellationRequested(() => cts.cancel()));
      const token = cts.token;
      try {
        await this.mergeInDataFromCopy(allProviders, dataTransfer, metadata, token);
        if (token.isCancellationRequested) {
          return;
        }
        const supportedProviders = allProviders.filter((provider) => this.isSupportedPasteProvider(provider, dataTransfer));
        if (!supportedProviders.length || supportedProviders.length === 1 && supportedProviders[0] instanceof DefaultTextPasteOrDropEditProvider) {
          return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);
        }
        const context = {
          triggerKind: DocumentPasteTriggerKind.Automatic
        };
        const editSession = await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, token);
        disposables.add(editSession);
        if (token.isCancellationRequested) {
          return;
        }
        if (editSession.edits.length === 1 && editSession.edits[0].provider instanceof DefaultTextPasteOrDropEditProvider) {
          return this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);
        }
        if (editSession.edits.length) {
          const canShowWidget = editor3.getOption(
            97
            /* EditorOption.pasteAs */
          ).showPasteSelector === "afterPaste";
          return this._postPasteWidgetManager.applyEditAndShowIfNeeded(selections, { activeEditIndex: this.getInitialActiveEditIndex(model, editSession.edits), allEdits: editSession.edits }, canShowWidget, async (edit, resolveToken) => {
            if (!edit.provider.resolveDocumentPasteEdit) {
              return edit;
            }
            const resolveP = edit.provider.resolveDocumentPasteEdit(edit, resolveToken);
            const showP = new DeferredPromise();
            const resolved = await this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize(916, "Resolving paste edit for '{0}'. Click to cancel", edit.title), raceCancellation(Promise.race([showP.p, resolveP]), resolveToken), {
              cancel: () => showP.cancel()
            }, 0);
            if (resolved) {
              edit.insertText = resolved.insertText;
              edit.additionalEdit = resolved.additionalEdit;
            }
            return edit;
          }, token);
        }
        await this.applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent);
      } finally {
        disposables.dispose();
        if (this._currentPasteOperation === p) {
          this._currentPasteOperation = void 0;
        }
      }
    });
    this._pasteProgressManager.showWhile(selections[0].getEndPosition(), localize(917, "Running paste handlers. Click to cancel and do basic paste"), p, {
      cancel: async () => {
        p.cancel();
        if (editorStateCts.token.isCancellationRequested) {
          return;
        }
        await this.applyDefaultPasteHandler(dataTransfer, metadata, editorStateCts.token, clipboardEvent);
      }
    }).finally(() => {
      editorStateCts.dispose();
    });
    this._currentPasteOperation = p;
  }
  showPasteAsPick(preference, allProviders, selections, dataTransfer, metadata) {
    this._logService.trace("CopyPasteController#showPasteAsPick");
    const p = createCancelablePromise(async (token) => {
      const editor2 = this._editor;
      if (!editor2.hasModel()) {
        return;
      }
      const model = editor2.getModel();
      const disposables = new DisposableStore();
      const tokenSource = disposables.add(new EditorStateCancellationTokenSource(editor2, 1 | 2, void 0, token));
      try {
        await this.mergeInDataFromCopy(allProviders, dataTransfer, metadata, tokenSource.token);
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        let supportedProviders = allProviders.filter((provider) => this.isSupportedPasteProvider(provider, dataTransfer, preference));
        if (preference) {
          supportedProviders = supportedProviders.filter((provider) => this.providerMatchesPreference(provider, preference));
        }
        const context = {
          triggerKind: DocumentPasteTriggerKind.PasteAs,
          only: preference && "only" in preference ? preference.only : void 0
        };
        let editSession = disposables.add(await this.getPasteEdits(supportedProviders, dataTransfer, model, selections, context, tokenSource.token));
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (preference) {
          editSession = {
            edits: editSession.edits.filter((edit) => {
              if ("only" in preference) {
                return preference.only.contains(edit.kind);
              } else if ("preferences" in preference) {
                return preference.preferences.some((preference2) => preference2.contains(edit.kind));
              } else {
                return preference.providerId === edit.provider.id;
              }
            }),
            dispose: editSession.dispose
          };
        }
        if (!editSession.edits.length) {
          if (preference) {
            this.showPasteAsNoEditMessage(selections, preference);
          }
          return;
        }
        let pickedEdit;
        if (preference) {
          pickedEdit = editSession.edits.at(0);
        } else {
          const configureDefaultItem = {
            id: "editor.pasteAs.default",
            label: localize(918, "Configure default paste action"),
            edit: void 0
          };
          const selected = await this._quickInputService.pick([
            ...editSession.edits.map((edit) => ({
              label: edit.title,
              description: edit.kind?.value,
              edit
            })),
            ...CopyPasteController_1._configureDefaultAction ? [
              upcast({ type: "separator" }),
              {
                label: CopyPasteController_1._configureDefaultAction.label,
                edit: void 0
              }
            ] : []
          ], {
            placeHolder: localize(919, "Select Paste Action")
          });
          if (selected === configureDefaultItem) {
            CopyPasteController_1._configureDefaultAction?.run();
            return;
          }
          pickedEdit = selected?.edit;
        }
        if (!pickedEdit) {
          return;
        }
        const combinedWorkspaceEdit = createCombinedWorkspaceEdit(model.uri, selections, pickedEdit);
        await this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });
      } finally {
        disposables.dispose();
        if (this._currentPasteOperation === p) {
          this._currentPasteOperation = void 0;
        }
      }
    });
    this._progressService.withProgress({
      location: 10,
      title: localize(920, "Running paste handlers")
    }, () => p);
  }
  setCopyMetadata(dataTransfer, metadata) {
    this._logService.trace("CopyPasteController#setCopyMetadata new id : ", metadata.id);
    dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));
  }
  fetchCopyMetadata(e) {
    this._logService.trace("CopyPasteController#fetchCopyMetadata");
    if (!e.clipboardData) {
      return;
    }
    const rawMetadata = e.clipboardData.getData(vscodeClipboardMime);
    if (rawMetadata) {
      try {
        return JSON.parse(rawMetadata);
      } catch {
        return void 0;
      }
    }
    const [_, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);
    if (metadata) {
      return {
        defaultPastePayload: {
          mode: metadata.mode,
          multicursorText: metadata.multicursorText ?? null,
          pasteOnNewLine: !!metadata.isFromEmptySelection
        }
      };
    }
    return void 0;
  }
  async mergeInDataFromCopy(allProviders, dataTransfer, metadata, token) {
    this._logService.trace("CopyPasteController#mergeInDataFromCopy with metadata : ", metadata?.id);
    if (metadata?.id && CopyPasteController_1._currentCopyOperation?.handle === metadata.id) {
      const toResolve = CopyPasteController_1._currentCopyOperation.operations.filter((op) => allProviders.some((provider) => provider.pasteMimeTypes.some((type) => matchesMimeType(type, op.providerMimeTypes)))).map((op) => op.operation);
      const toMergeResults = await Promise.all(toResolve);
      if (token.isCancellationRequested) {
        return;
      }
      for (const toMergeData of toMergeResults.reverse()) {
        if (toMergeData) {
          for (const [key, value] of toMergeData) {
            dataTransfer.replace(key, value);
          }
        }
      }
    }
    if (!dataTransfer.has(Mimes.uriList)) {
      const resources = await this._clipboardService.readResources();
      if (token.isCancellationRequested) {
        return;
      }
      if (resources.length) {
        dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
      }
    }
  }
  async getPasteEdits(providers, dataTransfer, model, selections, context, token) {
    const disposables = new DisposableStore();
    const results = await raceCancellation(Promise.all(providers.map(async (provider) => {
      try {
        const edits2 = await provider.provideDocumentPasteEdits?.(model, selections, dataTransfer, context, token);
        if (edits2) {
          disposables.add(edits2);
        }
        return edits2?.edits?.map((edit) => ({ ...edit, provider }));
      } catch (err) {
        if (!isCancellationError(err)) {
          console.error(err);
        }
        return void 0;
      }
    })), token);
    const edits = coalesce(results ?? []).flat().filter((edit) => {
      return !context.only || context.only.contains(edit.kind);
    });
    return {
      edits: sortEditsByYieldTo(edits),
      dispose: () => disposables.dispose()
    };
  }
  async applyDefaultPasteHandler(dataTransfer, metadata, token, clipboardEvent) {
    const textDataTransfer = dataTransfer.get(Mimes.text) ?? dataTransfer.get("text");
    const text = await textDataTransfer?.asString() ?? "";
    if (token.isCancellationRequested) {
      return;
    }
    const payload = {
      clipboardEvent,
      text,
      pasteOnNewLine: metadata?.defaultPastePayload.pasteOnNewLine ?? false,
      multicursorText: metadata?.defaultPastePayload.multicursorText ?? null,
      mode: null
    };
    this._logService.trace("CopyPasteController#applyDefaultPasteHandler for id : ", metadata?.id);
    this._editor.trigger("keyboard", "paste", payload);
  }
  /**
   * Filter out providers if they:
   * - Don't handle any of the data transfer types we have
   * - Don't match the preferred paste kind
   */
  isSupportedPasteProvider(provider, dataTransfer, preference) {
    if (!provider.pasteMimeTypes?.some((type) => dataTransfer.matches(type))) {
      return false;
    }
    return !preference || this.providerMatchesPreference(provider, preference);
  }
  providerMatchesPreference(provider, preference) {
    if ("only" in preference) {
      return provider.providedPasteEditKinds.some((providedKind) => preference.only.contains(providedKind));
    } else if ("preferences" in preference) {
      return preference.preferences.some((providedKind) => preference.preferences.some((preferredKind) => preferredKind.contains(providedKind)));
    } else {
      return provider.id === preference.providerId;
    }
  }
  getInitialActiveEditIndex(model, edits) {
    const preferredProviders = this._configService.getValue(pasteAsPreferenceConfig, { resource: model.uri });
    for (const config of Array.isArray(preferredProviders) ? preferredProviders : []) {
      const desiredKind = new HierarchicalKind(config);
      const editIndex = edits.findIndex((edit) => desiredKind.contains(edit.kind));
      if (editIndex >= 0) {
        return editIndex;
      }
    }
    return 0;
  }
}, CopyPasteController_1 = _a4, _a4.ID = "editor.contrib.copyPasteActionController", _a4);
CopyPasteController = CopyPasteController_1 = __decorate8([
  __param8(1, IInstantiationService),
  __param8(2, ILogService),
  __param8(3, IBulkEditService),
  __param8(4, IClipboardService),
  __param8(5, ICommandService),
  __param8(6, IConfigurationService),
  __param8(7, ILanguageFeaturesService),
  __param8(8, IQuickInputService),
  __param8(9, IProgressService)
], CopyPasteController);

// node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/browser/clipboard.js
var CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
var supportsCut = isNative || document.queryCommandSupported("cut");
var supportsCopy = isNative || document.queryCommandSupported("copy");
var supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
  command.register();
  return command;
}
var CutAction = supportsCut ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind cut keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 54,
      win: { primary: 2048 | 54, secondary: [
        1024 | 20
        /* KeyCode.Delete */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize(809, "Cu&&t"),
    order: 1
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize(810, "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize(811, "Cut"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize(812, "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }]
})) : void 0;
var CopyAction = supportsCopy ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind copy keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 33,
      win: { primary: 2048 | 33, secondary: [
        2048 | 19
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize(813, "&&Copy"),
    order: 2
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize(814, "Copy"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize(815, "Copy"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize(816, "Copy"),
    order: 2
  }]
})) : void 0;
MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: localize2(821, "Copy As"), group: "2_ccp", order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: localize2(822, "Copy As"), group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextShare, title: localize2(823, "Share"), group: "11_share", order: -1, when: ContextKeyExpr.and(ContextKeyExpr.notEquals("resourceScheme", "output"), EditorContextKeys.editorTextFocus) });
MenuRegistry.appendMenuItem(MenuId.ExplorerContext, { submenu: MenuId.ExplorerContextShare, title: localize2(824, "Share"), group: "11_share", order: -1 });
var PasteAction = supportsPaste ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: (
    // Do not bind paste keybindings in the browser,
    // since browsers do that for us and it avoids security prompts
    isNative ? {
      primary: 2048 | 52,
      win: { primary: 2048 | 52, secondary: [
        1024 | 19
        /* KeyCode.Insert */
      ] },
      linux: { primary: 2048 | 52, secondary: [
        1024 | 19
        /* KeyCode.Insert */
      ] },
      weight: 100
      /* KeybindingWeight.EditorContrib */
    } : void 0
  ),
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize(817, "&&Paste"),
    order: 4
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize(818, "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize(819, "Paste"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize(820, "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }]
})) : void 0;
var ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: localize2(825, "Copy with Syntax Highlighting"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const logService = accessor.get(ILogService);
    logService.trace("ExecCommandCopyWithSyntaxHighlightingAction#run");
    if (!editor2.hasModel()) {
      return;
    }
    const emptySelectionClipboard = editor2.getOption(
      45
      /* EditorOption.emptySelectionClipboard */
    );
    if (!emptySelectionClipboard && editor2.getSelection().isEmpty()) {
      return;
    }
    CopyOptions.forceCopyWithSyntaxHighlighting = true;
    editor2.focus();
    logService.trace("ExecCommandCopyWithSyntaxHighlightingAction (before execCommand copy)");
    editor2.getContainerDomNode().ownerDocument.execCommand("copy");
    logService.trace("ExecCommandCopyWithSyntaxHighlightingAction (after execCommand copy)");
    CopyOptions.forceCopyWithSyntaxHighlighting = false;
  }
};
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, "code-editor", (accessor, args) => {
    const logService = accessor.get(ILogService);
    logService.trace("registerExecCommandImpl (addImplementation code-editor for : ", browserCommand, ")");
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(
        45
        /* EditorOption.emptySelectionClipboard */
      );
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      if (focusedEditor.getOption(
        170
        /* EditorOption.effectiveEditContext */
      ) && browserCommand === "cut") {
        logCopyCommand(focusedEditor);
        logService.trace("registerExecCommandImpl (before execCommand copy)");
        focusedEditor.getContainerDomNode().ownerDocument.execCommand("copy");
        focusedEditor.trigger(void 0, "cut", void 0);
        logService.trace("registerExecCommandImpl (after execCommand copy)");
      } else {
        logCopyCommand(focusedEditor);
        logService.trace("registerExecCommandImpl (before execCommand " + browserCommand + ")");
        focusedEditor.getContainerDomNode().ownerDocument.execCommand(browserCommand);
        logService.trace("registerExecCommandImpl (after execCommand " + browserCommand + ")");
      }
      return true;
    }
    return false;
  });
  target.addImplementation(0, "generic-dom", (accessor, args) => {
    const logService = accessor.get(ILogService);
    logService.trace("registerExecCommandImpl (addImplementation generic-dom for : ", browserCommand, ")");
    logService.trace("registerExecCommandImpl (before execCommand " + browserCommand + ")");
    getActiveDocument().execCommand(browserCommand);
    logService.trace("registerExecCommandImpl (after execCommand " + browserCommand + ")");
    return true;
  });
}
function logCopyCommand(editor2) {
  const editContextEnabled = editor2.getOption(
    170
    /* EditorOption.effectiveEditContext */
  );
  if (editContextEnabled) {
    const nativeEditContext = NativeEditContextRegistry.get(editor2.getId());
    if (nativeEditContext) {
      nativeEditContext.onWillCopy();
    }
  }
}
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
  PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
    const logService = accessor.get(ILogService);
    logService.trace("registerExecCommandImpl (addImplementation code-editor for : paste)");
    const codeEditorService = accessor.get(ICodeEditorService);
    const clipboardService = accessor.get(IClipboardService);
    const telemetryService = accessor.get(ITelemetryService);
    const productService = accessor.get(IProductService);
    const focusedEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasModel() && focusedEditor.hasTextFocus()) {
      const editContextEnabled = focusedEditor.getOption(
        170
        /* EditorOption.effectiveEditContext */
      );
      if (editContextEnabled) {
        const nativeEditContext = NativeEditContextRegistry.get(focusedEditor.getId());
        if (nativeEditContext) {
          nativeEditContext.onWillPaste();
        }
      }
      const sw = StopWatch.create(true);
      logService.trace("registerExecCommandImpl (before triggerPaste)");
      const triggerPaste = clipboardService.triggerPaste(getActiveWindow().vscodeWindowId);
      if (triggerPaste) {
        logService.trace("registerExecCommandImpl (triggerPaste defined)");
        return triggerPaste.then(async () => {
          logService.trace("registerExecCommandImpl (after triggerPaste)");
          if (productService.quality !== "stable") {
            const duration = sw.elapsed();
            telemetryService.publicLog2("editorAsyncPaste", { duration });
          }
          return CopyPasteController.get(focusedEditor)?.finishedPaste() ?? Promise.resolve();
        });
      } else {
        logService.trace("registerExecCommandImpl (triggerPaste undefined)");
      }
      if (isWeb) {
        logService.trace("registerExecCommandImpl (Paste handling on web)");
        return (async () => {
          const clipboardText = await clipboardService.readText();
          if (clipboardText !== "") {
            const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
            let pasteOnNewLine = false;
            let multicursorText = null;
            let mode = null;
            if (metadata) {
              pasteOnNewLine = focusedEditor.getOption(
                45
                /* EditorOption.emptySelectionClipboard */
              ) && !!metadata.isFromEmptySelection;
              multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
              mode = metadata.mode;
            }
            logService.trace("registerExecCommandImpl (clipboardText.length : ", clipboardText.length, " id : ", metadata?.id, ")");
            focusedEditor.trigger("keyboard", "paste", {
              text: clipboardText,
              pasteOnNewLine,
              multicursorText,
              mode
            });
          }
        })();
      }
      return true;
    }
    return false;
  });
  PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
    const logService = accessor.get(ILogService);
    logService.trace("registerExecCommandImpl (addImplementation generic-dom for : paste)");
    const triggerPaste = accessor.get(IClipboardService).triggerPaste(getActiveWindow().vscodeWindowId);
    return triggerPaste ?? false;
  });
}
if (supportsCopy) {
  registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
init_strings();
init_editorExtensions();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeAction.js
init_arrays();
init_cancellation();
init_errors();
init_lifecycle();
init_uri();
init_nls();
init_commands();
init_telemetry();
init_range();
init_selection();
init_languages();
init_languageFeatures();
init_model();
init_textModelEditSource();
init_editorState();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/common/types.js
init_errors();
var CodeActionKind = new class {
  constructor() {
    this.QuickFix = new HierarchicalKind("quickfix");
    this.Refactor = new HierarchicalKind("refactor");
    this.RefactorExtract = this.Refactor.append("extract");
    this.RefactorInline = this.Refactor.append("inline");
    this.RefactorMove = this.Refactor.append("move");
    this.RefactorRewrite = this.Refactor.append("rewrite");
    this.Notebook = new HierarchicalKind("notebook");
    this.Source = new HierarchicalKind("source");
    this.SourceOrganizeImports = this.Source.append("organizeImports");
    this.SourceFixAll = this.Source.append("fixAll");
    this.SurroundWith = this.Refactor.append("surround");
  }
}();
var CodeActionTriggerSource;
(function(CodeActionTriggerSource2) {
  CodeActionTriggerSource2["Refactor"] = "refactor";
  CodeActionTriggerSource2["RefactorPreview"] = "refactor preview";
  CodeActionTriggerSource2["Lightbulb"] = "lightbulb";
  CodeActionTriggerSource2["Default"] = "other (default)";
  CodeActionTriggerSource2["SourceAction"] = "source action";
  CodeActionTriggerSource2["QuickFix"] = "quick fix action";
  CodeActionTriggerSource2["FixAll"] = "fix all";
  CodeActionTriggerSource2["OrganizeImports"] = "organize imports";
  CodeActionTriggerSource2["AutoFix"] = "auto fix";
  CodeActionTriggerSource2["QuickFixHover"] = "quick fix hover window";
  CodeActionTriggerSource2["OnSave"] = "save participants";
  CodeActionTriggerSource2["ProblemsView"] = "problems view";
})(CodeActionTriggerSource || (CodeActionTriggerSource = {}));
function mayIncludeActionsOfKind(filter, providedKind) {
  if (filter.include && !filter.include.intersects(providedKind)) {
    return false;
  }
  if (filter.excludes) {
    if (filter.excludes.some((exclude) => excludesAction(providedKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions && CodeActionKind.Source.contains(providedKind)) {
    return false;
  }
  return true;
}
function filtersAction(filter, action) {
  const actionKind = action.kind ? new HierarchicalKind(action.kind) : void 0;
  if (filter.include) {
    if (!actionKind || !filter.include.contains(actionKind)) {
      return false;
    }
  }
  if (filter.excludes) {
    if (actionKind && filter.excludes.some((exclude) => excludesAction(actionKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions) {
    if (actionKind && CodeActionKind.Source.contains(actionKind)) {
      return false;
    }
  }
  if (filter.onlyIncludePreferredActions) {
    if (!action.isPreferred) {
      return false;
    }
  }
  return true;
}
function excludesAction(providedKind, exclude, include) {
  if (!exclude.contains(providedKind)) {
    return false;
  }
  if (include && exclude.contains(include)) {
    return false;
  }
  return true;
}
var CodeActionCommandArgs = class _CodeActionCommandArgs {
  static fromUser(arg, defaults) {
    if (!arg || typeof arg !== "object") {
      return new _CodeActionCommandArgs(defaults.kind, defaults.apply, false);
    }
    return new _CodeActionCommandArgs(_CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), _CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), _CodeActionCommandArgs.getPreferredUser(arg));
  }
  static getApplyFromUser(arg, defaultAutoApply) {
    switch (typeof arg.apply === "string" ? arg.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return defaultAutoApply;
    }
  }
  static getKindFromUser(arg, defaultKind) {
    return typeof arg.kind === "string" ? new HierarchicalKind(arg.kind) : defaultKind;
  }
  static getPreferredUser(arg) {
    return typeof arg.preferred === "boolean" ? arg.preferred : false;
  }
  constructor(kind, apply, preferred) {
    this.kind = kind;
    this.apply = apply;
    this.preferred = preferred;
  }
};
var CodeActionItem = class {
  constructor(action, provider, highlightRange) {
    this.action = action;
    this.provider = provider;
    this.highlightRange = highlightRange;
  }
  async resolve(token) {
    if (this.provider?.resolveCodeAction && !this.action.edit) {
      let action;
      try {
        action = await this.provider.resolveCodeAction(this.action, token);
      } catch (err) {
        onUnexpectedExternalError(err);
      }
      if (action) {
        this.action.edit = action.edit;
      }
    }
    return this;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeAction.js
var codeActionCommandId = "editor.action.codeAction";
var quickFixCommandId = "editor.action.quickFix";
var autoFixCommandId = "editor.action.autoFix";
var refactorCommandId = "editor.action.refactor";
var sourceActionCommandId = "editor.action.sourceAction";
var organizeImportsCommandId = "editor.action.organizeImports";
var fixAllCommandId = "editor.action.fixAll";
var CODE_ACTION_SOUND_APPLIED_DURATION = 1e3;
var ManagedCodeActionSet = class _ManagedCodeActionSet extends Disposable {
  static codeActionsPreferredComparator(a, b) {
    if (a.isPreferred && !b.isPreferred) {
      return -1;
    } else if (!a.isPreferred && b.isPreferred) {
      return 1;
    } else {
      return 0;
    }
  }
  static codeActionsComparator({ action: a }, { action: b }) {
    if (a.isAI && !b.isAI) {
      return 1;
    } else if (!a.isAI && b.isAI) {
      return -1;
    }
    if (isNonEmptyArray(a.diagnostics)) {
      return isNonEmptyArray(b.diagnostics) ? _ManagedCodeActionSet.codeActionsPreferredComparator(a, b) : -1;
    } else if (isNonEmptyArray(b.diagnostics)) {
      return 1;
    } else {
      return _ManagedCodeActionSet.codeActionsPreferredComparator(a, b);
    }
  }
  constructor(actions, documentation, disposables) {
    super();
    this.documentation = documentation;
    this._register(disposables);
    this.allActions = [...actions].sort(_ManagedCodeActionSet.codeActionsComparator);
    this.validActions = this.allActions.filter(({ action }) => !action.disabled);
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: fix }) => !!fix.kind && CodeActionKind.QuickFix.contains(new HierarchicalKind(fix.kind)) && !!fix.isPreferred);
  }
  get hasAIFix() {
    return this.validActions.some(({ action: fix }) => !!fix.isAI);
  }
  get allAIFixes() {
    return this.validActions.every(({ action: fix }) => !!fix.isAI);
  }
};
var emptyCodeActionsResponse = { actions: [], documentation: void 0 };
async function getCodeActions(registry, model, rangeOrSelection, trigger, progress, token) {
  const filter = trigger.filter || {};
  const notebookFilter = {
    ...filter,
    excludes: [...filter.excludes || [], CodeActionKind.Notebook]
  };
  const codeActionContext = {
    only: filter.include?.value,
    trigger: trigger.type
  };
  const cts = new TextModelCancellationTokenSource(model, token);
  const excludeNotebookCodeActions = trigger.type === 2;
  const providers = getCodeActionProviders(registry, model, excludeNotebookCodeActions ? notebookFilter : filter);
  const disposables = new DisposableStore();
  const promises = providers.map(async (provider) => {
    const handle = setTimeout(() => progress.report(provider), 1250);
    try {
      const providedCodeActions = await provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
      if (cts.token.isCancellationRequested) {
        providedCodeActions?.dispose();
        return emptyCodeActionsResponse;
      }
      if (providedCodeActions) {
        disposables.add(providedCodeActions);
      }
      const filteredActions = (providedCodeActions?.actions || []).filter((action) => action && filtersAction(filter, action));
      const documentation = getDocumentationFromProvider(provider, filteredActions, filter.include);
      return {
        actions: filteredActions.map((action) => new CodeActionItem(action, provider)),
        documentation
      };
    } catch (err) {
      if (isCancellationError(err)) {
        throw err;
      }
      onUnexpectedExternalError(err);
      return emptyCodeActionsResponse;
    } finally {
      clearTimeout(handle);
    }
  });
  const listener = registry.onDidChange(() => {
    const newProviders = registry.all(model);
    if (!equals(newProviders, providers)) {
      cts.cancel();
    }
  });
  try {
    const actions = await Promise.all(promises);
    const allActions = actions.map((x) => x.actions).flat();
    const allDocumentation = [
      ...coalesce(actions.map((x) => x.documentation)),
      ...getAdditionalDocumentationForShowingActions(registry, model, trigger, allActions)
    ];
    const managedCodeActionSet = new ManagedCodeActionSet(allActions, allDocumentation, disposables);
    disposables.add(managedCodeActionSet);
    return managedCodeActionSet;
  } catch (err) {
    disposables.dispose();
    throw err;
  } finally {
    listener.dispose();
    cts.dispose();
  }
}
function getCodeActionProviders(registry, model, filter) {
  return registry.all(model).filter((provider) => {
    if (!provider.providedCodeActionKinds) {
      return true;
    }
    return provider.providedCodeActionKinds.some((kind) => mayIncludeActionsOfKind(filter, new HierarchicalKind(kind)));
  });
}
function* getAdditionalDocumentationForShowingActions(registry, model, trigger, actionsToShow) {
  if (model && actionsToShow.length) {
    for (const provider of registry.all(model)) {
      if (provider._getAdditionalMenuItems) {
        yield* provider._getAdditionalMenuItems?.({ trigger: trigger.type, only: trigger.filter?.include?.value }, actionsToShow.map((item) => item.action));
      }
    }
  }
}
function getDocumentationFromProvider(provider, providedCodeActions, only) {
  if (!provider.documentation) {
    return void 0;
  }
  const documentation = provider.documentation.map((entry) => ({ kind: new HierarchicalKind(entry.kind), command: entry.command }));
  if (only) {
    let currentBest;
    for (const entry of documentation) {
      if (entry.kind.contains(only)) {
        if (!currentBest) {
          currentBest = entry;
        } else {
          if (currentBest.kind.contains(entry.kind)) {
            currentBest = entry;
          }
        }
      }
    }
    if (currentBest) {
      return currentBest?.command;
    }
  }
  for (const action of providedCodeActions) {
    if (!action.kind) {
      continue;
    }
    for (const entry of documentation) {
      if (entry.kind.contains(new HierarchicalKind(action.kind))) {
        return entry.command;
      }
    }
  }
  return void 0;
}
var ApplyCodeActionReason;
(function(ApplyCodeActionReason2) {
  ApplyCodeActionReason2["OnSave"] = "onSave";
  ApplyCodeActionReason2["FromProblemsView"] = "fromProblemsView";
  ApplyCodeActionReason2["FromCodeActions"] = "fromCodeActions";
  ApplyCodeActionReason2["FromAILightbulb"] = "fromAILightbulb";
  ApplyCodeActionReason2["FromProblemsHover"] = "fromProblemsHover";
})(ApplyCodeActionReason || (ApplyCodeActionReason = {}));
async function applyCodeAction(accessor, item, codeActionReason, options, token = CancellationToken.None) {
  const bulkEditService = accessor.get(IBulkEditService);
  const commandService = accessor.get(ICommandService);
  const telemetryService = accessor.get(ITelemetryService);
  const notificationService = accessor.get(INotificationService);
  const accessibilitySignalService = accessor.get(IAccessibilitySignalService);
  telemetryService.publicLog2("codeAction.applyCodeAction", {
    codeActionTitle: item.action.title,
    codeActionKind: item.action.kind,
    codeActionIsPreferred: !!item.action.isPreferred,
    reason: codeActionReason
  });
  accessibilitySignalService.playSignal(AccessibilitySignal.codeActionTriggered);
  await item.resolve(token);
  if (token.isCancellationRequested) {
    return;
  }
  if (item.action.edit?.edits.length) {
    const result = await bulkEditService.apply(item.action.edit, {
      editor: options?.editor,
      label: item.action.title,
      quotableLabel: item.action.title,
      code: "undoredo.codeAction",
      respectAutoSaveConfig: codeActionReason !== ApplyCodeActionReason.OnSave,
      showPreview: options?.preview,
      reason: EditSources.codeAction({ kind: item.action.kind, providerId: ProviderId.fromExtensionId(item.provider?.extensionId) })
    });
    if (!result.isApplied) {
      return;
    }
  }
  if (item.action.command) {
    try {
      await commandService.executeCommand(item.action.command.id, ...item.action.command.arguments || []);
    } catch (err) {
      const message = asMessage(err);
      notificationService.error(typeof message === "string" ? message : localize(826, "An unknown error occurred while applying the code action"));
    }
  }
  setTimeout(() => accessibilitySignalService.playSignal(AccessibilitySignal.codeActionApplied), CODE_ACTION_SOUND_APPLIED_DURATION);
}
function asMessage(err) {
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error && typeof err.message === "string") {
    return err.message;
  } else {
    return void 0;
  }
}
CommandsRegistry.registerCommand("_executeCodeActionProvider", async function(accessor, resource, rangeOrSelection, kind, itemResolveCount) {
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const { codeActionProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection) ? Selection.liftSelection(rangeOrSelection) : Range.isIRange(rangeOrSelection) ? model.validateRange(rangeOrSelection) : void 0;
  if (!validatedRangeOrSelection) {
    throw illegalArgument();
  }
  const include = typeof kind === "string" ? new HierarchicalKind(kind) : void 0;
  const codeActionSet = await getCodeActions(codeActionProvider, model, validatedRangeOrSelection, { type: 1, triggerAction: CodeActionTriggerSource.Default, filter: { includeSourceActions: true, include } }, Progress.None, CancellationToken.None);
  const resolving = [];
  const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === "number" ? itemResolveCount : 0);
  for (let i2 = 0; i2 < resolveCount; i2++) {
    resolving.push(codeActionSet.validActions[i2].resolve(CancellationToken.None));
  }
  try {
    await Promise.all(resolving);
    return codeActionSet.validActions.map((item) => item.action);
  } finally {
    setTimeout(() => codeActionSet.dispose(), 100);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
init_nls();
init_contextkey();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionController.js
init_dom();
init_errors();
init_lazy();
init_lifecycle();
init_nls();
init_commands();
init_configuration();
init_contextkey();
init_instantiation();
init_colorRegistry();
init_theme();
init_themeService();
init_position();
init_textModel();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionKeybindingResolver.js
init_lazy();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CodeActionKeybindingResolver_1;
var _a5;
var CodeActionKeybindingResolver = (_a5 = class {
  constructor(keybindingService) {
    this.keybindingService = keybindingService;
  }
  getResolver() {
    const allCodeActionBindings = new Lazy(() => this.keybindingService.getKeybindings().filter((item) => CodeActionKeybindingResolver_1.codeActionCommands.indexOf(item.command) >= 0).filter((item) => item.resolvedKeybinding).map((item) => {
      let commandArgs = item.commandArgs;
      if (item.command === organizeImportsCommandId) {
        commandArgs = { kind: CodeActionKind.SourceOrganizeImports.value };
      } else if (item.command === fixAllCommandId) {
        commandArgs = { kind: CodeActionKind.SourceFixAll.value };
      }
      return {
        resolvedKeybinding: item.resolvedKeybinding,
        ...CodeActionCommandArgs.fromUser(commandArgs, {
          kind: HierarchicalKind.None,
          apply: "never"
          /* CodeActionAutoApply.Never */
        })
      };
    }));
    return (action) => {
      if (action.kind) {
        const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.value);
        return binding?.resolvedKeybinding;
      }
      return void 0;
    };
  }
  bestKeybindingForCodeAction(action, candidates) {
    if (!action.kind) {
      return void 0;
    }
    const kind = new HierarchicalKind(action.kind);
    return candidates.filter((candidate) => candidate.kind.contains(kind)).filter((candidate) => {
      if (candidate.preferred) {
        return action.isPreferred;
      }
      return true;
    }).reduceRight((currentBest, candidate) => {
      if (!currentBest) {
        return candidate;
      }
      return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;
    }, void 0);
  }
}, CodeActionKeybindingResolver_1 = _a5, _a5.codeActionCommands = [
  refactorCommandId,
  codeActionCommandId,
  sourceActionCommandId,
  organizeImportsCommandId,
  fixAllCommandId
], _a5);
CodeActionKeybindingResolver = CodeActionKeybindingResolver_1 = __decorate9([
  __param9(0, IKeybindingService)
], CodeActionKeybindingResolver);

// node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codiconStyles.js
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codicon/codicon.css";
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codicon/codicon-modifiers.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionMenu.js
init_codicons();

// node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/browser/symbolIcons.js
init_nls();
init_colorRegistry();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/browser/symbolIcons.css";
var SYMBOL_ICON_ARRAY_FOREGROUND = registerColor("symbolIcon.arrayForeground", foreground, localize(1480, "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor("symbolIcon.booleanForeground", foreground, localize(1481, "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CLASS_FOREGROUND = registerColor("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, localize(1482, "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_COLOR_FOREGROUND = registerColor("symbolIcon.colorForeground", foreground, localize(1483, "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor("symbolIcon.constantForeground", foreground, localize(1484, "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, localize(1485, "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, localize(1486, "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize(1487, "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_EVENT_FOREGROUND = registerColor("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, localize(1488, "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FIELD_FOREGROUND = registerColor("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize(1489, "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FILE_FOREGROUND = registerColor("symbolIcon.fileForeground", foreground, localize(1490, "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FOLDER_FOREGROUND = registerColor("symbolIcon.folderForeground", foreground, localize(1491, "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, localize(1492, "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize(1493, "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEY_FOREGROUND = registerColor("symbolIcon.keyForeground", foreground, localize(1494, "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor("symbolIcon.keywordForeground", foreground, localize(1495, "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_METHOD_FOREGROUND = registerColor("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, localize(1496, "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_MODULE_FOREGROUND = registerColor("symbolIcon.moduleForeground", foreground, localize(1497, "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor("symbolIcon.namespaceForeground", foreground, localize(1498, "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NULL_FOREGROUND = registerColor("symbolIcon.nullForeground", foreground, localize(1499, "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NUMBER_FOREGROUND = registerColor("symbolIcon.numberForeground", foreground, localize(1500, "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OBJECT_FOREGROUND = registerColor("symbolIcon.objectForeground", foreground, localize(1501, "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor("symbolIcon.operatorForeground", foreground, localize(1502, "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor("symbolIcon.packageForeground", foreground, localize(1503, "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor("symbolIcon.propertyForeground", foreground, localize(1504, "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor("symbolIcon.referenceForeground", foreground, localize(1505, "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor("symbolIcon.snippetForeground", foreground, localize(1506, "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRING_FOREGROUND = registerColor("symbolIcon.stringForeground", foreground, localize(1507, "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRUCT_FOREGROUND = registerColor("symbolIcon.structForeground", foreground, localize(1508, "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TEXT_FOREGROUND = registerColor("symbolIcon.textForeground", foreground, localize(1509, "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor("symbolIcon.typeParameterForeground", foreground, localize(1510, "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_UNIT_FOREGROUND = registerColor("symbolIcon.unitForeground", foreground, localize(1511, "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize(1512, "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionMenu.js
init_nls();
var uncategorizedCodeActionGroup = Object.freeze({ kind: HierarchicalKind.Empty, title: localize(862, "More Actions...") });
var codeActionGroups = Object.freeze([
  { kind: CodeActionKind.QuickFix, title: localize(863, "Quick Fix") },
  { kind: CodeActionKind.RefactorExtract, title: localize(864, "Extract"), icon: Codicon.wrench },
  { kind: CodeActionKind.RefactorInline, title: localize(865, "Inline"), icon: Codicon.wrench },
  { kind: CodeActionKind.RefactorRewrite, title: localize(866, "Rewrite"), icon: Codicon.wrench },
  { kind: CodeActionKind.RefactorMove, title: localize(867, "Move"), icon: Codicon.wrench },
  { kind: CodeActionKind.SurroundWith, title: localize(868, "Surround With"), icon: Codicon.surroundWith },
  { kind: CodeActionKind.Source, title: localize(869, "Source Action"), icon: Codicon.symbolFile },
  uncategorizedCodeActionGroup
]);
function toMenuItems(inputCodeActions, showHeaders, keybindingResolver) {
  if (!showHeaders) {
    return inputCodeActions.map((action) => {
      return {
        kind: "action",
        item: action,
        group: uncategorizedCodeActionGroup,
        disabled: !!action.action.disabled,
        label: action.action.disabled || action.action.title,
        canPreview: !!action.action.edit?.edits.length
      };
    });
  }
  const menuEntries = codeActionGroups.map((group) => ({ group, actions: [] }));
  for (const action of inputCodeActions) {
    const kind = action.action.kind ? new HierarchicalKind(action.action.kind) : HierarchicalKind.None;
    for (const menuEntry of menuEntries) {
      if (menuEntry.group.kind.contains(kind)) {
        menuEntry.actions.push(action);
        break;
      }
    }
  }
  const allMenuItems = [];
  for (const menuEntry of menuEntries) {
    if (menuEntry.actions.length) {
      allMenuItems.push({ kind: "header", group: menuEntry.group });
      for (const action of menuEntry.actions) {
        const group = menuEntry.group;
        allMenuItems.push({
          kind: "action",
          item: action,
          group: action.action.isAI ? { title: group.title, kind: group.kind, icon: Codicon.sparkle } : group,
          label: action.action.title,
          disabled: !!action.action.disabled,
          keybinding: keybindingResolver(action.action)
        });
      }
    }
  }
  return allMenuItems;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionModel.js
init_async();
init_errors();
init_event();
init_lifecycle();
init_resources();
init_contextkey();
init_position();
init_selection();
var SUPPORTED_CODE_ACTIONS = new RawContextKey("supportedCodeAction", "");
var APPLY_FIX_ALL_COMMAND_ID = "_typescript.applyFixAllCodeAction";
var CodeActionOracle = class extends Disposable {
  constructor(_editor, _markerService, _signalChange, _delay = 250) {
    super();
    this._editor = _editor;
    this._markerService = _markerService;
    this._signalChange = _signalChange;
    this._delay = _delay;
    this._autoTriggerTimer = this._register(new TimeoutTimer());
    this._register(this._markerService.onMarkerChanged((e) => this._onMarkerChanges(e)));
    this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));
  }
  trigger(trigger) {
    const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);
    this._signalChange(selection ? { trigger, selection } : void 0);
  }
  _onMarkerChanges(resources) {
    const model = this._editor.getModel();
    if (model && resources.some((resource) => isEqual(resource, model.uri))) {
      this._tryAutoTrigger();
    }
  }
  _tryAutoTrigger() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2, triggerAction: CodeActionTriggerSource.Default });
    }, this._delay);
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {
    if (!this._editor.hasModel()) {
      return void 0;
    }
    const selection = this._editor.getSelection();
    if (trigger.type === 1) {
      return selection;
    }
    const enabled = this._editor.getOption(
      73
      /* EditorOption.lightbulb */
    ).enabled;
    if (enabled === ShowLightbulbIconMode.Off) {
      return void 0;
    } else if (enabled === ShowLightbulbIconMode.On) {
      return selection;
    } else if (enabled === ShowLightbulbIconMode.OnCode) {
      const isSelectionEmpty = selection.isEmpty();
      if (!isSelectionEmpty) {
        return selection;
      }
      const model = this._editor.getModel();
      const { lineNumber, column } = selection.getPosition();
      const line = model.getLineContent(lineNumber);
      if (line.length === 0) {
        return void 0;
      } else if (column === 1) {
        if (/\s/.test(line[0])) {
          return void 0;
        }
      } else if (column === model.getLineMaxColumn(lineNumber)) {
        if (/\s/.test(line[line.length - 1])) {
          return void 0;
        }
      } else {
        if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) {
          return void 0;
        }
      }
    }
    return selection;
  }
};
var CodeActionsState;
(function(CodeActionsState2) {
  CodeActionsState2.Empty = {
    type: 0
    /* Type.Empty */
  };
  class Triggered {
    constructor(trigger, position, _cancellablePromise) {
      this.trigger = trigger;
      this.position = position;
      this._cancellablePromise = _cancellablePromise;
      this.type = 1;
      this.actions = _cancellablePromise.catch((e) => {
        if (isCancellationError(e)) {
          return emptyCodeActionSet;
        }
        throw e;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  CodeActionsState2.Triggered = Triggered;
})(CodeActionsState || (CodeActionsState = {}));
var emptyCodeActionSet = Object.freeze({
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: false,
  hasAIFix: false,
  allAIFixes: false
});
var CodeActionModel = class extends Disposable {
  constructor(_editor, _registry, _markerService, contextKeyService, _progressService, _configurationService) {
    super();
    this._editor = _editor;
    this._registry = _registry;
    this._markerService = _markerService;
    this._progressService = _progressService;
    this._configurationService = _configurationService;
    this._codeActionOracle = this._register(new MutableDisposable());
    this._state = CodeActionsState.Empty;
    this._onDidChangeState = this._register(new Emitter());
    this.onDidChangeState = this._onDidChangeState.event;
    this.codeActionsDisposable = this._register(new MutableDisposable());
    this._disposed = false;
    this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
    this._register(this._editor.onDidChangeModel(() => this._update()));
    this._register(this._editor.onDidChangeModelLanguage(() => this._update()));
    this._register(this._registry.onDidChange(() => this._update()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        73
        /* EditorOption.lightbulb */
      )) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    super.dispose();
    this.setState(CodeActionsState.Empty, true);
  }
  _settingEnabledNearbyQuickfixes() {
    const model = this._editor?.getModel();
    return this._configurationService ? this._configurationService.getValue("editor.codeActionWidget.includeNearbyQuickFixes", { resource: model?.uri }) : false;
  }
  _update() {
    if (this._disposed) {
      return;
    }
    this._codeActionOracle.value = void 0;
    this.setState(CodeActionsState.Empty);
    const model = this._editor.getModel();
    if (model && this._registry.has(model) && !this._editor.getOption(
      104
      /* EditorOption.readOnly */
    )) {
      const supportedActions = this._registry.all(model).flatMap((provider) => provider.providedCodeActionKinds ?? []);
      this._supportedCodeActions.set(supportedActions.join(" "));
      this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, (trigger) => {
        if (!trigger) {
          this.setState(CodeActionsState.Empty);
          return;
        }
        const startPosition = trigger.selection.getStartPosition();
        const actions = createCancelablePromise(async (token) => {
          if (this._settingEnabledNearbyQuickfixes() && trigger.trigger.type === 1 && (trigger.trigger.triggerAction === CodeActionTriggerSource.QuickFix || trigger.trigger.filter?.include?.contains(CodeActionKind.QuickFix))) {
            const codeActionSet2 = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);
            this.codeActionsDisposable.value = codeActionSet2;
            const allCodeActions = [...codeActionSet2.allActions];
            if (token.isCancellationRequested) {
              codeActionSet2.dispose();
              return emptyCodeActionSet;
            }
            const foundQuickfix = codeActionSet2.validActions?.some((action) => {
              return action.action.kind && CodeActionKind.QuickFix.contains(new HierarchicalKind(action.action.kind)) && !action.action.isAI;
            });
            const allMarkers = this._markerService.read({ resource: model.uri });
            if (foundQuickfix) {
              for (const action of codeActionSet2.validActions) {
                if (action.action.command?.arguments?.some((arg) => typeof arg === "string" && arg.includes(APPLY_FIX_ALL_COMMAND_ID))) {
                  action.action.diagnostics = [...allMarkers.filter((marker) => marker.relatedInformation)];
                }
              }
              return { validActions: codeActionSet2.validActions, allActions: allCodeActions, documentation: codeActionSet2.documentation, hasAutoFix: codeActionSet2.hasAutoFix, hasAIFix: codeActionSet2.hasAIFix, allAIFixes: codeActionSet2.allAIFixes, dispose: () => {
                this.codeActionsDisposable.value = codeActionSet2;
              } };
            } else if (!foundQuickfix) {
              if (allMarkers.length > 0) {
                const currPosition = trigger.selection.getPosition();
                let trackedPosition = currPosition;
                let distance = Number.MAX_VALUE;
                const currentActions = [...codeActionSet2.validActions];
                for (const marker of allMarkers) {
                  const col = marker.endColumn;
                  const row = marker.endLineNumber;
                  const startRow = marker.startLineNumber;
                  if (row === currPosition.lineNumber || startRow === currPosition.lineNumber) {
                    trackedPosition = new Position(row, col);
                    const newCodeActionTrigger = {
                      type: trigger.trigger.type,
                      triggerAction: trigger.trigger.triggerAction,
                      filter: { include: trigger.trigger.filter?.include ? trigger.trigger.filter?.include : CodeActionKind.QuickFix },
                      autoApply: trigger.trigger.autoApply,
                      context: { notAvailableMessage: trigger.trigger.context?.notAvailableMessage || "", position: trackedPosition }
                    };
                    const selectionAsPosition = new Selection(trackedPosition.lineNumber, trackedPosition.column, trackedPosition.lineNumber, trackedPosition.column);
                    const actionsAtMarker = await getCodeActions(this._registry, model, selectionAsPosition, newCodeActionTrigger, Progress.None, token);
                    if (token.isCancellationRequested) {
                      actionsAtMarker.dispose();
                      return emptyCodeActionSet;
                    }
                    if (actionsAtMarker.validActions.length !== 0) {
                      for (const action of actionsAtMarker.validActions) {
                        if (action.action.command?.arguments?.some((arg) => typeof arg === "string" && arg.includes(APPLY_FIX_ALL_COMMAND_ID))) {
                          action.action.diagnostics = [...allMarkers.filter((marker2) => marker2.relatedInformation)];
                        }
                      }
                      if (codeActionSet2.allActions.length === 0) {
                        allCodeActions.push(...actionsAtMarker.allActions);
                      }
                      if (Math.abs(currPosition.column - col) < distance) {
                        currentActions.unshift(...actionsAtMarker.validActions);
                      } else {
                        currentActions.push(...actionsAtMarker.validActions);
                      }
                    }
                    distance = Math.abs(currPosition.column - col);
                  }
                }
                const filteredActions = currentActions.filter((action, index, self2) => self2.findIndex((a) => a.action.title === action.action.title) === index);
                filteredActions.sort((a, b) => {
                  if (a.action.isPreferred && !b.action.isPreferred) {
                    return -1;
                  } else if (!a.action.isPreferred && b.action.isPreferred) {
                    return 1;
                  } else if (a.action.isAI && !b.action.isAI) {
                    return 1;
                  } else if (!a.action.isAI && b.action.isAI) {
                    return -1;
                  } else {
                    return 0;
                  }
                });
                return { validActions: filteredActions, allActions: allCodeActions, documentation: codeActionSet2.documentation, hasAutoFix: codeActionSet2.hasAutoFix, hasAIFix: codeActionSet2.hasAIFix, allAIFixes: codeActionSet2.allAIFixes, dispose: () => {
                  this.codeActionsDisposable.value = codeActionSet2;
                } };
              }
            }
          }
          if (trigger.trigger.type === 1) {
            const codeActions = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);
            this.codeActionsDisposable.value = codeActions;
            return codeActions;
          }
          const codeActionSet = await getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token);
          this.codeActionsDisposable.value = codeActionSet;
          return codeActionSet;
        });
        if (trigger.trigger.type === 1) {
          this._progressService?.showWhile(actions, 250);
        }
        const newState = new CodeActionsState.Triggered(trigger.trigger, startPosition, actions);
        let isManualToAutoTransition = false;
        if (this._state.type === 1) {
          isManualToAutoTransition = this._state.trigger.type === 1 && newState.type === 1 && newState.trigger.type === 2 && this._state.position !== newState.position;
        }
        if (!isManualToAutoTransition) {
          this.setState(newState);
        } else {
          setTimeout(() => {
            this.setState(newState);
          }, 500);
        }
      }, void 0);
      this._codeActionOracle.value.trigger({ type: 2, triggerAction: CodeActionTriggerSource.Default });
    } else {
      this._supportedCodeActions.reset();
    }
  }
  trigger(trigger) {
    this._codeActionOracle.value?.trigger(trigger);
    this.codeActionsDisposable.dispose();
  }
  setState(newState, skipNotify) {
    if (newState === this._state) {
      return;
    }
    if (this._state.type === 1) {
      this._state.cancel();
    }
    this._state = newState;
    if (!skipNotify && !this._disposed) {
      this._onDidChangeState.fire(newState);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/lightBulbWidget.js
init_dom();
init_codicons();
init_event();
init_lifecycle();
init_themables();
init_model2();
init_textModel();
init_utils();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/lightBulbWidget.css";
init_nls();
init_range();
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LightBulbWidget_1;
var GUTTER_LIGHTBULB_ICON = registerIcon("gutter-lightbulb", Codicon.lightBulb, localize(870, "Icon which spawns code actions menu from the gutter when there is no space in the editor."));
var GUTTER_LIGHTBULB_AUTO_FIX_ICON = registerIcon("gutter-lightbulb-auto-fix", Codicon.lightbulbAutofix, localize(871, "Icon which spawns code actions menu from the gutter when there is no space in the editor and a quick fix is available."));
var GUTTER_LIGHTBULB_AIFIX_ICON = registerIcon("gutter-lightbulb-sparkle", Codicon.lightbulbSparkle, localize(872, "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix is available."));
var GUTTER_LIGHTBULB_AIFIX_AUTO_FIX_ICON = registerIcon("gutter-lightbulb-aifix-auto-fix", Codicon.lightbulbSparkleAutofix, localize(873, "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix and a quick fix is available."));
var GUTTER_SPARKLE_FILLED_ICON = registerIcon("gutter-lightbulb-sparkle-filled", Codicon.sparkleFilled, localize(874, "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix and a quick fix is available."));
var LightBulbState;
(function(LightBulbState2) {
  LightBulbState2.Hidden = {
    type: 0
    /* Type.Hidden */
  };
  class Showing {
    constructor(actions, trigger, editorPosition, widgetPosition) {
      this.actions = actions;
      this.trigger = trigger;
      this.editorPosition = editorPosition;
      this.widgetPosition = widgetPosition;
      this.type = 1;
    }
  }
  LightBulbState2.Showing = Showing;
})(LightBulbState || (LightBulbState = {}));
var _a6;
var LightBulbWidget = (_a6 = class extends Disposable {
  constructor(_editor, _keybindingService) {
    super();
    this._editor = _editor;
    this._keybindingService = _keybindingService;
    this._onClick = this._register(new Emitter());
    this.onClick = this._onClick.event;
    this._state = LightBulbState.Hidden;
    this._gutterState = LightBulbState.Hidden;
    this._iconClasses = [];
    this.lightbulbClasses = [
      "codicon-" + GUTTER_LIGHTBULB_ICON.id,
      "codicon-" + GUTTER_LIGHTBULB_AIFIX_AUTO_FIX_ICON.id,
      "codicon-" + GUTTER_LIGHTBULB_AUTO_FIX_ICON.id,
      "codicon-" + GUTTER_LIGHTBULB_AIFIX_ICON.id,
      "codicon-" + GUTTER_SPARKLE_FILLED_ICON.id
    ];
    this.gutterDecoration = LightBulbWidget_1.GUTTER_DECORATION;
    this._domNode = $("div.lightBulbWidget");
    this._domNode.role = "listbox";
    this._register(Gesture.ignoreTarget(this._domNode));
    this._editor.addContentWidget(this);
    this._register(this._editor.onDidChangeModelContent((_) => {
      const editorModel = this._editor.getModel();
      if (this.state.type !== 1 || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {
        this.hide();
      }
      if (this.gutterState.type !== 1 || !editorModel || this.gutterState.editorPosition.lineNumber >= editorModel.getLineCount()) {
        this.gutterHide();
      }
    }));
    this._register(addStandardDisposableGenericMouseDownListener(this._domNode, (e) => {
      if (this.state.type !== 1) {
        return;
      }
      this._editor.focus();
      e.preventDefault();
      const { top, height } = getDomNodePagePosition(this._domNode);
      const lineHeight = this._editor.getOption(
        75
        /* EditorOption.lineHeight */
      );
      let pad = Math.floor(lineHeight / 3);
      if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {
        pad += lineHeight;
      }
      this._onClick.fire({
        x: e.posx,
        y: top + height + pad,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    }));
    this._register(addDisposableListener(this._domNode, "mouseenter", (e) => {
      if ((e.buttons & 1) !== 1) {
        return;
      }
      this.hide();
    }));
    this._register(Event.runAndSubscribe(this._keybindingService.onDidUpdateKeybindings, () => {
      this._preferredKbLabel = this._keybindingService.lookupKeybinding(autoFixCommandId)?.getLabel() ?? void 0;
      this._quickFixKbLabel = this._keybindingService.lookupKeybinding(quickFixCommandId)?.getLabel() ?? void 0;
      this._updateLightBulbTitleAndIcon();
    }));
    this._register(this._editor.onMouseDown(async (e) => {
      if (!e.target.element || !this.lightbulbClasses.some((cls) => e.target.element && e.target.element.classList.contains(cls))) {
        return;
      }
      if (this.gutterState.type !== 1) {
        return;
      }
      this._editor.focus();
      const { top, height } = getDomNodePagePosition(e.target.element);
      const lineHeight = this._editor.getOption(
        75
        /* EditorOption.lineHeight */
      );
      let pad = Math.floor(lineHeight / 3);
      if (this.gutterState.widgetPosition.position !== null && this.gutterState.widgetPosition.position.lineNumber < this.gutterState.editorPosition.lineNumber) {
        pad += lineHeight;
      }
      this._onClick.fire({
        x: e.event.posx,
        y: top + height + pad,
        actions: this.gutterState.actions,
        trigger: this.gutterState.trigger
      });
    }));
  }
  dispose() {
    super.dispose();
    this._editor.removeContentWidget(this);
    if (this._gutterDecorationID) {
      this._removeGutterDecoration(this._gutterDecorationID);
    }
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(actions, trigger, atPosition) {
    if (actions.validActions.length <= 0) {
      this.gutterHide();
      return this.hide();
    }
    const hasTextFocus = this._editor.hasTextFocus();
    if (!hasTextFocus) {
      this.gutterHide();
      return this.hide();
    }
    const options = this._editor.getOptions();
    if (!options.get(
      73
      /* EditorOption.lightbulb */
    ).enabled) {
      this.gutterHide();
      return this.hide();
    }
    const model = this._editor.getModel();
    if (!model) {
      this.gutterHide();
      return this.hide();
    }
    const { lineNumber, column } = model.validatePosition(atPosition);
    const tabSize = model.getOptions().tabSize;
    const fontInfo = this._editor.getOptions().get(
      59
      /* EditorOption.fontInfo */
    );
    const lineContent = model.getLineContent(lineNumber);
    const indent = computeIndentLevel(lineContent, tabSize);
    const lineHasSpace = fontInfo.spaceWidth * indent > 22;
    const isFolded = (lineNumber2) => {
      return lineNumber2 > 2 && this._editor.getTopForLineNumber(lineNumber2) === this._editor.getTopForLineNumber(lineNumber2 - 1);
    };
    const currLineDecorations = this._editor.getLineDecorations(lineNumber);
    let hasDecoration = false;
    if (currLineDecorations) {
      for (const decoration3 of currLineDecorations) {
        const glyphClass = decoration3.options.glyphMarginClassName;
        if (glyphClass && !this.lightbulbClasses.some((className) => glyphClass.includes(className))) {
          hasDecoration = true;
          break;
        }
      }
    }
    let effectiveLineNumber = lineNumber;
    let effectiveColumnNumber = 1;
    if (!lineHasSpace) {
      const isLineEmptyOrIndented = (lineNumber2) => {
        const lineContent2 = model.getLineContent(lineNumber2);
        return /^\s*$|^\s+/.test(lineContent2) || lineContent2.length <= effectiveColumnNumber;
      };
      if (lineNumber > 1 && !isFolded(lineNumber - 1)) {
        const lineCount = model.getLineCount();
        const endLine = lineNumber === lineCount;
        const prevLineEmptyOrIndented = lineNumber > 1 && isLineEmptyOrIndented(lineNumber - 1);
        const nextLineEmptyOrIndented = !endLine && isLineEmptyOrIndented(lineNumber + 1);
        const currLineEmptyOrIndented = isLineEmptyOrIndented(lineNumber);
        const notEmpty = !nextLineEmptyOrIndented && !prevLineEmptyOrIndented;
        if (!nextLineEmptyOrIndented && !prevLineEmptyOrIndented && !hasDecoration) {
          this.gutterState = new LightBulbState.Showing(actions, trigger, atPosition, {
            position: { lineNumber: effectiveLineNumber, column: effectiveColumnNumber },
            preference: LightBulbWidget_1._posPref
          });
          this.renderGutterLightbub();
          return this.hide();
        } else if (prevLineEmptyOrIndented || endLine || prevLineEmptyOrIndented && !currLineEmptyOrIndented) {
          effectiveLineNumber -= 1;
        } else if (nextLineEmptyOrIndented || notEmpty && currLineEmptyOrIndented) {
          effectiveLineNumber += 1;
        }
      } else if (lineNumber === 1 && (lineNumber === model.getLineCount() || !isLineEmptyOrIndented(lineNumber + 1) && !isLineEmptyOrIndented(lineNumber))) {
        this.gutterState = new LightBulbState.Showing(actions, trigger, atPosition, {
          position: { lineNumber: effectiveLineNumber, column: effectiveColumnNumber },
          preference: LightBulbWidget_1._posPref
        });
        if (hasDecoration) {
          this.gutterHide();
        } else {
          this.renderGutterLightbub();
          return this.hide();
        }
      } else if (lineNumber < model.getLineCount() && !isFolded(lineNumber + 1)) {
        effectiveLineNumber += 1;
      } else if (column * fontInfo.spaceWidth < 22) {
        return this.hide();
      }
      effectiveColumnNumber = /^\S\s*$/.test(model.getLineContent(effectiveLineNumber)) ? 2 : 1;
    }
    this.state = new LightBulbState.Showing(actions, trigger, atPosition, {
      position: { lineNumber: effectiveLineNumber, column: effectiveColumnNumber },
      preference: LightBulbWidget_1._posPref
    });
    if (this._gutterDecorationID) {
      this._removeGutterDecoration(this._gutterDecorationID);
      this.gutterHide();
    }
    const validActions = actions.validActions;
    const actionKind = actions.validActions[0].action.kind;
    if (validActions.length !== 1 || !actionKind) {
      this._editor.layoutContentWidget(this);
      return;
    }
    this._editor.layoutContentWidget(this);
  }
  hide() {
    if (this.state === LightBulbState.Hidden) {
      return;
    }
    this.state = LightBulbState.Hidden;
    this._editor.layoutContentWidget(this);
  }
  gutterHide() {
    if (this.gutterState === LightBulbState.Hidden) {
      return;
    }
    if (this._gutterDecorationID) {
      this._removeGutterDecoration(this._gutterDecorationID);
    }
    this.gutterState = LightBulbState.Hidden;
  }
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
    this._updateLightBulbTitleAndIcon();
  }
  get gutterState() {
    return this._gutterState;
  }
  set gutterState(value) {
    this._gutterState = value;
    this._updateGutterLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    this._domNode.classList.remove(...this._iconClasses);
    this._iconClasses = [];
    if (this.state.type !== 1) {
      return;
    }
    let icon;
    let autoRun = false;
    if (this.state.actions.allAIFixes) {
      icon = Codicon.sparkleFilled;
      if (this.state.actions.validActions.length === 1) {
        autoRun = true;
      }
    } else if (this.state.actions.hasAutoFix) {
      if (this.state.actions.hasAIFix) {
        icon = Codicon.lightbulbSparkleAutofix;
      } else {
        icon = Codicon.lightbulbAutofix;
      }
    } else if (this.state.actions.hasAIFix) {
      icon = Codicon.lightbulbSparkle;
    } else {
      icon = Codicon.lightBulb;
    }
    this._updateLightbulbTitle(this.state.actions.hasAutoFix, autoRun);
    this._iconClasses = ThemeIcon.asClassNameArray(icon);
    this._domNode.classList.add(...this._iconClasses);
  }
  _updateGutterLightBulbTitleAndIcon() {
    if (this.gutterState.type !== 1) {
      return;
    }
    let icon;
    let autoRun = false;
    if (this.gutterState.actions.allAIFixes) {
      icon = GUTTER_SPARKLE_FILLED_ICON;
      if (this.gutterState.actions.validActions.length === 1) {
        autoRun = true;
      }
    } else if (this.gutterState.actions.hasAutoFix) {
      if (this.gutterState.actions.hasAIFix) {
        icon = GUTTER_LIGHTBULB_AIFIX_AUTO_FIX_ICON;
      } else {
        icon = GUTTER_LIGHTBULB_AUTO_FIX_ICON;
      }
    } else if (this.gutterState.actions.hasAIFix) {
      icon = GUTTER_LIGHTBULB_AIFIX_ICON;
    } else {
      icon = GUTTER_LIGHTBULB_ICON;
    }
    this._updateLightbulbTitle(this.gutterState.actions.hasAutoFix, autoRun);
    const GUTTER_DECORATION = ModelDecorationOptions.register({
      description: "codicon-gutter-lightbulb-decoration",
      glyphMarginClassName: ThemeIcon.asClassName(icon),
      glyphMargin: { position: GlyphMarginLane.Left },
      stickiness: 1
    });
    this.gutterDecoration = GUTTER_DECORATION;
  }
  /* Gutter Helper Functions */
  renderGutterLightbub() {
    const selection = this._editor.getSelection();
    if (!selection) {
      return;
    }
    if (this._gutterDecorationID === void 0) {
      this._addGutterDecoration(selection.startLineNumber);
    } else {
      this._updateGutterDecoration(this._gutterDecorationID, selection.startLineNumber);
    }
  }
  _addGutterDecoration(lineNumber) {
    this._editor.changeDecorations((accessor) => {
      this._gutterDecorationID = accessor.addDecoration(new Range(lineNumber, 0, lineNumber, 0), this.gutterDecoration);
    });
  }
  _removeGutterDecoration(decorationId) {
    this._editor.changeDecorations((accessor) => {
      accessor.removeDecoration(decorationId);
      this._gutterDecorationID = void 0;
    });
  }
  _updateGutterDecoration(decorationId, lineNumber) {
    this._editor.changeDecorations((accessor) => {
      accessor.changeDecoration(decorationId, new Range(lineNumber, 0, lineNumber, 0));
      accessor.changeDecorationOptions(decorationId, this.gutterDecoration);
    });
  }
  _updateLightbulbTitle(autoFix, autoRun) {
    if (this.state.type !== 1) {
      return;
    }
    if (autoRun) {
      this.title = localize(875, "Run: {0}", this.state.actions.validActions[0].action.title);
    } else if (autoFix && this._preferredKbLabel) {
      this.title = localize(876, "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel);
    } else if (!autoFix && this._quickFixKbLabel) {
      this.title = localize(877, "Show Code Actions ({0})", this._quickFixKbLabel);
    } else if (!autoFix) {
      this.title = localize(878, "Show Code Actions");
    }
  }
  set title(value) {
    this._domNode.title = value;
  }
}, LightBulbWidget_1 = _a6, _a6.GUTTER_DECORATION = ModelDecorationOptions.register({
  description: "codicon-gutter-lightbulb-decoration",
  glyphMarginClassName: ThemeIcon.asClassName(Codicon.lightBulb),
  glyphMargin: { position: GlyphMarginLane.Left },
  stickiness: 1
}), _a6.ID = "editor.contrib.lightbulbWidget", _a6._posPref = [
  0
  /* ContentWidgetPositionPreference.EXACT */
], _a6);
LightBulbWidget = LightBulbWidget_1 = __decorate10([
  __param10(1, IKeybindingService)
], LightBulbWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionController.js
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CodeActionController_1;
var DECORATION_CLASS_NAME = "quickfix-edit-highlight";
var _a7;
var CodeActionController = (_a7 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CodeActionController_1.ID);
  }
  constructor(editor2, markerService, contextKeyService, instantiationService, languageFeaturesService, progressService, _commandService, _configurationService, _actionWidgetService, _instantiationService, _progressService) {
    super();
    this._commandService = _commandService;
    this._configurationService = _configurationService;
    this._actionWidgetService = _actionWidgetService;
    this._instantiationService = _instantiationService;
    this._progressService = _progressService;
    this._activeCodeActions = this._register(new MutableDisposable());
    this._showDisabled = false;
    this._disposed = false;
    this._editor = editor2;
    this._model = this._register(new CodeActionModel(this._editor, languageFeaturesService.codeActionProvider, markerService, contextKeyService, progressService, _configurationService));
    this._register(this._model.onDidChangeState((newState) => this.update(newState)));
    this._lightBulbWidget = new Lazy(() => {
      const widget = this._editor.getContribution(LightBulbWidget.ID);
      if (widget) {
        this._register(widget.onClick((e) => this.showCodeActionsFromLightbulb(e.actions, e)));
      }
      return widget;
    });
    this._resolver = instantiationService.createInstance(CodeActionKeybindingResolver);
    this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    this._disposed = true;
    super.dispose();
  }
  async showCodeActionsFromLightbulb(actions, at) {
    if (actions.allAIFixes && actions.validActions.length === 1) {
      const actionItem = actions.validActions[0];
      const command = actionItem.action.command;
      if (command && command.id === "inlineChat.start") {
        if (command.arguments && command.arguments.length >= 1) {
          command.arguments[0] = { ...command.arguments[0], autoSend: false };
        }
      }
      await this.applyCodeAction(actionItem, false, false, ApplyCodeActionReason.FromAILightbulb);
      return;
    }
    await this.showCodeActionList(actions, at, { includeDisabledActions: false, fromLightbulb: true });
  }
  showCodeActions(_trigger, actions, at) {
    return this.showCodeActionList(actions, at, { includeDisabledActions: false, fromLightbulb: false });
  }
  manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply) {
    if (!this._editor.hasModel()) {
      return;
    }
    MessageController.get(this._editor)?.closeMessage();
    const triggerPosition = this._editor.getPosition();
    this._trigger({ type: 1, triggerAction, filter, autoApply, context: { notAvailableMessage, position: triggerPosition } });
  }
  _trigger(trigger) {
    return this._model.trigger(trigger);
  }
  async applyCodeAction(action, retrigger, preview, actionReason) {
    const progress = this._progressService.show(true, 500);
    try {
      await this._instantiationService.invokeFunction(applyCodeAction, action, actionReason, { preview, editor: this._editor });
    } finally {
      if (retrigger) {
        this._trigger({ type: 2, triggerAction: CodeActionTriggerSource.QuickFix, filter: {} });
      }
      progress.done();
    }
  }
  hideLightBulbWidget() {
    this._lightBulbWidget.rawValue?.hide();
    this._lightBulbWidget.rawValue?.gutterHide();
  }
  async update(newState) {
    if (newState.type !== 1) {
      this.hideLightBulbWidget();
      return;
    }
    let actions;
    try {
      actions = await newState.actions;
    } catch (e) {
      onUnexpectedError(e);
      return;
    }
    if (this._disposed) {
      return;
    }
    const selection = this._editor.getSelection();
    if (selection?.startLineNumber !== newState.position.lineNumber) {
      return;
    }
    this._lightBulbWidget.value?.update(actions, newState.trigger, newState.position);
    if (newState.trigger.type === 1) {
      if (newState.trigger.filter?.include) {
        const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
        if (validActionToApply) {
          try {
            this.hideLightBulbWidget();
            await this.applyCodeAction(validActionToApply, false, false, ApplyCodeActionReason.FromCodeActions);
          } finally {
            actions.dispose();
          }
          return;
        }
        if (newState.trigger.context) {
          const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
          if (invalidAction && invalidAction.action.disabled) {
            MessageController.get(this._editor)?.showMessage(invalidAction.action.disabled, newState.trigger.context.position);
            actions.dispose();
            return;
          }
        }
      }
      const includeDisabledActions = !!newState.trigger.filter?.include;
      if (newState.trigger.context) {
        if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
          MessageController.get(this._editor)?.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
          this._activeCodeActions.value = actions;
          actions.dispose();
          return;
        }
      }
      this._activeCodeActions.value = actions;
      this.showCodeActionList(actions, this.toCoords(newState.position), { includeDisabledActions, fromLightbulb: false });
    } else {
      if (this._actionWidgetService.isVisible) {
        actions.dispose();
      } else {
        this._activeCodeActions.value = actions;
      }
    }
  }
  getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
    if (!actions.allActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions.allActions.length === 1) {
      return actions.allActions.find(({ action }) => action.disabled);
    }
    return void 0;
  }
  tryGetValidActionToApply(trigger, actions) {
    if (!actions.validActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions.validActions.length === 1) {
      return actions.validActions[0];
    }
    return void 0;
  }
  async showCodeActionList(actions, at, options) {
    const currentDecorations = this._editor.createDecorationsCollection();
    const editorDom = this._editor.getDomNode();
    if (!editorDom) {
      return;
    }
    const actionsToShow = options.includeDisabledActions && (this._showDisabled || actions.validActions.length === 0) ? actions.allActions : actions.validActions;
    if (!actionsToShow.length) {
      return;
    }
    const anchor = Position.isIPosition(at) ? this.toCoords(at) : at;
    const delegate = {
      onSelect: async (action, preview) => {
        this.applyCodeAction(
          action,
          /* retrigger */
          true,
          !!preview,
          options.fromLightbulb ? ApplyCodeActionReason.FromAILightbulb : ApplyCodeActionReason.FromCodeActions
        );
        this._actionWidgetService.hide(false);
        currentDecorations.clear();
      },
      onHide: (didCancel) => {
        this._editor?.focus();
        currentDecorations.clear();
      },
      onHover: async (action, token) => {
        if (token.isCancellationRequested) {
          return;
        }
        let canPreview = false;
        const actionKind = action.action.kind;
        if (actionKind) {
          const hierarchicalKind = new HierarchicalKind(actionKind);
          const refactorKinds = [
            CodeActionKind.RefactorExtract,
            CodeActionKind.RefactorInline,
            CodeActionKind.RefactorRewrite,
            CodeActionKind.RefactorMove,
            CodeActionKind.Source
          ];
          canPreview = refactorKinds.some((refactorKind) => refactorKind.contains(hierarchicalKind));
        }
        return { canPreview: canPreview || !!action.action.edit?.edits.length };
      },
      onFocus: (action) => {
        if (action && action.action) {
          const ranges = action.action.ranges;
          const diagnostics = action.action.diagnostics;
          currentDecorations.clear();
          if (ranges && ranges.length > 0) {
            const decorations = diagnostics && diagnostics?.length > 1 ? diagnostics.map((diagnostic) => ({ range: diagnostic, options: CodeActionController_1.DECORATION })) : ranges.map((range) => ({ range, options: CodeActionController_1.DECORATION }));
            currentDecorations.set(decorations);
          } else if (diagnostics && diagnostics.length > 0) {
            const decorations = diagnostics.map((diagnostic2) => ({ range: diagnostic2, options: CodeActionController_1.DECORATION }));
            currentDecorations.set(decorations);
            const diagnostic = diagnostics[0];
            if (diagnostic.startLineNumber && diagnostic.startColumn) {
              const selectionText = this._editor.getModel()?.getWordAtPosition({ lineNumber: diagnostic.startLineNumber, column: diagnostic.startColumn })?.word;
              status(localize(859, "Context: {0} at line {1} and column {2}.", selectionText, diagnostic.startLineNumber, diagnostic.startColumn));
            }
          }
        } else {
          currentDecorations.clear();
        }
      }
    };
    this._actionWidgetService.show("codeActionWidget", true, toMenuItems(actionsToShow, this._shouldShowHeaders(), this._resolver.getResolver()), delegate, anchor, editorDom, this._getActionBarActions(actions, at, options));
  }
  toCoords(position) {
    if (!this._editor.hasModel()) {
      return { x: 0, y: 0 };
    }
    this._editor.revealPosition(
      position,
      1
      /* ScrollType.Immediate */
    );
    this._editor.render();
    const cursorCoords = this._editor.getScrolledVisiblePosition(position);
    const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
    const x = editorCoords.left + cursorCoords.left;
    const y = editorCoords.top + cursorCoords.top + cursorCoords.height;
    return { x, y };
  }
  _shouldShowHeaders() {
    const model = this._editor?.getModel();
    return this._configurationService.getValue("editor.codeActionWidget.showHeaders", { resource: model?.uri });
  }
  _getActionBarActions(actions, at, options) {
    if (options.fromLightbulb) {
      return [];
    }
    const resultActions = actions.documentation.map((command) => ({
      id: command.id,
      label: command.title,
      tooltip: command.tooltip ?? "",
      class: void 0,
      enabled: true,
      run: () => this._commandService.executeCommand(command.id, ...command.arguments ?? [])
    }));
    if (options.includeDisabledActions && actions.validActions.length > 0 && actions.allActions.length !== actions.validActions.length) {
      resultActions.push(this._showDisabled ? {
        id: "hideMoreActions",
        label: localize(860, "Hide Disabled"),
        enabled: true,
        tooltip: "",
        class: void 0,
        run: () => {
          this._showDisabled = false;
          return this.showCodeActionList(actions, at, options);
        }
      } : {
        id: "showMoreActions",
        label: localize(861, "Show Disabled"),
        enabled: true,
        tooltip: "",
        class: void 0,
        run: () => {
          this._showDisabled = true;
          return this.showCodeActionList(actions, at, options);
        }
      });
    }
    return resultActions;
  }
}, CodeActionController_1 = _a7, _a7.ID = "editor.contrib.codeActionController", _a7.DECORATION = ModelDecorationOptions.register({
  description: "quickfix-highlight",
  className: DECORATION_CLASS_NAME
}), _a7);
CodeActionController = CodeActionController_1 = __decorate11([
  __param11(1, IMarkerService),
  __param11(2, IContextKeyService),
  __param11(3, IInstantiationService),
  __param11(4, ILanguageFeaturesService),
  __param11(5, IEditorProgressService),
  __param11(6, ICommandService),
  __param11(7, IConfigurationService),
  __param11(8, IActionWidgetService),
  __param11(9, IInstantiationService),
  __param11(10, IEditorProgressService)
], CodeActionController);
registerThemingParticipant((theme, collector) => {
  const addBackgroundColorRule = (selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  };
  addBackgroundColorRule(".quickfix-edit-highlight", theme.getColor(editorFindMatchHighlight));
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .quickfix-edit-highlight { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
var argsSchema = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    "kind": {
      type: "string",
      description: localize(827, "Kind of the code action to run.")
    },
    "apply": {
      type: "string",
      description: localize(828, "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: [
        "first",
        "ifSingle",
        "never"
        /* CodeActionAutoApply.Never */
      ],
      enumDescriptions: [
        localize(829, "Always apply the first returned code action."),
        localize(830, "Apply the first returned code action if it is the only one."),
        localize(831, "Do not apply the returned code actions.")
      ]
    },
    "preferred": {
      type: "boolean",
      default: false,
      description: localize(832, "Controls if only preferred code actions should be returned.")
    }
  }
};
function triggerCodeActionsForEditorSelection(editor2, notAvailableMessage, filter, autoApply, triggerAction = CodeActionTriggerSource.Default) {
  if (editor2.hasModel()) {
    const controller = CodeActionController.get(editor2);
    controller?.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply);
  }
}
var QuickFixAction = class extends EditorAction {
  constructor() {
    super({
      id: quickFixCommandId,
      label: localize2(849, "Quick Fix..."),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 89,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize(833, "No code actions available"), void 0, void 0, CodeActionTriggerSource.QuickFix);
  }
};
var CodeActionCommand = class extends EditorCommand {
  constructor() {
    super({
      id: codeActionCommandId,
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      metadata: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  runEditorCommand(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: HierarchicalKind.Empty,
      apply: "ifSingle"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof userArgs?.kind === "string" ? args.preferred ? localize(834, "No preferred code actions for '{0}' available", userArgs.kind) : localize(835, "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize(836, "No preferred code actions available") : localize(837, "No code actions available"), {
      include: args.kind,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var RefactorAction = class extends EditorAction {
  constructor() {
    super({
      id: refactorCommandId,
      label: localize2(850, "Refactor..."),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 48,
        mac: {
          primary: 256 | 1024 | 48
          /* KeyCode.KeyR */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
      },
      metadata: {
        description: "Refactor...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Refactor,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof userArgs?.kind === "string" ? args.preferred ? localize(838, "No preferred refactorings for '{0}' available", userArgs.kind) : localize(839, "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize(840, "No preferred refactorings available") : localize(841, "No refactorings available"), {
      include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : HierarchicalKind.None,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, CodeActionTriggerSource.Refactor);
  }
};
var SourceAction = class extends EditorAction {
  constructor() {
    super({
      id: sourceActionCommandId,
      label: localize2(851, "Source Action..."),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
      },
      metadata: {
        description: "Source Action...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Source,
      apply: "never"
      /* CodeActionAutoApply.Never */
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof userArgs?.kind === "string" ? args.preferred ? localize(842, "No preferred source actions for '{0}' available", userArgs.kind) : localize(843, "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize(844, "No preferred source actions available") : localize(845, "No source actions available"), {
      include: CodeActionKind.Source.contains(args.kind) ? args.kind : HierarchicalKind.None,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, CodeActionTriggerSource.SourceAction);
  }
};
var OrganizeImportsAction = class extends EditorAction {
  constructor() {
    super({
      id: organizeImportsCommandId,
      label: localize2(852, "Organize Imports"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 512 | 45,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(853, "Organize imports in the current file. Also called 'Optimize Imports' by some tools")
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize(846, "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle", CodeActionTriggerSource.OrganizeImports);
  }
};
var FixAllAction = class extends EditorAction {
  constructor() {
    super({
      id: fixAllCommandId,
      label: localize2(854, "Fix All"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize(847, "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle", CodeActionTriggerSource.FixAll);
  }
};
var AutoFixAction = class extends EditorAction {
  constructor() {
    super({
      id: autoFixCommandId,
      label: localize2(855, "Auto Fix..."),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 512 | 1024 | 89,
        mac: {
          primary: 2048 | 512 | 89
          /* KeyCode.Period */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize(848, "No auto fixes available"), {
      include: CodeActionKind.QuickFix,
      onlyIncludePreferredActions: true
    }, "ifSingle", CodeActionTriggerSource.AutoFix);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
init_nls();
init_configurationRegistry();
init_platform2();
registerEditorContribution(
  CodeActionController.ID,
  CodeActionController,
  3
  /* EditorContributionInstantiation.Eventually */
);
registerEditorContribution(
  LightBulbWidget.ID,
  LightBulbWidget,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());
Registry.as(Extensions.Configuration).registerConfiguration({
  ...editorConfigurationBaseNode,
  properties: {
    "editor.codeActionWidget.showHeaders": {
      type: "boolean",
      scope: 6,
      description: localize(856, "Enable/disable showing group headers in the Code Action menu."),
      default: true
    }
  }
});
Registry.as(Extensions.Configuration).registerConfiguration({
  ...editorConfigurationBaseNode,
  properties: {
    "editor.codeActionWidget.includeNearbyQuickFixes": {
      type: "boolean",
      scope: 6,
      description: localize(857, "Enable/disable showing nearest Quick Fix within a line when not currently on a diagnostic."),
      default: true
    }
  }
});
Registry.as(Extensions.Configuration).registerConfiguration({
  ...editorConfigurationBaseNode,
  properties: {
    "editor.codeActions.triggerOnFocusChange": {
      type: "boolean",
      scope: 6,
      markdownDescription: localize(858, "Enable triggering {0} when {1} is set to {2}. Code Actions must be set to {3} to be triggered for window and focus changes.", "`#editor.codeActionsOnSave#`", "`#files.autoSave#`", "`afterDelay`", "`always`"),
      default: false
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
init_async();
init_errors();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelens.js
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_model();
init_commands();
init_languageFeatures();
var _CodeLensModel = class _CodeLensModel {
  constructor() {
    this.lenses = [];
  }
  dispose() {
    this._store?.dispose();
  }
  get isDisposed() {
    return this._store?.isDisposed ?? false;
  }
  add(list, provider) {
    if (isDisposable(list)) {
      this._store ??= new DisposableStore();
      this._store.add(list);
    }
    for (const symbol of list.lenses) {
      this.lenses.push({ symbol, provider });
    }
  }
};
_CodeLensModel.Empty = new _CodeLensModel();
var CodeLensModel = _CodeLensModel;
async function getCodeLensModel(registry, model, token) {
  const provider = registry.ordered(model);
  const providerRanks = /* @__PURE__ */ new Map();
  const result = new CodeLensModel();
  const promises = provider.map(async (provider2, i2) => {
    providerRanks.set(provider2, i2);
    try {
      const list = await Promise.resolve(provider2.provideCodeLenses(model, token));
      if (list) {
        result.add(list, provider2);
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
  });
  await Promise.all(promises);
  if (token.isCancellationRequested) {
    result.dispose();
    return CodeLensModel.Empty;
  }
  result.lenses = result.lenses.sort((a, b) => {
    if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
      return -1;
    } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
      return 1;
    } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
      return -1;
    } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
      return 1;
    } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
      return -1;
    } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
      return 1;
    } else {
      return 0;
    }
  });
  return result;
}
CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
  let [uri, itemResolveCount] = args;
  assertType(URI.isUri(uri));
  assertType(typeof itemResolveCount === "number" || !itemResolveCount);
  const { codeLensProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const result = [];
  const disposables = new DisposableStore();
  return getCodeLensModel(codeLensProvider, model, CancellationToken.None).then((value) => {
    disposables.add(value);
    const resolve = [];
    for (const item of value.lenses) {
      if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) {
        result.push(item.symbol);
      } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
        resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
      }
    }
    return Promise.all(resolve);
  }).then(() => {
    return result;
  }).finally(() => {
    setTimeout(() => disposables.dispose(), 100);
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codeLensCache.js
init_event();
init_map();
init_range();
init_extensions();
init_instantiation();
init_window();
init_dom();
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ICodeLensCache = createDecorator("ICodeLensCache");
var CacheItem = class {
  constructor(lineCount, data) {
    this.lineCount = lineCount;
    this.data = data;
  }
};
var CodeLensCache = class CodeLensCache2 {
  constructor(storageService) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }();
    this._cache = new LRUCache(20, 0.75);
    const oldkey = "codelens/cache";
    runWhenWindowIdle(mainWindow, () => storageService.remove(
      oldkey,
      1
      /* StorageScope.WORKSPACE */
    ));
    const key = "codelens/cache2";
    const raw = storageService.get(key, 1, "{}");
    this._deserialize(raw);
    const onWillSaveStateBecauseOfShutdown = Event.filter(storageService.onWillSaveState, (e) => e.reason === WillSaveStateReason.SHUTDOWN);
    Event.once(onWillSaveStateBecauseOfShutdown)((e) => {
      storageService.store(
        key,
        this._serialize(),
        1,
        1
        /* StorageTarget.MACHINE */
      );
    });
  }
  put(model, data) {
    const copyItems = data.lenses.map((item2) => {
      return {
        range: item2.symbol.range,
        command: item2.symbol.command && { id: "", title: item2.symbol.command?.title }
      };
    });
    const copyModel = new CodeLensModel();
    copyModel.add({ lenses: copyItems }, this._fakeProvider);
    const item = new CacheItem(model.getLineCount(), copyModel);
    this._cache.set(model.uri.toString(), item);
  }
  get(model) {
    const item = this._cache.get(model.uri.toString());
    return item && item.lineCount === model.getLineCount() ? item.data : void 0;
  }
  delete(model) {
    this._cache.delete(model.uri.toString());
  }
  // --- persistence
  _serialize() {
    const data = /* @__PURE__ */ Object.create(null);
    for (const [key, value] of this._cache) {
      const lines = /* @__PURE__ */ new Set();
      for (const d of value.data.lenses) {
        lines.add(d.symbol.range.startLineNumber);
      }
      data[key] = {
        lineCount: value.lineCount,
        lines: [...lines.values()]
      };
    }
    return JSON.stringify(data);
  }
  _deserialize(raw) {
    try {
      const data = JSON.parse(raw);
      for (const key in data) {
        const element = data[key];
        const lenses = [];
        for (const line of element.lines) {
          lenses.push({ range: new Range(line, 1, line, 11) });
        }
        const model = new CodeLensModel();
        model.add({ lenses }, this._fakeProvider);
        this._cache.set(key, new CacheItem(element.lineCount, model));
      }
    } catch {
    }
  }
};
CodeLensCache = __decorate12([
  __param12(0, IStorageService)
], CodeLensCache);
registerSingleton(
  ICodeLensCache,
  CodeLensCache,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.js
init_dom();
init_iconLabels2();
init_range();
init_textModel();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.css";
var CodeLensViewZone = class {
  constructor(afterLineNumber, heightInPx, onHeight) {
    this.afterColumn = 1073741824;
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = heightInPx;
    this._onHeight = onHeight;
    this.suppressMouseDown = true;
    this.domNode = document.createElement("div");
  }
  onComputedHeight(height) {
    if (this._lastHeight === void 0) {
      this._lastHeight = height;
    } else if (this._lastHeight !== height) {
      this._lastHeight = height;
      this._onHeight();
    }
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
};
var _CodeLensContentWidget = class _CodeLensContentWidget {
  constructor(editor2, line) {
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this._commands = /* @__PURE__ */ new Map();
    this._isEmpty = true;
    this._editor = editor2;
    this._id = `codelens.widget-${_CodeLensContentWidget._idPool++}`;
    this.updatePosition(line);
    this._domNode = document.createElement("span");
    this._domNode.className = `codelens-decoration`;
  }
  withCommands(lenses, animate) {
    this._commands.clear();
    const children = [];
    let hasSymbol = false;
    for (let i2 = 0; i2 < lenses.length; i2++) {
      const lens = lenses[i2];
      if (!lens) {
        continue;
      }
      hasSymbol = true;
      if (lens.command) {
        const title = renderLabelWithIcons(lens.command.title.trim());
        if (lens.command.id) {
          const id = `c${_CodeLensContentWidget._idPool++}`;
          children.push($("a", { id, title: lens.command.tooltip, role: "button" }, ...title));
          this._commands.set(id, lens.command);
        } else {
          children.push($("span", { title: lens.command.tooltip }, ...title));
        }
        if (i2 + 1 < lenses.length) {
          children.push($("span", void 0, " | "));
        }
      }
    }
    if (!hasSymbol) {
      reset(this._domNode, $("span", void 0, "no commands"));
    } else {
      reset(this._domNode, ...children);
      if (this._isEmpty && animate) {
        this._domNode.classList.add("fadein");
      }
      this._isEmpty = false;
    }
  }
  getCommand(link) {
    return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(line) {
    const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
    this._widgetPosition = {
      position: { lineNumber: line, column },
      preference: [
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
};
_CodeLensContentWidget._idPool = 0;
var CodeLensContentWidget = _CodeLensContentWidget;
var CodeLensHelper = class {
  constructor() {
    this._removeDecorations = [];
    this._addDecorations = [];
    this._addDecorationsCallbacks = [];
  }
  addDecoration(decoration3, callback) {
    this._addDecorations.push(decoration3);
    this._addDecorationsCallbacks.push(callback);
  }
  removeDecoration(decorationId) {
    this._removeDecorations.push(decorationId);
  }
  commit(changeAccessor) {
    const resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i2 = 0, len = resultingDecorations.length; i2 < len; i2++) {
      this._addDecorationsCallbacks[i2](resultingDecorations[i2]);
    }
  }
};
var codeLensDecorationOptions = ModelDecorationOptions.register({
  collapseOnReplaceEdit: true,
  description: "codelens"
});
var CodeLensWidget = class {
  constructor(data, editor2, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
    this._isDisposed = false;
    this._editor = editor2;
    this._data = data;
    this._decorationIds = [];
    let range;
    const lenses = [];
    this._data.forEach((codeLensData, i2) => {
      if (codeLensData.symbol.command) {
        lenses.push(codeLensData.symbol);
      }
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: codeLensDecorationOptions
      }, (id) => this._decorationIds[i2] = id);
      if (!range) {
        range = Range.lift(codeLensData.symbol.range);
      } else {
        range = Range.plusRange(range, codeLensData.symbol.range);
      }
    });
    this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
    this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
    if (lenses.length > 0) {
      this._createContentWidgetIfNecessary();
      this._contentWidget.withCommands(lenses, false);
    }
  }
  _createContentWidgetIfNecessary() {
    if (!this._contentWidget) {
      this._contentWidget = new CodeLensContentWidget(this._editor, this._viewZone.afterLineNumber + 1);
      this._editor.addContentWidget(this._contentWidget);
    } else {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  dispose(helper, viewZoneChangeAccessor) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    viewZoneChangeAccessor?.removeZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.removeContentWidget(this._contentWidget);
      this._contentWidget = void 0;
    }
    this._isDisposed = true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((id, i2) => {
      const range = this._editor.getModel().getDecorationRange(id);
      const symbol = this._data[i2].symbol;
      return !!(range && Range.isEmpty(symbol.range) === range.isEmpty());
    });
  }
  updateCodeLensSymbols(data, helper) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    this._data = data;
    this._data.forEach((codeLensData, i2) => {
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: codeLensDecorationOptions
      }, (id) => this._decorationIds[i2] = id);
    });
  }
  updateHeight(height, viewZoneChangeAccessor) {
    this._viewZone.heightInPx = height;
    viewZoneChangeAccessor.layoutZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  computeIfNecessary(model) {
    if (!this._viewZone.isVisible()) {
      return null;
    }
    for (let i2 = 0; i2 < this._decorationIds.length; i2++) {
      const range = model.getDecorationRange(this._decorationIds[i2]);
      if (range) {
        this._data[i2].symbol.range = range;
      }
    }
    return this._data;
  }
  updateCommands(symbols) {
    this._createContentWidgetIfNecessary();
    this._contentWidget.withCommands(symbols, true);
    for (let i2 = 0; i2 < this._data.length; i2++) {
      const resolved = symbols[i2];
      if (resolved) {
        const { symbol } = this._data[i2];
        symbol.command = resolved.command || symbol.command;
      }
    }
  }
  getCommand(link) {
    return this._contentWidget?.getCommand(link);
  }
  getLineNumber() {
    const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    if (range) {
      return range.startLineNumber;
    }
    return -1;
  }
  update(viewZoneChangeAccessor) {
    if (this.isValid()) {
      const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      if (range) {
        this._viewZone.afterLineNumber = range.startLineNumber - 1;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._contentWidget.updatePosition(range.startLineNumber);
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
init_nls();
init_commands();
init_languageFeatureDebounce();
init_languageFeatures();
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a8;
var CodeLensContribution = (_a8 = class {
  constructor(_editor, _languageFeaturesService, debounceService, _commandService, _notificationService, _codeLensCache) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._codeLensCache = _codeLensCache;
    this._disposables = new DisposableStore();
    this._localToDispose = new DisposableStore();
    this._lenses = [];
    this._oldCodeLensModels = new DisposableStore();
    this._provideCodeLensDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensProvide", { min: 250 });
    this._resolveCodeLensesDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" });
    this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default());
    this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.fontInfo */
      ) || e.hasChanged(
        25
        /* EditorOption.codeLensFontSize */
      ) || e.hasChanged(
        24
        /* EditorOption.codeLensFontFamily */
      )) {
        this._updateLensStyle();
      }
      if (e.hasChanged(
        23
        /* EditorOption.codeLens */
      )) {
        this._onModelChange();
      }
    }));
    this._disposables.add(_languageFeaturesService.codeLensProvider.onDidChange(this._onModelChange, this));
    this._onModelChange();
    this._updateLensStyle();
  }
  dispose() {
    this._localDispose();
    this._localToDispose.dispose();
    this._disposables.dispose();
    this._oldCodeLensModels.dispose();
    this._currentCodeLensModel?.dispose();
  }
  _getLayoutInfo() {
    const lineHeightFactor = Math.max(1.3, this._editor.getOption(
      75
      /* EditorOption.lineHeight */
    ) / this._editor.getOption(
      61
      /* EditorOption.fontSize */
    ));
    let fontSize = this._editor.getOption(
      25
      /* EditorOption.codeLensFontSize */
    );
    if (!fontSize || fontSize < 5) {
      fontSize = this._editor.getOption(
        61
        /* EditorOption.fontSize */
      ) * 0.9 | 0;
    }
    return {
      fontSize,
      codeLensHeight: fontSize * lineHeightFactor | 0
    };
  }
  _updateLensStyle() {
    const { codeLensHeight, fontSize } = this._getLayoutInfo();
    const fontFamily = this._editor.getOption(
      24
      /* EditorOption.codeLensFontFamily */
    );
    const editorFontInfo = this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    const { style } = this._editor.getContainerDomNode();
    style.setProperty("--vscode-editorCodeLens-lineHeight", `${codeLensHeight}px`);
    style.setProperty("--vscode-editorCodeLens-fontSize", `${fontSize}px`);
    style.setProperty("--vscode-editorCodeLens-fontFeatureSettings", editorFontInfo.fontFeatureSettings);
    if (fontFamily) {
      style.setProperty("--vscode-editorCodeLens-fontFamily", fontFamily);
      style.setProperty("--vscode-editorCodeLens-fontFamilyDefault", EDITOR_FONT_DEFAULTS.fontFamily);
    }
    this._editor.changeViewZones((accessor) => {
      for (const lens of this._lenses) {
        lens.updateHeight(codeLensHeight, accessor);
      }
    });
  }
  _localDispose() {
    this._getCodeLensModelPromise?.cancel();
    this._getCodeLensModelPromise = void 0;
    this._resolveCodeLensesPromise?.cancel();
    this._resolveCodeLensesPromise = void 0;
    this._localToDispose.clear();
    this._oldCodeLensModels.clear();
    this._currentCodeLensModel?.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (!this._editor.getOption(
      23
      /* EditorOption.codeLens */
    ) || model.isTooLargeForTokenization()) {
      return;
    }
    const cachedLenses = this._codeLensCache.get(model);
    if (cachedLenses) {
      this._renderCodeLensSymbols(cachedLenses);
    }
    if (!this._languageFeaturesService.codeLensProvider.has(model)) {
      if (cachedLenses) {
        disposableTimeout(() => {
          const cachedLensesNow = this._codeLensCache.get(model);
          if (cachedLenses === cachedLensesNow) {
            this._codeLensCache.delete(model);
            this._onModelChange();
          }
        }, 30 * 1e3, this._localToDispose);
      }
      return;
    }
    for (const provider of this._languageFeaturesService.codeLensProvider.all(model)) {
      if (typeof provider.onDidChange === "function") {
        const registration = provider.onDidChange(() => scheduler.schedule());
        this._localToDispose.add(registration);
      }
    }
    const scheduler = new RunOnceScheduler(() => {
      const t1 = Date.now();
      this._getCodeLensModelPromise?.cancel();
      this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));
      this._getCodeLensModelPromise.then((result) => {
        if (this._currentCodeLensModel) {
          this._oldCodeLensModels.add(this._currentCodeLensModel);
        }
        this._currentCodeLensModel = result;
        this._codeLensCache.put(model, result);
        const newDelay = this._provideCodeLensDebounce.update(model, Date.now() - t1);
        scheduler.delay = newDelay;
        this._renderCodeLensSymbols(result);
        this._resolveCodeLensesInViewportSoon();
      }, onUnexpectedError);
    }, this._provideCodeLensDebounce.get(model));
    this._localToDispose.add(scheduler);
    this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._editor.changeDecorations((decorationsAccessor) => {
        this._editor.changeViewZones((viewZonesAccessor) => {
          const toDispose = [];
          let lastLensLineNumber = -1;
          this._lenses.forEach((lens) => {
            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
              toDispose.push(lens);
            } else {
              lens.update(viewZonesAccessor);
              lastLensLineNumber = lens.getLineNumber();
            }
          });
          const helper = new CodeLensHelper();
          toDispose.forEach((l) => {
            l.dispose(helper, viewZonesAccessor);
            this._lenses.splice(this._lenses.indexOf(l), 1);
          });
          helper.commit(decorationsAccessor);
        });
      });
      scheduler.schedule();
      this._resolveCodeLensesScheduler.cancel();
      this._resolveCodeLensesPromise?.cancel();
      this._resolveCodeLensesPromise = void 0;
    }));
    this._localToDispose.add(this._editor.onDidFocusEditorText(() => {
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidBlurEditorText(() => {
      scheduler.cancel();
    }));
    this._localToDispose.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged && this._lenses.length > 0) {
        this._resolveCodeLensesInViewportSoon();
      }
    }));
    this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    }));
    this._localToDispose.add(toDisposable(() => {
      if (this._editor.getModel()) {
        const scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZonesAccessor) => {
            this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
          });
        });
        scrollState.restore(this._editor);
      } else {
        this._disposeAllLenses(void 0, void 0);
      }
    }));
    this._localToDispose.add(this._editor.onMouseDown((e) => {
      if (e.target.type !== 9) {
        return;
      }
      let target = e.target.element;
      if (target?.tagName === "SPAN") {
        target = target.parentElement;
      }
      if (target?.tagName === "A") {
        for (const lens of this._lenses) {
          const command = lens.getCommand(target);
          if (command) {
            this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
            break;
          }
        }
      }
    }));
    scheduler.schedule();
  }
  _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
    const helper = new CodeLensHelper();
    for (const lens of this._lenses) {
      lens.dispose(helper, viewZoneChangeAccessor);
    }
    if (decChangeAccessor) {
      helper.commit(decChangeAccessor);
    }
    this._lenses.length = 0;
  }
  _renderCodeLensSymbols(symbols) {
    if (!this._editor.hasModel()) {
      return;
    }
    const maxLineNumber = this._editor.getModel().getLineCount();
    const groups = [];
    let lastGroup;
    for (const symbol of symbols.lenses) {
      const line = symbol.symbol.range.startLineNumber;
      if (line < 1 || line > maxLineNumber) {
        continue;
      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
        lastGroup.push(symbol);
      } else {
        lastGroup = [symbol];
        groups.push(lastGroup);
      }
    }
    if (!groups.length && !this._lenses.length) {
      return;
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    const layoutInfo = this._getLayoutInfo();
    this._editor.changeDecorations((decorationsAccessor) => {
      this._editor.changeViewZones((viewZoneAccessor) => {
        const helper = new CodeLensHelper();
        let codeLensIndex = 0;
        let groupsIndex = 0;
        while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
          const symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
          const codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
          if (codeLensLineNumber < symbolsLineNumber) {
            this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
            this._lenses.splice(codeLensIndex, 1);
          } else if (codeLensLineNumber === symbolsLineNumber) {
            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
            groupsIndex++;
            codeLensIndex++;
          } else {
            this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
            codeLensIndex++;
            groupsIndex++;
          }
        }
        while (codeLensIndex < this._lenses.length) {
          this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
          this._lenses.splice(codeLensIndex, 1);
        }
        while (groupsIndex < groups.length) {
          this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
          groupsIndex++;
        }
        helper.commit(decorationsAccessor);
      });
    });
    scrollState.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    const model = this._editor.getModel();
    if (model) {
      this._resolveCodeLensesScheduler.schedule();
    }
  }
  _resolveCodeLensesInViewport() {
    this._resolveCodeLensesPromise?.cancel();
    this._resolveCodeLensesPromise = void 0;
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    const toResolve = [];
    const lenses = [];
    this._lenses.forEach((lens) => {
      const request = lens.computeIfNecessary(model);
      if (request) {
        toResolve.push(request);
        lenses.push(lens);
      }
    });
    if (toResolve.length === 0) {
      this._oldCodeLensModels.clear();
      return;
    }
    const t1 = Date.now();
    const resolvePromise = createCancelablePromise((token) => {
      const promises = toResolve.map((request, i2) => {
        const resolvedSymbols = new Array(request.length);
        const promises2 = request.map((request2, i3) => {
          if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
            return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol) => {
              resolvedSymbols[i3] = symbol;
            }, onUnexpectedExternalError);
          } else {
            resolvedSymbols[i3] = request2.symbol;
            return Promise.resolve(void 0);
          }
        });
        return Promise.all(promises2).then(() => {
          if (!token.isCancellationRequested && !lenses[i2].isDisposed()) {
            lenses[i2].updateCommands(resolvedSymbols);
          }
        });
      });
      return Promise.all(promises);
    });
    this._resolveCodeLensesPromise = resolvePromise;
    this._resolveCodeLensesPromise.then(() => {
      const newDelay = this._resolveCodeLensesDebounce.update(model, Date.now() - t1);
      this._resolveCodeLensesScheduler.delay = newDelay;
      if (this._currentCodeLensModel) {
        this._codeLensCache.put(model, this._currentCodeLensModel);
      }
      this._oldCodeLensModels.clear();
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    }, (err) => {
      onUnexpectedError(err);
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    });
  }
  async getModel() {
    await this._getCodeLensModelPromise;
    await this._resolveCodeLensesPromise;
    return !this._currentCodeLensModel?.isDisposed ? this._currentCodeLensModel : void 0;
  }
}, _a8.ID = "css.editor.codeLens", _a8);
CodeLensContribution = __decorate13([
  __param13(1, ILanguageFeaturesService),
  __param13(2, ILanguageFeatureDebounceService),
  __param13(3, ICommandService),
  __param13(4, INotificationService),
  __param13(5, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(
  CodeLensContribution.ID,
  CodeLensContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: EditorContextKeys.hasCodeLensProvider,
      label: localize2(880, "Show CodeLens Commands for Current Line")
    });
  }
  async run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const quickInputService = accessor.get(IQuickInputService);
    const commandService = accessor.get(ICommandService);
    const notificationService = accessor.get(INotificationService);
    const lineNumber = editor2.getSelection().positionLineNumber;
    const codelensController = editor2.getContribution(CodeLensContribution.ID);
    if (!codelensController) {
      return;
    }
    const model = await codelensController.getModel();
    if (!model) {
      return;
    }
    const items = [];
    for (const lens of model.lenses) {
      if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {
        items.push({
          label: lens.symbol.command.title,
          command: lens.symbol.command
        });
      }
    }
    if (items.length === 0) {
      return;
    }
    const item = await quickInputService.pick(items, {
      canPickMany: false,
      placeHolder: localize(879, "Select a command")
    });
    if (!item) {
      return;
    }
    let command = item.command;
    if (model.isDisposed) {
      const newModel = await codelensController.getModel();
      const newLens = newModel?.lenses.find((lens) => lens.symbol.range.startLineNumber === lineNumber && lens.symbol.command?.title === command.title);
      if (!newLens || !newLens.symbol.command) {
        return;
      }
      command = newLens.symbol.command;
    }
    try {
      await commandService.executeCommand(command.id, ...command.arguments || []);
    } catch (err) {
      notificationService.error(err);
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerContribution.js
init_cancellation();
init_errors();
init_uri();
init_actions2();
init_commands();
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverTypes.js
var HoverRangeAnchor = class {
  constructor(priority, range, initialMousePosX, initialMousePosY) {
    this.priority = priority;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.type = 1;
  }
  equals(other) {
    return other.type === 1 && this.range.equalsRange(other.range);
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
  }
};
var HoverForeignElementAnchor = class {
  constructor(priority, owner, range, initialMousePosX, initialMousePosY, supportsMarkerHover) {
    this.priority = priority;
    this.owner = owner;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.supportsMarkerHover = supportsMarkerHover;
    this.type = 2;
  }
  equals(other) {
    return other.type === 2 && this.owner === other.owner;
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
  }
};
var RenderedHoverParts = class {
  constructor(renderedHoverParts, disposables) {
    this.renderedHoverParts = renderedHoverParts;
    this.disposables = disposables;
  }
  dispose() {
    for (const part of this.renderedHoverParts) {
      part.dispose();
    }
    this.disposables?.dispose();
  }
};
var HoverParticipantRegistry = new class HoverParticipantRegistry2 {
  constructor() {
    this._participants = [];
  }
  register(ctor) {
    this._participants.push(ctor);
  }
  getAll() {
    return this._participants;
  }
}();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/color.js
init_cancellation();
init_errors();
init_model();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/defaultDocumentColorProvider.js
init_color();
init_lifecycle();
init_languageFeatures();
init_editorWorker();
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultDocumentColorProvider = class DefaultDocumentColorProvider2 {
  constructor(_editorWorkerService) {
    this._editorWorkerService = _editorWorkerService;
  }
  async provideDocumentColors(model, _token) {
    return this._editorWorkerService.computeDefaultDocumentColors(model.uri);
  }
  provideColorPresentations(_model, colorInfo, _token) {
    const range = colorInfo.range;
    const colorFromInfo = colorInfo.color;
    const alpha = colorFromInfo.alpha;
    const color = new Color(new RGBA(Math.round(255 * colorFromInfo.red), Math.round(255 * colorFromInfo.green), Math.round(255 * colorFromInfo.blue), alpha));
    const rgb = alpha ? Color.Format.CSS.formatRGBA(color) : Color.Format.CSS.formatRGB(color);
    const hsl = alpha ? Color.Format.CSS.formatHSLA(color) : Color.Format.CSS.formatHSL(color);
    const hex = alpha ? Color.Format.CSS.formatHexA(color) : Color.Format.CSS.formatHex(color);
    const colorPresentations = [];
    colorPresentations.push({ label: rgb, textEdit: { range, text: rgb } });
    colorPresentations.push({ label: hsl, textEdit: { range, text: hsl } });
    colorPresentations.push({ label: hex, textEdit: { range, text: hex } });
    return colorPresentations;
  }
};
DefaultDocumentColorProvider = __decorate14([
  __param14(0, IEditorWorkerService)
], DefaultDocumentColorProvider);
var DefaultDocumentColorProviderFeature = class DefaultDocumentColorProviderFeature2 extends Disposable {
  constructor(_languageFeaturesService, editorWorkerService) {
    super();
    this._register(_languageFeaturesService.colorProvider.register("*", new DefaultDocumentColorProvider(editorWorkerService)));
  }
};
DefaultDocumentColorProviderFeature = __decorate14([
  __param14(0, ILanguageFeaturesService),
  __param14(1, IEditorWorkerService)
], DefaultDocumentColorProviderFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/color.js
init_configuration();
async function getColors(colorProviderRegistry, model, token, defaultColorDecoratorsEnablement = "auto") {
  return _findColorData(new ColorDataCollector(), colorProviderRegistry, model, token, defaultColorDecoratorsEnablement);
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
var ColorDataCollector = class {
  constructor() {
  }
  async compute(provider, model, token, colors) {
    const documentColors = await provider.provideDocumentColors(model, token);
    if (Array.isArray(documentColors)) {
      for (const colorInfo of documentColors) {
        colors.push({ colorInfo, provider });
      }
    }
    return Array.isArray(documentColors);
  }
};
var ExtColorDataCollector = class {
  constructor() {
  }
  async compute(provider, model, token, colors) {
    const documentColors = await provider.provideDocumentColors(model, token);
    if (Array.isArray(documentColors)) {
      for (const colorInfo of documentColors) {
        colors.push({ range: colorInfo.range, color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha] });
      }
    }
    return Array.isArray(documentColors);
  }
};
var ColorPresentationsCollector = class {
  constructor(colorInfo) {
    this.colorInfo = colorInfo;
  }
  async compute(provider, model, _token, colors) {
    const documentColors = await provider.provideColorPresentations(model, this.colorInfo, CancellationToken.None);
    if (Array.isArray(documentColors)) {
      colors.push(...documentColors);
    }
    return Array.isArray(documentColors);
  }
};
async function _findColorData(collector, colorProviderRegistry, model, token, defaultColorDecoratorsEnablement) {
  let validDocumentColorProviderFound = false;
  let defaultProvider;
  const colorData = [];
  const documentColorProviders = colorProviderRegistry.ordered(model);
  for (let i2 = documentColorProviders.length - 1; i2 >= 0; i2--) {
    const provider = documentColorProviders[i2];
    if (defaultColorDecoratorsEnablement !== "always" && provider instanceof DefaultDocumentColorProvider) {
      defaultProvider = provider;
    } else {
      try {
        if (await collector.compute(provider, model, token, colorData)) {
          validDocumentColorProviderFound = true;
        }
      } catch (e) {
        onUnexpectedExternalError(e);
      }
    }
  }
  if (validDocumentColorProviderFound) {
    return colorData;
  }
  if (defaultProvider && defaultColorDecoratorsEnablement !== "never") {
    await collector.compute(defaultProvider, model, token, colorData);
    return colorData;
  }
  return [];
}
function _setupColorCommand(accessor, resource) {
  const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const defaultColorDecoratorsEnablement = accessor.get(IConfigurationService).getValue("editor.defaultColorDecorators", { resource });
  return { model, colorProviderRegistry, defaultColorDecoratorsEnablement };
}

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorDetector.js
init_async();
init_color();
init_errors();
init_event();
init_lifecycle();
init_stopwatch();
init_strings();
init_range();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();
init_configuration();
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ColorDetector_1;
var ColorDecorationInjectedTextMarker = /* @__PURE__ */ Object.create({});
var _a9;
var ColorDetector = (_a9 = class extends Disposable {
  // ms
  constructor(_editor, _configurationService, _languageFeaturesService, languageFeatureDebounceService) {
    super();
    this._editor = _editor;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._localToDispose = this._register(new DisposableStore());
    this._decorationsIds = [];
    this._colorDatas = /* @__PURE__ */ new Map();
    this._decoratorLimitReporter = this._register(new DecoratorLimitReporter());
    this._colorDecorationClassRefs = this._register(new DisposableStore());
    this._colorDecoratorIds = this._editor.createDecorationsCollection();
    this._ruleFactory = this._register(new DynamicCssRules(this._editor));
    this._debounceInformation = languageFeatureDebounceService.for(_languageFeaturesService.colorProvider, "Document Colors", { min: ColorDetector_1.RECOMPUTE_TIME });
    this._register(_editor.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled();
      this.updateColors();
    }));
    this._register(_editor.onDidChangeModelLanguage(() => this.updateColors()));
    this._register(_languageFeaturesService.colorProvider.onDidChange(() => this.updateColors()));
    this._register(_editor.onDidChangeConfiguration((e) => {
      const prevIsEnabled = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled();
      this._defaultColorDecoratorsEnablement = this._editor.getOption(
        167
        /* EditorOption.defaultColorDecorators */
      );
      const updatedColorDecoratorsSetting = prevIsEnabled !== this._isColorDecoratorsEnabled || e.hasChanged(
        27
        /* EditorOption.colorDecoratorsLimit */
      );
      const updatedDefaultColorDecoratorsSetting = e.hasChanged(
        167
        /* EditorOption.defaultColorDecorators */
      );
      if (updatedColorDecoratorsSetting || updatedDefaultColorDecoratorsSetting) {
        if (this._isColorDecoratorsEnabled) {
          this.updateColors();
        } else {
          this.removeAllDecorations();
        }
      }
    }));
    this._timeoutTimer = null;
    this._computePromise = null;
    this._isColorDecoratorsEnabled = this.isEnabled();
    this._defaultColorDecoratorsEnablement = this._editor.getOption(
      167
      /* EditorOption.defaultColorDecorators */
    );
    this.updateColors();
  }
  isEnabled() {
    const model = this._editor.getModel();
    if (!model) {
      return false;
    }
    const languageId = model.getLanguageId();
    const deprecatedConfig = this._configurationService.getValue(languageId);
    if (deprecatedConfig && typeof deprecatedConfig === "object") {
      const colorDecorators = deprecatedConfig["colorDecorators"];
      if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
        return colorDecorators["enable"];
      }
    }
    return this._editor.getOption(
      26
      /* EditorOption.colorDecorators */
    );
  }
  static get(editor2) {
    return editor2.getContribution(this.ID);
  }
  dispose() {
    this.stop();
    this.removeAllDecorations();
    super.dispose();
  }
  updateColors() {
    this.stop();
    if (!this._isColorDecoratorsEnabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.colorProvider.has(model)) {
      return;
    }
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!this._timeoutTimer) {
        this._timeoutTimer = new TimeoutTimer();
        this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null;
          this.beginCompute();
        }, this._debounceInformation.get(model));
      }
    }));
    this.beginCompute();
  }
  async beginCompute() {
    this._computePromise = createCancelablePromise(async (token) => {
      const model = this._editor.getModel();
      if (!model) {
        return [];
      }
      const sw = new StopWatch(false);
      const colors = await getColors(this._languageFeaturesService.colorProvider, model, token, this._defaultColorDecoratorsEnablement);
      this._debounceInformation.update(model, sw.elapsed());
      return colors;
    });
    try {
      const colors = await this._computePromise;
      this.updateDecorations(colors);
      this.updateColorDecorators(colors);
      this._computePromise = null;
    } catch (e) {
      onUnexpectedError(e);
    }
  }
  stop() {
    if (this._timeoutTimer) {
      this._timeoutTimer.cancel();
      this._timeoutTimer = null;
    }
    if (this._computePromise) {
      this._computePromise.cancel();
      this._computePromise = null;
    }
    this._localToDispose.clear();
  }
  updateDecorations(colorDatas) {
    const decorations = colorDatas.map((c) => ({
      range: {
        startLineNumber: c.colorInfo.range.startLineNumber,
        startColumn: c.colorInfo.range.startColumn,
        endLineNumber: c.colorInfo.range.endLineNumber,
        endColumn: c.colorInfo.range.endColumn
      },
      options: ModelDecorationOptions.EMPTY
    }));
    this._editor.changeDecorations((changeAccessor) => {
      this._decorationsIds = changeAccessor.deltaDecorations(this._decorationsIds, decorations);
      this._colorDatas = /* @__PURE__ */ new Map();
      this._decorationsIds.forEach((id, i2) => this._colorDatas.set(id, colorDatas[i2]));
    });
  }
  updateColorDecorators(colorData) {
    this._colorDecorationClassRefs.clear();
    const decorations = [];
    const limit = this._editor.getOption(
      27
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let i2 = 0; i2 < colorData.length && decorations.length < limit; i2++) {
      const { red, green, blue, alpha } = colorData[i2].colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      const color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      const ref = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: color
      }));
      decorations.push({
        range: {
          startLineNumber: colorData[i2].colorInfo.range.startLineNumber,
          startColumn: colorData[i2].colorInfo.range.startColumn,
          endLineNumber: colorData[i2].colorInfo.range.endLineNumber,
          endColumn: colorData[i2].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: noBreakWhitespace,
            inlineClassName: `${ref.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: true,
            attachedData: ColorDecorationInjectedTextMarker
          }
        }
      });
    }
    const limited = limit < colorData.length ? limit : false;
    this._decoratorLimitReporter.update(colorData.length, limited);
    this._colorDecoratorIds.set(decorations);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds);
    this._decorationsIds = [];
    this._colorDecoratorIds.clear();
    this._colorDecorationClassRefs.clear();
  }
  getColorData(position) {
    const model = this._editor.getModel();
    if (!model) {
      return null;
    }
    const decorations = model.getDecorationsInRange(Range.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
    if (decorations.length === 0) {
      return null;
    }
    return this._colorDatas.get(decorations[0].id);
  }
  isColorDecoration(decoration3) {
    return this._colorDecoratorIds.has(decoration3);
  }
}, ColorDetector_1 = _a9, _a9.ID = "editor.contrib.colorDetector", _a9.RECOMPUTE_TIME = 1e3, _a9);
ColorDetector = ColorDetector_1 = __decorate15([
  __param15(1, IConfigurationService),
  __param15(2, ILanguageFeaturesService),
  __param15(3, ILanguageFeatureDebounceService)
], ColorDetector);
var DecoratorLimitReporter = class extends Disposable {
  constructor() {
    super(...arguments);
    this._onDidChange = this._register(new Emitter());
    this._computed = 0;
    this._limited = false;
  }
  update(computed, limited) {
    if (computed !== this._computed || limited !== this._limited) {
      this._computed = computed;
      this._limited = limited;
      this._onDidChange.fire();
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/hoverColorPicker/hoverColorPickerContribution.js
init_lifecycle();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverActionIds.js
init_nls();
var SHOW_OR_FOCUS_HOVER_ACTION_ID = "editor.action.showHover";
var SHOW_DEFINITION_PREVIEW_HOVER_ACTION_ID = "editor.action.showDefinitionPreviewHover";
var HIDE_HOVER_ACTION_ID = "editor.action.hideHover";
var SCROLL_UP_HOVER_ACTION_ID = "editor.action.scrollUpHover";
var SCROLL_DOWN_HOVER_ACTION_ID = "editor.action.scrollDownHover";
var SCROLL_LEFT_HOVER_ACTION_ID = "editor.action.scrollLeftHover";
var SCROLL_RIGHT_HOVER_ACTION_ID = "editor.action.scrollRightHover";
var PAGE_UP_HOVER_ACTION_ID = "editor.action.pageUpHover";
var PAGE_DOWN_HOVER_ACTION_ID = "editor.action.pageDownHover";
var GO_TO_TOP_HOVER_ACTION_ID = "editor.action.goToTopHover";
var GO_TO_BOTTOM_HOVER_ACTION_ID = "editor.action.goToBottomHover";
var INCREASE_HOVER_VERBOSITY_ACTION_ID = "editor.action.increaseHoverVerbosityLevel";
var INCREASE_HOVER_VERBOSITY_ACTION_LABEL = localize(1097, "Increase Hover Verbosity Level");
var DECREASE_HOVER_VERBOSITY_ACTION_ID = "editor.action.decreaseHoverVerbosityLevel";
var DECREASE_HOVER_VERBOSITY_ACTION_LABEL = localize(1098, "Decrease Hover Verbosity Level");

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverController.js
init_lifecycle();
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/hintsWidget/inlineCompletionsHintsWidget.js
init_dom();
init_actions();
init_arrays();
init_async();
init_codicons();
init_lifecycle();
init_observable();
init_platform();
init_themables();
init_nls();
init_actions2();
init_commands();
init_contextkey();
init_instantiation();
init_telemetry();
init_position();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/commandIds.js
var inlineSuggestCommitId = "editor.action.inlineSuggest.commit";
var showPreviousInlineSuggestionActionId = "editor.action.inlineSuggest.showPrevious";
var showNextInlineSuggestionActionId = "editor.action.inlineSuggest.showNext";
var jumpToNextInlineEditId = "editor.action.inlineSuggest.jump";
var hideInlineCompletionId = "editor.action.inlineSuggest.hide";
var toggleShowCollapsedId = "editor.action.inlineSuggest.toggleShowCollapsed";

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/hintsWidget/inlineCompletionsHintsWidget.js
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/hintsWidget/inlineCompletionsHintsWidget.css";
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineSuggestionHintsContentWidget_1;
var InlineCompletionsHintsWidget = class InlineCompletionsHintsWidget2 extends Disposable {
  constructor(editor2, model, instantiationService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.instantiationService = instantiationService;
    this.alwaysShowToolbar = observableFromEvent(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always");
    this.sessionPosition = void 0;
    this.position = derived(this, (reader) => {
      const ghostText = this.model.read(reader)?.primaryGhostText.read(reader);
      if (!this.alwaysShowToolbar.read(reader) || !ghostText || ghostText.parts.length === 0) {
        this.sessionPosition = void 0;
        return null;
      }
      const firstColumn = ghostText.parts[0].column;
      if (this.sessionPosition && this.sessionPosition.lineNumber !== ghostText.lineNumber) {
        this.sessionPosition = void 0;
      }
      const position = new Position(ghostText.lineNumber, Math.min(firstColumn, this.sessionPosition?.column ?? Number.MAX_SAFE_INTEGER));
      this.sessionPosition = position;
      return position;
    });
    this._register(autorunWithStore((reader, store) => {
      const model2 = this.model.read(reader);
      if (!model2 || !this.alwaysShowToolbar.read(reader)) {
        return;
      }
      const contentWidgetValue = derived((reader2) => {
        const contentWidget = reader2.store.add(this.instantiationService.createInstance(InlineSuggestionHintsContentWidget.hot.read(reader2), this.editor, true, this.position, model2.selectedInlineCompletionIndex, model2.inlineCompletionsCount, model2.activeCommands, model2.warning, () => {
        }));
        editor2.addContentWidget(contentWidget);
        reader2.store.add(toDisposable(() => editor2.removeContentWidget(contentWidget)));
        reader2.store.add(autorun((reader3) => {
          const position = this.position.read(reader3);
          if (!position) {
            return;
          }
          if (model2.lastTriggerKind.read(reader3) !== InlineCompletionTriggerKind.Explicit) {
            model2.triggerExplicitly();
          }
        }));
        return contentWidget;
      });
      const hadPosition = derivedObservableWithCache(this, (reader2, lastValue) => !!this.position.read(reader2) || !!lastValue);
      store.add(autorun((reader2) => {
        if (hadPosition.read(reader2)) {
          contentWidgetValue.read(reader2);
        }
      }));
    }));
  }
};
InlineCompletionsHintsWidget = __decorate16([
  __param16(2, IInstantiationService)
], InlineCompletionsHintsWidget);
var inlineSuggestionHintsNextIcon = registerIcon("inline-suggestion-hints-next", Codicon.chevronRight, localize(1198, "Icon for show next parameter hint."));
var inlineSuggestionHintsPreviousIcon = registerIcon("inline-suggestion-hints-previous", Codicon.chevronLeft, localize(1199, "Icon for show previous parameter hint."));
var _a10;
var InlineSuggestionHintsContentWidget = (_a10 = class extends Disposable {
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  createCommandAction(commandId, label, iconClassName) {
    const action = new Action(commandId, label, iconClassName, true, () => this._commandService.executeCommand(commandId));
    const kb = this.keybindingService.lookupKeybinding(commandId, this._contextKeyService);
    let tooltip = label;
    if (kb) {
      tooltip = localize(1200, "{0} ({1})", label, kb.getLabel());
    }
    action.tooltip = tooltip;
    return action;
  }
  constructor(editor2, withBorder, _position, _currentSuggestionIdx, _suggestionCount, _extraCommands, _warning, _relayout, _commandService, instantiationService, keybindingService, _contextKeyService, _menuService) {
    super();
    this.editor = editor2;
    this.withBorder = withBorder;
    this._position = _position;
    this._currentSuggestionIdx = _currentSuggestionIdx;
    this._suggestionCount = _suggestionCount;
    this._extraCommands = _extraCommands;
    this._warning = _warning;
    this._relayout = _relayout;
    this._commandService = _commandService;
    this.keybindingService = keybindingService;
    this._contextKeyService = _contextKeyService;
    this._menuService = _menuService;
    this.id = `InlineSuggestionHintsContentWidget${InlineSuggestionHintsContentWidget_1.id++}`;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._warningMessageContentNode = derived((reader) => {
      const warning = this._warning.read(reader);
      if (!warning) {
        return void 0;
      }
      if (typeof warning.message === "string") {
        return warning.message;
      }
      const markdownElement = reader.store.add(renderMarkdown(warning.message));
      return markdownElement.element;
    });
    this._warningMessageNode = n.div({
      class: "warningMessage",
      style: {
        maxWidth: 400,
        margin: 4,
        marginBottom: 4,
        display: derived((reader) => this._warning.read(reader) ? "block" : "none")
      }
    }, [
      this._warningMessageContentNode
    ]).keepUpdated(this._store);
    this.nodes = h("div.inlineSuggestionsHints", { className: this.withBorder ? "monaco-hover monaco-hover-content" : "" }, [
      this._warningMessageNode.element,
      h("div@toolBar")
    ]);
    this.previousAction = this._register(this.createCommandAction(showPreviousInlineSuggestionActionId, localize(1201, "Previous"), ThemeIcon.asClassName(inlineSuggestionHintsPreviousIcon)));
    this.availableSuggestionCountAction = this._register(new Action("inlineSuggestionHints.availableSuggestionCount", "", void 0, false));
    this.nextAction = this._register(this.createCommandAction(showNextInlineSuggestionActionId, localize(1202, "Next"), ThemeIcon.asClassName(inlineSuggestionHintsNextIcon)));
    this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
    this.clearAvailableSuggestionCountLabelDebounced = this._register(new RunOnceScheduler(() => {
      this.availableSuggestionCountAction.label = "";
    }, 100));
    this.disableButtonsDebounced = this._register(new RunOnceScheduler(() => {
      this.previousAction.enabled = this.nextAction.enabled = false;
    }, 100));
    this._register(autorun((reader) => {
      this._warningMessageContentNode.read(reader);
      this._warningMessageNode.readEffect(reader);
      this._relayout();
    }));
    this.toolBar = this._register(instantiationService.createInstance(CustomizedMenuWorkbenchToolBar, this.nodes.toolBar, MenuId.InlineSuggestionToolbar, {
      menuOptions: { renderShortTitle: true },
      toolbarOptions: { primaryGroup: (g) => g.startsWith("primary") },
      actionViewItemProvider: (action, options) => {
        if (action instanceof MenuItemAction) {
          return instantiationService.createInstance(StatusBarViewItem, action, void 0);
        }
        if (action === this.availableSuggestionCountAction) {
          const a = new ActionViewItemWithClassName(void 0, action, { label: true, icon: false });
          a.setClass("availableSuggestionCount");
          return a;
        }
        return void 0;
      },
      telemetrySource: "InlineSuggestionToolbar"
    }));
    this.toolBar.setPrependedPrimaryActions([
      this.previousAction,
      this.availableSuggestionCountAction,
      this.nextAction
    ]);
    this._register(this.toolBar.onDidChangeDropdownVisibility((e) => {
      InlineSuggestionHintsContentWidget_1._dropDownVisible = e;
    }));
    this._register(autorun((reader) => {
      this._position.read(reader);
      this.editor.layoutContentWidget(this);
    }));
    this._register(autorun((reader) => {
      const suggestionCount = this._suggestionCount.read(reader);
      const currentSuggestionIdx = this._currentSuggestionIdx.read(reader);
      if (suggestionCount !== void 0) {
        this.clearAvailableSuggestionCountLabelDebounced.cancel();
        this.availableSuggestionCountAction.label = `${currentSuggestionIdx + 1}/${suggestionCount}`;
      } else {
        this.clearAvailableSuggestionCountLabelDebounced.schedule();
      }
      if (suggestionCount !== void 0 && suggestionCount > 1) {
        this.disableButtonsDebounced.cancel();
        this.previousAction.enabled = this.nextAction.enabled = true;
      } else {
        this.disableButtonsDebounced.schedule();
      }
    }));
    this._register(autorun((reader) => {
      const extraCommands = this._extraCommands.read(reader);
      const extraActions = extraCommands.map((c) => ({
        class: void 0,
        id: c.command.id,
        enabled: true,
        tooltip: c.command.tooltip || "",
        label: c.command.title,
        run: (event) => {
          return this._commandService.executeCommand(c.command.id);
        }
      }));
      for (const [_, group] of this.inlineCompletionsActionsMenus.getActions()) {
        for (const action of group) {
          if (action instanceof MenuItemAction) {
            extraActions.push(action);
          }
        }
      }
      if (extraActions.length > 0) {
        extraActions.unshift(new Separator());
      }
      this.toolBar.setAdditionalSecondaryActions(extraActions);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
}, InlineSuggestionHintsContentWidget_1 = _a10, _a10.hot = createHotClass(InlineSuggestionHintsContentWidget_1), _a10._dropDownVisible = false, _a10.id = 0, _a10);
InlineSuggestionHintsContentWidget = InlineSuggestionHintsContentWidget_1 = __decorate16([
  __param16(8, ICommandService),
  __param16(9, IInstantiationService),
  __param16(10, IKeybindingService),
  __param16(11, IContextKeyService),
  __param16(12, IMenuService)
], InlineSuggestionHintsContentWidget);
var ActionViewItemWithClassName = class extends ActionViewItem {
  constructor() {
    super(...arguments);
    this._className = void 0;
  }
  setClass(className) {
    this._className = className;
  }
  render(container) {
    super.render(container);
    if (this._className) {
      container.classList.add(this._className);
    }
  }
  updateTooltip() {
  }
};
var StatusBarViewItem = class extends MenuEntryActionViewItem {
  updateLabel() {
    const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService, true);
    if (!kb) {
      return super.updateLabel();
    }
    if (this.label) {
      const div = h("div.keybinding").root;
      const k = this._register(new KeybindingLabel(div, OS, { disableTitle: true, ...unthemedKeybindingLabelOptions }));
      k.set(kb);
      this.label.textContent = this._action.label;
      this.label.appendChild(div);
      this.label.classList.add("inlineSuggestionStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
};
var CustomizedMenuWorkbenchToolBar = class CustomizedMenuWorkbenchToolBar2 extends WorkbenchToolBar {
  constructor(container, menuId, options2, menuService, contextKeyService, contextMenuService, keybindingService, commandService, telemetryService) {
    super(container, { resetMenu: menuId, ...options2 }, menuService, contextKeyService, contextMenuService, keybindingService, commandService, telemetryService);
    this.menuId = menuId;
    this.options2 = options2;
    this.menuService = menuService;
    this.contextKeyService = contextKeyService;
    this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: true }));
    this.additionalActions = [];
    this.prependedPrimaryActions = [];
    this.additionalPrimaryActions = [];
    this._store.add(this.menu.onDidChange(() => this.updateToolbar()));
    this.updateToolbar();
  }
  updateToolbar() {
    const { primary, secondary } = getActionBarActions(this.menu.getActions(this.options2?.menuOptions), this.options2?.toolbarOptions?.primaryGroup, this.options2?.toolbarOptions?.shouldInlineSubmenu, this.options2?.toolbarOptions?.useSeparatorsInPrimaryActions);
    secondary.push(...this.additionalActions);
    primary.unshift(...this.prependedPrimaryActions);
    primary.push(...this.additionalPrimaryActions);
    this.setActions(primary, secondary);
  }
  setPrependedPrimaryActions(actions) {
    if (equals(this.prependedPrimaryActions, actions, (a, b) => a === b)) {
      return;
    }
    this.prependedPrimaryActions = actions;
    this.updateToolbar();
  }
  setAdditionalSecondaryActions(actions) {
    if (equals(this.additionalActions, actions, (a, b) => a === b)) {
      return;
    }
    this.additionalActions = actions;
    this.updateToolbar();
  }
};
CustomizedMenuWorkbenchToolBar = __decorate16([
  __param16(3, IMenuService),
  __param16(4, IContextKeyService),
  __param16(5, IContextMenuService),
  __param16(6, IKeybindingService),
  __param16(7, ICommandService),
  __param16(8, ITelemetryService)
], CustomizedMenuWorkbenchToolBar);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverController.js
init_async();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverUtils.js
init_dom();
function isMousePositionWithinElement(element, posx, posy) {
  const elementRect = getDomNodePagePosition(element);
  if (posx < elementRect.left || posx > elementRect.left + elementRect.width || posy < elementRect.top || posy > elementRect.top + elementRect.height) {
    return false;
  }
  return true;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverWidgetWrapper.js
init_dom();
init_lifecycle();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverOperation.js
init_async();
init_errors();
init_event();
init_lifecycle();
var HoverResult = class {
  constructor(value, isComplete, hasLoadingMessage, options) {
    this.value = value;
    this.isComplete = isComplete;
    this.hasLoadingMessage = hasLoadingMessage;
    this.options = options;
  }
};
var HoverOperation = class extends Disposable {
  constructor(_editor, _computer) {
    super();
    this._editor = _editor;
    this._computer = _computer;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._asyncComputationScheduler = this._register(new Debouncer((options) => this._triggerAsyncComputation(options), 0));
    this._syncComputationScheduler = this._register(new Debouncer((options) => this._triggerSyncComputation(options), 0));
    this._loadingMessageScheduler = this._register(new Debouncer((options) => this._triggerLoadingMessage(options), 0));
    this._state = 0;
    this._asyncIterable = null;
    this._asyncIterableDone = false;
    this._result = [];
  }
  dispose() {
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    this._options = void 0;
    super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      69
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(state, options) {
    this._options = options;
    this._state = state;
    this._fireResult(options);
  }
  _triggerAsyncComputation(options) {
    this._setState(2, options);
    this._syncComputationScheduler.schedule(options, this._secondWaitTime);
    if (this._computer.computeAsync) {
      this._asyncIterableDone = false;
      this._asyncIterable = createCancelableAsyncIterableProducer((token) => this._computer.computeAsync(options, token));
      (async () => {
        try {
          for await (const item of this._asyncIterable) {
            if (item) {
              this._result.push(item);
              this._fireResult(options);
            }
          }
          this._asyncIterableDone = true;
          if (this._state === 3 || this._state === 4) {
            this._setState(0, options);
          }
        } catch (e) {
          onUnexpectedError(e);
        }
      })();
    } else {
      this._asyncIterableDone = true;
    }
  }
  _triggerSyncComputation(options) {
    if (this._computer.computeSync) {
      this._result = this._result.concat(this._computer.computeSync(options));
    }
    this._setState(this._asyncIterableDone ? 0 : 3, options);
  }
  _triggerLoadingMessage(options) {
    if (this._state === 3) {
      this._setState(4, options);
    }
  }
  _fireResult(options) {
    if (this._state === 1 || this._state === 2) {
      return;
    }
    const isComplete = this._state === 0;
    const hasLoadingMessage = this._state === 4;
    this._onResult.fire(new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage, options));
  }
  start(mode, options) {
    if (mode === 0) {
      if (this._state === 0) {
        this._setState(1, options);
        this._asyncComputationScheduler.schedule(options, this._firstWaitTime);
        this._loadingMessageScheduler.schedule(options, this._loadingMessageTime);
      }
    } else {
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation(options);
          this._syncComputationScheduler.cancel();
          this._triggerSyncComputation(options);
          break;
        case 2:
          this._syncComputationScheduler.cancel();
          this._triggerSyncComputation(options);
          break;
      }
    }
  }
  cancel() {
    this._asyncComputationScheduler.cancel();
    this._syncComputationScheduler.cancel();
    this._loadingMessageScheduler.cancel();
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    this._result = [];
    this._options = void 0;
    this._state = 0;
  }
  get options() {
    return this._options;
  }
};
var Debouncer = class extends Disposable {
  constructor(runner, debounceTimeMs) {
    super();
    this._scheduler = this._register(new RunOnceScheduler(() => runner(this._options), debounceTimeMs));
  }
  schedule(options, debounceTimeMs) {
    this._options = options;
    this._scheduler.schedule(debounceTimeMs);
  }
  cancel() {
    this._scheduler.cancel();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverWidgetWrapper.js
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverWidget.js
init_dom();

// node_modules/monaco-editor/esm/vs/base/browser/ui/resizable/resizable.js
init_dom();
init_event();
init_lifecycle();
var ResizableHTMLElement = class {
  get onDidWillResize() {
    return this._onDidWillResize.event;
  }
  get onDidResize() {
    return this._onDidResize.event;
  }
  constructor() {
    this._onDidWillResize = new Emitter();
    this._onDidResize = new Emitter();
    this._sashListener = new DisposableStore();
    this._size = new Dimension(0, 0);
    this._minSize = new Dimension(0, 0);
    this._maxSize = new Dimension(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    this.domNode = document.createElement("div");
    this._eastSash = new Sash(this.domNode, { getVerticalSashLeft: () => this._size.width }, {
      orientation: 0
      /* Orientation.VERTICAL */
    });
    this._westSash = new Sash(this.domNode, { getVerticalSashLeft: () => 0 }, {
      orientation: 0
      /* Orientation.VERTICAL */
    });
    this._northSash = new Sash(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: OrthogonalEdge.North });
    this._southSash = new Sash(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: OrthogonalEdge.South });
    this._northSash.orthogonalStartSash = this._westSash;
    this._northSash.orthogonalEndSash = this._eastSash;
    this._southSash.orthogonalStartSash = this._westSash;
    this._southSash.orthogonalEndSash = this._eastSash;
    let currentSize;
    let deltaY = 0;
    let deltaX = 0;
    this._sashListener.add(Event.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      if (currentSize === void 0) {
        this._onDidWillResize.fire();
        currentSize = this._size;
        deltaY = 0;
        deltaX = 0;
      }
    }));
    this._sashListener.add(Event.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      if (currentSize !== void 0) {
        currentSize = void 0;
        deltaY = 0;
        deltaX = 0;
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
    this._sashListener.add(this._eastSash.onDidChange((e) => {
      if (currentSize) {
        deltaX = e.currentX - e.startX;
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, east: true });
      }
    }));
    this._sashListener.add(this._westSash.onDidChange((e) => {
      if (currentSize) {
        deltaX = -(e.currentX - e.startX);
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, west: true });
      }
    }));
    this._sashListener.add(this._northSash.onDidChange((e) => {
      if (currentSize) {
        deltaY = -(e.currentY - e.startY);
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, north: true });
      }
    }));
    this._sashListener.add(this._southSash.onDidChange((e) => {
      if (currentSize) {
        deltaY = e.currentY - e.startY;
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, south: true });
      }
    }));
    this._sashListener.add(Event.any(this._eastSash.onDidReset, this._westSash.onDidReset)((e) => {
      if (this._preferredSize) {
        this.layout(this._size.height, this._preferredSize.width);
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
    this._sashListener.add(Event.any(this._northSash.onDidReset, this._southSash.onDidReset)((e) => {
      if (this._preferredSize) {
        this.layout(this._preferredSize.height, this._size.width);
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
  }
  dispose() {
    this._northSash.dispose();
    this._southSash.dispose();
    this._eastSash.dispose();
    this._westSash.dispose();
    this._sashListener.dispose();
    this._onDidResize.dispose();
    this._onDidWillResize.dispose();
    this.domNode.remove();
  }
  enableSashes(north, east, south, west) {
    this._northSash.state = north ? 3 : 0;
    this._eastSash.state = east ? 3 : 0;
    this._southSash.state = south ? 3 : 0;
    this._westSash.state = west ? 3 : 0;
  }
  layout(height = this.size.height, width = this.size.width) {
    const { height: minHeight, width: minWidth } = this._minSize;
    const { height: maxHeight, width: maxWidth } = this._maxSize;
    height = Math.max(minHeight, Math.min(maxHeight, height));
    width = Math.max(minWidth, Math.min(maxWidth, width));
    const newSize = new Dimension(width, height);
    if (!Dimension.equals(newSize, this._size)) {
      this.domNode.style.height = height + "px";
      this.domNode.style.width = width + "px";
      this._size = newSize;
      this._northSash.layout();
      this._eastSash.layout();
      this._southSash.layout();
      this._westSash.layout();
    }
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState();
    this._westSash.clearSashHoverState();
    this._northSash.clearSashHoverState();
    this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(value) {
    this._maxSize = value;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(value) {
    this._minSize = value;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(value) {
    this._preferredSize = value;
  }
  get preferredSize() {
    return this._preferredSize;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/resizableContentWidget.js
init_lifecycle();
init_position();
init_dom();
var TOP_HEIGHT = 30;
var BOTTOM_HEIGHT = 24;
var ResizableContentWidget = class extends Disposable {
  constructor(_editor, minimumSize = new Dimension(10, 10)) {
    super();
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._resizableNode = this._register(new ResizableHTMLElement());
    this._contentPosition = null;
    this._isResizing = false;
    this._resizableNode.domNode.style.position = "absolute";
    this._resizableNode.minSize = Dimension.lift(minimumSize);
    this._resizableNode.layout(minimumSize.height, minimumSize.width);
    this._resizableNode.enableSashes(true, true, true, true);
    this._register(this._resizableNode.onDidResize((e) => {
      this._resize(new Dimension(e.dimension.width, e.dimension.height));
      if (e.done) {
        this._isResizing = false;
      }
    }));
    this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = true;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    return this._contentPosition?.position ? Position.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(position) {
    const editorDomNode = this._editor.getDomNode();
    const mouseBox = this._editor.getScrolledVisiblePosition(position);
    if (!editorDomNode || !mouseBox) {
      return;
    }
    const editorBox = getDomNodePagePosition(editorDomNode);
    return editorBox.top + mouseBox.top - TOP_HEIGHT;
  }
  _availableVerticalSpaceBelow(position) {
    const editorDomNode = this._editor.getDomNode();
    const mouseBox = this._editor.getScrolledVisiblePosition(position);
    if (!editorDomNode || !mouseBox) {
      return;
    }
    const editorBox = getDomNodePagePosition(editorDomNode);
    const bodyBox = getClientArea(editorDomNode.ownerDocument.body);
    const mouseBottom = editorBox.top + mouseBox.top + mouseBox.height;
    return bodyBox.height - mouseBottom - BOTTOM_HEIGHT;
  }
  _findPositionPreference(widgetHeight, showAtPosition) {
    const maxHeightBelow = Math.min(this._availableVerticalSpaceBelow(showAtPosition) ?? Infinity, widgetHeight);
    const maxHeightAbove = Math.min(this._availableVerticalSpaceAbove(showAtPosition) ?? Infinity, widgetHeight);
    const maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow), widgetHeight);
    const height = Math.min(widgetHeight, maxHeight);
    let renderingAbove;
    if (this._editor.getOption(
      69
      /* EditorOption.hover */
    ).above) {
      renderingAbove = height <= maxHeightAbove ? 1 : 2;
    } else {
      renderingAbove = height <= maxHeightBelow ? 2 : 1;
    }
    if (renderingAbove === 1) {
      this._resizableNode.enableSashes(true, true, false, false);
    } else {
      this._resizableNode.enableSashes(false, true, true, false);
    }
    return renderingAbove;
  }
  _resize(dimension) {
    this._resizableNode.layout(dimension.height, dimension.width);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverWidget.js
init_contextkey();
init_configuration();
init_editorContextKeys();
init_event();
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContentHoverWidget_1;
var HORIZONTAL_SCROLLING_BY = 30;
var _a11;
var ContentHoverWidget = (_a11 = class extends ResizableContentWidget {
  get isVisibleFromKeyboard() {
    return this._renderedHover?.source === 2;
  }
  get isVisible() {
    return this._hoverVisibleKey.get() ?? false;
  }
  get isFocused() {
    return this._hoverFocusedKey.get() ?? false;
  }
  constructor(editor2, contextKeyService, _configurationService, _accessibilityService, _keybindingService) {
    const minimumHeight = editor2.getOption(
      75
      /* EditorOption.lineHeight */
    ) + 8;
    const minimumWidth = 150;
    const minimumSize = new Dimension(minimumWidth, minimumHeight);
    super(editor2, minimumSize);
    this._configurationService = _configurationService;
    this._accessibilityService = _accessibilityService;
    this._keybindingService = _keybindingService;
    this._hover = this._register(new HoverWidget(true));
    this._onDidResize = this._register(new Emitter());
    this.onDidResize = this._onDidResize.event;
    this._onDidScroll = this._register(new Emitter());
    this.onDidScroll = this._onDidScroll.event;
    this._onContentsChanged = this._register(new Emitter());
    this.onContentsChanged = this._onContentsChanged.event;
    this._minimumSize = minimumSize;
    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(contextKeyService);
    this._hoverFocusedKey = EditorContextKeys.hoverFocused.bindTo(contextKeyService);
    append(this._resizableNode.domNode, this._hover.containerDomNode);
    this._resizableNode.domNode.style.zIndex = "50";
    this._resizableNode.domNode.className = "monaco-resizable-hover";
    this._register(this._editor.onDidLayoutChange(() => {
      if (this.isVisible) {
        this._updateMaxDimensions();
      }
    }));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    const focusTracker = this._register(trackFocus(this._resizableNode.domNode));
    this._register(focusTracker.onDidFocus(() => {
      this._hoverFocusedKey.set(true);
    }));
    this._register(focusTracker.onDidBlur(() => {
      this._hoverFocusedKey.set(false);
    }));
    this._register(this._hover.scrollbar.onScroll((e) => {
      this._onDidScroll.fire(e);
    }));
    this._setRenderedHover(void 0);
    this._editor.addContentWidget(this);
  }
  dispose() {
    super.dispose();
    this._renderedHover?.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return ContentHoverWidget_1.ID;
  }
  static _applyDimensions(container, width, height) {
    const transformedWidth = typeof width === "number" ? `${width}px` : width;
    const transformedHeight = typeof height === "number" ? `${height}px` : height;
    container.style.width = transformedWidth;
    container.style.height = transformedHeight;
  }
  _setContentsDomNodeDimensions(width, height) {
    const contentsDomNode = this._hover.contentsDomNode;
    return ContentHoverWidget_1._applyDimensions(contentsDomNode, width, height);
  }
  _setContainerDomNodeDimensions(width, height) {
    const containerDomNode = this._hover.containerDomNode;
    return ContentHoverWidget_1._applyDimensions(containerDomNode, width, height);
  }
  _setScrollableElementDimensions(width, height) {
    const scrollbarDomElement = this._hover.scrollbar.getDomNode();
    return ContentHoverWidget_1._applyDimensions(scrollbarDomElement, width, height);
  }
  _setHoverWidgetDimensions(width, height) {
    this._setContainerDomNodeDimensions(width, height);
    this._setScrollableElementDimensions(width, height);
    this._setContentsDomNodeDimensions(width, height);
    this._layoutContentWidget();
  }
  static _applyMaxDimensions(container, width, height) {
    const transformedWidth = typeof width === "number" ? `${width}px` : width;
    const transformedHeight = typeof height === "number" ? `${height}px` : height;
    container.style.maxWidth = transformedWidth;
    container.style.maxHeight = transformedHeight;
  }
  _setHoverWidgetMaxDimensions(width, height) {
    ContentHoverWidget_1._applyMaxDimensions(this._hover.contentsDomNode, width, height);
    ContentHoverWidget_1._applyMaxDimensions(this._hover.scrollbar.getDomNode(), width, height);
    ContentHoverWidget_1._applyMaxDimensions(this._hover.containerDomNode, width, height);
    this._hover.containerDomNode.style.setProperty("--vscode-hover-maxWidth", typeof width === "number" ? `${width}px` : width);
    this._layoutContentWidget();
  }
  _setAdjustedHoverWidgetDimensions(size2) {
    this._setHoverWidgetMaxDimensions("none", "none");
    this._setHoverWidgetDimensions(size2.width, size2.height);
  }
  _updateResizableNodeMaxDimensions() {
    const maxRenderingWidth = this._findMaximumRenderingWidth() ?? Infinity;
    const maxRenderingHeight = this._findMaximumRenderingHeight() ?? Infinity;
    this._resizableNode.maxSize = new Dimension(maxRenderingWidth, maxRenderingHeight);
    this._setHoverWidgetMaxDimensions(maxRenderingWidth, maxRenderingHeight);
  }
  _resize(size2) {
    ContentHoverWidget_1._lastDimensions = new Dimension(size2.width, size2.height);
    this._setAdjustedHoverWidgetDimensions(size2);
    this._resizableNode.layout(size2.height, size2.width);
    this._updateResizableNodeMaxDimensions();
    this._hover.scrollbar.scanDomNode();
    this._editor.layoutContentWidget(this);
    this._onDidResize.fire();
  }
  _findAvailableSpaceVertically() {
    const position = this._renderedHover?.showAtPosition;
    if (!position) {
      return;
    }
    return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(position) : this._availableVerticalSpaceBelow(position);
  }
  _findMaximumRenderingHeight() {
    const availableSpace = this._findAvailableSpaceVertically();
    if (!availableSpace) {
      return;
    }
    const children = this._hover.contentsDomNode.children;
    let maximumHeight = children.length - 1;
    Array.from(this._hover.contentsDomNode.children).forEach((hoverPart) => {
      maximumHeight += hoverPart.clientHeight;
    });
    return Math.min(availableSpace, maximumHeight);
  }
  _isHoverTextOverflowing() {
    this._hover.containerDomNode.style.setProperty("--vscode-hover-whiteSpace", "nowrap");
    this._hover.containerDomNode.style.setProperty("--vscode-hover-sourceWhiteSpace", "nowrap");
    const overflowing = Array.from(this._hover.contentsDomNode.children).some((hoverElement) => {
      return hoverElement.scrollWidth > hoverElement.clientWidth;
    });
    this._hover.containerDomNode.style.removeProperty("--vscode-hover-whiteSpace");
    this._hover.containerDomNode.style.removeProperty("--vscode-hover-sourceWhiteSpace");
    return overflowing;
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel()) {
      return;
    }
    const overflowing = this._isHoverTextOverflowing();
    const initialWidth = typeof this._contentWidth === "undefined" ? 0 : this._contentWidth;
    if (overflowing || this._hover.containerDomNode.clientWidth < initialWidth) {
      const bodyBoxWidth = getClientArea(this._hover.containerDomNode.ownerDocument.body).width;
      const horizontalPadding = 14;
      return bodyBoxWidth - horizontalPadding;
    } else {
      return this._hover.containerDomNode.clientWidth;
    }
  }
  isMouseGettingCloser(posx, posy) {
    if (!this._renderedHover) {
      return false;
    }
    if (this._renderedHover.initialMousePosX === void 0 || this._renderedHover.initialMousePosY === void 0) {
      this._renderedHover.initialMousePosX = posx;
      this._renderedHover.initialMousePosY = posy;
      return false;
    }
    const widgetRect = getDomNodePagePosition(this.getDomNode());
    if (this._renderedHover.closestMouseDistance === void 0) {
      this._renderedHover.closestMouseDistance = computeDistanceFromPointToRectangle(this._renderedHover.initialMousePosX, this._renderedHover.initialMousePosY, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    }
    const distance = computeDistanceFromPointToRectangle(posx, posy, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    if (distance > this._renderedHover.closestMouseDistance + 4) {
      return false;
    }
    this._renderedHover.closestMouseDistance = Math.min(this._renderedHover.closestMouseDistance, distance);
    return true;
  }
  _setRenderedHover(renderedHover) {
    this._renderedHover?.dispose();
    this._renderedHover = renderedHover;
    this._hoverVisibleKey.set(!!renderedHover);
    this._hover.containerDomNode.classList.toggle("hidden", !renderedHover);
  }
  _updateFont() {
    const { fontSize, lineHeight } = this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    const contentsDomNode = this._hover.contentsDomNode;
    contentsDomNode.style.fontSize = `${fontSize}px`;
    contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _updateContent(node) {
    const contentsDomNode = this._hover.contentsDomNode;
    contentsDomNode.style.paddingBottom = "";
    contentsDomNode.textContent = "";
    contentsDomNode.appendChild(node);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this);
    this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250, ContentHoverWidget_1._lastDimensions.height);
    const width = Math.max(this._editor.getLayoutInfo().width * 0.66, 750, ContentHoverWidget_1._lastDimensions.width);
    this._resizableNode.maxSize = new Dimension(width, height);
    this._setHoverWidgetMaxDimensions(width, height);
  }
  _render(renderedHover) {
    this._setRenderedHover(renderedHover);
    this._updateFont();
    this._updateContent(renderedHover.domNode);
    this.handleContentsChanged();
    this._editor.render();
  }
  getPosition() {
    if (!this._renderedHover) {
      return null;
    }
    return {
      position: this._renderedHover.showAtPosition,
      secondaryPosition: this._renderedHover.showAtSecondaryPosition,
      positionAffinity: this._renderedHover.shouldAppearBeforeContent ? 3 : void 0,
      preference: [
        this._positionPreference ?? 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    };
  }
  show(renderedHover) {
    if (!this._editor || !this._editor.hasModel()) {
      return;
    }
    this._render(renderedHover);
    const widgetHeight = getTotalHeight(this._hover.containerDomNode);
    const widgetPosition = renderedHover.showAtPosition;
    this._positionPreference = this._findPositionPreference(widgetHeight, widgetPosition) ?? 1;
    this.handleContentsChanged();
    if (renderedHover.shouldFocus) {
      this._hover.containerDomNode.focus();
    }
    this._onDidResize.fire();
    const hoverFocused = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode;
    const accessibleViewHint = hoverFocused && getHoverAccessibleViewHint(this._configurationService.getValue("accessibility.verbosity.hover") === true && this._accessibilityService.isScreenReaderOptimized(), this._keybindingService.lookupKeybinding("editor.action.accessibleView")?.getAriaLabel() ?? "");
    if (accessibleViewHint) {
      this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ", " + accessibleViewHint;
    }
  }
  hide() {
    if (!this._renderedHover) {
      return;
    }
    const hoverStoleFocus = this._renderedHover.shouldFocus || this._hoverFocusedKey.get();
    this._setRenderedHover(void 0);
    this._resizableNode.maxSize = new Dimension(Infinity, Infinity);
    this._resizableNode.clearSashHoverState();
    this._hoverFocusedKey.set(false);
    this._editor.layoutContentWidget(this);
    if (hoverStoleFocus) {
      this._editor.focus();
    }
  }
  _removeConstraintsRenderNormally() {
    const layoutInfo = this._editor.getLayoutInfo();
    this._resizableNode.layout(layoutInfo.height, layoutInfo.width);
    this._setHoverWidgetDimensions("auto", "auto");
    this._updateMaxDimensions();
  }
  setMinimumDimensions(dimensions) {
    this._minimumSize = new Dimension(Math.max(this._minimumSize.width, dimensions.width), Math.max(this._minimumSize.height, dimensions.height));
    this._updateMinimumWidth();
  }
  _updateMinimumWidth() {
    const width = typeof this._contentWidth === "undefined" ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);
    this._resizableNode.minSize = new Dimension(width, this._minimumSize.height);
  }
  handleContentsChanged() {
    this._removeConstraintsRenderNormally();
    const contentsDomNode = this._hover.contentsDomNode;
    let height = getTotalHeight(contentsDomNode);
    let width = getTotalWidth(contentsDomNode) + 2;
    this._resizableNode.layout(height, width);
    this._setHoverWidgetDimensions(width, height);
    height = getTotalHeight(contentsDomNode);
    width = getTotalWidth(contentsDomNode);
    this._contentWidth = width;
    this._updateMinimumWidth();
    this._resizableNode.layout(height, width);
    if (this._renderedHover?.showAtPosition) {
      const widgetHeight = getTotalHeight(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(widgetHeight, this._renderedHover.showAtPosition);
    }
    this._layoutContentWidget();
    this._onContentsChanged.fire();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const fontInfo = this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - fontInfo.lineHeight });
  }
  scrollDown() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const fontInfo = this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + fontInfo.lineHeight });
  }
  scrollLeft() {
    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft - HORIZONTAL_SCROLLING_BY });
  }
  scrollRight() {
    const scrollLeft = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: scrollLeft + HORIZONTAL_SCROLLING_BY });
  }
  pageUp() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop - scrollHeight });
  }
  pageDown() {
    const scrollTop = this._hover.scrollbar.getScrollPosition().scrollTop;
    const scrollHeight = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: scrollTop + scrollHeight });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
}, ContentHoverWidget_1 = _a11, _a11.ID = "editor.contrib.resizableContentHoverWidget", _a11._lastDimensions = new Dimension(0, 0), _a11);
ContentHoverWidget = ContentHoverWidget_1 = __decorate17([
  __param17(1, IContextKeyService),
  __param17(2, IConfigurationService),
  __param17(3, IAccessibilityService),
  __param17(4, IKeybindingService)
], ContentHoverWidget);
function computeDistanceFromPointToRectangle(pointX, pointY, left, top, width, height) {
  const x = left + width / 2;
  const y = top + height / 2;
  const dx = Math.max(Math.abs(pointX - x) - width / 2, 0);
  const dy = Math.max(Math.abs(pointY - y) - height / 2, 0);
  return Math.sqrt(dx * dx + dy * dy);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverComputer.js
init_arrays();
init_async();
var ContentHoverComputer = class _ContentHoverComputer {
  constructor(_editor, _participants) {
    this._editor = _editor;
    this._participants = _participants;
  }
  static _getLineDecorations(editor2, anchor) {
    if (anchor.type !== 1 && !anchor.supportsMarkerHover) {
      return [];
    }
    const model = editor2.getModel();
    const lineNumber = anchor.range.startLineNumber;
    if (lineNumber > model.getLineCount()) {
      return [];
    }
    const maxColumn = model.getLineMaxColumn(lineNumber);
    return editor2.getLineDecorations(lineNumber).filter((d) => {
      if (d.options.isWholeLine) {
        return true;
      }
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      if (d.options.showIfCollapsed) {
        if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {
          return false;
        }
      } else {
        if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {
          return false;
        }
      }
      return true;
    });
  }
  computeAsync(options, token) {
    const anchor = options.anchor;
    if (!this._editor.hasModel() || !anchor) {
      return AsyncIterableProducer.EMPTY;
    }
    const lineDecorations = _ContentHoverComputer._getLineDecorations(this._editor, anchor);
    return AsyncIterableProducer.merge(this._participants.map((participant) => {
      if (!participant.computeAsync) {
        return AsyncIterableProducer.EMPTY;
      }
      return participant.computeAsync(anchor, lineDecorations, options.source, token);
    }));
  }
  computeSync(options) {
    if (!this._editor.hasModel()) {
      return [];
    }
    const anchor = options.anchor;
    const lineDecorations = _ContentHoverComputer._getLineDecorations(this._editor, anchor);
    let result = [];
    for (const participant of this._participants) {
      result = result.concat(participant.computeSync(anchor, lineDecorations, options.source));
    }
    return coalesce(result);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverTypes.js
var ContentHoverResult = class {
  constructor(hoverParts, isComplete, options) {
    this.hoverParts = hoverParts;
    this.isComplete = isComplete;
    this.options = options;
  }
  filter(anchor) {
    const filteredHoverParts = this.hoverParts.filter((m) => m.isValidForHoverAnchor(anchor));
    if (filteredHoverParts.length === this.hoverParts.length) {
      return this;
    }
    return new FilteredContentHoverResult(this, filteredHoverParts, this.isComplete, this.options);
  }
};
var FilteredContentHoverResult = class extends ContentHoverResult {
  constructor(original, messages, isComplete, options) {
    super(messages, isComplete, options);
    this.original = original;
  }
  filter(anchor) {
    return this.original.filter(anchor);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverWidgetWrapper.js
init_event();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverRendered.js
init_lifecycle();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverStatusBar.js
init_dom();
init_lifecycle();
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $2 = $;
var EditorHoverStatusBar = class EditorHoverStatusBar2 extends Disposable {
  get hasContent() {
    return this._hasContent;
  }
  constructor(_keybindingService, _hoverService) {
    super();
    this._keybindingService = _keybindingService;
    this._hoverService = _hoverService;
    this.actions = [];
    this._hasContent = false;
    this.hoverElement = $2("div.hover-row.status-bar");
    this.hoverElement.tabIndex = 0;
    this.actionsElement = append(this.hoverElement, $2("div.actions"));
  }
  addAction(actionOptions) {
    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
    const keybindingLabel = keybinding ? keybinding.getLabel() : null;
    this._hasContent = true;
    const action = this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
    this._register(this._hoverService.setupManagedHover(getDefaultHoverDelegate("element"), action.actionContainer, action.actionRenderedLabel));
    this.actions.push(action);
    return action;
  }
  append(element) {
    const result = append(this.actionsElement, element);
    this._hasContent = true;
    return result;
  }
};
EditorHoverStatusBar = __decorate18([
  __param18(0, IKeybindingService),
  __param18(1, IHoverService)
], EditorHoverStatusBar);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverRendered.js
init_textModel();
init_position();
init_range();
init_dom();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
init_dom();
init_arrays();
init_cancellation();
init_htmlContent();
init_lifecycle();
init_range();
init_language();
init_nls();
init_configuration();
init_languageFeatures();
init_languages();
init_codicons();
init_themables();
init_errors();
init_async();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/getHover.js
init_async();
init_cancellation();
init_errors();
init_editorExtensions();
init_languageFeatures();
var HoverProviderResult = class {
  constructor(provider, hover, ordinal) {
    this.provider = provider;
    this.hover = hover;
    this.ordinal = ordinal;
  }
};
async function executeProvider(provider, ordinal, model, position, token) {
  const result = await Promise.resolve(provider.provideHover(model, position, token)).catch(onUnexpectedExternalError);
  if (!result || !isValid(result)) {
    return void 0;
  }
  return new HoverProviderResult(provider, result, ordinal);
}
function getHoverProviderResultsAsAsyncIterable(registry, model, position, token, recursive = false) {
  const providers = registry.ordered(model, recursive);
  const promises = providers.map((provider, index) => executeProvider(provider, index, model, position, token));
  return AsyncIterableProducer.fromPromisesResolveOrder(promises).coalesce();
}
async function getHoversPromise(registry, model, position, token, recursive = false) {
  const out = [];
  for await (const item of getHoverProviderResultsAsAsyncIterable(registry, model, position, token, recursive)) {
    out.push(item.hover);
  }
  return out;
}
registerModelAndPositionCommand("_executeHoverProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getHoversPromise(languageFeaturesService.hoverProvider, model, position, CancellationToken.None);
});
registerModelAndPositionCommand("_executeHoverProvider_recursive", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getHoversPromise(languageFeaturesService.hoverProvider, model, position, CancellationToken.None, true);
});
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
init_commands();
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $3 = $;
var increaseHoverVerbosityIcon = registerIcon("hover-increase-verbosity", Codicon.add, localize(1123, "Icon for increaseing hover verbosity."));
var decreaseHoverVerbosityIcon = registerIcon("hover-decrease-verbosity", Codicon.remove, localize(1124, "Icon for decreasing hover verbosity."));
var MarkdownHover = class {
  constructor(owner, range, contents, isBeforeContent, ordinal, source = void 0) {
    this.owner = owner;
    this.range = range;
    this.contents = contents;
    this.isBeforeContent = isBeforeContent;
    this.ordinal = ordinal;
    this.source = source;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var HoverSource = class {
  constructor(hover, hoverProvider, hoverPosition) {
    this.hover = hover;
    this.hoverProvider = hoverProvider;
    this.hoverPosition = hoverPosition;
  }
  supportsVerbosityAction(hoverVerbosityAction) {
    switch (hoverVerbosityAction) {
      case HoverVerbosityAction.Increase:
        return this.hover.canIncreaseVerbosity ?? false;
      case HoverVerbosityAction.Decrease:
        return this.hover.canDecreaseVerbosity ?? false;
    }
  }
};
var MarkdownHoverParticipant = class MarkdownHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, _configurationService, _languageFeaturesService, _keybindingService, _hoverService, _commandService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._keybindingService = _keybindingService;
    this._hoverService = _hoverService;
    this._commandService = _commandService;
    this.hoverOrdinal = 3;
  }
  createLoadingMessage(anchor) {
    return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize(1125, "Loading..."))], false, 2e3);
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    let index = 1e3;
    const lineLength = model.getLineLength(lineNumber);
    const languageId = model.getLanguageIdAtPosition(anchor.range.startLineNumber, anchor.range.startColumn);
    const stopRenderingLineAfter = this._editor.getOption(
      133
      /* EditorOption.stopRenderingLineAfter */
    );
    const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: languageId
    });
    let stopRenderingMessage = false;
    if (stopRenderingLineAfter >= 0 && lineLength > stopRenderingLineAfter && anchor.range.startColumn >= stopRenderingLineAfter) {
      stopRenderingMessage = true;
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize(1126, "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
      }], false, index++));
    }
    if (!stopRenderingMessage && typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) {
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize(1127, "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
      }], false, index++));
    }
    let isBeforeContent = false;
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const hoverMessage = d.options.hoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      if (d.options.beforeContentClassName) {
        isBeforeContent = true;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkdownHover(this, range, asArray(hoverMessage), isBeforeContent, index++));
    }
    return result;
  }
  computeAsync(anchor, lineDecorations, source, token) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return AsyncIterableProducer.EMPTY;
    }
    const model = this._editor.getModel();
    const hoverProviderRegistry = this._languageFeaturesService.hoverProvider;
    if (!hoverProviderRegistry.has(model)) {
      return AsyncIterableProducer.EMPTY;
    }
    return this._getMarkdownHovers(hoverProviderRegistry, model, anchor, token);
  }
  async *_getMarkdownHovers(hoverProviderRegistry, model, anchor, token) {
    const position = anchor.range.getStartPosition();
    const hoverProviderResults = getHoverProviderResultsAsAsyncIterable(hoverProviderRegistry, model, position, token);
    for await (const item of hoverProviderResults) {
      if (!isEmptyMarkdownString(item.hover.contents)) {
        const range = item.hover.range ? Range.lift(item.hover.range) : anchor.range;
        const hoverSource = new HoverSource(item.hover, item.provider, position);
        yield new MarkdownHover(this, range, item.hover.contents, false, item.ordinal, hoverSource);
      }
    }
  }
  renderHoverParts(context, hoverParts) {
    this._renderedHoverParts = new MarkdownRenderedHoverParts(hoverParts, context.fragment, this, this._editor, this._languageService, this._openerService, this._commandService, this._keybindingService, this._hoverService, this._configurationService, context.onContentsChanged);
    return this._renderedHoverParts;
  }
  handleScroll(e) {
    this._renderedHoverParts?.handleScroll(e);
  }
  updateMarkdownHoverVerbosityLevel(action, index) {
    return Promise.resolve(this._renderedHoverParts?.updateMarkdownHoverPartVerbosityLevel(action, index));
  }
};
MarkdownHoverParticipant = __decorate19([
  __param19(1, ILanguageService),
  __param19(2, IOpenerService),
  __param19(3, IConfigurationService),
  __param19(4, ILanguageFeaturesService),
  __param19(5, IKeybindingService),
  __param19(6, IHoverService),
  __param19(7, ICommandService)
], MarkdownHoverParticipant);
var RenderedMarkdownHoverPart = class {
  constructor(hoverPart, hoverElement, disposables, actionsContainer) {
    this.hoverPart = hoverPart;
    this.hoverElement = hoverElement;
    this.disposables = disposables;
    this.actionsContainer = actionsContainer;
  }
  dispose() {
    this.disposables.dispose();
  }
};
var MarkdownRenderedHoverParts = class {
  constructor(hoverParts, hoverPartsContainer, _hoverParticipant, _editor, _languageService, _openerService, _commandService, _keybindingService, _hoverService, _configurationService, _onFinishedRendering) {
    this._hoverParticipant = _hoverParticipant;
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._commandService = _commandService;
    this._keybindingService = _keybindingService;
    this._hoverService = _hoverService;
    this._configurationService = _configurationService;
    this._onFinishedRendering = _onFinishedRendering;
    this._ongoingHoverOperations = /* @__PURE__ */ new Map();
    this._disposables = new DisposableStore();
    this.renderedHoverParts = this._renderHoverParts(hoverParts, hoverPartsContainer, this._onFinishedRendering);
    this._disposables.add(toDisposable(() => {
      this.renderedHoverParts.forEach((renderedHoverPart) => {
        renderedHoverPart.dispose();
      });
      this._ongoingHoverOperations.forEach((operation) => {
        operation.tokenSource.dispose(true);
      });
    }));
  }
  _renderHoverParts(hoverParts, hoverPartsContainer, onFinishedRendering) {
    hoverParts.sort(compareBy((hover) => hover.ordinal, numberComparator));
    return hoverParts.map((hoverPart) => {
      const renderedHoverPart = this._renderHoverPart(hoverPart, onFinishedRendering);
      hoverPartsContainer.appendChild(renderedHoverPart.hoverElement);
      return renderedHoverPart;
    });
  }
  _renderHoverPart(hoverPart, onFinishedRendering) {
    const renderedMarkdownPart = this._renderMarkdownHover(hoverPart, onFinishedRendering);
    const renderedMarkdownElement = renderedMarkdownPart.hoverElement;
    const hoverSource = hoverPart.source;
    const disposables = new DisposableStore();
    disposables.add(renderedMarkdownPart);
    if (!hoverSource) {
      return new RenderedMarkdownHoverPart(hoverPart, renderedMarkdownElement, disposables);
    }
    const canIncreaseVerbosity = hoverSource.supportsVerbosityAction(HoverVerbosityAction.Increase);
    const canDecreaseVerbosity = hoverSource.supportsVerbosityAction(HoverVerbosityAction.Decrease);
    if (!canIncreaseVerbosity && !canDecreaseVerbosity) {
      return new RenderedMarkdownHoverPart(hoverPart, renderedMarkdownElement, disposables);
    }
    const actionsContainer = $3("div.verbosity-actions");
    renderedMarkdownElement.prepend(actionsContainer);
    const actionsContainerInner = $3("div.verbosity-actions-inner");
    actionsContainer.append(actionsContainerInner);
    disposables.add(this._renderHoverExpansionAction(actionsContainerInner, HoverVerbosityAction.Increase, canIncreaseVerbosity));
    disposables.add(this._renderHoverExpansionAction(actionsContainerInner, HoverVerbosityAction.Decrease, canDecreaseVerbosity));
    return new RenderedMarkdownHoverPart(hoverPart, renderedMarkdownElement, disposables, actionsContainerInner);
  }
  _renderMarkdownHover(markdownHover, onFinishedRendering) {
    const renderedMarkdownHover = renderMarkdown2(this._editor, markdownHover, this._languageService, this._openerService, onFinishedRendering);
    return renderedMarkdownHover;
  }
  _renderHoverExpansionAction(container, action, actionEnabled) {
    const store = new DisposableStore();
    const isActionIncrease = action === HoverVerbosityAction.Increase;
    const actionElement = append(container, $3(ThemeIcon.asCSSSelector(isActionIncrease ? increaseHoverVerbosityIcon : decreaseHoverVerbosityIcon)));
    actionElement.tabIndex = 0;
    const hoverDelegate = new WorkbenchHoverDelegate("mouse", void 0, { target: container, position: {
      hoverPosition: 0
      /* HoverPosition.LEFT */
    } }, this._configurationService, this._hoverService);
    store.add(this._hoverService.setupManagedHover(hoverDelegate, actionElement, labelForHoverVerbosityAction(this._keybindingService, action)));
    if (!actionEnabled) {
      actionElement.classList.add("disabled");
      return store;
    }
    actionElement.classList.add("enabled");
    const actionFunction = () => this._commandService.executeCommand(action === HoverVerbosityAction.Increase ? INCREASE_HOVER_VERBOSITY_ACTION_ID : DECREASE_HOVER_VERBOSITY_ACTION_ID, { focus: true });
    store.add(new ClickAction(actionElement, actionFunction));
    store.add(new KeyDownAction(actionElement, actionFunction, [
      3,
      10
      /* KeyCode.Space */
    ]));
    return store;
  }
  handleScroll(e) {
    this.renderedHoverParts.forEach((renderedHoverPart) => {
      const actionsContainerInner = renderedHoverPart.actionsContainer;
      if (!actionsContainerInner) {
        return;
      }
      const hoverElement = renderedHoverPart.hoverElement;
      const topOfHoverScrollPosition = e.scrollTop;
      const bottomOfHoverScrollPosition = topOfHoverScrollPosition + e.height;
      const topOfRenderedPart = hoverElement.offsetTop;
      const hoverElementHeight = hoverElement.clientHeight;
      const bottomOfRenderedPart = topOfRenderedPart + hoverElementHeight;
      const iconsHeight = 22;
      let top;
      if (bottomOfRenderedPart <= bottomOfHoverScrollPosition || topOfRenderedPart >= bottomOfHoverScrollPosition) {
        top = hoverElementHeight - iconsHeight;
      } else {
        top = bottomOfHoverScrollPosition - topOfRenderedPart - iconsHeight;
      }
      actionsContainerInner.style.top = `${top}px`;
    });
  }
  async updateMarkdownHoverPartVerbosityLevel(action, index) {
    const model = this._editor.getModel();
    if (!model) {
      return void 0;
    }
    const hoverRenderedPart = this._getRenderedHoverPartAtIndex(index);
    const hoverSource = hoverRenderedPart?.hoverPart.source;
    if (!hoverRenderedPart || !hoverSource?.supportsVerbosityAction(action)) {
      return void 0;
    }
    const newHover = await this._fetchHover(hoverSource, model, action);
    if (!newHover) {
      return void 0;
    }
    const newHoverSource = new HoverSource(newHover, hoverSource.hoverProvider, hoverSource.hoverPosition);
    const initialHoverPart = hoverRenderedPart.hoverPart;
    const newHoverPart = new MarkdownHover(this._hoverParticipant, initialHoverPart.range, newHover.contents, initialHoverPart.isBeforeContent, initialHoverPart.ordinal, newHoverSource);
    const newHoverRenderedPart = this._updateRenderedHoverPart(index, newHoverPart);
    if (!newHoverRenderedPart) {
      return void 0;
    }
    return {
      hoverPart: newHoverPart,
      hoverElement: newHoverRenderedPart.hoverElement
    };
  }
  async _fetchHover(hoverSource, model, action) {
    let verbosityDelta = action === HoverVerbosityAction.Increase ? 1 : -1;
    const provider = hoverSource.hoverProvider;
    const ongoingHoverOperation = this._ongoingHoverOperations.get(provider);
    if (ongoingHoverOperation) {
      ongoingHoverOperation.tokenSource.cancel();
      verbosityDelta += ongoingHoverOperation.verbosityDelta;
    }
    const tokenSource = new CancellationTokenSource();
    this._ongoingHoverOperations.set(provider, { verbosityDelta, tokenSource });
    const context = { verbosityRequest: { verbosityDelta, previousHover: hoverSource.hover } };
    let hover;
    try {
      hover = await Promise.resolve(provider.provideHover(model, hoverSource.hoverPosition, tokenSource.token, context));
    } catch (e) {
      onUnexpectedExternalError(e);
    }
    tokenSource.dispose();
    this._ongoingHoverOperations.delete(provider);
    return hover;
  }
  _updateRenderedHoverPart(index, hoverPart) {
    if (index >= this.renderedHoverParts.length || index < 0) {
      return void 0;
    }
    const renderedHoverPart = this._renderHoverPart(hoverPart, this._onFinishedRendering);
    const currentRenderedHoverPart = this.renderedHoverParts[index];
    const currentRenderedMarkdown = currentRenderedHoverPart.hoverElement;
    const renderedMarkdown = renderedHoverPart.hoverElement;
    const renderedChildrenElements = Array.from(renderedMarkdown.children);
    currentRenderedMarkdown.replaceChildren(...renderedChildrenElements);
    const newRenderedHoverPart = new RenderedMarkdownHoverPart(hoverPart, currentRenderedMarkdown, renderedHoverPart.disposables, renderedHoverPart.actionsContainer);
    currentRenderedHoverPart.dispose();
    this.renderedHoverParts[index] = newRenderedHoverPart;
    return newRenderedHoverPart;
  }
  _getRenderedHoverPartAtIndex(index) {
    return this.renderedHoverParts[index];
  }
  dispose() {
    this._disposables.dispose();
  }
};
function renderMarkdownHovers(context, markdownHovers, editor2, languageService, openerService) {
  markdownHovers.sort(compareBy((hover) => hover.ordinal, numberComparator));
  const renderedHoverParts = [];
  for (const markdownHover of markdownHovers) {
    const renderedHoverPart = renderMarkdown2(editor2, markdownHover, languageService, openerService, context.onContentsChanged);
    context.fragment.appendChild(renderedHoverPart.hoverElement);
    renderedHoverParts.push(renderedHoverPart);
  }
  return new RenderedHoverParts(renderedHoverParts);
}
function renderMarkdown2(editor2, markdownHover, languageService, openerService, onFinishedRendering) {
  const disposables = new DisposableStore();
  const renderedMarkdown = $3("div.hover-row");
  const renderedMarkdownContents = $3("div.hover-row-contents");
  renderedMarkdown.appendChild(renderedMarkdownContents);
  const markdownStrings = markdownHover.contents;
  for (const markdownString of markdownStrings) {
    if (isEmptyMarkdownString(markdownString)) {
      continue;
    }
    const markdownHoverElement = $3("div.markdown-hover");
    const hoverContentsElement = append(markdownHoverElement, $3("div.hover-contents"));
    const renderer = new MarkdownRenderer({ editor: editor2 }, languageService, openerService);
    const renderedContents = disposables.add(renderer.render(markdownString, {
      asyncRenderCallback: () => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        onFinishedRendering();
      }
    }));
    hoverContentsElement.appendChild(renderedContents.element);
    renderedMarkdownContents.appendChild(markdownHoverElement);
  }
  const renderedHoverPart = {
    hoverPart: markdownHover,
    hoverElement: renderedMarkdown,
    dispose() {
      disposables.dispose();
    }
  };
  return renderedHoverPart;
}
function labelForHoverVerbosityAction(keybindingService, action) {
  switch (action) {
    case HoverVerbosityAction.Increase: {
      const kb = keybindingService.lookupKeybinding(INCREASE_HOVER_VERBOSITY_ACTION_ID);
      return kb ? localize(1128, "Increase Hover Verbosity ({0})", kb.getLabel()) : localize(1129, "Increase Hover Verbosity");
    }
    case HoverVerbosityAction.Decrease: {
      const kb = keybindingService.lookupKeybinding(DECREASE_HOVER_VERBOSITY_ACTION_ID);
      return kb ? localize(1130, "Decrease Hover Verbosity ({0})", kb.getLabel()) : localize(1131, "Decrease Hover Verbosity");
    }
  }
}

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/hoverColorPicker/hoverColorPickerParticipant.js
init_async();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
init_dom();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerBody.js
init_dom();
init_color();
init_lifecycle();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerSaturationBox.js
init_dom();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
init_color();
init_event();
init_lifecycle();
var $4 = $;
var SaturationBox = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._domNode = $4(".saturation-wrap");
    append(container, this._domNode);
    this._canvas = document.createElement("canvas");
    this._canvas.className = "saturation-box";
    append(this._domNode, this._canvas);
    this.selection = $4(".saturation-selection");
    append(this._domNode, this.selection);
    this.layout();
    this._register(addDisposableListener(this._domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
    this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    this.monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this._domNode);
    if (e.target !== this.selection) {
      this.onDidChangePosition(e.offsetX, e.offsetY);
    }
    this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangePosition(event.pageX - origin.left, event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(e.target.ownerDocument, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      if (this.monitor) {
        this.monitor.stopMonitoring(true);
        this.monitor = null;
      }
    }, true);
  }
  onDidChangePosition(left, top) {
    const s = Math.max(0, Math.min(1, left / this.width));
    const v = Math.max(0, Math.min(1, 1 - top / this.height));
    this.paintSelection(s, v);
    this._onDidChange.fire({ s, v });
  }
  layout() {
    this.width = this._domNode.offsetWidth;
    this.height = this._domNode.offsetHeight;
    this._canvas.width = this.width * this.pixelRatio;
    this._canvas.height = this.height * this.pixelRatio;
    this.paint();
    const hsva = this.model.color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
  paint() {
    const hsva = this.model.color.hsva;
    const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
    const ctx = this._canvas.getContext("2d");
    const whiteGradient = ctx.createLinearGradient(0, 0, this._canvas.width, 0);
    whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
    whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    const blackGradient = ctx.createLinearGradient(0, 0, 0, this._canvas.height);
    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
    blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.rect(0, 0, this._canvas.width, this._canvas.height);
    ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
    ctx.fill();
    ctx.fillStyle = whiteGradient;
    ctx.fill();
    ctx.fillStyle = blackGradient;
    ctx.fill();
  }
  paintSelection(s, v) {
    this.selection.style.left = `${s * this.width}px`;
    this.selection.style.top = `${this.height - v * this.height}px`;
  }
  onDidChangeColor(color) {
    if (this.monitor && this.monitor.isMonitoring()) {
      return;
    }
    this.paint();
    const hsva = color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerInsertButton.js
init_dom();
init_event();
init_lifecycle();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
var InsertButton = class extends Disposable {
  constructor(container) {
    super();
    this._onClicked = this._register(new Emitter());
    this.onClicked = this._onClicked.event;
    this._button = append(container, document.createElement("button"));
    this._button.classList.add("insert-button");
    this._button.textContent = "Insert";
    this._register(addDisposableListener(this._button, EventType.CLICK, () => {
      this._onClicked.fire();
    }));
  }
  get button() {
    return this._button;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerStrip.js
init_dom();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
init_color();
init_event();
init_lifecycle();
var $5 = $;
var Strip = class extends Disposable {
  constructor(container, model, type) {
    super();
    this.model = model;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    if (type === "standalone") {
      this.domNode = append(container, $5(".standalone-strip"));
      this.overlay = append(this.domNode, $5(".standalone-overlay"));
    } else {
      this.domNode = append(container, $5(".strip"));
      this.overlay = append(this.domNode, $5(".overlay"));
    }
    this.slider = append(this.domNode, $5(".slider"));
    this.slider.style.top = `0px`;
    this._register(addDisposableListener(this.domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const value = this.getValue(this.model.color);
    this.updateSliderPosition(value);
  }
  onDidChangeColor(color) {
    const value = this.getValue(color);
    this.updateSliderPosition(value);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    const monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    this.domNode.classList.add("grabbing");
    if (e.target !== this.slider) {
      this.onDidChangeTop(e.offsetY);
    }
    monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangeTop(event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(e.target.ownerDocument, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      monitor.stopMonitoring(true);
      this.domNode.classList.remove("grabbing");
    }, true);
  }
  onDidChangeTop(top) {
    const value = Math.max(0, Math.min(1, 1 - top / this.height));
    this.updateSliderPosition(value);
    this._onDidChange.fire(value);
  }
  updateSliderPosition(value) {
    this.slider.style.top = `${(1 - value) * this.height}px`;
  }
};
var OpacityStrip = class extends Strip {
  constructor(container, model, type) {
    super(container, model, type);
    this.domNode.classList.add("opacity-strip");
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    super.onDidChangeColor(color);
    const { r, g, b } = color.rgba;
    const opaque = new Color(new RGBA(r, g, b, 1));
    const transparent2 = new Color(new RGBA(r, g, b, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent2} 100%)`;
  }
  getValue(color) {
    return color.hsva.a;
  }
};
var HueStrip = class extends Strip {
  constructor(container, model, type) {
    super(container, model, type);
    this.domNode.classList.add("hue-strip");
  }
  getValue(color) {
    return 1 - color.hsva.h / 360;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerBody.js
var $6 = $;
var ColorPickerBody = class extends Disposable {
  constructor(container, model, pixelRatio, type) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._insertButton = null;
    this._domNode = $6(".colorpicker-body");
    append(container, this._domNode);
    this._saturationBox = new SaturationBox(this._domNode, this.model, this.pixelRatio);
    this._register(this._saturationBox);
    this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this));
    this._register(this._saturationBox.onColorFlushed(this.flushColor, this));
    this._opacityStrip = new OpacityStrip(this._domNode, this.model, type);
    this._register(this._opacityStrip);
    this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this));
    this._register(this._opacityStrip.onColorFlushed(this.flushColor, this));
    this._hueStrip = new HueStrip(this._domNode, this.model, type);
    this._register(this._hueStrip);
    this._register(this._hueStrip.onDidChange(this.onDidHueChange, this));
    this._register(this._hueStrip.onColorFlushed(this.flushColor, this));
    if (type === "standalone") {
      this._insertButton = this._register(new InsertButton(this._domNode));
      this._domNode.classList.add("standalone-colorpicker");
    }
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s, v }) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
  }
  onDidOpacityChange(a) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
  }
  onDidHueChange(value) {
    const hsva = this.model.color.hsva;
    const h2 = (1 - value) * 360;
    this.model.color = new Color(new HSVA(h2 === 360 ? 0 : h2, hsva.s, hsva.v, hsva.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout();
    this._opacityStrip.layout();
    this._hueStrip.layout();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerHeader.js
init_dom();
init_color();
init_lifecycle();
init_nls();
init_colorRegistry();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerCloseButton.js
init_dom();
init_lifecycle();
init_nls();
init_event();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
init_themables();
init_codicons();
var $7 = $;
var CloseButton = class extends Disposable {
  constructor(container) {
    super();
    this._onClicked = this._register(new Emitter());
    this.onClicked = this._onClicked.event;
    this._button = document.createElement("div");
    this._button.classList.add("close-button");
    append(container, this._button);
    const innerDiv = document.createElement("div");
    innerDiv.classList.add("close-button-inner-div");
    append(this._button, innerDiv);
    const closeButton = append(innerDiv, $7(".button" + ThemeIcon.asCSSSelector(registerIcon("color-picker-close", Codicon.close, localize(881, "Icon to close the color picker")))));
    closeButton.classList.add("close-icon");
    this._register(addDisposableListener(this._button, EventType.CLICK, () => {
      this._onClicked.fire();
    }));
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParts/colorPickerHeader.js
var $8 = $;
var ColorPickerHeader = class extends Disposable {
  constructor(container, model, themeService, type) {
    super();
    this.model = model;
    this.type = type;
    this._closeButton = null;
    this._domNode = $8(".colorpicker-header");
    append(container, this._domNode);
    this._pickedColorNode = append(this._domNode, $8(".picked-color"));
    append(this._pickedColorNode, $8("span.codicon.codicon-color-mode"));
    this._pickedColorPresentation = append(this._pickedColorNode, document.createElement("span"));
    this._pickedColorPresentation.classList.add("picked-color-presentation");
    const tooltip = localize(882, "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", tooltip);
    this._originalColorNode = append(this._domNode, $8(".original-color"));
    this._originalColorNode.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
    this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
    this._register(themeService.onDidColorThemeChange((theme) => {
      this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
    }));
    this._register(addDisposableListener(this._pickedColorNode, EventType.CLICK, () => this.model.selectNextColorPresentation()));
    this._register(addDisposableListener(this._originalColorNode, EventType.CLICK, () => {
      this.model.color = this.model.originalColor;
      this.model.flushColor();
    }));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
    this._pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
    this._pickedColorNode.classList.toggle("light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
    this.onDidChangeColor(this.model.color);
    if (this.type === "standalone") {
      this._domNode.classList.add("standalone-colorpicker");
      this._closeButton = this._register(new CloseButton(this._domNode));
    }
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(color) {
    this._pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
    this._pickedColorNode.classList.toggle("light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
    this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
var $9 = $;
var ColorPickerWidget = class extends Widget {
  constructor(container, model, pixelRatio, themeService, type) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._register(PixelRatio.getInstance(getWindow(container)).onDidChange(() => this.layout()));
    this._domNode = $9(".colorpicker-widget");
    container.appendChild(this._domNode);
    this.header = this._register(new ColorPickerHeader(this._domNode, this.model, themeService, type));
    this.body = this._register(new ColorPickerBody(this._domNode, this.model, this.pixelRatio, type));
  }
  layout() {
    this.body.layout();
  }
  get domNode() {
    return this._domNode;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/hoverColorPicker/hoverColorPickerParticipant.js
init_themeService();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParticipantUtils.js
init_cancellation();
init_color();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerModel.js
init_event();
var ColorPickerModel = class {
  get color() {
    return this._color;
  }
  set color(color) {
    if (this._color.equals(color)) {
      return;
    }
    this._color = color;
    this._onDidChangeColor.fire(color);
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(colorPresentations) {
    this._colorPresentations = colorPresentations;
    if (this.presentationIndex > colorPresentations.length - 1) {
      this.presentationIndex = 0;
    }
    this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(color, availableColorPresentations, presentationIndex) {
    this.presentationIndex = presentationIndex;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._onDidChangeColor = new Emitter();
    this.onDidChangeColor = this._onDidChangeColor.event;
    this._onDidChangePresentation = new Emitter();
    this.onDidChangePresentation = this._onDidChangePresentation.event;
    this.originalColor = color;
    this._color = color;
    this._colorPresentations = availableColorPresentations;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
    this.flushColor();
    this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(color, originalText) {
    let presentationIndex = -1;
    for (let i2 = 0; i2 < this.colorPresentations.length; i2++) {
      if (originalText.toLowerCase() === this.colorPresentations[i2].label) {
        presentationIndex = i2;
        break;
      }
    }
    if (presentationIndex === -1) {
      const originalTextPrefix = originalText.split("(")[0].toLowerCase();
      for (let i2 = 0; i2 < this.colorPresentations.length; i2++) {
        if (this.colorPresentations[i2].label.toLowerCase().startsWith(originalTextPrefix)) {
          presentationIndex = i2;
          break;
        }
      }
    }
    if (presentationIndex !== -1 && presentationIndex !== this.presentationIndex) {
      this.presentationIndex = presentationIndex;
      this._onDidChangePresentation.fire(this.presentation);
    }
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerParticipantUtils.js
init_range();
async function createColorHover(editorModel, colorInfo, provider) {
  const originalText = editorModel.getValueInRange(colorInfo.range);
  const { red, green, blue, alpha } = colorInfo.color;
  const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
  const color = new Color(rgba);
  const colorPresentations = await getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
  const model = new ColorPickerModel(color, [], 0);
  model.colorPresentations = colorPresentations || [];
  model.guessColorPresentation(color, originalText);
  return {
    range: Range.lift(colorInfo.range),
    model,
    provider
  };
}
function updateEditorModel(editor2, range, model) {
  const textEdits = [];
  const edit = model.presentation.textEdit ?? { range, text: model.presentation.label, forceMoveMarkers: false };
  textEdits.push(edit);
  if (model.presentation.additionalTextEdits) {
    textEdits.push(...model.presentation.additionalTextEdits);
  }
  const replaceRange = Range.lift(edit.range);
  const trackedRange = editor2.getModel()._setTrackedRange(
    null,
    replaceRange,
    3
    /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  );
  editor2.executeEdits("colorpicker", textEdits);
  editor2.pushUndoStop();
  return editor2.getModel()._getTrackedRange(trackedRange) ?? replaceRange;
}
async function updateColorPresentations(editorModel, colorPickerModel, color, range, colorHover) {
  const colorPresentations = await getColorPresentations(editorModel, {
    range,
    color: {
      red: color.rgba.r / 255,
      green: color.rgba.g / 255,
      blue: color.rgba.b / 255,
      alpha: color.rgba.a
    }
  }, colorHover.provider, CancellationToken.None);
  colorPickerModel.colorPresentations = colorPresentations || [];
}

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/hoverColorPicker/hoverColorPickerParticipant.js
init_dom();
init_lifecycle();
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ColorHover = class _ColorHover {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
    this.forceShowAtRange = true;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
  static fromBaseColor(owner, color) {
    return new _ColorHover(owner, color.range, color.model, color.provider);
  }
};
var HoverColorPickerParticipant = class HoverColorPickerParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
    this.hoverOrdinal = 2;
  }
  computeSync(_anchor, _lineDecorations, source) {
    return [];
  }
  computeAsync(anchor, lineDecorations, source, token) {
    return AsyncIterableProducer.fromPromise(this._computeAsync(anchor, lineDecorations, source));
  }
  async _computeAsync(_anchor, lineDecorations, source) {
    if (!this._editor.hasModel()) {
      return [];
    }
    if (!this._isValidRequest(source)) {
      return [];
    }
    const colorDetector = ColorDetector.get(this._editor);
    if (!colorDetector) {
      return [];
    }
    for (const d of lineDecorations) {
      if (!colorDetector.isColorDecoration(d)) {
        continue;
      }
      const colorData = colorDetector.getColorData(d.range.getStartPosition());
      if (colorData) {
        const colorHover = ColorHover.fromBaseColor(this, await createColorHover(this._editor.getModel(), colorData.colorInfo, colorData.provider));
        return [colorHover];
      }
    }
    return [];
  }
  _isValidRequest(source) {
    const decoratorActivatedOn = this._editor.getOption(
      168
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    switch (source) {
      case 0:
        return decoratorActivatedOn === "hover" || decoratorActivatedOn === "clickAndHover";
      case 1:
        return decoratorActivatedOn === "click" || decoratorActivatedOn === "clickAndHover";
      case 2:
        return true;
    }
  }
  renderHoverParts(context, hoverParts) {
    const editor2 = this._editor;
    if (hoverParts.length === 0 || !editor2.hasModel()) {
      return new RenderedHoverParts([]);
    }
    const minimumHeight = editor2.getOption(
      75
      /* EditorOption.lineHeight */
    ) + 8;
    context.setMinimumDimensions(new Dimension(302, minimumHeight));
    const disposables = new DisposableStore();
    const colorHover = hoverParts[0];
    const editorModel = editor2.getModel();
    const model = colorHover.model;
    this._colorPicker = disposables.add(new ColorPickerWidget(
      context.fragment,
      model,
      editor2.getOption(
        163
        /* EditorOption.pixelRatio */
      ),
      this._themeService,
      "hover"
      /* ColorPickerWidgetType.Hover */
    ));
    let editorUpdatedByColorPicker = false;
    let range = new Range(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
    disposables.add(model.onColorFlushed(async (color) => {
      await updateColorPresentations(editorModel, model, color, range, colorHover);
      editorUpdatedByColorPicker = true;
      range = updateEditorModel(editor2, range, model);
    }));
    disposables.add(model.onDidChangeColor((color) => {
      updateColorPresentations(editorModel, model, color, range, colorHover);
    }));
    disposables.add(editor2.onDidChangeModelContent((e) => {
      if (editorUpdatedByColorPicker) {
        editorUpdatedByColorPicker = false;
      } else {
        context.hide();
        editor2.focus();
      }
    }));
    const renderedHoverPart = {
      hoverPart: ColorHover.fromBaseColor(this, colorHover),
      hoverElement: this._colorPicker.domNode,
      dispose() {
        disposables.dispose();
      }
    };
    return new RenderedHoverParts([renderedHoverPart]);
  }
  handleResize() {
    this._colorPicker?.layout();
  }
  handleContentsChanged() {
    this._colorPicker?.layout();
  }
  handleHide() {
    this._colorPicker?.dispose();
    this._colorPicker = void 0;
  }
  isColorPickerVisible() {
    return !!this._colorPicker;
  }
};
HoverColorPickerParticipant = __decorate20([
  __param20(1, IThemeService)
], HoverColorPickerParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js
init_async();
init_htmlContent();
init_position();
init_textModel();
init_language();
init_resolverService();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
init_dom();
init_arrays();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_map();
init_types();
init_uri();
init_range();
init_languages();
init_model2();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();
init_resolverService();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js
init_event();
init_lifecycle();
init_platform();
function hasModifier(e, modifier) {
  return !!e[modifier];
}
var ClickLinkMouseEvent = class {
  constructor(source, opts) {
    this.target = source.target;
    this.isLeftClick = source.event.leftButton;
    this.isMiddleClick = source.event.middleButton;
    this.isRightClick = source.event.rightButton;
    this.mouseMiddleClickAction = opts.mouseMiddleClickAction;
    this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
    if (this.isMiddleClick && opts.mouseMiddleClickAction === "ctrlLeftClick") {
      this.isMiddleClick = false;
      this.isLeftClick = true;
      this.hasTriggerModifier = true;
    }
    this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
    this.isNoneOrSingleMouseDown = source.event.detail <= 1;
  }
};
var ClickLinkKeyboardEvent = class {
  constructor(source, opts) {
    this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
    this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
    this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
  }
};
var ClickLinkOptions = class {
  constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier, mouseMiddleClickAction) {
    this.mouseMiddleClickAction = mouseMiddleClickAction;
    this.triggerKey = triggerKey;
    this.triggerModifier = triggerModifier;
    this.triggerSideBySideKey = triggerSideBySideKey;
    this.triggerSideBySideModifier = triggerSideBySideModifier;
  }
  equals(other) {
    return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier && this.mouseMiddleClickAction === other.mouseMiddleClickAction;
  }
};
function createOptions(multiCursorModifier, mouseMiddleClickAction) {
  if (multiCursorModifier === "altKey") {
    if (isMacintosh) {
      return new ClickLinkOptions(57, "metaKey", 6, "altKey", mouseMiddleClickAction);
    }
    return new ClickLinkOptions(5, "ctrlKey", 6, "altKey", mouseMiddleClickAction);
  }
  if (isMacintosh) {
    return new ClickLinkOptions(6, "altKey", 57, "metaKey", mouseMiddleClickAction);
  }
  return new ClickLinkOptions(6, "altKey", 5, "ctrlKey", mouseMiddleClickAction);
}
var ClickLinkGesture = class extends Disposable {
  constructor(editor2, opts) {
    super();
    this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter());
    this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
    this._onExecute = this._register(new Emitter());
    this.onExecute = this._onExecute.event;
    this._onCancel = this._register(new Emitter());
    this.onCancel = this._onCancel.event;
    this._editor = editor2;
    this._extractLineNumberFromMouseEvent = opts?.extractLineNumberFromMouseEvent ?? ((e) => e.target.position ? e.target.position.lineNumber : 0);
    this._opts = createOptions(this._editor.getOption(
      86
      /* EditorOption.multiCursorModifier */
    ), this._editor.getOption(
      87
      /* EditorOption.mouseMiddleClickAction */
    ));
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._lineNumberOnMouseDown = 0;
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        86
        /* EditorOption.multiCursorModifier */
      ) || e.hasChanged(
        87
        /* EditorOption.mouseMiddleClickAction */
      )) {
        const newOpts = createOptions(this._editor.getOption(
          86
          /* EditorOption.multiCursorModifier */
        ), this._editor.getOption(
          87
          /* EditorOption.mouseMiddleClickAction */
        ));
        if (this._opts.equals(newOpts)) {
          return;
        }
        this._opts = newOpts;
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._lineNumberOnMouseDown = 0;
        this._onCancel.fire();
      }
    }));
    this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onMouseDrag(() => this._resetHandler()));
    this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
    this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
    this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || e.scrollLeftChanged) {
        this._resetHandler();
      }
    }));
  }
  _onDidChangeCursorSelection(e) {
    if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
      this._resetHandler();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    this._lastMouseMoveEvent = mouseEvent;
    this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
  }
  _onEditorMouseDown(mouseEvent) {
    this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
    this._lineNumberOnMouseDown = this._extractLineNumberFromMouseEvent(mouseEvent);
  }
  _onEditorMouseUp(mouseEvent) {
    const currentLineNumber = this._extractLineNumberFromMouseEvent(mouseEvent);
    const lineNumbersCorrect = !!this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber;
    if (lineNumbersCorrect && (this._hasTriggerKeyOnMouseDown || mouseEvent.isMiddleClick && mouseEvent.mouseMiddleClickAction === "openLink")) {
      this._onExecute.fire(mouseEvent);
    }
  }
  _onEditorKeyDown(e) {
    if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) {
      this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
    } else if (e.hasTriggerModifier) {
      this._onCancel.fire();
    }
  }
  _onEditorKeyUp(e) {
    if (e.keyCodeIsTriggerKey) {
      this._onCancel.fire();
    }
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._onCancel.fire();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHints.js
init_errors();
init_lifecycle();
init_position();
init_range();
init_htmlContent();
var InlayHintAnchor = class {
  constructor(range, direction) {
    this.range = range;
    this.direction = direction;
  }
};
var InlayHintItem = class _InlayHintItem {
  constructor(hint, anchor, provider) {
    this.hint = hint;
    this.anchor = anchor;
    this.provider = provider;
    this._isResolved = false;
  }
  with(delta) {
    const result = new _InlayHintItem(this.hint, delta.anchor, this.provider);
    result._isResolved = this._isResolved;
    result._currentResolve = this._currentResolve;
    return result;
  }
  async resolve(token) {
    if (typeof this.provider.resolveInlayHint !== "function") {
      return;
    }
    if (this._currentResolve) {
      await this._currentResolve;
      if (token.isCancellationRequested) {
        return;
      }
      return this.resolve(token);
    }
    if (!this._isResolved) {
      this._currentResolve = this._doResolve(token).finally(() => this._currentResolve = void 0);
    }
    await this._currentResolve;
  }
  async _doResolve(token) {
    try {
      const newHint = await Promise.resolve(this.provider.resolveInlayHint(this.hint, token));
      this.hint.tooltip = newHint?.tooltip ?? this.hint.tooltip;
      this.hint.label = newHint?.label ?? this.hint.label;
      this.hint.textEdits = newHint?.textEdits ?? this.hint.textEdits;
      this._isResolved = true;
    } catch (err) {
      onUnexpectedExternalError(err);
      this._isResolved = false;
    }
  }
};
var _InlayHintsFragments = class _InlayHintsFragments {
  static async create(registry, model, ranges, token) {
    const data = [];
    const promises = registry.ordered(model).reverse().map((provider) => ranges.map(async (range) => {
      try {
        const result = await provider.provideInlayHints(model, range, token);
        if (result?.hints.length || provider.onDidChangeInlayHints) {
          data.push([result ?? _InlayHintsFragments._emptyInlayHintList, provider]);
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    await Promise.all(promises.flat());
    if (token.isCancellationRequested || model.isDisposed()) {
      throw new CancellationError();
    }
    return new _InlayHintsFragments(ranges, data, model);
  }
  constructor(ranges, data, model) {
    this._disposables = new DisposableStore();
    this.ranges = ranges;
    this.provider = /* @__PURE__ */ new Set();
    const items = [];
    for (const [list, provider] of data) {
      this._disposables.add(list);
      this.provider.add(provider);
      for (const hint of list.hints) {
        const position = model.validatePosition(hint.position);
        let direction = "before";
        const wordRange = _InlayHintsFragments._getRangeAtPosition(model, position);
        let range;
        if (wordRange.getStartPosition().isBefore(position)) {
          range = Range.fromPositions(wordRange.getStartPosition(), position);
          direction = "after";
        } else {
          range = Range.fromPositions(position, wordRange.getEndPosition());
          direction = "before";
        }
        items.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));
      }
    }
    this.items = items.sort((a, b) => Position.compare(a.hint.position, b.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(model, position) {
    const line = position.lineNumber;
    const word = model.getWordAtPosition(position);
    if (word) {
      return new Range(line, word.startColumn, line, word.endColumn);
    }
    model.tokenization.tokenizeIfCheap(line);
    const tokens = model.tokenization.getLineTokens(line);
    const offset = position.column - 1;
    const idx = tokens.findTokenIndexAtOffset(offset);
    let start = tokens.getStartOffset(idx);
    let end = tokens.getEndOffset(idx);
    if (end - start === 1) {
      if (start === offset && idx > 1) {
        start = tokens.getStartOffset(idx - 1);
        end = tokens.getEndOffset(idx - 1);
      } else if (end === offset && idx < tokens.getCount() - 1) {
        start = tokens.getStartOffset(idx + 1);
        end = tokens.getEndOffset(idx + 1);
      }
    }
    return new Range(line, start + 1, line, end + 1);
  }
};
_InlayHintsFragments._emptyInlayHintList = Object.freeze({ dispose() {
}, hints: [] });
var InlayHintsFragments = _InlayHintsFragments;
function asCommandLink(command) {
  return createCommandUri(command.id, ...command.arguments ?? []).toString();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js
init_dom();
init_actions();
init_cancellation();
init_uuid();
init_range();
init_resolverService();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_async();
init_keyCodes();
init_types();
init_uri();
init_editorState();
init_editorExtensions();
init_codeEditorService();

// node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditor/embeddedCodeEditorWidget.js
init_objects();
init_codeEditorService();
init_languageConfigurationRegistry();
init_languageFeatures();
init_commands();
init_contextkey();
init_instantiation();
init_themeService();
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget2 extends CodeEditorWidget {
  constructor(domElement, options, codeEditorWidgetOptions, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
    super(domElement, { ...parentEditor.getRawOptions(), overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }, codeEditorWidgetOptions, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
    this._parentEditor = parentEditor;
    this._overwriteOptions = options;
    super.updateOptions(this._overwriteOptions);
    this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions());
    super.updateOptions(this._overwriteOptions);
  }
  updateOptions(newOptions) {
    mixin(this._overwriteOptions, newOptions, true);
    super.updateOptions(this._overwriteOptions);
  }
};
EmbeddedCodeEditorWidget = __decorate21([
  __param21(4, IInstantiationService),
  __param21(5, ICodeEditorService),
  __param21(6, ICommandService),
  __param21(7, IContextKeyService),
  __param21(8, IThemeService),
  __param21(9, INotificationService),
  __param21(10, IAccessibilityService),
  __param21(11, ILanguageConfigurationService),
  __param21(12, ILanguageFeaturesService)
], EmbeddedCodeEditorWidget);
function getOuterEditor(accessor) {
  const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (editor2 instanceof EmbeddedCodeEditorWidget) {
    return editor2.getParentEditor();
  }
  return editor2;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_position();
init_range();
init_editorContextKeys();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
init_async();
init_errors();
init_keyCodes();
init_lifecycle();
init_codeEditorService();
init_position();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/peekView.js
init_dom();
init_actions();
init_codicons();
init_themables();
init_color();
init_event();
init_objects();
init_editorExtensions();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/media/peekViewWidget.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/browser/zoneWidget.js
init_color();
init_lifecycle();
init_objects();
init_range();
init_textModel();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/browser/zoneWidget.css";
var defaultColor = new Color(new RGBA(0, 122, 204));
var defaultOptions = {
  showArrow: true,
  showFrame: true,
  className: "",
  frameColor: defaultColor,
  arrowColor: defaultColor,
  keepEditorSelection: false
};
var WIDGET_ID = "vs.editor.contrib.zoneWidget";
var ViewZoneDelegate = class {
  constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight, showInHiddenAreas, ordinal) {
    this.id = "";
    this.domNode = domNode;
    this.afterLineNumber = afterLineNumber;
    this.afterColumn = afterColumn;
    this.heightInLines = heightInLines;
    this.showInHiddenAreas = showInHiddenAreas;
    this.ordinal = ordinal;
    this._onDomNodeTop = onDomNodeTop;
    this._onComputedHeight = onComputedHeight;
  }
  onDomNodeTop(top) {
    this._onDomNodeTop(top);
  }
  onComputedHeight(height) {
    this._onComputedHeight(height);
  }
};
var OverlayWidgetDelegate = class {
  constructor(id, domNode) {
    this._id = id;
    this._domNode = domNode;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
};
var _Arrow = class _Arrow {
  constructor(_editor) {
    this._editor = _editor;
    this._ruleName = _Arrow._IdGenerator.nextId();
    this._color = null;
    this._height = -1;
    this._decorations = this._editor.createDecorationsCollection();
  }
  dispose() {
    this.hide();
    removeCSSRulesContainingSelector(this._ruleName);
  }
  set color(value) {
    if (this._color !== value) {
      this._color = value;
      this._updateStyle();
    }
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this._updateStyle();
    }
  }
  _updateStyle() {
    removeCSSRulesContainingSelector(this._ruleName);
    createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px !important; margin-left: -${this._height}px; `);
  }
  show(where) {
    if (where.column === 1) {
      where = { lineNumber: where.lineNumber, column: 2 };
    }
    this._decorations.set([{
      range: Range.fromPositions(where),
      options: {
        description: "zone-widget-arrow",
        className: this._ruleName,
        stickiness: 1
        /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
      }
    }]);
  }
  hide() {
    this._decorations.clear();
  }
};
_Arrow._IdGenerator = new IdGenerator(".arrow-decoration-");
var Arrow = _Arrow;
var ZoneWidget = class {
  constructor(editor2, options = {}) {
    this._arrow = null;
    this._overlayWidget = null;
    this._resizeSash = null;
    this._isSashResizeHeight = false;
    this._viewZone = null;
    this._disposables = new DisposableStore();
    this.container = null;
    this._isShowing = false;
    this.editor = editor2;
    this._positionMarkerId = this.editor.createDecorationsCollection();
    this.options = deepClone(options);
    mixin(this.options, defaultOptions, false);
    this.domNode = document.createElement("div");
    if (!this.options.isAccessible) {
      this.domNode.setAttribute("aria-hidden", "true");
      this.domNode.setAttribute("role", "presentation");
    }
    this._disposables.add(this.editor.onDidLayoutChange((info) => {
      const width = this._getWidth(info);
      this.domNode.style.width = width + "px";
      this.domNode.style.left = this._getLeft(info) + "px";
      this._onWidth(width);
    }));
  }
  dispose() {
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
        this._viewZone = null;
      });
    }
    this._positionMarkerId.clear();
    this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget");
    if (this.options.className) {
      this.domNode.classList.add(this.options.className);
    }
    this.container = document.createElement("div");
    this.container.classList.add("zone-widget-container");
    this.domNode.appendChild(this.container);
    if (this.options.showArrow) {
      this._arrow = new Arrow(this.editor);
      this._disposables.add(this._arrow);
    }
    this._fillContainer(this.container);
    this._initSash();
    this._applyStyles();
  }
  style(styles) {
    if (styles.frameColor) {
      this.options.frameColor = styles.frameColor;
    }
    if (styles.arrowColor) {
      this.options.arrowColor = styles.arrowColor;
    }
    this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      const frameColor = this.options.frameColor.toString();
      this.container.style.borderTopColor = frameColor;
      this.container.style.borderBottomColor = frameColor;
    }
    if (this._arrow && this.options.arrowColor) {
      const arrowColor = this.options.arrowColor.toString();
      this._arrow.color = arrowColor;
    }
  }
  _getWidth(info) {
    return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
  }
  _getLeft(info) {
    if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {
      return info.minimap.minimapWidth;
    }
    return 0;
  }
  _onViewZoneTop(top) {
    this.domNode.style.top = top + "px";
  }
  _onViewZoneHeight(height) {
    this.domNode.style.height = `${height}px`;
    if (this.container) {
      const containerHeight = height - this._decoratingElementsHeight();
      this.container.style.height = `${containerHeight}px`;
      const layoutInfo = this.editor.getLayoutInfo();
      this._doLayout(containerHeight, this._getWidth(layoutInfo));
    }
    this._resizeSash?.layout();
  }
  get position() {
    const range = this._positionMarkerId.getRange(0);
    if (!range) {
      return void 0;
    }
    return range.getStartPosition();
  }
  show(rangeOrPos, heightInLines) {
    const range = Range.isIRange(rangeOrPos) ? Range.lift(rangeOrPos) : Range.fromPositions(rangeOrPos);
    this._isShowing = true;
    this._showImpl(range, heightInLines);
    this._isShowing = false;
    this._positionMarkerId.set([{ range, options: ModelDecorationOptions.EMPTY }]);
  }
  hide() {
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
      });
      this._viewZone = null;
    }
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    this._arrow?.hide();
    this._positionMarkerId.clear();
    this._isSashResizeHeight = false;
  }
  _decoratingElementsHeight() {
    const lineHeight = this.editor.getOption(
      75
      /* EditorOption.lineHeight */
    );
    let result = 0;
    if (this.options.showArrow) {
      const arrowHeight = Math.round(lineHeight / 3);
      result += 2 * arrowHeight;
    }
    if (this.options.showFrame) {
      const frameThickness = this.options.frameWidth ?? Math.round(lineHeight / 9);
      result += 2 * frameThickness;
    }
    return result;
  }
  /** Gets the maximum widget height in lines. */
  _getMaximumHeightInLines() {
    return Math.max(12, this.editor.getLayoutInfo().height / this.editor.getOption(
      75
      /* EditorOption.lineHeight */
    ) * 0.8);
  }
  _showImpl(where, heightInLines) {
    const position = where.getStartPosition();
    const layoutInfo = this.editor.getLayoutInfo();
    const width = this._getWidth(layoutInfo);
    this.domNode.style.width = `${width}px`;
    this.domNode.style.left = this._getLeft(layoutInfo) + "px";
    const viewZoneDomNode = document.createElement("div");
    viewZoneDomNode.style.overflow = "hidden";
    const lineHeight = this.editor.getOption(
      75
      /* EditorOption.lineHeight */
    );
    const maxHeightInLines = this._getMaximumHeightInLines();
    if (maxHeightInLines !== void 0) {
      heightInLines = Math.min(heightInLines, maxHeightInLines);
    }
    let arrowHeight = 0;
    let frameThickness = 0;
    if (this._arrow && this.options.showArrow) {
      arrowHeight = Math.round(lineHeight / 3);
      this._arrow.height = arrowHeight;
      this._arrow.show(position);
    }
    if (this.options.showFrame) {
      frameThickness = Math.round(lineHeight / 9);
    }
    this.editor.changeViewZones((accessor) => {
      if (this._viewZone) {
        accessor.removeZone(this._viewZone.id);
      }
      if (this._overlayWidget) {
        this.editor.removeOverlayWidget(this._overlayWidget);
        this._overlayWidget = null;
      }
      this.domNode.style.top = "-1000px";
      this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height), this.options.showInHiddenAreas, this.options.ordinal);
      this._viewZone.id = accessor.addZone(this._viewZone);
      this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);
      this.editor.addOverlayWidget(this._overlayWidget);
    });
    this._updateSashEnablement();
    if (this.container && this.options.showFrame) {
      const width2 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
      this.container.style.borderTopWidth = width2 + "px";
      this.container.style.borderBottomWidth = width2 + "px";
    }
    const containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
    if (this.container) {
      this.container.style.top = arrowHeight + "px";
      this.container.style.height = containerHeight + "px";
      this.container.style.overflow = "hidden";
    }
    this._doLayout(containerHeight, width);
    if (!this.options.keepEditorSelection) {
      this.editor.setSelection(where);
    }
    const model = this.editor.getModel();
    if (model) {
      const range = model.validateRange(new Range(where.startLineNumber, 1, where.endLineNumber + 1, 1));
      this.revealRange(range, range.startLineNumber === model.getLineCount());
    }
  }
  revealRange(range, isLastLine) {
    if (isLastLine) {
      this.editor.revealLineNearTop(
        range.endLineNumber,
        0
        /* ScrollType.Smooth */
      );
    } else {
      this.editor.revealRange(
        range,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  setCssClass(className, classToReplace) {
    if (!this.container) {
      return;
    }
    if (classToReplace) {
      this.container.classList.remove(classToReplace);
    }
    this.container.classList.add(className);
  }
  _onWidth(widthInPixel) {
  }
  _doLayout(heightInPixel, widthInPixel) {
  }
  _relayout(_newHeightInLines, useMax) {
    const maxHeightInLines = this._getMaximumHeightInLines();
    const newHeightInLines = useMax && maxHeightInLines !== void 0 ? Math.min(maxHeightInLines, _newHeightInLines) : _newHeightInLines;
    if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          this._viewZone.heightInLines = newHeightInLines;
          accessor.layoutZone(this._viewZone.id);
        }
      });
      this._updateSashEnablement();
    }
  }
  // --- sash
  _initSash() {
    if (this._resizeSash) {
      return;
    }
    this._resizeSash = this._disposables.add(new Sash(this.domNode, this, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    }));
    if (!this.options.isResizeable) {
      this._resizeSash.state = 0;
    }
    let data;
    this._disposables.add(this._resizeSash.onDidStart((e) => {
      if (this._viewZone) {
        data = {
          startY: e.startY,
          heightInLines: this._viewZone.heightInLines,
          ...this._getResizeBounds()
        };
      }
    }));
    this._disposables.add(this._resizeSash.onDidEnd(() => {
      data = void 0;
    }));
    this._disposables.add(this._resizeSash.onDidChange((evt) => {
      if (data) {
        const lineDelta = (evt.currentY - data.startY) / this.editor.getOption(
          75
          /* EditorOption.lineHeight */
        );
        const roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
        const newHeightInLines = data.heightInLines + roundedLineDelta;
        if (newHeightInLines > data.minLines && newHeightInLines < data.maxLines) {
          this._isSashResizeHeight = true;
          this._relayout(newHeightInLines);
        }
      }
    }));
  }
  _updateSashEnablement() {
    if (this._resizeSash) {
      const { minLines, maxLines } = this._getResizeBounds();
      this._resizeSash.state = minLines === maxLines ? 0 : 3;
    }
  }
  _getResizeBounds() {
    return { minLines: 5, maxLines: 35 };
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const layoutInfo = this.editor.getLayoutInfo();
    return layoutInfo.width - layoutInfo.minimap.minimapWidth;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/peekView.js
init_nls();
init_contextkey();
init_extensions();
init_instantiation();
init_colorRegistry();
init_observableCodeEditor();
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IPeekViewService = createDecorator("IPeekViewService");
registerSingleton(
  IPeekViewService,
  class {
    constructor() {
      this._widgets = /* @__PURE__ */ new Map();
    }
    addExclusiveWidget(editor2, widget) {
      const existing = this._widgets.get(editor2);
      if (existing) {
        existing.listener.dispose();
        existing.widget.dispose();
      }
      const remove = () => {
        const data = this._widgets.get(editor2);
        if (data && data.widget === widget) {
          data.listener.dispose();
          this._widgets.delete(editor2);
        }
      };
      this._widgets.set(editor2, { widget, listener: widget.onDidClose(remove) });
    }
  },
  1
  /* InstantiationType.Delayed */
);
var PeekContext;
(function(PeekContext2) {
  PeekContext2.inPeekEditor = new RawContextKey("inReferenceSearchEditor", true, localize(1306, "Whether the current code editor is embedded inside peek"));
  PeekContext2.notInPeekEditor = PeekContext2.inPeekEditor.toNegated();
})(PeekContext || (PeekContext = {}));
var _a12;
var PeekContextController = (_a12 = class {
  constructor(editor2, contextKeyService) {
    if (editor2 instanceof EmbeddedCodeEditorWidget) {
      PeekContext.inPeekEditor.bindTo(contextKeyService);
    }
  }
  dispose() {
  }
}, _a12.ID = "editor.contrib.referenceController", _a12);
PeekContextController = __decorate22([
  __param22(1, IContextKeyService)
], PeekContextController);
registerEditorContribution(
  PeekContextController.ID,
  PeekContextController,
  0
  /* EditorContributionInstantiation.Eager */
);
var defaultOptions2 = {
  headerBackgroundColor: Color.white,
  primaryHeadingColor: Color.fromHex("#333333"),
  secondaryHeadingColor: Color.fromHex("#6c6c6cb3")
};
var PeekViewWidget = class PeekViewWidget2 extends ZoneWidget {
  constructor(editor2, options, instantiationService) {
    super(editor2, options);
    this.instantiationService = instantiationService;
    this._onDidClose = new Emitter();
    this.onDidClose = this._onDidClose.event;
    mixin(this.options, defaultOptions2, false);
    const e = observableCodeEditor(this.editor);
    e.openedPeekWidgets.set(e.openedPeekWidgets.get() + 1, void 0);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      super.dispose();
      this._onDidClose.fire(this);
      const e = observableCodeEditor(this.editor);
      e.openedPeekWidgets.set(e.openedPeekWidgets.get() - 1, void 0);
    }
  }
  style(styles) {
    const options = this.options;
    if (styles.headerBackgroundColor) {
      options.headerBackgroundColor = styles.headerBackgroundColor;
    }
    if (styles.primaryHeadingColor) {
      options.primaryHeadingColor = styles.primaryHeadingColor;
    }
    if (styles.secondaryHeadingColor) {
      options.secondaryHeadingColor = styles.secondaryHeadingColor;
    }
    super.style(styles);
  }
  _applyStyles() {
    super._applyStyles();
    const options = this.options;
    if (this._headElement && options.headerBackgroundColor) {
      this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
    }
    if (this._primaryHeading && options.primaryHeadingColor) {
      this._primaryHeading.style.color = options.primaryHeadingColor.toString();
    }
    if (this._secondaryHeading && options.secondaryHeadingColor) {
      this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
    }
    if (this._bodyElement && options.frameColor) {
      this._bodyElement.style.borderColor = options.frameColor.toString();
    }
  }
  _fillContainer(container) {
    this.setCssClass("peekview-widget");
    this._headElement = $(".head");
    this._bodyElement = $(".body");
    this._fillHead(this._headElement);
    this._fillBody(this._bodyElement);
    container.appendChild(this._headElement);
    container.appendChild(this._bodyElement);
  }
  _fillHead(container, noCloseAction) {
    this._titleElement = $(".peekview-title");
    if (this.options.supportOnTitleClick) {
      this._titleElement.classList.add("clickable");
      addStandardDisposableListener(this._titleElement, "click", (event) => this._onTitleClick(event));
    }
    append(this._headElement, this._titleElement);
    this._fillTitleIcon(this._titleElement);
    this._primaryHeading = $("span.filename");
    this._secondaryHeading = $("span.dirname");
    this._metaHeading = $("span.meta");
    append(this._titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const actionsContainer = $(".peekview-actions");
    append(this._headElement, actionsContainer);
    const actionBarOptions = this._getActionBarOptions();
    this._actionbarWidget = new ActionBar(actionsContainer, actionBarOptions);
    this._disposables.add(this._actionbarWidget);
    if (!noCloseAction) {
      this._actionbarWidget.push(this._disposables.add(new Action("peekview.close", localize(1307, "Close"), ThemeIcon.asClassName(Codicon.close), true, () => {
        this.dispose();
        return Promise.resolve();
      })), { label: false, icon: true });
    }
  }
  _fillTitleIcon(container) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: createActionViewItem.bind(void 0, this.instantiationService),
      orientation: 0
      /* ActionsOrientation.HORIZONTAL */
    };
  }
  _onTitleClick(event) {
  }
  setTitle(primaryHeading, secondaryHeading) {
    if (this._primaryHeading && this._secondaryHeading) {
      this._primaryHeading.innerText = primaryHeading;
      this._primaryHeading.setAttribute("title", primaryHeading);
      if (secondaryHeading) {
        this._secondaryHeading.innerText = secondaryHeading;
      } else {
        clearNode(this._secondaryHeading);
      }
    }
  }
  setMetaTitle(value) {
    if (this._metaHeading) {
      if (value) {
        this._metaHeading.innerText = value;
        show(this._metaHeading);
      } else {
        hide(this._metaHeading);
      }
    }
  }
  _doLayout(heightInPixel, widthInPixel) {
    if (!this._isShowing && heightInPixel < 0) {
      this.dispose();
      return;
    }
    const headHeight = Math.ceil(this.editor.getOption(
      75
      /* EditorOption.lineHeight */
    ) * 1.2);
    const bodyHeight = Math.round(heightInPixel - (headHeight + 1));
    this._doLayoutHead(headHeight, widthInPixel);
    this._doLayoutBody(bodyHeight, widthInPixel);
  }
  _doLayoutHead(heightInPixel, widthInPixel) {
    if (this._headElement) {
      this._headElement.style.height = `${heightInPixel}px`;
      this._headElement.style.lineHeight = this._headElement.style.height;
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    if (this._bodyElement) {
      this._bodyElement.style.height = `${heightInPixel}px`;
    }
  }
};
PeekViewWidget = __decorate22([
  __param22(2, IInstantiationService)
], PeekViewWidget);
var peekViewTitleBackground = registerColor("peekViewTitle.background", { dark: "#252526", light: "#F3F3F3", hcDark: Color.black, hcLight: Color.white }, localize(1308, "Background color of the peek view title area."));
var peekViewTitleForeground = registerColor("peekViewTitleLabel.foreground", { dark: Color.white, light: Color.black, hcDark: Color.white, hcLight: editorForeground }, localize(1309, "Color of the peek view title."));
var peekViewTitleInfoForeground = registerColor("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hcDark: "#FFFFFF99", hcLight: "#292929" }, localize(1310, "Color of the peek view title info."));
var peekViewBorder = registerColor("peekView.border", { dark: editorInfoForeground, light: editorInfoForeground, hcDark: contrastBorder, hcLight: contrastBorder }, localize(1311, "Color of the peek view borders and arrow."));
var peekViewResultsBackground = registerColor("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hcDark: Color.black, hcLight: Color.white }, localize(1312, "Background color of the peek view result list."));
var peekViewResultsMatchForeground = registerColor("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hcDark: Color.white, hcLight: editorForeground }, localize(1313, "Foreground color for line nodes in the peek view result list."));
var peekViewResultsFileForeground = registerColor("peekViewResult.fileForeground", { dark: Color.white, light: "#1E1E1E", hcDark: Color.white, hcLight: editorForeground }, localize(1314, "Foreground color for file nodes in the peek view result list."));
var peekViewResultsSelectionBackground = registerColor("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hcDark: null, hcLight: null }, localize(1315, "Background color of the selected entry in the peek view result list."));
var peekViewResultsSelectionForeground = registerColor("peekViewResult.selectionForeground", { dark: Color.white, light: "#6C6C6C", hcDark: Color.white, hcLight: editorForeground }, localize(1316, "Foreground color of the selected entry in the peek view result list."));
var peekViewEditorBackground = registerColor("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hcDark: Color.black, hcLight: Color.white }, localize(1317, "Background color of the peek view editor."));
var peekViewEditorGutterBackground = registerColor("peekViewEditorGutter.background", peekViewEditorBackground, localize(1318, "Background color of the gutter in the peek view editor."));
var peekViewEditorStickyScrollBackground = registerColor("peekViewEditorStickyScroll.background", peekViewEditorBackground, localize(1319, "Background color of sticky scroll in the peek view editor."));
var peekViewEditorStickyScrollGutterBackground = registerColor("peekViewEditorStickyScrollGutter.background", peekViewEditorBackground, localize(1320, "Background color of the gutter part of sticky scroll in the peek view editor."));
var peekViewResultsMatchHighlight = registerColor("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hcDark: null, hcLight: null }, localize(1321, "Match highlight color in the peek view result list."));
var peekViewEditorMatchHighlight = registerColor("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hcDark: null, hcLight: null }, localize(1322, "Match highlight color in the peek view editor."));
var peekViewEditorMatchHighlightBorder = registerColor("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize(1323, "Match highlight border in the peek view editor."));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
init_nls();
init_commands();
init_configuration();
init_contextkey();
init_instantiation();
init_keybindingsRegistry();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/referencesModel.js
init_errors();
init_event();
init_lifecycle();
init_map();
init_resources();
init_strings();
init_range();
init_nls();
var OneReference = class {
  constructor(isProviderFirst, parent, link, _rangeCallback) {
    this.isProviderFirst = isProviderFirst;
    this.parent = parent;
    this.link = link;
    this._rangeCallback = _rangeCallback;
    this.id = defaultGenerator.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    return this._range ?? this.link.targetSelectionRange ?? this.link.range;
  }
  set range(value) {
    this._range = value;
    this._rangeCallback(this);
  }
  get ariaMessage() {
    const preview = this.parent.getPreview(this)?.preview(this.range);
    if (!preview) {
      return localize(1082, "in {0} on line {1} at column {2}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn);
    } else {
      return localize(1083, "{0} in {1} on line {2} at column {3}", preview.value, basename2(this.uri), this.range.startLineNumber, this.range.startColumn);
    }
  }
};
var FilePreview = class {
  constructor(_modelReference) {
    this._modelReference = _modelReference;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(range, n2 = 8) {
    const model = this._modelReference.object.textEditorModel;
    if (!model) {
      return void 0;
    }
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n2 });
    const beforeRange = new Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
    const afterRange = new Range(
      endLineNumber,
      endColumn,
      endLineNumber,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
    const inside = model.getValueInRange(range);
    const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
    return {
      value: before + inside + after,
      highlight: { start: before.length, end: before.length + inside.length }
    };
  }
};
var FileReferences = class {
  constructor(parent, uri) {
    this.parent = parent;
    this.uri = uri;
    this.children = [];
    this._previews = new ResourceMap();
  }
  dispose() {
    dispose(this._previews.values());
    this._previews.clear();
  }
  getPreview(child) {
    return this._previews.get(child.uri);
  }
  get ariaMessage() {
    const len = this.children.length;
    if (len === 1) {
      return localize(1084, "1 symbol in {0}, full path {1}", basename2(this.uri), this.uri.fsPath);
    } else {
      return localize(1085, "{0} symbols in {1}, full path {2}", len, basename2(this.uri), this.uri.fsPath);
    }
  }
  async resolve(textModelResolverService) {
    if (this._previews.size !== 0) {
      return this;
    }
    for (const child of this.children) {
      if (this._previews.has(child.uri)) {
        continue;
      }
      try {
        const ref = await textModelResolverService.createModelReference(child.uri);
        this._previews.set(child.uri, new FilePreview(ref));
      } catch (err) {
        onUnexpectedError(err);
      }
    }
    return this;
  }
};
var ReferencesModel = class _ReferencesModel {
  constructor(links, title) {
    this.groups = [];
    this.references = [];
    this._onDidChangeReferenceRange = new Emitter();
    this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
    this._links = links;
    this._title = title;
    const [providersFirst] = links;
    links.sort(_ReferencesModel._compareReferences);
    let current;
    for (const link of links) {
      if (!current || !extUri.isEqual(current.uri, link.uri, true)) {
        current = new FileReferences(this, link.uri);
        this.groups.push(current);
      }
      if (current.children.length === 0 || _ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {
        const oneRef = new OneReference(providersFirst === link, current, link, (ref) => this._onDidChangeReferenceRange.fire(ref));
        this.references.push(oneRef);
        current.children.push(oneRef);
      }
    }
  }
  dispose() {
    dispose(this.groups);
    this._onDidChangeReferenceRange.dispose();
    this.groups.length = 0;
  }
  clone() {
    return new _ReferencesModel(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    if (this.isEmpty) {
      return localize(1086, "No results found");
    } else if (this.references.length === 1) {
      return localize(1087, "Found 1 symbol in {0}", this.references[0].uri.fsPath);
    } else if (this.groups.length === 1) {
      return localize(1088, "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
    } else {
      return localize(1089, "Found {0} symbols in {1} files", this.references.length, this.groups.length);
    }
  }
  nextOrPreviousReference(reference, next) {
    const { parent } = reference;
    let idx = parent.children.indexOf(reference);
    const childCount = parent.children.length;
    const groupCount = parent.parent.groups.length;
    if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
      if (next) {
        idx = (idx + 1) % childCount;
      } else {
        idx = (idx + childCount - 1) % childCount;
      }
      return parent.children[idx];
    }
    idx = parent.parent.groups.indexOf(parent);
    if (next) {
      idx = (idx + 1) % groupCount;
      return parent.parent.groups[idx].children[0];
    } else {
      idx = (idx + groupCount - 1) % groupCount;
      return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
    }
  }
  nearestReference(resource, position) {
    const nearest = this.references.map((ref, idx) => {
      return {
        idx,
        prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
        offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
      };
    }).sort((a, b) => {
      if (a.prefixLen > b.prefixLen) {
        return -1;
      } else if (a.prefixLen < b.prefixLen) {
        return 1;
      } else if (a.offsetDist < b.offsetDist) {
        return -1;
      } else if (a.offsetDist > b.offsetDist) {
        return 1;
      } else {
        return 0;
      }
    })[0];
    if (nearest) {
      return this.references[nearest.idx];
    }
    return void 0;
  }
  referenceAt(resource, position) {
    for (const ref of this.references) {
      if (ref.uri.toString() === resource.toString()) {
        if (Range.containsPosition(ref.range, position)) {
          return ref;
        }
      }
    }
    return void 0;
  }
  firstReference() {
    for (const ref of this.references) {
      if (ref.isProviderFirst) {
        return ref;
      }
    }
    return this.references[0];
  }
  static _compareReferences(a, b) {
    return extUri.compare(a.uri, b.uri) || Range.compareRangesUsingStarts(a.range, b.range);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js
init_dom();
init_color();
init_event();
init_lifecycle();
init_network();
init_resources();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.css";
init_range();
init_textModel();
init_modesRegistry();
init_resolverService();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js
init_dom();
init_filters();
init_lifecycle();
init_resources();
init_resolverService();
init_nls();
init_instantiation();
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var FileReferencesRenderer_1;
var DataSource = class DataSource2 {
  constructor(_resolverService) {
    this._resolverService = _resolverService;
  }
  hasChildren(element) {
    if (element instanceof ReferencesModel) {
      return true;
    }
    if (element instanceof FileReferences) {
      return true;
    }
    return false;
  }
  getChildren(element) {
    if (element instanceof ReferencesModel) {
      return element.groups;
    }
    if (element instanceof FileReferences) {
      return element.resolve(this._resolverService).then((val) => {
        return val.children;
      });
    }
    throw new Error("bad tree");
  }
};
DataSource = __decorate23([
  __param23(0, ITextModelService)
], DataSource);
var Delegate = class {
  getHeight() {
    return 23;
  }
  getTemplateId(element) {
    if (element instanceof FileReferences) {
      return FileReferencesRenderer.id;
    } else {
      return OneReferenceRenderer.id;
    }
  }
};
var StringRepresentationProvider = class StringRepresentationProvider2 {
  constructor(_keybindingService) {
    this._keybindingService = _keybindingService;
  }
  getKeyboardNavigationLabel(element) {
    if (element instanceof OneReference) {
      const parts = element.parent.getPreview(element)?.preview(element.range);
      if (parts) {
        return parts.value;
      }
    }
    return basename2(element.uri);
  }
};
StringRepresentationProvider = __decorate23([
  __param23(0, IKeybindingService)
], StringRepresentationProvider);
var IdentityProvider = class {
  getId(element) {
    return element instanceof OneReference ? element.id : element.uri;
  }
};
var FileReferencesTemplate = class FileReferencesTemplate2 extends Disposable {
  constructor(container, _labelService) {
    super();
    this._labelService = _labelService;
    const parent = document.createElement("div");
    parent.classList.add("reference-file");
    this.file = this._register(new IconLabel(parent, { supportHighlights: true }));
    this.badge = this._register(new CountBadge(append(parent, $(".count")), {}, defaultCountBadgeStyles));
    container.appendChild(parent);
  }
  set(element, matches) {
    const parent = dirname2(element.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(element.uri), this._labelService.getUriLabel(parent, { relative: true }), { title: this._labelService.getUriLabel(element.uri), matches });
    const len = element.children.length;
    this.badge.setCount(len);
    if (len > 1) {
      this.badge.setTitleFormat(localize(1076, "{0} references", len));
    } else {
      this.badge.setTitleFormat(localize(1077, "{0} reference", len));
    }
  }
};
FileReferencesTemplate = __decorate23([
  __param23(1, ILabelService)
], FileReferencesTemplate);
var _a13;
var FileReferencesRenderer = (_a13 = class {
  constructor(_instantiationService) {
    this._instantiationService = _instantiationService;
    this.templateId = FileReferencesRenderer_1.id;
  }
  renderTemplate(container) {
    return this._instantiationService.createInstance(FileReferencesTemplate, container);
  }
  renderElement(node, index, template) {
    template.set(node.element, createMatches(node.filterData));
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
}, FileReferencesRenderer_1 = _a13, _a13.id = "FileReferencesRenderer", _a13);
FileReferencesRenderer = FileReferencesRenderer_1 = __decorate23([
  __param23(0, IInstantiationService)
], FileReferencesRenderer);
var OneReferenceTemplate = class extends Disposable {
  constructor(container) {
    super();
    this.label = this._register(new HighlightedLabel(container));
  }
  set(element, score2) {
    const preview = element.parent.getPreview(element)?.preview(element.range);
    if (!preview || !preview.value) {
      this.label.set(`${basename2(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
    } else {
      const { value, highlight } = preview;
      if (score2 && !FuzzyScore.isDefault(score2)) {
        this.label.element.classList.toggle("referenceMatch", false);
        this.label.set(value, createMatches(score2));
      } else {
        this.label.element.classList.toggle("referenceMatch", true);
        this.label.set(value, [highlight]);
      }
    }
  }
};
var _OneReferenceRenderer = class _OneReferenceRenderer {
  constructor() {
    this.templateId = _OneReferenceRenderer.id;
  }
  renderTemplate(container) {
    return new OneReferenceTemplate(container);
  }
  renderElement(node, index, templateData) {
    templateData.set(node.element, node.filterData);
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
};
_OneReferenceRenderer.id = "OneReferenceRenderer";
var OneReferenceRenderer = _OneReferenceRenderer;
var AccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize(1078, "References");
  }
  getAriaLabel(element) {
    return element.ariaMessage;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js
init_nls();
init_instantiation();
init_themeService();
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _DecorationsManager = class _DecorationsManager {
  constructor(_editor, _model) {
    this._editor = _editor;
    this._model = _model;
    this._decorations = /* @__PURE__ */ new Map();
    this._decorationIgnoreSet = /* @__PURE__ */ new Set();
    this._callOnDispose = new DisposableStore();
    this._callOnModelChange = new DisposableStore();
    this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
    this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose();
    this._callOnDispose.dispose();
    this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (const ref of this._model.references) {
      if (ref.uri.toString() === model.uri.toString()) {
        this._addDecorations(ref.parent);
        return;
      }
    }
  }
  _addDecorations(reference) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const newDecorations = [];
    const newDecorationsActualIndex = [];
    for (let i2 = 0, len = reference.children.length; i2 < len; i2++) {
      const oneReference = reference.children[i2];
      if (this._decorationIgnoreSet.has(oneReference.id)) {
        continue;
      }
      if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {
        continue;
      }
      newDecorations.push({
        range: oneReference.range,
        options: _DecorationsManager.DecorationOptions
      });
      newDecorationsActualIndex.push(i2);
    }
    this._editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations([], newDecorations);
      for (let i2 = 0; i2 < decorations.length; i2++) {
        this._decorations.set(decorations[i2], reference.children[newDecorationsActualIndex[i2]]);
      }
    });
  }
  _onDecorationChanged() {
    const toRemove = [];
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (const [decorationId, reference] of this._decorations) {
      const newRange = model.getDecorationRange(decorationId);
      if (!newRange) {
        continue;
      }
      let ignore = false;
      if (Range.equalsRange(newRange, reference.range)) {
        continue;
      }
      if (Range.spansMultipleLines(newRange)) {
        ignore = true;
      } else {
        const lineLength = reference.range.endColumn - reference.range.startColumn;
        const newLineLength = newRange.endColumn - newRange.startColumn;
        if (lineLength !== newLineLength) {
          ignore = true;
        }
      }
      if (ignore) {
        this._decorationIgnoreSet.add(reference.id);
        toRemove.push(decorationId);
      } else {
        reference.range = newRange;
      }
    }
    for (let i2 = 0, len = toRemove.length; i2 < len; i2++) {
      this._decorations.delete(toRemove[i2]);
    }
    this._editor.removeDecorations(toRemove);
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]);
    this._decorations.clear();
  }
};
_DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
var DecorationsManager = _DecorationsManager;
var LayoutData = class {
  constructor() {
    this.ratio = 0.7;
    this.heightInLines = 18;
  }
  static fromJSON(raw) {
    let ratio;
    let heightInLines;
    try {
      const data = JSON.parse(raw);
      ratio = data.ratio;
      heightInLines = data.heightInLines;
    } catch {
    }
    return {
      ratio: ratio || 0.7,
      heightInLines: heightInLines || 18
    };
  }
};
var ReferencesTree = class extends WorkbenchAsyncDataTree {
};
var ReferencesDragAndDrop = class ReferencesDragAndDrop2 {
  constructor(labelService) {
    this.labelService = labelService;
    this.disposables = new DisposableStore();
  }
  getDragURI(element) {
    if (element instanceof FileReferences) {
      return element.uri.toString();
    } else if (element instanceof OneReference) {
      return withSelection(element.uri, element.range).toString();
    }
    return null;
  }
  getDragLabel(elements) {
    if (elements.length === 0) {
      return void 0;
    }
    const labels = elements.map((e) => this.labelService.getUriBasenameLabel(e.uri));
    return labels.join(", ");
  }
  onDragStart(data, originalEvent) {
    if (!originalEvent.dataTransfer) {
      return;
    }
    const elements = data.elements;
    const resources = elements.map((e) => this.getDragURI(e)).filter(Boolean);
    if (resources.length) {
      originalEvent.dataTransfer.setData(DataTransfers.RESOURCES, JSON.stringify(resources));
      originalEvent.dataTransfer.setData(DataTransfers.TEXT, resources.join("\n"));
    }
  }
  onDragOver() {
    return false;
  }
  drop() {
  }
  dispose() {
    this.disposables.dispose();
  }
};
ReferencesDragAndDrop = __decorate24([
  __param24(0, ILabelService)
], ReferencesDragAndDrop);
var ReferenceWidget = class ReferenceWidget2 extends PeekViewWidget {
  constructor(editor2, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _keybindingService) {
    super(editor2, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true, supportOnTitleClick: true }, _instantiationService);
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this.layoutData = layoutData;
    this._textModelResolverService = _textModelResolverService;
    this._instantiationService = _instantiationService;
    this._peekViewService = _peekViewService;
    this._uriLabel = _uriLabel;
    this._keybindingService = _keybindingService;
    this._disposeOnNewModel = new DisposableStore();
    this._callOnDispose = new DisposableStore();
    this._onDidSelectReference = new Emitter();
    this.onDidSelectReference = this._onDidSelectReference.event;
    this._dim = new Dimension(0, 0);
    this._isClosing = false;
    this._applyTheme(themeService.getColorTheme());
    this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._peekViewService.addExclusiveWidget(editor2, this);
    this.create();
  }
  get isClosing() {
    return this._isClosing;
  }
  dispose() {
    this._isClosing = true;
    this.setModel(void 0);
    this._callOnDispose.dispose();
    this._disposeOnNewModel.dispose();
    dispose(this._preview);
    dispose(this._previewNotAvailableMessage);
    dispose(this._tree);
    dispose(this._previewModelReference);
    this._splitView.dispose();
    super.dispose();
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  show(where) {
    super.show(where, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    if (this._preview && this._preview.getModel()) {
      this._onDidSelectReference.fire({
        element: this._getFocusedReference(),
        kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
        source: "title"
      });
    }
  }
  _fillBody(containerElement) {
    this.setCssClass("reference-zone-widget");
    this._messageContainer = append(containerElement, $("div.messages"));
    hide(this._messageContainer);
    this._splitView = new SplitView(containerElement, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    });
    this._previewContainer = append(containerElement, $("div.preview.inline"));
    const options = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: true
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, {}, this.editor);
    hide(this._previewContainer);
    this._previewNotAvailableMessage = this._instantiationService.createInstance(TextModel, localize(1079, "no preview available"), PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null);
    this._treeContainer = append(containerElement, $("div.ref-tree.inline"));
    const treeOptions = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new AccessibilityProvider(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
      identityProvider: new IdentityProvider(),
      openOnSingleClick: true,
      selectionNavigation: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      },
      dnd: this._instantiationService.createInstance(ReferencesDragAndDrop)
    };
    if (this._defaultTreeKeyboardSupport) {
      this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
        if (e.equals(
          9
          /* KeyCode.Escape */
        )) {
          this._keybindingService.dispatchEvent(e, e.target);
          e.stopPropagation();
        }
      }, true));
    }
    this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [
      this._instantiationService.createInstance(FileReferencesRenderer),
      this._instantiationService.createInstance(OneReferenceRenderer)
    ], this._instantiationService.createInstance(DataSource), treeOptions);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._preview.layout({ height: this._dim.height, width });
      }
    }, Sizing.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._treeContainer.style.height = `${this._dim.height}px`;
        this._treeContainer.style.width = `${width}px`;
        this._tree.layout(this._dim.height, width);
      }
    }, Sizing.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }, void 0));
    const onEvent = (element, kind) => {
      if (element instanceof OneReference) {
        if (kind === "show") {
          this._revealReference(element, false);
        }
        this._onDidSelectReference.fire({ element, kind, source: "tree" });
      }
    };
    this._disposables.add(this._tree.onDidOpen((e) => {
      if (e.sideBySide) {
        onEvent(e.element, "side");
      } else if (e.editorOptions.pinned) {
        onEvent(e.element, "goto");
      } else {
        onEvent(e.element, "show");
      }
    }));
    hide(this._treeContainer);
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._dim = new Dimension(widthInPixel, heightInPixel);
    this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
    this._splitView.layout(widthInPixel);
    this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
  }
  setSelection(selection) {
    return this._revealReference(selection, true).then(() => {
      if (!this._model) {
        return;
      }
      this._tree.setSelection([selection]);
      this._tree.setFocus([selection]);
    });
  }
  setModel(newModel) {
    this._disposeOnNewModel.clear();
    this._model = newModel;
    if (this._model) {
      return this._onNewModel();
    }
    return Promise.resolve();
  }
  _onNewModel() {
    if (!this._model) {
      return Promise.resolve(void 0);
    }
    if (this._model.isEmpty) {
      this.setTitle("");
      this._messageContainer.innerText = localize(1080, "No results");
      show(this._messageContainer);
      return Promise.resolve(void 0);
    }
    hide(this._messageContainer);
    this._decorationsManager = new DecorationsManager(this._preview, this._model);
    this._disposeOnNewModel.add(this._decorationsManager);
    this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference) => this._tree.rerender(reference)));
    this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event, target } = e;
      if (event.detail !== 2) {
        return;
      }
      const element = this._getFocusedReference();
      if (!element) {
        return;
      }
      this._onDidSelectReference.fire({
        element: { uri: element.uri, range: target.range },
        kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
        source: "editor"
      });
    }));
    this.container.classList.add("results-loaded");
    show(this._treeContainer);
    show(this._previewContainer);
    this._splitView.layout(this._dim.width);
    this.focusOnReferenceTree();
    return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
  }
  _getFocusedReference() {
    const [element] = this._tree.getFocus();
    if (element instanceof OneReference) {
      return element;
    } else if (element instanceof FileReferences) {
      if (element.children.length > 0) {
        return element.children[0];
      }
    }
    return void 0;
  }
  async revealReference(reference) {
    await this._revealReference(reference, false);
    this._onDidSelectReference.fire({ element: reference, kind: "goto", source: "tree" });
  }
  async _revealReference(reference, revealParent) {
    if (this._revealedReference === reference) {
      return;
    }
    this._revealedReference = reference;
    if (reference.uri.scheme !== Schemas.inMemory) {
      this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname2(reference.uri)));
    } else {
      this.setTitle(localize(1081, "References"));
    }
    const promise = this._textModelResolverService.createModelReference(reference.uri);
    if (this._tree.getInput() === reference.parent) {
      this._tree.reveal(reference);
    } else {
      if (revealParent) {
        this._tree.reveal(reference.parent);
      }
      await this._tree.expand(reference.parent);
      this._tree.reveal(reference);
    }
    const ref = await promise;
    if (!this._model) {
      ref.dispose();
      return;
    }
    dispose(this._previewModelReference);
    const model = ref.object;
    if (model) {
      const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
      const sel = Range.lift(reference.range).collapseToStart();
      this._previewModelReference = ref;
      this._preview.setModel(model.textEditorModel);
      this._preview.setSelection(sel);
      this._preview.revealRangeInCenter(sel, scrollType);
    } else {
      this._preview.setModel(this._previewNotAvailableMessage);
      ref.dispose();
    }
  }
};
ReferenceWidget = __decorate24([
  __param24(3, IThemeService),
  __param24(4, ITextModelService),
  __param24(5, IInstantiationService),
  __param24(6, IPeekViewService),
  __param24(7, ILabelService),
  __param24(8, IKeybindingService)
], ReferenceWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
init_editorContextKeys();
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ReferencesController_1;
var ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false, localize(1073, "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
var _a14;
var ReferencesController = (_a14 = class {
  static get(editor2) {
    return editor2.getContribution(ReferencesController_1.ID);
  }
  constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this._editor = _editor;
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._instantiationService = _instantiationService;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._requestIdPool = 0;
    this._ignoreModelChangeEvent = false;
    this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
  }
  dispose() {
    this._referenceSearchVisible.reset();
    this._disposables.dispose();
    this._widget?.dispose();
    this._model?.dispose();
    this._widget = void 0;
    this._model = void 0;
  }
  toggleWidget(range, modelPromise, peekMode) {
    let widgetPosition;
    if (this._widget) {
      widgetPosition = this._widget.position;
    }
    this.closeWidget();
    if (!!widgetPosition && range.containsPosition(widgetPosition)) {
      return;
    }
    this._peekMode = peekMode;
    this._referenceSearchVisible.set(true);
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    }));
    this._disposables.add(this._editor.onDidChangeModel(() => {
      if (!this._ignoreModelChangeEvent) {
        this.closeWidget();
      }
    }));
    const storageKey = "peekViewLayout";
    const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
    this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
    this._widget.setTitle(localize(1074, "Loading..."));
    this._widget.show(range);
    this._disposables.add(this._widget.onDidClose(() => {
      modelPromise.cancel();
      if (this._widget) {
        this._storageService.store(
          storageKey,
          JSON.stringify(this._widget.layoutData),
          0,
          1
          /* StorageTarget.MACHINE */
        );
        if (!this._widget.isClosing) {
          this.closeWidget();
        }
        this._widget = void 0;
      } else {
        this.closeWidget();
      }
    }));
    this._disposables.add(this._widget.onDidSelectReference((event) => {
      const { element, kind } = event;
      if (!element) {
        return;
      }
      switch (kind) {
        case "open":
          if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) {
            this.openReference(element, false, false);
          }
          break;
        case "side":
          this.openReference(element, true, false);
          break;
        case "goto":
          if (peekMode) {
            this._gotoReference(element, true);
          } else {
            this.openReference(element, false, true);
          }
          break;
      }
    }));
    const requestId = ++this._requestIdPool;
    modelPromise.then((model) => {
      if (requestId !== this._requestIdPool || !this._widget) {
        model.dispose();
        return void 0;
      }
      this._model?.dispose();
      this._model = model;
      return this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          if (!this._model.isEmpty) {
            this._widget.setMetaTitle(localize(1075, "{0} ({1})", this._model.title, this._model.references.length));
          } else {
            this._widget.setMetaTitle("");
          }
          const uri = this._editor.getModel().uri;
          const pos = new Position(range.startLineNumber, range.startColumn);
          const selection = this._model.nearestReference(uri, pos);
          if (selection) {
            return this._widget.setSelection(selection).then(() => {
              if (this._widget && this._editor.getOption(
                99
                /* EditorOption.peekWidgetDefaultFocus */
              ) === "editor") {
                this._widget.focusOnPreviewEditor();
              }
            });
          }
        }
        return void 0;
      });
    }, (error) => {
      this._notificationService.error(error);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    if (!this._widget) {
      return;
    }
    if (this._widget.isPreviewEditorFocused()) {
      this._widget.focusOnReferenceTree();
    } else {
      this._widget.focusOnPreviewEditor();
    }
  }
  async goToNextOrPreviousReference(fwd) {
    if (!this._editor.hasModel() || !this._model || !this._widget) {
      return;
    }
    const currentPosition = this._widget.position;
    if (!currentPosition) {
      return;
    }
    const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
    if (!source) {
      return;
    }
    const target = this._model.nextOrPreviousReference(source, fwd);
    const editorFocus = this._editor.hasTextFocus();
    const previewEditorFocus = this._widget.isPreviewEditorFocused();
    await this._widget.setSelection(target);
    await this._gotoReference(target, false);
    if (editorFocus) {
      this._editor.focus();
    } else if (this._widget && previewEditorFocus) {
      this._widget.focusOnPreviewEditor();
    }
  }
  async revealReference(reference) {
    if (!this._editor.hasModel() || !this._model || !this._widget) {
      return;
    }
    await this._widget.revealReference(reference);
  }
  closeWidget(focusEditor = true) {
    this._widget?.dispose();
    this._model?.dispose();
    this._referenceSearchVisible.reset();
    this._disposables.clear();
    this._widget = void 0;
    this._model = void 0;
    if (focusEditor) {
      this._editor.focus();
    }
    this._requestIdPool += 1;
  }
  _gotoReference(ref, pinned) {
    this._widget?.hide();
    this._ignoreModelChangeEvent = true;
    const range = Range.lift(ref.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: ref.uri,
      options: { selection: range, selectionSource: "code.jump", pinned }
    }, this._editor).then((openedEditor) => {
      this._ignoreModelChangeEvent = false;
      if (!openedEditor || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === openedEditor) {
        this._widget.show(range);
        this._widget.focusOnReferenceTree();
      } else {
        const other = ReferencesController_1.get(openedEditor);
        const model = this._model.clone();
        this.closeWidget();
        openedEditor.focus();
        other?.toggleWidget(range, createCancelablePromise((_) => Promise.resolve(model)), this._peekMode ?? false);
      }
    }, (err) => {
      this._ignoreModelChangeEvent = false;
      onUnexpectedError(err);
    });
  }
  openReference(ref, sideBySide, pinned) {
    if (!sideBySide) {
      this.closeWidget();
    }
    const { uri, range } = ref;
    this._editorService.openCodeEditor({
      resource: uri,
      options: { selection: range, selectionSource: "code.jump", pinned }
    }, this._editor, sideBySide);
  }
}, ReferencesController_1 = _a14, _a14.ID = "editor.contrib.referencesController", _a14);
ReferencesController = ReferencesController_1 = __decorate25([
  __param25(2, IContextKeyService),
  __param25(3, ICodeEditorService),
  __param25(4, INotificationService),
  __param25(5, IInstantiationService),
  __param25(6, IStorageService),
  __param25(7, IConfigurationService)
], ReferencesController);
function withController(accessor, fn) {
  const outerEditor = getOuterEditor(accessor);
  if (!outerEditor) {
    return;
  }
  const controller = ReferencesController.get(outerEditor);
  if (controller) {
    fn(controller);
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: KeyChord(
    2048 | 41,
    60
    /* KeyCode.F2 */
  ),
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.changeFocusBetweenPreviewAndReferences();
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 100 - 10,
  primary: 62,
  secondary: [
    70
    /* KeyCode.F12 */
  ],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(true);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 100 - 10,
  primary: 1024 | 62,
  secondary: [
    1024 | 70
    /* KeyCode.F12 */
  ],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(false);
    });
  }
});
CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 100 - 101,
  primary: 9,
  secondary: [
    1024 | 9
    /* KeyCode.Escape */
  ],
  when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 200 + 50,
  primary: 9,
  secondary: [
    1024 | 9
    /* KeyCode.Escape */
  ],
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"), ContextKeyExpr.or(EditorContextKeys.editorTextFocus, InputFocusedContext.negate()))
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [
      2048 | 18
      /* KeyCode.DownArrow */
    ]
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
  handler(accessor) {
    const listService = accessor.get(IListService);
    const focus = listService.lastFocusedList?.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.revealReference(focus[0]));
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2048 | 3,
  mac: {
    primary: 256 | 3
    /* KeyCode.Enter */
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
  handler(accessor) {
    const listService = accessor.get(IListService);
    const focus = listService.lastFocusedList?.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.openReference(focus[0], true, true));
    }
  }
});
CommandsRegistry.registerCommand("openReference", (accessor) => {
  const listService = accessor.get(IListService);
  const focus = listService.lastFocusedList?.getFocus();
  if (Array.isArray(focus) && focus[0] instanceof OneReference) {
    withController(accessor, (controller) => controller.openReference(focus[0], false, true));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js
init_event();
init_lifecycle();
init_resources();
init_editorExtensions();
init_codeEditorService();
init_range();
init_nls();
init_contextkey();
init_extensions();
init_instantiation();
init_keybindingsRegistry();
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ctxHasSymbols = new RawContextKey("hasSymbols", false, localize(1090, "Whether there are symbol locations that can be navigated via keyboard-only."));
var ISymbolNavigationService = createDecorator("ISymbolNavigationService");
var SymbolNavigationService = class SymbolNavigationService2 {
  constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._keybindingService = _keybindingService;
    this._currentModel = void 0;
    this._currentIdx = -1;
    this._ignoreEditorChange = false;
    this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
  }
  reset() {
    this._ctxHasSymbols.reset();
    this._currentState?.dispose();
    this._currentMessage?.close();
    this._currentModel = void 0;
    this._currentIdx = -1;
  }
  put(anchor) {
    const refModel = anchor.parent.parent;
    if (refModel.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = refModel;
    this._currentIdx = refModel.references.indexOf(anchor);
    this._ctxHasSymbols.set(true);
    this._showMessage();
    const editorState = new EditorState2(this._editorService);
    const listener = editorState.onDidChange((_) => {
      if (this._ignoreEditorChange) {
        return;
      }
      const editor2 = this._editorService.getActiveCodeEditor();
      if (!editor2) {
        return;
      }
      const model = editor2.getModel();
      const position = editor2.getPosition();
      if (!model || !position) {
        return;
      }
      let seenUri = false;
      let seenPosition = false;
      for (const reference of refModel.references) {
        if (isEqual(reference.uri, model.uri)) {
          seenUri = true;
          seenPosition = seenPosition || Range.containsPosition(reference.range, position);
        } else if (seenUri) {
          break;
        }
      }
      if (!seenUri || !seenPosition) {
        this.reset();
      }
    });
    this._currentState = combinedDisposable(editorState, listener);
  }
  revealNext(source) {
    if (!this._currentModel) {
      return Promise.resolve();
    }
    this._currentIdx += 1;
    this._currentIdx %= this._currentModel.references.length;
    const reference = this._currentModel.references[this._currentIdx];
    this._showMessage();
    this._ignoreEditorChange = true;
    return this._editorService.openCodeEditor({
      resource: reference.uri,
      options: {
        selection: Range.collapseToStart(reference.range),
        selectionRevealType: 3
        /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */
      }
    }, source).finally(() => {
      this._ignoreEditorChange = false;
    });
  }
  _showMessage() {
    this._currentMessage?.close();
    const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
    const message = kb ? localize(1091, "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize(1092, "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(message);
  }
};
SymbolNavigationService = __decorate26([
  __param26(0, IContextKeyService),
  __param26(1, ICodeEditorService),
  __param26(2, INotificationService),
  __param26(3, IKeybindingService)
], SymbolNavigationService);
registerSingleton(
  ISymbolNavigationService,
  SymbolNavigationService,
  1
  /* InstantiationType.Delayed */
);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: ctxHasSymbols,
      kbOpts: {
        weight: 100,
        primary: 70
        /* KeyCode.F12 */
      }
    });
  }
  runEditorCommand(accessor, editor2) {
    return accessor.get(ISymbolNavigationService).revealNext(editor2);
  }
}());
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: ctxHasSymbols,
  primary: 9,
  handler(accessor) {
    accessor.get(ISymbolNavigationService).reset();
  }
});
var EditorState2 = class EditorState3 {
  constructor(editorService) {
    this._listener = /* @__PURE__ */ new Map();
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
    this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
    editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
    dispose(this._listener.values());
  }
  _onDidAddEditor(editor2) {
    this._listener.set(editor2, combinedDisposable(editor2.onDidChangeCursorPosition((_) => this._onDidChange.fire({ editor: editor2 })), editor2.onDidChangeModelContent((_) => this._onDidChange.fire({ editor: editor2 }))));
  }
  _onDidRemoveEditor(editor2) {
    this._listener.get(editor2)?.dispose();
    this._listener.delete(editor2);
  }
};
EditorState2 = __decorate26([
  __param26(0, ICodeEditorService)
], EditorState2);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_nls();
init_actions2();
init_commands();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js
init_arrays();
init_cancellation();
init_errors();
init_network();
init_editorExtensions();
init_languageFeatures();
function shouldIncludeLocationLink(sourceModel, loc) {
  if (loc.uri.scheme === sourceModel.uri.scheme) {
    return true;
  }
  if (matchesSomeScheme(loc.uri, Schemas.walkThroughSnippet, Schemas.vscodeChatCodeBlock, Schemas.vscodeChatCodeCompareBlock)) {
    return false;
  }
  return true;
}
async function getLocationLinks(model, position, registry, recursive, provide) {
  const provider = registry.ordered(model, recursive);
  const promises = provider.map((provider2) => {
    return Promise.resolve(provide(provider2, model, position)).then(void 0, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  });
  const values = await Promise.all(promises);
  return coalesce(values.flat()).filter((loc) => shouldIncludeLocationLink(model, loc));
}
function getDefinitionsAtPosition(registry, model, position, recursive, token) {
  return getLocationLinks(model, position, registry, recursive, (provider, model2, position2) => {
    return provider.provideDefinition(model2, position2, token);
  });
}
function getDeclarationsAtPosition(registry, model, position, recursive, token) {
  return getLocationLinks(model, position, registry, recursive, (provider, model2, position2) => {
    return provider.provideDeclaration(model2, position2, token);
  });
}
function getImplementationsAtPosition(registry, model, position, recursive, token) {
  return getLocationLinks(model, position, registry, recursive, (provider, model2, position2) => {
    return provider.provideImplementation(model2, position2, token);
  });
}
function getTypeDefinitionsAtPosition(registry, model, position, recursive, token) {
  return getLocationLinks(model, position, registry, recursive, (provider, model2, position2) => {
    return provider.provideTypeDefinition(model2, position2, token);
  });
}
function getReferencesAtPosition(registry, model, position, compact, recursive, token) {
  return getLocationLinks(model, position, registry, recursive, async (provider, model2, position2) => {
    const result = (await provider.provideReferences(model2, position2, { includeDeclaration: true }, token))?.filter((ref) => shouldIncludeLocationLink(model2, ref));
    if (!compact || !result || result.length !== 2) {
      return result;
    }
    const resultWithoutDeclaration = (await provider.provideReferences(model2, position2, { includeDeclaration: false }, token))?.filter((ref) => shouldIncludeLocationLink(model2, ref));
    if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
      return resultWithoutDeclaration;
    }
    return result;
  });
}
async function _sortedAndDeduped(callback) {
  const rawLinks = await callback();
  const model = new ReferencesModel(rawLinks, "");
  const modelLinks = model.references.map((ref) => ref.link);
  model.dispose();
  return modelLinks;
}
registerModelAndPositionCommand("_executeDefinitionProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeDefinitionProvider_recursive", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, true, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeTypeDefinitionProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeTypeDefinitionProvider_recursive", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, true, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeDeclarationProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeDeclarationProvider_recursive", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, true, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeReferenceProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeReferenceProvider_recursive", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, true, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeImplementationProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeImplementationProvider_recursive", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, true, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_languageFeatures();
init_iterator();
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
  submenu: MenuId.EditorContextPeek,
  title: localize(1033, "Peek"),
  group: "navigation",
  order: 100
});
var SymbolNavigationAnchor = class _SymbolNavigationAnchor {
  static is(thing) {
    if (!thing || typeof thing !== "object") {
      return false;
    }
    if (thing instanceof _SymbolNavigationAnchor) {
      return true;
    }
    if (Position.isIPosition(thing.position) && thing.model) {
      return true;
    }
    return false;
  }
  constructor(model, position) {
    this.model = model;
    this.position = position;
  }
};
var _SymbolNavigationAction = class _SymbolNavigationAction extends EditorAction2 {
  static all() {
    return _SymbolNavigationAction._allSymbolNavigationCommands.values();
  }
  static _patchConfig(opts) {
    const result = { ...opts, f1: true };
    if (result.menu) {
      for (const item of Iterable.wrap(result.menu)) {
        if (item.id === MenuId.EditorContext || item.id === MenuId.EditorContextPeek) {
          item.when = ContextKeyExpr.and(opts.precondition, item.when);
        }
      }
    }
    return result;
  }
  constructor(configuration, opts) {
    super(_SymbolNavigationAction._patchConfig(opts));
    this.configuration = configuration;
    _SymbolNavigationAction._allSymbolNavigationCommands.set(opts.id, this);
  }
  runEditorCommand(accessor, editor2, arg, range) {
    if (!editor2.hasModel()) {
      return Promise.resolve(void 0);
    }
    const notificationService = accessor.get(INotificationService);
    const editorService = accessor.get(ICodeEditorService);
    const progressService = accessor.get(IEditorProgressService);
    const symbolNavService = accessor.get(ISymbolNavigationService);
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const instaService = accessor.get(IInstantiationService);
    const model = editor2.getModel();
    const position = editor2.getPosition();
    const anchor = SymbolNavigationAnchor.is(arg) ? arg : new SymbolNavigationAnchor(model, position);
    const cts = new EditorStateCancellationTokenSource(
      editor2,
      1 | 4
      /* CodeEditorStateFlag.Position */
    );
    const promise = raceCancellation(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then(async (references) => {
      if (!references || cts.token.isCancellationRequested) {
        return;
      }
      alert(references.ariaMessage);
      let altAction;
      if (references.referenceAt(model.uri, position)) {
        const altActionId = this._getAlternativeCommand(editor2);
        if (altActionId !== void 0 && !_SymbolNavigationAction._activeAlternativeCommands.has(altActionId) && _SymbolNavigationAction._allSymbolNavigationCommands.has(altActionId)) {
          altAction = _SymbolNavigationAction._allSymbolNavigationCommands.get(altActionId);
        }
      }
      const referenceCount = references.references.length;
      if (referenceCount === 0) {
        if (!this.configuration.muteMessage) {
          const info = model.getWordAtPosition(position);
          MessageController.get(editor2)?.showMessage(this._getNoResultFoundMessage(info), position);
        }
      } else if (referenceCount === 1 && altAction) {
        _SymbolNavigationAction._activeAlternativeCommands.add(this.desc.id);
        instaService.invokeFunction((accessor2) => altAction.runEditorCommand(accessor2, editor2, arg, range).finally(() => {
          _SymbolNavigationAction._activeAlternativeCommands.delete(this.desc.id);
        }));
      } else {
        return this._onResult(editorService, symbolNavService, editor2, references, range);
      }
    }, (err) => {
      notificationService.error(err);
    }).finally(() => {
      cts.dispose();
    });
    progressService.showWhile(promise, 250);
    return promise;
  }
  async _onResult(editorService, symbolNavService, editor2, model, range) {
    const gotoLocation = this._getGoToPreference(editor2);
    if (!(editor2 instanceof EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) {
      this._openInPeek(editor2, model, range);
    } else {
      const next = model.firstReference();
      const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
      const targetEditor = await this._openReference(editor2, editorService, next, this.configuration.openToSide, !peek);
      if (peek && targetEditor) {
        this._openInPeek(targetEditor, model, range);
      } else {
        model.dispose();
      }
      if (gotoLocation === "goto") {
        symbolNavService.put(next);
      }
    }
  }
  async _openReference(editor2, editorService, reference, sideBySide, highlight) {
    let range = void 0;
    if (isLocationLink(reference)) {
      range = reference.targetSelectionRange;
    }
    if (!range) {
      range = reference.range;
    }
    if (!range) {
      return void 0;
    }
    const targetEditor = await editorService.openCodeEditor({
      resource: reference.uri,
      options: {
        selection: Range.collapseToStart(range),
        selectionRevealType: 3,
        selectionSource: "code.jump"
        /* TextEditorSelectionSource.JUMP */
      }
    }, editor2, sideBySide);
    if (!targetEditor) {
      return void 0;
    }
    if (highlight) {
      const modelNow = targetEditor.getModel();
      const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
      setTimeout(() => {
        if (targetEditor.getModel() === modelNow) {
          decorations.clear();
        }
      }, 350);
    }
    return targetEditor;
  }
  _openInPeek(target, model, range) {
    const controller = ReferencesController.get(target);
    if (controller && target.hasModel()) {
      controller.toggleWidget(range ?? target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this.configuration.openInPeek);
    } else {
      model.dispose();
    }
  }
};
_SymbolNavigationAction._allSymbolNavigationCommands = /* @__PURE__ */ new Map();
_SymbolNavigationAction._activeAlternativeCommands = /* @__PURE__ */ new Set();
var SymbolNavigationAction = _SymbolNavigationAction;
var DefinitionAction = class extends SymbolNavigationAction {
  async _getLocationModel(languageFeaturesService, model, position, token) {
    return new ReferencesModel(await getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, false, token), localize(1034, "Definitions"));
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize(1035, "No definition found for '{0}'", info.word) : localize(1036, "No definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).alternativeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).multipleDefinitions;
  }
};
var _a15;
registerAction2((_a15 = class extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: _a15.id,
      title: {
        ...localize2(1060, "Go to Definition"),
        mnemonicTitle: localize(1037, "Go to &&Definition")
      },
      precondition: EditorContextKeys.hasDefinitionProvider,
      keybinding: [{
        when: EditorContextKeys.editorTextFocus,
        primary: 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, IsWebContext),
        primary: 2048 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }],
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 2
      }]
    });
    CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", _a15.id);
  }
}, _a15.id = "editor.action.revealDefinition", _a15));
var _a16;
registerAction2((_a16 = class extends DefinitionAction {
  constructor() {
    super({
      openToSide: true,
      openInPeek: false,
      muteMessage: false
    }, {
      id: _a16.id,
      title: localize2(1061, "Open Definition to the Side"),
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      keybinding: [{
        when: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ContextKeyExpr.and(EditorContextKeys.editorTextFocus, IsWebContext),
        primary: KeyChord(
          2048 | 41,
          2048 | 70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
    CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", _a16.id);
  }
}, _a16.id = "editor.action.revealDefinitionAside", _a16));
var _a17;
registerAction2((_a17 = class extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: _a17.id,
      title: localize2(1062, "Peek Definition"),
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 512 | 70,
        linux: {
          primary: 2048 | 1024 | 68
          /* KeyCode.F10 */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 2
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", _a17.id);
  }
}, _a17.id = "editor.action.peekDefinition", _a17));
var DeclarationAction = class extends SymbolNavigationAction {
  async _getLocationModel(languageFeaturesService, model, position, token) {
    return new ReferencesModel(await getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, false, token), localize(1038, "Declarations"));
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize(1039, "No declaration found for '{0}'", info.word) : localize(1040, "No declaration found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).alternativeDeclarationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).multipleDeclarations;
  }
};
var _a18;
registerAction2((_a18 = class extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: _a18.id,
      title: {
        ...localize2(1063, "Go to Declaration"),
        mnemonicTitle: localize(1041, "Go to &&Declaration")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize(1042, "No declaration found for '{0}'", info.word) : localize(1043, "No declaration found");
  }
}, _a18.id = "editor.action.revealDeclaration", _a18));
registerAction2(class PeekDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.peekDeclaration",
      title: localize2(1064, "Peek Declaration"),
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
var TypeDefinitionAction = class extends SymbolNavigationAction {
  async _getLocationModel(languageFeaturesService, model, position, token) {
    return new ReferencesModel(await getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, false, token), localize(1044, "Type Definitions"));
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize(1045, "No type definition found for '{0}'", info.word) : localize(1046, "No type definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).multipleTypeDefinitions;
  }
};
var _a19;
registerAction2((_a19 = class extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: _a19.ID,
      title: {
        ...localize2(1065, "Go to Type Definition"),
        mnemonicTitle: localize(1047, "Go to &&Type Definition")
      },
      precondition: EditorContextKeys.hasTypeDefinitionProvider,
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, _a19.ID = "editor.action.goToTypeDefinition", _a19));
var _a20;
registerAction2((_a20 = class extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: _a20.ID,
      title: localize2(1066, "Peek Type Definition"),
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, _a20.ID = "editor.action.peekTypeDefinition", _a20));
var ImplementationAction = class extends SymbolNavigationAction {
  async _getLocationModel(languageFeaturesService, model, position, token) {
    return new ReferencesModel(await getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, false, token), localize(1048, "Implementations"));
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize(1049, "No implementation found for '{0}'", info.word) : localize(1050, "No implementation found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).alternativeImplementationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).multipleImplementations;
  }
};
var _a21;
registerAction2((_a21 = class extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: _a21.ID,
      title: {
        ...localize2(1067, "Go to Implementations"),
        mnemonicTitle: localize(1051, "Go to &&Implementations")
      },
      precondition: EditorContextKeys.hasImplementationProvider,
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 2048 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, _a21.ID = "editor.action.goToImplementation", _a21));
var _a22;
registerAction2((_a22 = class extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: _a22.ID,
      title: localize2(1068, "Peek Implementations"),
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, _a22.ID = "editor.action.peekImplementation", _a22));
var ReferencesAction = class extends SymbolNavigationAction {
  _getNoResultFoundMessage(info) {
    return info ? localize(1052, "No references found for '{0}'", info.word) : localize(1053, "No references found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).alternativeReferenceCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
};
registerAction2(class GoToReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: "editor.action.goToReferences",
      title: {
        ...localize2(1069, "Go to References"),
        mnemonicTitle: localize(1054, "Go to &&References")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 1024 | 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: MenuId.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  async _getLocationModel(languageFeaturesService, model, position, token) {
    return new ReferencesModel(await getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, true, false, token), localize(1055, "References"));
  }
});
registerAction2(class PeekReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: localize2(1070, "Peek References"),
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  async _getLocationModel(languageFeaturesService, model, position, token) {
    return new ReferencesModel(await getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, false, token), localize(1056, "References"));
  }
});
var GenericGoToLocationAction = class extends SymbolNavigationAction {
  constructor(config, _references, _gotoMultipleBehaviour) {
    super(config, {
      id: "editor.action.goToLocation",
      title: localize2(1071, "Go to Any Symbol"),
      precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInEmbeddedEditor.toNegated())
    });
    this._references = _references;
    this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
  }
  async _getLocationModel(languageFeaturesService, _model, _position, _token) {
    return new ReferencesModel(this._references, localize(1057, "Locations"));
  }
  _getNoResultFoundMessage(info) {
    return info && localize(1058, "No results for '{0}'", info.word) || "";
  }
  _getGoToPreference(editor2) {
    return this._gotoMultipleBehaviour ?? editor2.getOption(
      67
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
  _getAlternativeCommand() {
    return void 0;
  }
};
CommandsRegistry.registerCommand({
  id: "editor.action.goToLocations",
  metadata: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI },
      { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: async (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    assertType(Array.isArray(references));
    assertType(typeof multiple === "undefined" || typeof multiple === "string");
    assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
    const editorService = accessor.get(ICodeEditorService);
    const editor2 = await editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
    if (isCodeEditor(editor2)) {
      editor2.setPosition(position);
      editor2.revealPositionInCenterIfOutsideViewport(
        position,
        0
        /* ScrollType.Smooth */
      );
      return editor2.invokeWithinContext((accessor2) => {
        const command = new class extends GenericGoToLocationAction {
          _getNoResultFoundMessage(info) {
            return noResultsMessage || super._getNoResultFoundMessage(info);
          }
        }({
          muteMessage: !Boolean(noResultsMessage),
          openInPeek: Boolean(openInPeek),
          openToSide: false
        }, references, multiple);
        accessor2.get(IInstantiationService).invokeFunction(command.run.bind(command), editor2);
      });
    }
  }
});
CommandsRegistry.registerCommand({
  id: "editor.action.peekLocations",
  metadata: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI },
      { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" }
    ]
  },
  handler: async (accessor, resource, position, references, multiple) => {
    accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
  }
});
CommandsRegistry.registerCommand({
  id: "editor.action.findReferences",
  handler: (accessor, resource, position) => {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const codeEditorService = accessor.get(ICodeEditorService);
    return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then((control) => {
      if (!isCodeEditor(control) || !control.hasModel()) {
        return void 0;
      }
      const controller = ReferencesController.get(control);
      if (!controller) {
        return void 0;
      }
      const references = createCancelablePromise((token) => getReferencesAtPosition(languageFeaturesService.referenceProvider, control.getModel(), Position.lift(position), false, false, token).then((references2) => new ReferencesModel(references2, localize(1059, "References"))));
      const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
      return Promise.resolve(controller.toggleWidget(range, references, false));
    });
  }
});
CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js
init_actions2();
init_commands();
init_contextkey();
init_instantiation();
async function showGoToContextMenu(accessor, editor2, anchor, part) {
  const resolverService = accessor.get(ITextModelService);
  const contextMenuService = accessor.get(IContextMenuService);
  const commandService = accessor.get(ICommandService);
  const instaService = accessor.get(IInstantiationService);
  const notificationService = accessor.get(INotificationService);
  await part.item.resolve(CancellationToken.None);
  if (!part.part.location) {
    return;
  }
  const location = part.part.location;
  const menuActions = [];
  const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext).map((item) => isIMenuItem(item) ? item.command.id : generateUuid()));
  for (const delegate of SymbolNavigationAction.all()) {
    if (filter.has(delegate.desc.id)) {
      menuActions.push(new Action(delegate.desc.id, MenuItemAction.label(delegate.desc, { renderShortTitle: true }), void 0, true, async () => {
        const ref = await resolverService.createModelReference(location.uri);
        try {
          const symbolAnchor = new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range));
          const range = part.item.anchor.range;
          await instaService.invokeFunction(delegate.runEditorCommand.bind(delegate), editor2, symbolAnchor, range);
        } finally {
          ref.dispose();
        }
      }));
    }
  }
  if (part.part.command) {
    const { command } = part.part;
    menuActions.push(new Separator());
    menuActions.push(new Action(command.id, command.title, void 0, true, async () => {
      try {
        await commandService.executeCommand(command.id, ...command.arguments ?? []);
      } catch (err) {
        notificationService.notify({
          severity: Severity.Error,
          source: part.item.provider.displayName,
          message: err
        });
      }
    }));
  }
  const useShadowDOM = editor2.getOption(
    144
    /* EditorOption.useShadowDOM */
  );
  contextMenuService.showContextMenu({
    domForShadowRoot: useShadowDOM ? editor2.getDomNode() ?? void 0 : void 0,
    getAnchor: () => {
      const box = getDomNodePagePosition(anchor);
      return { x: box.left, y: box.top + box.height + 8 };
    },
    getActions: () => menuActions,
    onHide: () => {
      editor2.focus();
    },
    autoSelectFirstItem: true
  });
}
async function goToDefinitionWithLocation(accessor, event, editor2, location) {
  const resolverService = accessor.get(ITextModelService);
  const ref = await resolverService.createModelReference(location.uri);
  await editor2.invokeWithinContext(async (accessor2) => {
    const openToSide = event.hasSideBySideModifier;
    const contextKeyService = accessor2.get(IContextKeyService);
    const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
    const canPeek = !openToSide && editor2.getOption(
      101
      /* EditorOption.definitionLinkOpensInPeek */
    ) && !isInPeek;
    const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
    return action.run(accessor2, new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location.range)), Range.lift(location.range));
  });
  ref.dispose();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
init_commands();
init_extensions();
init_instantiation();
init_colorRegistry();
init_themeService();
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlayHintsController_1;
var InlayHintsCache = class _InlayHintsCache {
  constructor() {
    this._entries = new LRUCache(50);
  }
  get(model) {
    const key = _InlayHintsCache._key(model);
    return this._entries.get(key);
  }
  set(model, value) {
    const key = _InlayHintsCache._key(model);
    this._entries.set(key, value);
  }
  static _key(model) {
    return `${model.uri.toString()}/${model.getVersionId()}`;
  }
};
var IInlayHintsCache = createDecorator("IInlayHintsCache");
registerSingleton(
  IInlayHintsCache,
  InlayHintsCache,
  1
  /* InstantiationType.Delayed */
);
var RenderedInlayHintLabelPart = class {
  constructor(item, index) {
    this.item = item;
    this.index = index;
  }
  get part() {
    const label = this.item.hint.label;
    if (typeof label === "string") {
      return { label };
    } else {
      return label[this.index];
    }
  }
};
var ActiveInlayHintInfo = class {
  constructor(part, hasTriggerModifier2) {
    this.part = part;
    this.hasTriggerModifier = hasTriggerModifier2;
  }
};
var _a23;
var InlayHintsController = (_a23 = class {
  static get(editor2) {
    return editor2.getContribution(InlayHintsController_1.ID) ?? void 0;
  }
  constructor(_editor, _languageFeaturesService, _featureDebounce, _inlayHintsCache, _commandService, _notificationService, _instaService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._inlayHintsCache = _inlayHintsCache;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._instaService = _instaService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._decorationsMetadata = /* @__PURE__ */ new Map();
    this._activeRenderMode = 0;
    this._ruleFactory = this._disposables.add(new DynamicCssRules(this._editor));
    this._debounceInfo = _featureDebounce.for(_languageFeaturesService.inlayHintsProvider, "InlayHint", { min: 25 });
    this._disposables.add(_languageFeaturesService.inlayHintsProvider.onDidChange(() => this._update()));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        159
        /* EditorOption.inlayHints */
      )) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._sessionDisposables.dispose();
    this._removeAllDecorations();
    this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    this._removeAllDecorations();
    const options = this._editor.getOption(
      159
      /* EditorOption.inlayHints */
    );
    if (options.enabled === "off") {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.inlayHintsProvider.has(model)) {
      return;
    }
    if (options.enabled === "on") {
      this._activeRenderMode = 0;
    } else {
      let defaultMode;
      let altMode;
      if (options.enabled === "onUnlessPressed") {
        defaultMode = 0;
        altMode = 1;
      } else {
        defaultMode = 1;
        altMode = 0;
      }
      this._activeRenderMode = defaultMode;
      this._sessionDisposables.add(ModifierKeyEmitter.getInstance().event((e) => {
        if (!this._editor.hasModel()) {
          return;
        }
        const newRenderMode = e.altKey && e.ctrlKey && !(e.shiftKey || e.metaKey) ? altMode : defaultMode;
        if (newRenderMode !== this._activeRenderMode) {
          this._activeRenderMode = newRenderMode;
          const model2 = this._editor.getModel();
          const copies = this._copyInlayHintsWithCurrentAnchor(model2);
          this._updateHintsDecorators([model2.getFullModelRange()], copies);
          scheduler.schedule(0);
        }
      }));
    }
    const cached = this._inlayHintsCache.get(model);
    if (cached) {
      this._updateHintsDecorators([model.getFullModelRange()], cached);
    }
    this._sessionDisposables.add(toDisposable(() => {
      if (!model.isDisposed()) {
        this._cacheHintsForFastRestore(model);
      }
    }));
    let cts;
    const watchedProviders = /* @__PURE__ */ new Set();
    const scheduler = new RunOnceScheduler(async () => {
      const t1 = Date.now();
      cts?.dispose(true);
      cts = new CancellationTokenSource();
      const listener = model.onWillDispose(() => cts?.cancel());
      try {
        const myToken = cts.token;
        const inlayHints = await InlayHintsFragments.create(this._languageFeaturesService.inlayHintsProvider, model, this._getHintsRanges(), myToken);
        scheduler.delay = this._debounceInfo.update(model, Date.now() - t1);
        if (myToken.isCancellationRequested) {
          inlayHints.dispose();
          return;
        }
        for (const provider of inlayHints.provider) {
          if (typeof provider.onDidChangeInlayHints === "function" && !watchedProviders.has(provider)) {
            watchedProviders.add(provider);
            this._sessionDisposables.add(provider.onDidChangeInlayHints(() => {
              if (!scheduler.isScheduled()) {
                scheduler.schedule();
              }
            }));
          }
        }
        this._sessionDisposables.add(inlayHints);
        this._updateHintsDecorators(inlayHints.ranges, inlayHints.items);
        this._cacheHintsForFastRestore(model);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        cts.dispose();
        listener.dispose();
      }
    }, this._debounceInfo.get(model));
    this._sessionDisposables.add(scheduler);
    this._sessionDisposables.add(toDisposable(() => cts?.dispose(true)));
    scheduler.schedule(0);
    this._sessionDisposables.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || !scheduler.isScheduled()) {
        scheduler.schedule();
      }
    }));
    const cursor = this._sessionDisposables.add(new MutableDisposable());
    this._sessionDisposables.add(this._editor.onDidChangeModelContent((e) => {
      cts?.cancel();
      const delay = Math.max(scheduler.delay, 800);
      this._cursorInfo = { position: this._editor.getPosition(), notEarlierThan: Date.now() + delay };
      cursor.value = disposableTimeout(() => scheduler.schedule(0), delay);
      scheduler.schedule();
    }));
    this._sessionDisposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        159
        /* EditorOption.inlayHints */
      )) {
        scheduler.schedule();
      }
    }));
    this._sessionDisposables.add(this._installDblClickGesture(() => scheduler.schedule(0)));
    this._sessionDisposables.add(this._installLinkGesture());
    this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const store = new DisposableStore();
    const gesture = store.add(new ClickLinkGesture(this._editor));
    const sessionStore = new DisposableStore();
    store.add(sessionStore);
    store.add(gesture.onMouseMoveOrRelevantKeyDown((e) => {
      const [mouseEvent] = e;
      const labelPart = this._getInlayHintLabelPart(mouseEvent);
      const model = this._editor.getModel();
      if (!labelPart || !model) {
        sessionStore.clear();
        return;
      }
      const cts = new CancellationTokenSource();
      sessionStore.add(toDisposable(() => cts.dispose(true)));
      labelPart.item.resolve(cts.token);
      this._activeInlayHintPart = labelPart.part.command || labelPart.part.location ? new ActiveInlayHintInfo(labelPart, mouseEvent.hasTriggerModifier) : void 0;
      const lineNumber = model.validatePosition(labelPart.item.hint.position).lineNumber;
      const range = new Range(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber));
      const lineHints = this._getInlineHintsForRange(range);
      this._updateHintsDecorators([range], lineHints);
      sessionStore.add(toDisposable(() => {
        this._activeInlayHintPart = void 0;
        this._updateHintsDecorators([range], lineHints);
      }));
    }));
    store.add(gesture.onCancel(() => sessionStore.clear()));
    store.add(gesture.onExecute(async (e) => {
      const label = this._getInlayHintLabelPart(e);
      if (label) {
        const part = label.part;
        if (part.location) {
          this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, part.location);
        } else if (Command.is(part.command)) {
          await this._invokeCommand(part.command, label.item);
        }
      }
    }));
    return store;
  }
  _getInlineHintsForRange(range) {
    const lineHints = /* @__PURE__ */ new Set();
    for (const data of this._decorationsMetadata.values()) {
      if (range.containsRange(data.item.anchor.range)) {
        lineHints.add(data.item);
      }
    }
    return Array.from(lineHints);
  }
  _installDblClickGesture(updateInlayHints) {
    return this._editor.onMouseUp(async (e) => {
      if (e.event.detail !== 2) {
        return;
      }
      const part = this._getInlayHintLabelPart(e);
      if (!part) {
        return;
      }
      e.event.preventDefault();
      await part.item.resolve(CancellationToken.None);
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        const edits = part.item.hint.textEdits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text));
        this._editor.executeEdits("inlayHint.default", edits);
        updateInlayHints();
      }
    });
  }
  _installContextMenu() {
    return this._editor.onContextMenu(async (e) => {
      if (!isHTMLElement(e.event.target)) {
        return;
      }
      const part = this._getInlayHintLabelPart(e);
      if (part) {
        await this._instaService.invokeFunction(showGoToContextMenu, this._editor, e.event.target, part);
      }
    });
  }
  _getInlayHintLabelPart(e) {
    if (e.target.type !== 6) {
      return void 0;
    }
    const options = e.target.detail.injectedText?.options;
    if (options instanceof ModelDecorationInjectedTextOptions && options?.attachedData instanceof RenderedInlayHintLabelPart) {
      return options.attachedData;
    }
    return void 0;
  }
  async _invokeCommand(command, item) {
    try {
      await this._commandService.executeCommand(command.id, ...command.arguments ?? []);
    } catch (err) {
      this._notificationService.notify({
        severity: Severity.Error,
        source: item.provider.displayName,
        message: err
      });
    }
  }
  _cacheHintsForFastRestore(model) {
    const hints = this._copyInlayHintsWithCurrentAnchor(model);
    this._inlayHintsCache.set(model, hints);
  }
  // return inlay hints but with an anchor that reflects "updates"
  // that happened after receiving them, e.g adding new lines before a hint
  _copyInlayHintsWithCurrentAnchor(model) {
    const items = /* @__PURE__ */ new Map();
    for (const [id, obj] of this._decorationsMetadata) {
      if (items.has(obj.item)) {
        continue;
      }
      const range = model.getDecorationRange(id);
      if (range) {
        const anchor = new InlayHintAnchor(range, obj.item.anchor.direction);
        const copy = obj.item.with({ anchor });
        items.set(obj.item, copy);
      }
    }
    return Array.from(items.values());
  }
  _getHintsRanges() {
    const extra = 30;
    const model = this._editor.getModel();
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    const result = [];
    for (const range of visibleRanges.sort(Range.compareRangesUsingStarts)) {
      const extendedRange = model.validateRange(new Range(range.startLineNumber - extra, range.startColumn, range.endLineNumber + extra, range.endColumn));
      if (result.length === 0 || !Range.areIntersectingOrTouching(result[result.length - 1], extendedRange)) {
        result.push(extendedRange);
      } else {
        result[result.length - 1] = Range.plusRange(result[result.length - 1], extendedRange);
      }
    }
    return result;
  }
  _updateHintsDecorators(ranges, items) {
    const itemFixedLengths = /* @__PURE__ */ new Map();
    if (this._cursorInfo && this._cursorInfo.notEarlierThan > Date.now() && ranges.some((range) => range.containsPosition(this._cursorInfo.position))) {
      const { position } = this._cursorInfo;
      this._cursorInfo = void 0;
      const lengths = /* @__PURE__ */ new Map();
      for (const deco of this._editor.getLineDecorations(position.lineNumber) ?? []) {
        const data = this._decorationsMetadata.get(deco.id);
        if (deco.range.startColumn > position.column) {
          continue;
        }
        const opts = data?.decoration.options[data.item.anchor.direction];
        if (opts && opts.attachedData !== InlayHintsController_1._whitespaceData) {
          const len = lengths.get(data.item) ?? 0;
          lengths.set(data.item, len + opts.content.length);
        }
      }
      const newItemsWithFixedLength = items.filter((item) => item.anchor.range.startLineNumber === position.lineNumber && item.anchor.range.endColumn <= position.column);
      const fixedLengths = Array.from(lengths.values());
      let lastItem;
      while (true) {
        const targetItem = newItemsWithFixedLength.shift();
        const fixedLength = fixedLengths.shift();
        if (!fixedLength && !targetItem) {
          break;
        }
        if (targetItem) {
          itemFixedLengths.set(targetItem, fixedLength ?? 0);
          lastItem = targetItem;
        } else if (lastItem && fixedLength) {
          let len = itemFixedLengths.get(lastItem);
          len += fixedLength;
          len += fixedLengths.reduce((p, c) => p + c, 0);
          fixedLengths.length = 0;
          break;
        }
      }
    }
    const newDecorationsData = [];
    const addInjectedText = (item, ref, content, cursorStops, attachedData) => {
      const opts = {
        content,
        inlineClassNameAffectsLetterSpacing: true,
        inlineClassName: ref.className,
        cursorStops,
        attachedData
      };
      newDecorationsData.push({
        item,
        classNameRef: ref,
        decoration: {
          range: item.anchor.range,
          options: {
            // className: "rangeHighlight", // DEBUG highlight to see to what range a hint is attached
            description: "InlayHint",
            showIfCollapsed: item.anchor.range.isEmpty(),
            // "original" range is empty
            collapseOnReplaceEdit: !item.anchor.range.isEmpty(),
            stickiness: 0,
            [item.anchor.direction]: this._activeRenderMode === 0 ? opts : void 0
          }
        }
      });
    };
    const addInjectedWhitespace = (item, isLast) => {
      const marginRule = this._ruleFactory.createClassNameRef({
        width: `${fontSize / 3 | 0}px`,
        display: "inline-block"
      });
      addInjectedText(item, marginRule, " ", isLast ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None, InlayHintsController_1._whitespaceData);
    };
    const { fontSize, fontFamily, padding, isUniform } = this._getLayoutInfo();
    const maxLength = this._editor.getOption(
      159
      /* EditorOption.inlayHints */
    ).maximumLength;
    const fontFamilyVar = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily);
    let currentLineInfo = { line: 0, totalLen: 0 };
    for (let i2 = 0; i2 < items.length; i2++) {
      const item = items[i2];
      if (currentLineInfo.line !== item.anchor.range.startLineNumber) {
        currentLineInfo = { line: item.anchor.range.startLineNumber, totalLen: 0 };
      }
      if (maxLength && currentLineInfo.totalLen > maxLength) {
        continue;
      }
      if (item.hint.paddingLeft) {
        addInjectedWhitespace(item, false);
      }
      const parts = typeof item.hint.label === "string" ? [{ label: item.hint.label }] : item.hint.label;
      const itemFixedLength = itemFixedLengths.get(item);
      let itemActualLength = 0;
      for (let i3 = 0; i3 < parts.length; i3++) {
        const part = parts[i3];
        const isFirst = i3 === 0;
        const isLast = i3 === parts.length - 1;
        const cssProperties = {
          fontSize: `${fontSize}px`,
          fontFamily: `var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}`,
          verticalAlign: isUniform ? "baseline" : "middle",
          unicodeBidi: "isolate"
        };
        if (isNonEmptyArray(item.hint.textEdits)) {
          cssProperties.cursor = "default";
        }
        this._fillInColors(cssProperties, item.hint);
        if ((part.command || part.location) && this._activeInlayHintPart?.part.item === item && this._activeInlayHintPart.part.index === i3) {
          cssProperties.textDecoration = "underline";
          if (this._activeInlayHintPart.hasTriggerModifier) {
            cssProperties.color = themeColorFromId(editorActiveLinkForeground);
            cssProperties.cursor = "pointer";
          }
        }
        let textlabel = part.label;
        currentLineInfo.totalLen += textlabel.length;
        let tooLong = false;
        const over = maxLength !== 0 ? currentLineInfo.totalLen - maxLength : 0;
        if (over > 0) {
          textlabel = textlabel.slice(0, -over) + "…";
          tooLong = true;
        }
        itemActualLength += textlabel.length;
        if (itemFixedLength !== void 0) {
          const overFixedLength = itemActualLength - itemFixedLength;
          if (overFixedLength >= 0) {
            itemActualLength -= overFixedLength;
            textlabel = textlabel.slice(0, -(1 + overFixedLength)) + "…";
            tooLong = true;
          }
        }
        if (padding) {
          if (isFirst && (isLast || tooLong)) {
            cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px`;
            cssProperties.borderRadius = `${fontSize / 4 | 0}px`;
          } else if (isFirst) {
            cssProperties.padding = `1px 0 1px ${Math.max(1, fontSize / 4) | 0}px`;
            cssProperties.borderRadius = `${fontSize / 4 | 0}px 0 0 ${fontSize / 4 | 0}px`;
          } else if (isLast || tooLong) {
            cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px 1px 0`;
            cssProperties.borderRadius = `0 ${fontSize / 4 | 0}px ${fontSize / 4 | 0}px 0`;
          } else {
            cssProperties.padding = `1px 0 1px 0`;
          }
        }
        addInjectedText(item, this._ruleFactory.createClassNameRef(cssProperties), fixSpace(textlabel), isLast && !item.hint.paddingRight ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None, new RenderedInlayHintLabelPart(item, i3));
        if (tooLong) {
          break;
        }
      }
      if (itemFixedLength !== void 0 && itemActualLength < itemFixedLength) {
        const pad = itemFixedLength - itemActualLength;
        addInjectedText(item, this._ruleFactory.createClassNameRef({}), " ".repeat(pad), InjectedTextCursorStops.None);
      }
      if (item.hint.paddingRight) {
        addInjectedWhitespace(item, true);
      }
      if (newDecorationsData.length > InlayHintsController_1._MAX_DECORATORS) {
        break;
      }
    }
    const decorationIdsToReplace = [];
    for (const [id, metadata] of this._decorationsMetadata) {
      const range = this._editor.getModel()?.getDecorationRange(id);
      if (range && ranges.some((r) => r.containsRange(range))) {
        decorationIdsToReplace.push(id);
        metadata.classNameRef.dispose();
        this._decorationsMetadata.delete(id);
      }
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    this._editor.changeDecorations((accessor) => {
      const newDecorationIds = accessor.deltaDecorations(decorationIdsToReplace, newDecorationsData.map((d) => d.decoration));
      for (let i2 = 0; i2 < newDecorationIds.length; i2++) {
        const data = newDecorationsData[i2];
        this._decorationsMetadata.set(newDecorationIds[i2], data);
      }
    });
    scrollState.restore(this._editor);
  }
  _fillInColors(props, hint) {
    if (hint.kind === InlayHintKind.Parameter) {
      props.backgroundColor = themeColorFromId(editorInlayHintParameterBackground);
      props.color = themeColorFromId(editorInlayHintParameterForeground);
    } else if (hint.kind === InlayHintKind.Type) {
      props.backgroundColor = themeColorFromId(editorInlayHintTypeBackground);
      props.color = themeColorFromId(editorInlayHintTypeForeground);
    } else {
      props.backgroundColor = themeColorFromId(editorInlayHintBackground);
      props.color = themeColorFromId(editorInlayHintForeground);
    }
  }
  _getLayoutInfo() {
    const options = this._editor.getOption(
      159
      /* EditorOption.inlayHints */
    );
    const padding = options.padding;
    const editorFontSize = this._editor.getOption(
      61
      /* EditorOption.fontSize */
    );
    const editorFontFamily = this._editor.getOption(
      58
      /* EditorOption.fontFamily */
    );
    let fontSize = options.fontSize;
    if (!fontSize || fontSize < 5 || fontSize > editorFontSize) {
      fontSize = editorFontSize;
    }
    const fontFamily = options.fontFamily || editorFontFamily;
    const isUniform = !padding && fontFamily === editorFontFamily && fontSize === editorFontSize;
    return { fontSize, fontFamily, padding, isUniform };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const obj of this._decorationsMetadata.values()) {
      obj.classNameRef.dispose();
    }
    this._decorationsMetadata.clear();
  }
}, InlayHintsController_1 = _a23, _a23.ID = "editor.contrib.InlayHints", _a23._MAX_DECORATORS = 1500, _a23._whitespaceData = {}, _a23);
InlayHintsController = InlayHintsController_1 = __decorate27([
  __param27(1, ILanguageFeaturesService),
  __param27(2, ILanguageFeatureDebounceService),
  __param27(3, IInlayHintsCache),
  __param27(4, ICommandService),
  __param27(5, INotificationService),
  __param27(6, IInstantiationService)
], InlayHintsController);
function fixSpace(str) {
  const noBreakWhitespace2 = " ";
  return str.replace(/[ \t]/g, noBreakWhitespace2);
}
CommandsRegistry.registerCommand("_executeInlayHintProvider", async (accessor, ...args) => {
  const [uri, range] = args;
  assertType(URI.isUri(uri));
  assertType(Range.isIRange(range));
  const { inlayHintsProvider } = accessor.get(ILanguageFeaturesService);
  const ref = await accessor.get(ITextModelService).createModelReference(uri);
  try {
    const model = await InlayHintsFragments.create(inlayHintsProvider, ref.object.textEditorModel, [Range.lift(range)], CancellationToken.None);
    const result = model.items.map((i2) => i2.hint);
    setTimeout(() => model.dispose(), 0);
    return result;
  } finally {
    ref.dispose();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js
init_configuration();
init_languageFeatures();
init_nls();
init_platform();
init_arrays();
init_commands();
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlayHintsHoverAnchor = class extends HoverForeignElementAnchor {
  constructor(part, owner, initialMousePosX, initialMousePosY) {
    super(10, owner, part.item.anchor.range, initialMousePosX, initialMousePosY, true);
    this.part = part;
  }
};
var InlayHintsHover = class InlayHintsHover2 extends MarkdownHoverParticipant {
  constructor(editor2, languageService, openerService, keybindingService, hoverService, configurationService, _resolverService, languageFeaturesService, commandService) {
    super(editor2, languageService, openerService, configurationService, languageFeaturesService, keybindingService, hoverService, commandService);
    this._resolverService = _resolverService;
    this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = InlayHintsController.get(this._editor);
    if (!controller) {
      return null;
    }
    if (mouseEvent.target.type !== 6) {
      return null;
    }
    const options = mouseEvent.target.detail.injectedText?.options;
    if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) {
      return null;
    }
    return new InlayHintsHoverAnchor(options.attachedData, this, mouseEvent.event.posx, mouseEvent.event.posy);
  }
  computeSync() {
    return [];
  }
  computeAsync(anchor, _lineDecorations, source, token) {
    if (!(anchor instanceof InlayHintsHoverAnchor)) {
      return AsyncIterableProducer.EMPTY;
    }
    return new AsyncIterableProducer(async (executor) => {
      const { part } = anchor;
      await part.item.resolve(token);
      if (token.isCancellationRequested) {
        return;
      }
      let itemTooltip;
      if (typeof part.item.hint.tooltip === "string") {
        itemTooltip = new MarkdownString().appendText(part.item.hint.tooltip);
      } else if (part.item.hint.tooltip) {
        itemTooltip = part.item.hint.tooltip;
      }
      if (itemTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [itemTooltip], false, 0));
      }
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize(1157, "Double-click to insert"))], false, 10001));
      }
      let partTooltip;
      if (typeof part.part.tooltip === "string") {
        partTooltip = new MarkdownString().appendText(part.part.tooltip);
      } else if (part.part.tooltip) {
        partTooltip = part.part.tooltip;
      }
      if (partTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [partTooltip], false, 1));
      }
      if (part.part.location || part.part.command) {
        let linkHint;
        const useMetaKey = this._editor.getOption(
          86
          /* EditorOption.multiCursorModifier */
        ) === "altKey";
        const kb = useMetaKey ? isMacintosh ? localize(1158, "cmd + click") : localize(1159, "ctrl + click") : isMacintosh ? localize(1160, "option + click") : localize(1161, "alt + click");
        if (part.part.location && part.part.command) {
          linkHint = new MarkdownString().appendText(localize(1162, "Go to Definition ({0}), right click for more", kb));
        } else if (part.part.location) {
          linkHint = new MarkdownString().appendText(localize(1163, "Go to Definition ({0})", kb));
        } else if (part.part.command) {
          linkHint = new MarkdownString(`[${localize(1164, "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
        }
        if (linkHint) {
          executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], false, 1e4));
        }
      }
      const iterable = this._resolveInlayHintLabelPartHover(part, token);
      for await (const item of iterable) {
        executor.emitOne(item);
      }
    });
  }
  async *_resolveInlayHintLabelPartHover(part, token) {
    if (!part.part.location) {
      return;
    }
    const { uri, range } = part.part.location;
    const ref = await this._resolverService.createModelReference(uri);
    try {
      const model = ref.object.textEditorModel;
      if (!this._languageFeaturesService.hoverProvider.has(model)) {
        return;
      }
      for await (const item of getHoverProviderResultsAsAsyncIterable(this._languageFeaturesService.hoverProvider, model, new Position(range.startLineNumber, range.startColumn), token)) {
        if (!isEmptyMarkdownString(item.hover.contents)) {
          yield new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal);
        }
      }
    } finally {
      ref.dispose();
    }
  }
};
InlayHintsHover = __decorate28([
  __param28(1, ILanguageService),
  __param28(2, IOpenerService),
  __param28(3, IKeybindingService),
  __param28(4, IHoverService),
  __param28(5, IConfigurationService),
  __param28(6, ITextModelService),
  __param28(7, ILanguageFeaturesService),
  __param28(8, ICommandService)
], InlayHintsHover);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverRendered.js
init_errors();
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RenderedContentHover_1;
var RenderedContentHoverParts_1;
var RenderedContentHover = RenderedContentHover_1 = class RenderedContentHover2 extends Disposable {
  constructor(editor2, hoverResult, participants, context, keybindingService, hoverService) {
    super();
    const parts = hoverResult.hoverParts;
    this._renderedHoverParts = this._register(new RenderedContentHoverParts(editor2, participants, parts, context, keybindingService, hoverService));
    const contentHoverComputerOptions = hoverResult.options;
    const anchor = contentHoverComputerOptions.anchor;
    const { showAtPosition, showAtSecondaryPosition } = RenderedContentHover_1.computeHoverPositions(editor2, anchor.range, parts);
    this.shouldAppearBeforeContent = parts.some((m) => m.isBeforeContent);
    this.showAtPosition = showAtPosition;
    this.showAtSecondaryPosition = showAtSecondaryPosition;
    this.initialMousePosX = anchor.initialMousePosX;
    this.initialMousePosY = anchor.initialMousePosY;
    this.shouldFocus = contentHoverComputerOptions.shouldFocus;
    this.source = contentHoverComputerOptions.source;
  }
  get domNode() {
    return this._renderedHoverParts.domNode;
  }
  get domNodeHasChildren() {
    return this._renderedHoverParts.domNodeHasChildren;
  }
  get focusedHoverPartIndex() {
    return this._renderedHoverParts.focusedHoverPartIndex;
  }
  get hoverPartsCount() {
    return this._renderedHoverParts.hoverPartsCount;
  }
  focusHoverPartWithIndex(index) {
    this._renderedHoverParts.focusHoverPartWithIndex(index);
  }
  async updateHoverVerbosityLevel(action, index, focus) {
    this._renderedHoverParts.updateHoverVerbosityLevel(action, index, focus);
  }
  isColorPickerVisible() {
    return this._renderedHoverParts.isColorPickerVisible();
  }
  static computeHoverPositions(editor2, anchorRange, hoverParts) {
    let startColumnBoundary = 1;
    if (editor2.hasModel()) {
      const viewModel = editor2._getViewModel();
      const coordinatesConverter = viewModel.coordinatesConverter;
      const anchorViewRange = coordinatesConverter.convertModelRangeToViewRange(anchorRange);
      const anchorViewMinColumn = viewModel.getLineMinColumn(anchorViewRange.startLineNumber);
      const anchorViewRangeStart = new Position(anchorViewRange.startLineNumber, anchorViewMinColumn);
      startColumnBoundary = coordinatesConverter.convertViewPositionToModelPosition(anchorViewRangeStart).column;
    }
    const anchorStartLineNumber = anchorRange.startLineNumber;
    let secondaryPositionColumn = anchorRange.startColumn;
    let forceShowAtRange;
    for (const hoverPart of hoverParts) {
      const hoverPartRange = hoverPart.range;
      const hoverPartRangeOnAnchorStartLine = hoverPartRange.startLineNumber === anchorStartLineNumber;
      const hoverPartRangeOnAnchorEndLine = hoverPartRange.endLineNumber === anchorStartLineNumber;
      const hoverPartRangeIsOnAnchorLine = hoverPartRangeOnAnchorStartLine && hoverPartRangeOnAnchorEndLine;
      if (hoverPartRangeIsOnAnchorLine) {
        const hoverPartStartColumn = hoverPartRange.startColumn;
        const minSecondaryPositionColumn = Math.min(secondaryPositionColumn, hoverPartStartColumn);
        secondaryPositionColumn = Math.max(minSecondaryPositionColumn, startColumnBoundary);
      }
      if (hoverPart.forceShowAtRange) {
        forceShowAtRange = hoverPartRange;
      }
    }
    let showAtPosition;
    let showAtSecondaryPosition;
    if (forceShowAtRange) {
      const forceShowAtPosition = forceShowAtRange.getStartPosition();
      showAtPosition = forceShowAtPosition;
      showAtSecondaryPosition = forceShowAtPosition;
    } else {
      showAtPosition = anchorRange.getStartPosition();
      showAtSecondaryPosition = new Position(anchorStartLineNumber, secondaryPositionColumn);
    }
    return {
      showAtPosition,
      showAtSecondaryPosition
    };
  }
};
RenderedContentHover = RenderedContentHover_1 = __decorate29([
  __param29(4, IKeybindingService),
  __param29(5, IHoverService)
], RenderedContentHover);
var RenderedStatusBar = class {
  constructor(fragment, _statusBar) {
    this._statusBar = _statusBar;
    fragment.appendChild(this._statusBar.hoverElement);
  }
  get hoverElement() {
    return this._statusBar.hoverElement;
  }
  get actions() {
    return this._statusBar.actions;
  }
  dispose() {
    this._statusBar.dispose();
  }
};
var _a24;
var RenderedContentHoverParts = (_a24 = class extends Disposable {
  constructor(editor2, participants, hoverParts, context, keybindingService, hoverService) {
    super();
    this._renderedParts = [];
    this._focusedHoverPartIndex = -1;
    this._context = context;
    this._fragment = document.createDocumentFragment();
    this._register(this._renderParts(participants, hoverParts, context, keybindingService, hoverService));
    this._register(this._registerListenersOnRenderedParts());
    this._register(this._createEditorDecorations(editor2, hoverParts));
    this._updateMarkdownAndColorParticipantInfo(participants);
  }
  _createEditorDecorations(editor2, hoverParts) {
    if (hoverParts.length === 0) {
      return Disposable.None;
    }
    let highlightRange = hoverParts[0].range;
    for (const hoverPart of hoverParts) {
      const hoverPartRange = hoverPart.range;
      highlightRange = Range.plusRange(highlightRange, hoverPartRange);
    }
    const highlightDecoration = editor2.createDecorationsCollection();
    highlightDecoration.set([{
      range: highlightRange,
      options: RenderedContentHoverParts_1._DECORATION_OPTIONS
    }]);
    return toDisposable(() => {
      highlightDecoration.clear();
    });
  }
  _renderParts(participants, hoverParts, hoverContext, keybindingService, hoverService) {
    const statusBar = new EditorHoverStatusBar(keybindingService, hoverService);
    const hoverRenderingContext = {
      fragment: this._fragment,
      statusBar,
      ...hoverContext
    };
    const disposables = new DisposableStore();
    disposables.add(statusBar);
    for (const participant of participants) {
      const renderedHoverParts = this._renderHoverPartsForParticipant(hoverParts, participant, hoverRenderingContext);
      disposables.add(renderedHoverParts);
      for (const renderedHoverPart of renderedHoverParts.renderedHoverParts) {
        this._renderedParts.push({
          type: "hoverPart",
          participant,
          hoverPart: renderedHoverPart.hoverPart,
          hoverElement: renderedHoverPart.hoverElement
        });
      }
    }
    const renderedStatusBar = this._renderStatusBar(this._fragment, statusBar);
    if (renderedStatusBar) {
      disposables.add(renderedStatusBar);
      this._renderedParts.push({
        type: "statusBar",
        hoverElement: renderedStatusBar.hoverElement,
        actions: renderedStatusBar.actions
      });
    }
    return disposables;
  }
  _renderHoverPartsForParticipant(hoverParts, participant, hoverRenderingContext) {
    const hoverPartsForParticipant = hoverParts.filter((hoverPart) => hoverPart.owner === participant);
    const hasHoverPartsForParticipant = hoverPartsForParticipant.length > 0;
    if (!hasHoverPartsForParticipant) {
      return new RenderedHoverParts([]);
    }
    return participant.renderHoverParts(hoverRenderingContext, hoverPartsForParticipant);
  }
  _renderStatusBar(fragment, statusBar) {
    if (!statusBar.hasContent) {
      return void 0;
    }
    return new RenderedStatusBar(fragment, statusBar);
  }
  _registerListenersOnRenderedParts() {
    const disposables = new DisposableStore();
    this._renderedParts.forEach((renderedPart, index) => {
      const element = renderedPart.hoverElement;
      element.tabIndex = 0;
      disposables.add(addDisposableListener(element, EventType.FOCUS_IN, (event) => {
        event.stopPropagation();
        this._focusedHoverPartIndex = index;
      }));
      disposables.add(addDisposableListener(element, EventType.FOCUS_OUT, (event) => {
        event.stopPropagation();
        this._focusedHoverPartIndex = -1;
      }));
    });
    return disposables;
  }
  _updateMarkdownAndColorParticipantInfo(participants) {
    const markdownHoverParticipant = participants.find((p) => {
      return p instanceof MarkdownHoverParticipant && !(p instanceof InlayHintsHover);
    });
    if (markdownHoverParticipant) {
      this._markdownHoverParticipant = markdownHoverParticipant;
    }
    this._colorHoverParticipant = participants.find((p) => p instanceof HoverColorPickerParticipant);
  }
  focusHoverPartWithIndex(index) {
    if (index < 0 || index >= this._renderedParts.length) {
      return;
    }
    this._renderedParts[index].hoverElement.focus();
  }
  async updateHoverVerbosityLevel(action, index, focus) {
    if (!this._markdownHoverParticipant) {
      return;
    }
    let rangeOfIndicesToUpdate;
    if (index >= 0) {
      rangeOfIndicesToUpdate = { start: index, endExclusive: index + 1 };
    } else {
      rangeOfIndicesToUpdate = this._findRangeOfMarkdownHoverParts(this._markdownHoverParticipant);
    }
    for (let i2 = rangeOfIndicesToUpdate.start; i2 < rangeOfIndicesToUpdate.endExclusive; i2++) {
      const normalizedMarkdownHoverIndex = this._normalizedIndexToMarkdownHoverIndexRange(this._markdownHoverParticipant, i2);
      if (normalizedMarkdownHoverIndex === void 0) {
        continue;
      }
      const renderedPart = await this._markdownHoverParticipant.updateMarkdownHoverVerbosityLevel(action, normalizedMarkdownHoverIndex);
      if (!renderedPart) {
        continue;
      }
      this._renderedParts[i2] = {
        type: "hoverPart",
        participant: this._markdownHoverParticipant,
        hoverPart: renderedPart.hoverPart,
        hoverElement: renderedPart.hoverElement
      };
    }
    if (focus) {
      if (index >= 0) {
        this.focusHoverPartWithIndex(index);
      } else {
        this._context.focus();
      }
    }
    this._context.onContentsChanged();
  }
  isColorPickerVisible() {
    return this._colorHoverParticipant?.isColorPickerVisible() ?? false;
  }
  _normalizedIndexToMarkdownHoverIndexRange(markdownHoverParticipant, index) {
    const renderedPart = this._renderedParts[index];
    if (!renderedPart || renderedPart.type !== "hoverPart") {
      return void 0;
    }
    const isHoverPartMarkdownHover = renderedPart.participant === markdownHoverParticipant;
    if (!isHoverPartMarkdownHover) {
      return void 0;
    }
    const firstIndexOfMarkdownHovers = this._renderedParts.findIndex((renderedPart2) => renderedPart2.type === "hoverPart" && renderedPart2.participant === markdownHoverParticipant);
    if (firstIndexOfMarkdownHovers === -1) {
      throw new BugIndicatingError();
    }
    return index - firstIndexOfMarkdownHovers;
  }
  _findRangeOfMarkdownHoverParts(markdownHoverParticipant) {
    const copiedRenderedParts = this._renderedParts.slice();
    const firstIndexOfMarkdownHovers = copiedRenderedParts.findIndex((renderedPart) => renderedPart.type === "hoverPart" && renderedPart.participant === markdownHoverParticipant);
    const inversedLastIndexOfMarkdownHovers = copiedRenderedParts.reverse().findIndex((renderedPart) => renderedPart.type === "hoverPart" && renderedPart.participant === markdownHoverParticipant);
    const lastIndexOfMarkdownHovers = inversedLastIndexOfMarkdownHovers >= 0 ? copiedRenderedParts.length - inversedLastIndexOfMarkdownHovers : inversedLastIndexOfMarkdownHovers;
    return { start: firstIndexOfMarkdownHovers, endExclusive: lastIndexOfMarkdownHovers + 1 };
  }
  get domNode() {
    return this._fragment;
  }
  get domNodeHasChildren() {
    return this._fragment.hasChildNodes();
  }
  get focusedHoverPartIndex() {
    return this._focusedHoverPartIndex;
  }
  get hoverPartsCount() {
    return this._renderedParts.length;
  }
}, RenderedContentHoverParts_1 = _a24, _a24._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
}), _a24);
RenderedContentHoverParts = RenderedContentHoverParts_1 = __decorate29([
  __param29(4, IKeybindingService),
  __param29(5, IHoverService)
], RenderedContentHoverParts);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverWidgetWrapper.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContentHoverWidgetWrapper = class ContentHoverWidgetWrapper2 extends Disposable {
  constructor(_editor, _instantiationService, _keybindingService, _hoverService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._keybindingService = _keybindingService;
    this._hoverService = _hoverService;
    this._currentResult = null;
    this._renderedContentHover = this._register(new MutableDisposable());
    this._onContentsChanged = this._register(new Emitter());
    this.onContentsChanged = this._onContentsChanged.event;
    this._contentHoverWidget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor));
    this._participants = this._initializeHoverParticipants();
    this._hoverOperation = this._register(new HoverOperation(this._editor, new ContentHoverComputer(this._editor, this._participants)));
    this._registerListeners();
  }
  _initializeHoverParticipants() {
    const participants = [];
    for (const participant of HoverParticipantRegistry.getAll()) {
      const participantInstance = this._instantiationService.createInstance(participant, this._editor);
      participants.push(participantInstance);
    }
    participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);
    this._register(this._contentHoverWidget.onDidResize(() => {
      this._participants.forEach((participant) => participant.handleResize?.());
    }));
    this._register(this._contentHoverWidget.onDidScroll((e) => {
      this._participants.forEach((participant) => participant.handleScroll?.(e));
    }));
    this._register(this._contentHoverWidget.onContentsChanged(() => {
      this._participants.forEach((participant) => participant.handleContentsChanged?.());
    }));
    return participants;
  }
  _registerListeners() {
    this._register(this._hoverOperation.onResult((result) => {
      const messages = result.hasLoadingMessage ? this._addLoadingMessage(result) : result.value;
      this._withResult(new ContentHoverResult(messages, result.isComplete, result.options));
    }));
    const contentHoverWidgetNode = this._contentHoverWidget.getDomNode();
    this._register(addStandardDisposableListener(contentHoverWidgetNode, "keydown", (e) => {
      if (e.equals(
        9
        /* KeyCode.Escape */
      )) {
        this.hide();
      }
    }));
    this._register(addStandardDisposableListener(contentHoverWidgetNode, "mouseleave", (e) => {
      this._onMouseLeave(e);
    }));
    this._register(TokenizationRegistry.onDidChange(() => {
      if (this._contentHoverWidget.position && this._currentResult) {
        this._setCurrentResult(this._currentResult);
      }
    }));
    this._register(this._contentHoverWidget.onContentsChanged(() => {
      this._onContentsChanged.fire();
    }));
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(anchor, mode, source, focus, mouseEvent) {
    const contentHoverIsVisible = this._contentHoverWidget.position && this._currentResult;
    if (!contentHoverIsVisible) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
        return true;
      }
      return false;
    }
    const isHoverSticky = this._editor.getOption(
      69
      /* EditorOption.hover */
    ).sticky;
    const isMouseGettingCloser = mouseEvent && this._contentHoverWidget.isMouseGettingCloser(mouseEvent.event.posx, mouseEvent.event.posy);
    const isHoverStickyAndIsMouseGettingCloser = isHoverSticky && isMouseGettingCloser;
    if (isHoverStickyAndIsMouseGettingCloser) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, true);
      }
      return true;
    }
    if (!anchor) {
      this._setCurrentResult(null);
      return false;
    }
    const currentAnchorEqualsPreviousAnchor = this._currentResult && this._currentResult.options.anchor.equals(anchor);
    if (currentAnchorEqualsPreviousAnchor) {
      return true;
    }
    const currentAnchorCompatibleWithPreviousAnchor = this._currentResult && anchor.canAdoptVisibleHover(this._currentResult.options.anchor, this._contentHoverWidget.position);
    if (!currentAnchorCompatibleWithPreviousAnchor) {
      this._setCurrentResult(null);
      this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
      return true;
    }
    if (this._currentResult) {
      this._setCurrentResult(this._currentResult.filter(anchor));
    }
    this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
    return true;
  }
  _startHoverOperationIfNecessary(anchor, mode, source, shouldFocus, insistOnKeepingHoverVisible) {
    const currentAnchorEqualToPreviousHover = this._hoverOperation.options && this._hoverOperation.options.anchor.equals(anchor);
    if (currentAnchorEqualToPreviousHover) {
      return;
    }
    this._hoverOperation.cancel();
    const contentHoverComputerOptions = {
      anchor,
      source,
      shouldFocus,
      insistOnKeepingHoverVisible
    };
    this._hoverOperation.start(mode, contentHoverComputerOptions);
  }
  _setCurrentResult(hoverResult) {
    let currentHoverResult = hoverResult;
    const currentResultEqualToPreviousResult = this._currentResult === currentHoverResult;
    if (currentResultEqualToPreviousResult) {
      return;
    }
    const currentHoverResultIsEmpty = currentHoverResult && currentHoverResult.hoverParts.length === 0;
    if (currentHoverResultIsEmpty) {
      currentHoverResult = null;
    }
    this._currentResult = currentHoverResult;
    if (this._currentResult) {
      this._showHover(this._currentResult);
    } else {
      this._hideHover();
    }
  }
  _addLoadingMessage(hoverResult) {
    for (const participant of this._participants) {
      if (!participant.createLoadingMessage) {
        continue;
      }
      const loadingMessage = participant.createLoadingMessage(hoverResult.options.anchor);
      if (!loadingMessage) {
        continue;
      }
      return hoverResult.value.slice(0).concat([loadingMessage]);
    }
    return hoverResult.value;
  }
  _withResult(hoverResult) {
    const previousHoverIsVisibleWithCompleteResult = this._contentHoverWidget.position && this._currentResult && this._currentResult.isComplete;
    if (!previousHoverIsVisibleWithCompleteResult) {
      this._setCurrentResult(hoverResult);
    }
    const isCurrentHoverResultComplete = hoverResult.isComplete;
    if (!isCurrentHoverResultComplete) {
      return;
    }
    const currentHoverResultIsEmpty = hoverResult.hoverParts.length === 0;
    const insistOnKeepingPreviousHoverVisible = hoverResult.options.insistOnKeepingHoverVisible;
    const shouldKeepPreviousHoverVisible = currentHoverResultIsEmpty && insistOnKeepingPreviousHoverVisible;
    if (shouldKeepPreviousHoverVisible) {
      return;
    }
    this._setCurrentResult(hoverResult);
  }
  _showHover(hoverResult) {
    const context = this._getHoverContext();
    this._renderedContentHover.value = new RenderedContentHover(this._editor, hoverResult, this._participants, context, this._keybindingService, this._hoverService);
    if (this._renderedContentHover.value.domNodeHasChildren) {
      this._contentHoverWidget.show(this._renderedContentHover.value);
    } else {
      this._renderedContentHover.clear();
    }
  }
  _hideHover() {
    this._contentHoverWidget.hide();
    this._participants.forEach((participant) => participant.handleHide?.());
  }
  _getHoverContext() {
    const hide2 = () => {
      this.hide();
    };
    const onContentsChanged = () => {
      this._contentHoverWidget.handleContentsChanged();
    };
    const setMinimumDimensions = (dimensions) => {
      this._contentHoverWidget.setMinimumDimensions(dimensions);
    };
    const focus = () => this.focus();
    return { hide: hide2, onContentsChanged, setMinimumDimensions, focus };
  }
  showsOrWillShow(mouseEvent) {
    const isContentWidgetResizing = this._contentHoverWidget.isResizing;
    if (isContentWidgetResizing) {
      return true;
    }
    const anchorCandidates = this._findHoverAnchorCandidates(mouseEvent);
    const anchorCandidatesExist = anchorCandidates.length > 0;
    if (!anchorCandidatesExist) {
      return this._startShowingOrUpdateHover(null, 0, 0, false, mouseEvent);
    }
    const anchor = anchorCandidates[0];
    return this._startShowingOrUpdateHover(anchor, 0, 0, false, mouseEvent);
  }
  _findHoverAnchorCandidates(mouseEvent) {
    const anchorCandidates = [];
    for (const participant of this._participants) {
      if (!participant.suggestHoverAnchor) {
        continue;
      }
      const anchor = participant.suggestHoverAnchor(mouseEvent);
      if (!anchor) {
        continue;
      }
      anchorCandidates.push(anchor);
    }
    const target = mouseEvent.target;
    switch (target.type) {
      case 6: {
        anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
        break;
      }
      case 7: {
        const epsilon = this._editor.getOption(
          59
          /* EditorOption.fontInfo */
        ).typicalHalfwidthCharacterWidth / 2;
        const mouseIsWithinLinesAndCloseToHover = !target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === "number" && target.detail.horizontalDistanceToText < epsilon;
        if (!mouseIsWithinLinesAndCloseToHover) {
          break;
        }
        anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
        break;
      }
    }
    anchorCandidates.sort((a, b) => b.priority - a.priority);
    return anchorCandidates;
  }
  _onMouseLeave(e) {
    const editorDomNode = this._editor.getDomNode();
    const isMousePositionOutsideOfEditor = !editorDomNode || !isMousePositionWithinElement(editorDomNode, e.x, e.y);
    if (isMousePositionOutsideOfEditor) {
      this.hide();
    }
  }
  startShowingAtRange(range, mode, source, focus) {
    this._startShowingOrUpdateHover(new HoverRangeAnchor(0, range, void 0, void 0), mode, source, focus, null);
  }
  async updateHoverVerbosityLevel(action, index, focus) {
    this._renderedContentHover.value?.updateHoverVerbosityLevel(action, index, focus);
  }
  focusedHoverPartIndex() {
    return this._renderedContentHover.value?.focusedHoverPartIndex ?? -1;
  }
  containsNode(node) {
    return node ? this._contentHoverWidget.getDomNode().contains(node) : false;
  }
  focus() {
    const hoverPartsCount = this._renderedContentHover.value?.hoverPartsCount;
    if (hoverPartsCount === 1) {
      this.focusHoverPartWithIndex(0);
      return;
    }
    this._contentHoverWidget.focus();
  }
  focusHoverPartWithIndex(index) {
    this._renderedContentHover.value?.focusHoverPartWithIndex(index);
  }
  scrollUp() {
    this._contentHoverWidget.scrollUp();
  }
  scrollDown() {
    this._contentHoverWidget.scrollDown();
  }
  scrollLeft() {
    this._contentHoverWidget.scrollLeft();
  }
  scrollRight() {
    this._contentHoverWidget.scrollRight();
  }
  pageUp() {
    this._contentHoverWidget.pageUp();
  }
  pageDown() {
    this._contentHoverWidget.pageDown();
  }
  goToTop() {
    this._contentHoverWidget.goToTop();
  }
  goToBottom() {
    this._contentHoverWidget.goToBottom();
  }
  hide() {
    this._hoverOperation.cancel();
    this._setCurrentResult(null);
  }
  getDomNode() {
    return this._contentHoverWidget.getDomNode();
  }
  get isColorPickerVisible() {
    return this._renderedContentHover.value?.isColorPickerVisible() ?? false;
  }
  get isVisibleFromKeyboard() {
    return this._contentHoverWidget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._contentHoverWidget.isVisible;
  }
  get isFocused() {
    return this._contentHoverWidget.isFocused;
  }
  get isResizing() {
    return this._contentHoverWidget.isResizing;
  }
  get widget() {
    return this._contentHoverWidget;
  }
};
ContentHoverWidgetWrapper = __decorate30([
  __param30(1, IInstantiationService),
  __param30(2, IKeybindingService),
  __param30(3, IHoverService)
], ContentHoverWidgetWrapper);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverController.js
init_event();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/hoverColorPicker/hoverColorPicker.js
function isOnColorDecorator(mouseEvent) {
  const target = mouseEvent.target;
  return !!target && target.type === 6 && target.detail.injectedText?.options.attachedData === ColorDecorationInjectedTextMarker;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHoverController.js
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContentHoverController_1;
var _sticky = false;
var _a25;
var ContentHoverController = (_a25 = class extends Disposable {
  constructor(_editor, _contextMenuService, _instantiationService, _keybindingService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._keybindingService = _keybindingService;
    this._onHoverContentsChanged = this._register(new Emitter());
    this.shouldKeepOpenOnEditorMouseMoveOrLeave = false;
    this._listenersStore = new DisposableStore();
    this._isMouseDown = false;
    this._ignoreMouseEvents = false;
    this._reactToEditorMouseMoveRunner = this._register(new RunOnceScheduler(() => {
      if (this._mouseMoveEvent) {
        this._reactToEditorMouseMove(this._mouseMoveEvent);
      }
    }, 0));
    this._register(_contextMenuService.onDidShowContextMenu(() => {
      this.hideContentHover();
      this._ignoreMouseEvents = true;
    }));
    this._register(_contextMenuService.onDidHideContextMenu(() => {
      this._ignoreMouseEvents = false;
    }));
    this._hookListeners();
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        69
        /* EditorOption.hover */
      )) {
        this._unhookListeners();
        this._hookListeners();
      }
    }));
  }
  static get(editor2) {
    return editor2.getContribution(ContentHoverController_1.ID);
  }
  _hookListeners() {
    const hoverOpts = this._editor.getOption(
      69
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: hoverOpts.enabled,
      sticky: hoverOpts.sticky,
      hidingDelay: hoverOpts.hidingDelay
    };
    if (!hoverOpts.enabled) {
      this._cancelSchedulerAndHide();
    }
    this._listenersStore.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp()));
    this._listenersStore.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
    this._listenersStore.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    this._listenersStore.add(this._editor.onMouseLeave((e) => this._onEditorMouseLeave(e)));
    this._listenersStore.add(this._editor.onDidChangeModel(() => this._cancelSchedulerAndHide()));
    this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler()));
    this._listenersStore.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelSchedulerAndHide() {
    this._cancelScheduler();
    this.hideContentHover();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0;
    this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    if (this._ignoreMouseEvents) {
      return;
    }
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this.hideContentHover();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    if (this._ignoreMouseEvents) {
      return;
    }
    this._isMouseDown = true;
    const shouldKeepHoverWidgetVisible = this._shouldKeepHoverWidgetVisible(mouseEvent);
    if (shouldKeepHoverWidgetVisible) {
      return;
    }
    this.hideContentHover();
  }
  _shouldKeepHoverWidgetVisible(mouseEvent) {
    return this._isMouseOnContentHoverWidget(mouseEvent) || this._isContentWidgetResizing() || isOnColorDecorator(mouseEvent);
  }
  _isMouseOnContentHoverWidget(mouseEvent) {
    if (!this._contentWidget) {
      return false;
    }
    return isMousePositionWithinElement(this._contentWidget.getDomNode(), mouseEvent.event.posx, mouseEvent.event.posy);
  }
  _onEditorMouseUp() {
    if (this._ignoreMouseEvents) {
      return;
    }
    this._isMouseDown = false;
  }
  _onEditorMouseLeave(mouseEvent) {
    if (this._ignoreMouseEvents) {
      return;
    }
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave) {
      return;
    }
    this._cancelScheduler();
    const shouldKeepHoverWidgetVisible = this._shouldKeepHoverWidgetVisible(mouseEvent);
    if (shouldKeepHoverWidgetVisible) {
      return;
    }
    if (_sticky) {
      return;
    }
    this.hideContentHover();
  }
  _shouldKeepCurrentHover(mouseEvent) {
    const contentWidget = this._contentWidget;
    if (!contentWidget) {
      return false;
    }
    const isHoverSticky = this._hoverSettings.sticky;
    const isMouseOnStickyContentHoverWidget = (mouseEvent2, isHoverSticky2) => {
      const isMouseOnContentHoverWidget = this._isMouseOnContentHoverWidget(mouseEvent2);
      return isHoverSticky2 && isMouseOnContentHoverWidget;
    };
    const isMouseOnColorPickerOrChoosingColor = (mouseEvent2) => {
      const isColorPickerVisible = contentWidget.isColorPickerVisible;
      const isMouseOnContentHoverWidget = this._isMouseOnContentHoverWidget(mouseEvent2);
      const isMouseOnHoverWithColorPicker = isColorPickerVisible && isMouseOnContentHoverWidget;
      const isMaybeChoosingColor = isColorPickerVisible && this._isMouseDown;
      return isMouseOnHoverWithColorPicker || isMaybeChoosingColor;
    };
    const isTextSelectedWithinContentHoverWidget = (mouseEvent2, sticky) => {
      const view = mouseEvent2.event.browserEvent.view;
      if (!view) {
        return false;
      }
      return sticky && contentWidget.containsNode(view.document.activeElement) && !view.getSelection()?.isCollapsed;
    };
    const isFocused = contentWidget.isFocused;
    const isResizing = contentWidget.isResizing;
    const isStickyAndVisibleFromKeyboard = this._hoverSettings.sticky && contentWidget.isVisibleFromKeyboard;
    return this.shouldKeepOpenOnEditorMouseMoveOrLeave || isFocused || isResizing || isStickyAndVisibleFromKeyboard || isMouseOnStickyContentHoverWidget(mouseEvent, isHoverSticky) || isMouseOnColorPickerOrChoosingColor(mouseEvent) || isTextSelectedWithinContentHoverWidget(mouseEvent, isHoverSticky);
  }
  _onEditorMouseMove(mouseEvent) {
    if (this._ignoreMouseEvents) {
      return;
    }
    this._mouseMoveEvent = mouseEvent;
    const shouldKeepCurrentHover = this._shouldKeepCurrentHover(mouseEvent);
    if (shouldKeepCurrentHover) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    const shouldRescheduleHoverComputation = this._shouldRescheduleHoverComputation();
    if (shouldRescheduleHoverComputation) {
      if (!this._reactToEditorMouseMoveRunner.isScheduled()) {
        this._reactToEditorMouseMoveRunner.schedule(this._hoverSettings.hidingDelay);
      }
      return;
    }
    this._reactToEditorMouseMove(mouseEvent);
  }
  _shouldRescheduleHoverComputation() {
    const hidingDelay = this._hoverSettings.hidingDelay;
    const isContentHoverWidgetVisible = this._contentWidget?.isVisible ?? false;
    return isContentHoverWidgetVisible && this._hoverSettings.sticky && hidingDelay > 0;
  }
  _reactToEditorMouseMove(mouseEvent) {
    if (this._hoverSettings.enabled) {
      const contentWidget = this._getOrCreateContentWidget();
      if (contentWidget.showsOrWillShow(mouseEvent)) {
        return;
      }
    }
    if (_sticky) {
      return;
    }
    this.hideContentHover();
  }
  _onKeyDown(e) {
    if (this._ignoreMouseEvents) {
      return;
    }
    if (!this._contentWidget) {
      return;
    }
    const isPotentialKeyboardShortcut = this._isPotentialKeyboardShortcut(e);
    const isModifierKeyPressed = this._isModifierKeyPressed(e);
    if (isPotentialKeyboardShortcut || isModifierKeyPressed) {
      return;
    }
    if (this._contentWidget.isFocused && e.keyCode === 2) {
      return;
    }
    this.hideContentHover();
  }
  _isPotentialKeyboardShortcut(e) {
    if (!this._editor.hasModel() || !this._contentWidget) {
      return false;
    }
    const resolvedKeyboardEvent = this._keybindingService.softDispatch(e, this._editor.getDomNode());
    const moreChordsAreNeeded = resolvedKeyboardEvent.kind === 1;
    const isHoverAction = resolvedKeyboardEvent.kind === 2 && (resolvedKeyboardEvent.commandId === SHOW_OR_FOCUS_HOVER_ACTION_ID || resolvedKeyboardEvent.commandId === INCREASE_HOVER_VERBOSITY_ACTION_ID || resolvedKeyboardEvent.commandId === DECREASE_HOVER_VERBOSITY_ACTION_ID) && this._contentWidget.isVisible;
    return moreChordsAreNeeded || isHoverAction;
  }
  _isModifierKeyPressed(e) {
    return e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4;
  }
  hideContentHover() {
    if (_sticky) {
      return;
    }
    if (InlineSuggestionHintsContentWidget.dropDownVisible) {
      return;
    }
    this._contentWidget?.hide();
  }
  _getOrCreateContentWidget() {
    if (!this._contentWidget) {
      this._contentWidget = this._instantiationService.createInstance(ContentHoverWidgetWrapper, this._editor);
      this._listenersStore.add(this._contentWidget.onContentsChanged(() => this._onHoverContentsChanged.fire()));
    }
    return this._contentWidget;
  }
  showContentHover(range, mode, source, focus) {
    this._getOrCreateContentWidget().startShowingAtRange(range, mode, source, focus);
  }
  _isContentWidgetResizing() {
    return this._contentWidget?.widget.isResizing || false;
  }
  focusedHoverPartIndex() {
    return this._getOrCreateContentWidget().focusedHoverPartIndex();
  }
  updateHoverVerbosityLevel(action, index, focus) {
    this._getOrCreateContentWidget().updateHoverVerbosityLevel(action, index, focus);
  }
  focus() {
    this._contentWidget?.focus();
  }
  scrollUp() {
    this._contentWidget?.scrollUp();
  }
  scrollDown() {
    this._contentWidget?.scrollDown();
  }
  scrollLeft() {
    this._contentWidget?.scrollLeft();
  }
  scrollRight() {
    this._contentWidget?.scrollRight();
  }
  pageUp() {
    this._contentWidget?.pageUp();
  }
  pageDown() {
    this._contentWidget?.pageDown();
  }
  goToTop() {
    this._contentWidget?.goToTop();
  }
  goToBottom() {
    this._contentWidget?.goToBottom();
  }
  get isColorPickerVisible() {
    return this._contentWidget?.isColorPickerVisible;
  }
  get isHoverVisible() {
    return this._contentWidget?.isVisible;
  }
  dispose() {
    super.dispose();
    this._unhookListeners();
    this._listenersStore.dispose();
    this._contentWidget?.dispose();
  }
}, ContentHoverController_1 = _a25, _a25.ID = "editor.contrib.contentHover", _a25);
ContentHoverController = ContentHoverController_1 = __decorate31([
  __param31(1, IContextMenuService),
  __param31(2, IInstantiationService),
  __param31(3, IKeybindingService)
], ContentHoverController);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/hoverColorPicker/hoverColorPickerContribution.js
var _HoverColorPickerContribution = class _HoverColorPickerContribution extends Disposable {
  // ms
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(_editor.onMouseDown((e) => this.onMouseDown(e)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(mouseEvent) {
    const colorDecoratorsActivatedOn = this._editor.getOption(
      168
      /* EditorOption.colorDecoratorsActivatedOn */
    );
    if (colorDecoratorsActivatedOn !== "click" && colorDecoratorsActivatedOn !== "clickAndHover") {
      return;
    }
    if (!isOnColorDecorator(mouseEvent)) {
      return;
    }
    const hoverController = this._editor.getContribution(ContentHoverController.ID);
    if (!hoverController) {
      return;
    }
    if (hoverController.isColorPickerVisible) {
      return;
    }
    const targetRange = mouseEvent.target.range;
    if (!targetRange) {
      return;
    }
    const range = new Range(targetRange.startLineNumber, targetRange.startColumn + 1, targetRange.endLineNumber, targetRange.endColumn + 1);
    hoverController.showContentHover(range, 1, 1, false);
  }
};
_HoverColorPickerContribution.ID = "editor.contrib.colorContribution";
var HoverColorPickerContribution = _HoverColorPickerContribution;

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerActions.js
init_editorExtensions();
init_nls();
init_editorContextKeys();
init_actions2();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerController.js
init_contextkey();
init_instantiation();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerWidget.js
init_lifecycle();
init_instantiation();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPicker.css";
init_event();
init_languageFeatures();
init_editorWorker();

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerParticipant.js
init_cancellation();
init_lifecycle();
init_themeService();
init_range();
init_dom();
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneColorPickerHover = class _StandaloneColorPickerHover {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
  }
  static fromBaseColor(owner, color) {
    return new _StandaloneColorPickerHover(owner, color.range, color.model, color.provider);
  }
};
var StandaloneColorPickerRenderedParts = class extends Disposable {
  constructor(editor2, context, colorHover, themeService) {
    super();
    const editorModel = editor2.getModel();
    const colorPickerModel = colorHover.model;
    this.color = colorHover.model.color;
    this.colorPicker = this._register(new ColorPickerWidget(
      context.fragment,
      colorPickerModel,
      editor2.getOption(
        163
        /* EditorOption.pixelRatio */
      ),
      themeService,
      "standalone"
      /* ColorPickerWidgetType.Standalone */
    ));
    this._register(colorPickerModel.onColorFlushed((color) => {
      this.color = color;
    }));
    this._register(colorPickerModel.onDidChangeColor((color) => {
      updateColorPresentations(editorModel, colorPickerModel, color, colorHover.range, colorHover);
    }));
    let editorUpdatedByColorPicker = false;
    this._register(editor2.onDidChangeModelContent((e) => {
      if (editorUpdatedByColorPicker) {
        editorUpdatedByColorPicker = false;
      } else {
        context.hide();
        editor2.focus();
      }
    }));
    updateColorPresentations(editorModel, colorPickerModel, this.color, colorHover.range, colorHover);
  }
};
var StandaloneColorPickerParticipant = class StandaloneColorPickerParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
  }
  async createColorHover(defaultColorInfo, defaultColorProvider, colorProviderRegistry) {
    if (!this._editor.hasModel()) {
      return null;
    }
    const colorDetector = ColorDetector.get(this._editor);
    if (!colorDetector) {
      return null;
    }
    const colors = await getColors(colorProviderRegistry, this._editor.getModel(), CancellationToken.None);
    let foundColorInfo = null;
    let foundColorProvider = null;
    for (const colorData of colors) {
      const colorInfo2 = colorData.colorInfo;
      if (Range.containsRange(colorInfo2.range, defaultColorInfo.range)) {
        foundColorInfo = colorInfo2;
        foundColorProvider = colorData.provider;
      }
    }
    const colorInfo = foundColorInfo ?? defaultColorInfo;
    const colorProvider = foundColorProvider ?? defaultColorProvider;
    const foundInEditor = !!foundColorInfo;
    const colorHover = StandaloneColorPickerHover.fromBaseColor(this, await createColorHover(this._editor.getModel(), colorInfo, colorProvider));
    return { colorHover, foundInEditor };
  }
  async updateEditorModel(colorHoverData) {
    if (!this._editor.hasModel()) {
      return;
    }
    const colorPickerModel = colorHoverData.model;
    let range = new Range(colorHoverData.range.startLineNumber, colorHoverData.range.startColumn, colorHoverData.range.endLineNumber, colorHoverData.range.endColumn);
    if (this._color) {
      await updateColorPresentations(this._editor.getModel(), colorPickerModel, this._color, range, colorHoverData);
      range = updateEditorModel(this._editor, range, colorPickerModel);
    }
  }
  renderHoverParts(context, hoverParts) {
    if (hoverParts.length === 0 || !this._editor.hasModel()) {
      return void 0;
    }
    this._setMinimumDimensions(context);
    this._renderedParts = new StandaloneColorPickerRenderedParts(this._editor, context, hoverParts[0], this._themeService);
    return this._renderedParts;
  }
  _setMinimumDimensions(context) {
    const minimumHeight = this._editor.getOption(
      75
      /* EditorOption.lineHeight */
    ) + 8;
    context.setMinimumDimensions(new Dimension(302, minimumHeight));
  }
  get _color() {
    return this._renderedParts?.color;
  }
};
StandaloneColorPickerParticipant = __decorate32([
  __param32(1, IThemeService)
], StandaloneColorPickerParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerWidget.js
init_dom();
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneColorPickerWidget_1;
var StandaloneColorPickerResult = class {
  // The color picker result consists of: an array of color results and a boolean indicating if the color was found in the editor
  constructor(value, foundInEditor) {
    this.value = value;
    this.foundInEditor = foundInEditor;
  }
};
var PADDING = 8;
var CLOSE_BUTTON_WIDTH = 22;
var _a26;
var StandaloneColorPickerWidget = (_a26 = class extends Disposable {
  constructor(_editor, _standaloneColorPickerVisible, _standaloneColorPickerFocused, _instantiationService, _keybindingService, _languageFeaturesService, _editorWorkerService, _hoverService) {
    super();
    this._editor = _editor;
    this._standaloneColorPickerVisible = _standaloneColorPickerVisible;
    this._standaloneColorPickerFocused = _standaloneColorPickerFocused;
    this._keybindingService = _keybindingService;
    this._languageFeaturesService = _languageFeaturesService;
    this._editorWorkerService = _editorWorkerService;
    this._hoverService = _hoverService;
    this.allowEditorOverflow = true;
    this._position = void 0;
    this._body = document.createElement("div");
    this._colorHover = null;
    this._selectionSetInEditor = false;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._renderedHoverParts = this._register(new MutableDisposable());
    this._renderedStatusBar = this._register(new MutableDisposable());
    this._standaloneColorPickerVisible.set(true);
    this._standaloneColorPickerParticipant = _instantiationService.createInstance(StandaloneColorPickerParticipant, this._editor);
    this._position = this._editor._getViewModel()?.getPrimaryCursorState().modelState.position;
    const editorSelection = this._editor.getSelection();
    const selection = editorSelection ? {
      startLineNumber: editorSelection.startLineNumber,
      startColumn: editorSelection.startColumn,
      endLineNumber: editorSelection.endLineNumber,
      endColumn: editorSelection.endColumn
    } : { startLineNumber: 0, endLineNumber: 0, endColumn: 0, startColumn: 0 };
    const focusTracker = this._register(trackFocus(this._body));
    this._register(focusTracker.onDidBlur((_) => {
      this.hide();
    }));
    this._register(focusTracker.onDidFocus((_) => {
      this.focus();
    }));
    this._register(this._editor.onDidChangeCursorPosition(() => {
      if (!this._selectionSetInEditor) {
        this.hide();
      } else {
        this._selectionSetInEditor = false;
      }
    }));
    this._register(this._editor.onMouseMove((e) => {
      const classList = e.target.element?.classList;
      if (classList && classList.contains("colorpicker-color-decoration")) {
        this.hide();
      }
    }));
    this._register(this.onResult((result) => {
      this._render(result.value, result.foundInEditor);
    }));
    this._start(selection);
    this._body.style.zIndex = "50";
    this._editor.addContentWidget(this);
  }
  updateEditor() {
    if (this._colorHover) {
      this._standaloneColorPickerParticipant.updateEditorModel(this._colorHover);
    }
  }
  getId() {
    return StandaloneColorPickerWidget_1.ID;
  }
  getDomNode() {
    return this._body;
  }
  getPosition() {
    if (!this._position) {
      return null;
    }
    const positionPreference = this._editor.getOption(
      69
      /* EditorOption.hover */
    ).above;
    return {
      position: this._position,
      secondaryPosition: this._position,
      preference: positionPreference ? [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ] : [
        2,
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ],
      positionAffinity: 2
      /* PositionAffinity.None */
    };
  }
  hide() {
    this.dispose();
    this._standaloneColorPickerVisible.set(false);
    this._standaloneColorPickerFocused.set(false);
    this._editor.removeContentWidget(this);
    this._editor.focus();
  }
  focus() {
    this._standaloneColorPickerFocused.set(true);
    this._body.focus();
  }
  async _start(selection) {
    const computeAsyncResult = await this._computeAsync(selection);
    if (!computeAsyncResult) {
      return;
    }
    this._onResult.fire(new StandaloneColorPickerResult(computeAsyncResult.result, computeAsyncResult.foundInEditor));
  }
  async _computeAsync(range) {
    if (!this._editor.hasModel()) {
      return null;
    }
    const colorInfo = {
      range,
      color: { red: 0, green: 0, blue: 0, alpha: 1 }
    };
    const colorHoverResult = await this._standaloneColorPickerParticipant.createColorHover(colorInfo, new DefaultDocumentColorProvider(this._editorWorkerService), this._languageFeaturesService.colorProvider);
    if (!colorHoverResult) {
      return null;
    }
    return { result: colorHoverResult.colorHover, foundInEditor: colorHoverResult.foundInEditor };
  }
  _render(colorHover, foundInEditor) {
    const fragment = document.createDocumentFragment();
    this._renderedStatusBar.value = this._register(new EditorHoverStatusBar(this._keybindingService, this._hoverService));
    const context = {
      fragment,
      statusBar: this._renderedStatusBar.value,
      onContentsChanged: () => {
      },
      setMinimumDimensions: () => {
      },
      hide: () => this.hide(),
      focus: () => this.focus()
    };
    this._colorHover = colorHover;
    this._renderedHoverParts.value = this._standaloneColorPickerParticipant.renderHoverParts(context, [colorHover]);
    if (!this._renderedHoverParts.value) {
      this._renderedStatusBar.clear();
      this._renderedHoverParts.clear();
      return;
    }
    const colorPicker = this._renderedHoverParts.value.colorPicker;
    this._body.classList.add("standalone-colorpicker-body");
    this._body.style.maxHeight = Math.max(this._editor.getLayoutInfo().height / 4, 250) + "px";
    this._body.style.maxWidth = Math.max(this._editor.getLayoutInfo().width * 0.66, 500) + "px";
    this._body.tabIndex = 0;
    this._body.appendChild(fragment);
    colorPicker.layout();
    const colorPickerBody = colorPicker.body;
    const saturationBoxWidth = colorPickerBody.saturationBox.domNode.clientWidth;
    const widthOfOriginalColorBox = colorPickerBody.domNode.clientWidth - saturationBoxWidth - CLOSE_BUTTON_WIDTH - PADDING;
    const enterButton = colorPicker.body.enterButton;
    enterButton?.onClicked(() => {
      this.updateEditor();
      this.hide();
    });
    const colorPickerHeader = colorPicker.header;
    const pickedColorNode = colorPickerHeader.pickedColorNode;
    pickedColorNode.style.width = saturationBoxWidth + PADDING + "px";
    const originalColorNode = colorPickerHeader.originalColorNode;
    originalColorNode.style.width = widthOfOriginalColorBox + "px";
    const closeButton = colorPicker.header.closeButton;
    closeButton?.onClicked(() => {
      this.hide();
    });
    if (foundInEditor) {
      if (enterButton) {
        enterButton.button.textContent = "Replace";
      }
      this._selectionSetInEditor = true;
      this._editor.setSelection(colorHover.range);
    }
    this._editor.layoutContentWidget(this);
  }
}, StandaloneColorPickerWidget_1 = _a26, _a26.ID = "editor.contrib.standaloneColorPickerWidget", _a26);
StandaloneColorPickerWidget = StandaloneColorPickerWidget_1 = __decorate33([
  __param33(3, IInstantiationService),
  __param33(4, IKeybindingService),
  __param33(5, ILanguageFeaturesService),
  __param33(6, IEditorWorkerService),
  __param33(7, IHoverService)
], StandaloneColorPickerWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerController.js
init_lifecycle();
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneColorPickerController_1;
var _a27;
var StandaloneColorPickerController = (_a27 = class extends Disposable {
  constructor(_editor, _contextKeyService, _instantiationService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._standaloneColorPickerWidget = null;
    this._standaloneColorPickerVisible = EditorContextKeys.standaloneColorPickerVisible.bindTo(_contextKeyService);
    this._standaloneColorPickerFocused = EditorContextKeys.standaloneColorPickerFocused.bindTo(_contextKeyService);
  }
  showOrFocus() {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._standaloneColorPickerVisible.get()) {
      this._standaloneColorPickerWidget = this._instantiationService.createInstance(StandaloneColorPickerWidget, this._editor, this._standaloneColorPickerVisible, this._standaloneColorPickerFocused);
    } else if (!this._standaloneColorPickerFocused.get()) {
      this._standaloneColorPickerWidget?.focus();
    }
  }
  hide() {
    this._standaloneColorPickerFocused.set(false);
    this._standaloneColorPickerVisible.set(false);
    this._standaloneColorPickerWidget?.hide();
    this._editor.focus();
  }
  insertColor() {
    this._standaloneColorPickerWidget?.updateEditor();
    this.hide();
  }
  static get(editor2) {
    return editor2.getContribution(StandaloneColorPickerController_1.ID);
  }
}, StandaloneColorPickerController_1 = _a27, _a27.ID = "editor.contrib.standaloneColorPickerController", _a27);
StandaloneColorPickerController = StandaloneColorPickerController_1 = __decorate34([
  __param34(1, IContextKeyService),
  __param34(2, IInstantiationService)
], StandaloneColorPickerController);

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/standaloneColorPicker/standaloneColorPickerActions.js
var ShowOrFocusStandaloneColorPicker = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.showOrFocusStandaloneColorPicker",
      title: {
        ...localize2(884, "Show or Focus Standalone Color Picker"),
        mnemonicTitle: localize(883, "&&Show or Focus Standalone Color Picker")
      },
      precondition: void 0,
      menu: [
        { id: MenuId.CommandPalette }
      ],
      metadata: {
        description: localize2(885, "Show or focus a standalone color picker which uses the default color provider. It displays hex/rgb/hsl colors.")
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    StandaloneColorPickerController.get(editor2)?.showOrFocus();
  }
};
var HideStandaloneColorPicker = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.hideColorPicker",
      label: localize2(886, "Hide the Color Picker"),
      precondition: EditorContextKeys.standaloneColorPickerVisible.isEqualTo(true),
      kbOpts: {
        primary: 9,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(887, "Hide the standalone color picker.")
      }
    });
  }
  run(_accessor, editor2) {
    StandaloneColorPickerController.get(editor2)?.hide();
  }
};
var InsertColorWithStandaloneColorPicker = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertColorWithStandaloneColorPicker",
      label: localize2(888, "Insert Color with Standalone Color Picker"),
      precondition: EditorContextKeys.standaloneColorPickerFocused.isEqualTo(true),
      kbOpts: {
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(889, "Insert hex/rgb/hsl colors with the focused standalone color picker.")
      }
    });
  }
  run(_accessor, editor2) {
    StandaloneColorPickerController.get(editor2)?.insertColor();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerContribution.js
init_range();
registerEditorAction(HideStandaloneColorPicker);
registerEditorAction(InsertColorWithStandaloneColorPicker);
registerAction2(ShowOrFocusStandaloneColorPicker);
registerEditorContribution(
  HoverColorPickerContribution.ID,
  HoverColorPickerContribution,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorContribution(
  StandaloneColorPickerController.ID,
  StandaloneColorPickerController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorContribution(
  ColorDetector.ID,
  ColorDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorFeature(DefaultDocumentColorProviderFeature);
HoverParticipantRegistry.register(HoverColorPickerParticipant);
CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const { model, colorProviderRegistry, defaultColorDecoratorsEnablement } = _setupColorCommand(accessor, resource);
  return _findColorData(new ExtColorDataCollector(), colorProviderRegistry, model, CancellationToken.None, defaultColorDecoratorsEnablement);
});
CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
  const [color, context] = args;
  const { uri, range } = context;
  if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range)) {
    throw illegalArgument();
  }
  const { model, colorProviderRegistry, defaultColorDecoratorsEnablement } = _setupColorCommand(accessor, uri);
  const [red, green, blue, alpha] = color;
  return _findColorData(new ColorPresentationsCollector({ range, color: { red, green, blue, alpha } }), colorProviderRegistry, model, CancellationToken.None, defaultColorDecoratorsEnablement);
});

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
init_keyCodes();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/blockCommentCommand.js
init_position();
init_range();
init_selection();
var BlockCommentCommand = class _BlockCommentCommand {
  constructor(selection, insertSpace, languageConfigurationService) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._insertSpace = insertSpace;
    this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(haystack, needle, offset) {
    if (offset < 0) {
      return false;
    }
    const needleLength = needle.length;
    const haystackLength = haystack.length;
    if (offset + needleLength > haystackLength) {
      return false;
    }
    for (let i2 = 0; i2 < needleLength; i2++) {
      const codeA = haystack.charCodeAt(offset + i2);
      const codeB = needle.charCodeAt(i2);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
        continue;
      }
      if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
        continue;
      }
      return false;
    }
    return true;
  }
  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
    const startLineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endLineNumber = selection.endLineNumber;
    const endColumn = selection.endColumn;
    const startLineText = model.getLineContent(startLineNumber);
    const endLineText = model.getLineContent(endLineNumber);
    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (startLineNumber === endLineNumber) {
        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
        if (lineBetweenTokens.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      } else {
        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      }
    }
    let ops;
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
        startToken = startToken + " ";
      }
      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
        endToken = " " + endToken;
        endTokenIndex -= 1;
      }
      ops = _BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    } else {
      ops = _BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
      this._usedEndToken = ops.length === 1 ? endToken : null;
    }
    for (const op of ops) {
      builder.addTrackedEditOperation(op.range, op.text);
    }
  }
  static _createRemoveBlockCommentOperations(r, startToken, endToken) {
    const res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
    } else {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
    }
    return res;
  }
  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
    const res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
    } else {
      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
    }
    return res;
  }
  getEditOperations(model, builder) {
    const startLineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    if (inverseEditOperations.length === 2) {
      const startTokenEditOperation = inverseEditOperations[0];
      const endTokenEditOperation = inverseEditOperations[1];
      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
    } else {
      const srcRange = inverseEditOperations[0].range;
      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js
init_strings();
init_position();
init_range();
init_selection();
var LineCommentCommand = class _LineCommentCommand {
  constructor(languageConfigurationService, selection, indentSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._indentSize = indentSize;
    this._type = type;
    this._insertSpace = insertSpace;
    this._selectionId = null;
    this._deltaColumn = 0;
    this._moveEndPositionDown = false;
    this._ignoreEmptyLines = ignoreEmptyLines;
    this._ignoreFirstLine = ignoreFirstLine || false;
  }
  /**
   * Do an initial pass over the lines and gather info about the line comment string.
   * Returns null if any of the lines doesn't support a line comment string.
   */
  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;
    const commentStr = config ? config.lineCommentToken : null;
    if (!commentStr) {
      return null;
    }
    const lines = [];
    for (let i2 = 0, lineCount = endLineNumber - startLineNumber + 1; i2 < lineCount; i2++) {
      lines[i2] = {
        ignore: false,
        commentStr,
        commentStrOffset: 0,
        commentStrLength: commentStr.length
      };
    }
    return lines;
  }
  /**
   * Analyze lines and decide which lines are relevant and what the toggle should do.
   * Also, build up several offsets and lengths useful in the generation of editor operations.
   */
  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService, languageId) {
    let onlyWhitespaceLines = true;
    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;
    const lineCommentNoIndent = config?.lineCommentNoIndent ?? false;
    let shouldRemoveComments;
    if (type === 0) {
      shouldRemoveComments = true;
    } else if (type === 1) {
      shouldRemoveComments = false;
    } else {
      shouldRemoveComments = true;
    }
    for (let i2 = 0, lineCount = lines.length; i2 < lineCount; i2++) {
      const lineData = lines[i2];
      const lineNumber = startLineNumber + i2;
      if (lineNumber === startLineNumber && ignoreFirstLine) {
        lineData.ignore = true;
        continue;
      }
      const lineContent = model.getLineContent(lineNumber);
      const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
      if (lineContentStartOffset === -1) {
        lineData.ignore = ignoreEmptyLines;
        lineData.commentStrOffset = lineCommentNoIndent ? 0 : lineContent.length;
        continue;
      }
      onlyWhitespaceLines = false;
      const offset = lineCommentNoIndent ? 0 : lineContentStartOffset;
      lineData.ignore = false;
      lineData.commentStrOffset = offset;
      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, offset)) {
        if (type === 0) {
          shouldRemoveComments = false;
        } else if (type === 1) {
        } else {
          lineData.ignore = true;
        }
      }
      if (shouldRemoveComments && insertSpace) {
        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
          lineData.commentStrLength += 1;
        }
      }
    }
    if (type === 0 && onlyWhitespaceLines) {
      shouldRemoveComments = false;
      for (let i2 = 0, lineCount = lines.length; i2 < lineCount; i2++) {
        lines[i2].ignore = false;
      }
    }
    return {
      supported: true,
      shouldRemoveComments,
      lines
    };
  }
  /**
   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
   */
  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    const lines = _LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    if (lines === null) {
      return {
        supported: false
      };
    }
    return _LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService, languageId);
  }
  /**
   * Given a successful analysis, execute either insert line comments, either remove line comments
   */
  _executeLineComments(model, builder, data, s) {
    let ops;
    if (data.shouldRemoveComments) {
      ops = _LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
    } else {
      _LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);
      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
    }
    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
    for (let i2 = 0, len = ops.length; i2 < len; i2++) {
      builder.addEditOperation(ops[i2].range, ops[i2].text);
      if (Range.isEmpty(ops[i2].range) && Range.getStartPosition(ops[i2].range).equals(cursorPosition)) {
        const lineContent = model.getLineContent(cursorPosition.lineNumber);
        if (lineContent.length + 1 === cursorPosition.column) {
          this._deltaColumn = (ops[i2].text || "").length;
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  _attemptRemoveBlockComment(model, s, startToken, endToken) {
    let startLineNumber = s.startLineNumber;
    let endLineNumber = s.endLineNumber;
    const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
    if (startTokenIndex !== -1 && endTokenIndex === -1) {
      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      endLineNumber = startLineNumber;
    }
    if (startTokenIndex === -1 && endTokenIndex !== -1) {
      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
      startLineNumber = endLineNumber;
    }
    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
      if (startTokenIndex !== -1) {
        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      }
    }
    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
      startToken += " ";
    }
    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
      endToken = " " + endToken;
      endTokenIndex -= 1;
    }
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    }
    return null;
  }
  /**
   * Given an unsuccessful analysis, delegate to the block comment command
   */
  _executeBlockComment(model, builder, s) {
    model.tokenization.tokenizeIfCheap(s.startLineNumber);
    const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    const startToken = config.blockCommentStartToken;
    const endToken = config.blockCommentEndToken;
    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
    if (!ops) {
      if (s.isEmpty()) {
        const lineContent = model.getLineContent(s.startLineNumber);
        let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
        if (firstNonWhitespaceIndex2 === -1) {
          firstNonWhitespaceIndex2 = lineContent.length;
        }
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex2 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
      } else {
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
      }
      if (ops.length === 1) {
        this._deltaColumn = startToken.length + 1;
      }
    }
    this._selectionId = builder.trackSelection(s);
    for (const op of ops) {
      builder.addEditOperation(op.range, op.text);
    }
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._moveEndPositionDown = false;
    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
      this._selectionId = builder.trackSelection(s);
      return;
    }
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const data = _LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    if (data.supported) {
      return this._executeLineComments(model, builder, data, s);
    }
    return this._executeBlockComment(model, builder, s);
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
  }
  /**
   * Generate edit operations in the remove line comment case
   */
  static _createRemoveLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    for (let i2 = 0, len = lines.length; i2 < len; i2++) {
      const lineData = lines[i2];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.delete(new Range(startLineNumber + i2, lineData.commentStrOffset + 1, startLineNumber + i2, lineData.commentStrOffset + lineData.commentStrLength + 1)));
    }
    return res;
  }
  /**
   * Generate edit operations in the add line comment case
   */
  _createAddLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    const afterCommentStr = this._insertSpace ? " " : "";
    for (let i2 = 0, len = lines.length; i2 < len; i2++) {
      const lineData = lines[i2];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.insert(new Position(startLineNumber + i2, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
    }
    return res;
  }
  static nextVisibleColumn(currentVisibleColumn, indentSize, isTab, columnSize) {
    if (isTab) {
      return currentVisibleColumn + (indentSize - currentVisibleColumn % indentSize);
    }
    return currentVisibleColumn + columnSize;
  }
  /**
   * Adjust insertion points to have them vertically aligned in the add line comment case
   */
  static _normalizeInsertionPoint(model, lines, startLineNumber, indentSize) {
    let minVisibleColumn = 1073741824;
    let j;
    let lenJ;
    for (let i2 = 0, len = lines.length; i2 < len; i2++) {
      if (lines[i2].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i2);
      let currentVisibleColumn = 0;
      for (let j2 = 0, lenJ2 = lines[i2].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
        currentVisibleColumn = _LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j2) === 9, 1);
      }
      if (currentVisibleColumn < minVisibleColumn) {
        minVisibleColumn = currentVisibleColumn;
      }
    }
    minVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;
    for (let i2 = 0, len = lines.length; i2 < len; i2++) {
      if (lines[i2].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i2);
      let currentVisibleColumn = 0;
      for (j = 0, lenJ = lines[i2].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
        currentVisibleColumn = _LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === 9, 1);
      }
      if (currentVisibleColumn > minVisibleColumn) {
        lines[i2].commentStrOffset = j - 1;
      } else {
        lines[i2].commentStrOffset = j;
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
init_nls();
init_actions2();
var CommentLineAction = class extends EditorAction {
  constructor(type, opts) {
    super(opts);
    this._type = type;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const modelOptions = model.getOptions();
    const commentsOptions = editor2.getOption(
      29
      /* EditorOption.comments */
    );
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignoreFirstLine: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i2 = 1; i2 < selections.length; i2++) {
      const curr = selections[i2];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignoreFirstLine = true;
        } else {
          prev.ignoreFirstLine = true;
          prev = curr;
        }
      }
    }
    for (const selection of selections) {
      commands.push(new LineCommentCommand(languageConfigurationService, selection.selection, modelOptions.indentSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var ToggleCommentLineAction = class extends CommentLineAction {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: localize2(892, "Toggle Line Comment"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 90,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize(890, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
};
var AddLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: localize2(893, "Add Line Comment"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 33
          /* KeyCode.KeyC */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var RemoveLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: localize2(894, "Remove Line Comment"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 51
          /* KeyCode.KeyU */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var BlockCommentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: localize2(895, "Toggle Block Comment"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 31,
        linux: {
          primary: 2048 | 1024 | 31
          /* KeyCode.KeyA */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize(891, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const commentsOptions = editor2.getOption(
      29
      /* EditorOption.comments */
    );
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/browser/contextmenu.js
init_dom();
init_actions();
init_lifecycle();
init_platform();
init_editorExtensions();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
init_configuration();
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuController_1;
var _a28;
var ContextMenuController = (_a28 = class {
  static get(editor2) {
    return editor2.getContribution(ContextMenuController_1.ID);
  }
  constructor(editor2, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService, _configurationService, _workspaceContextService) {
    this._contextMenuService = _contextMenuService;
    this._contextViewService = _contextViewService;
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._menuService = _menuService;
    this._configurationService = _configurationService;
    this._workspaceContextService = _workspaceContextService;
    this._toDispose = new DisposableStore();
    this._contextMenuIsBeingShownCount = 0;
    this._editor = editor2;
    this._toDispose.add(this._editor.onContextMenu((e) => this._onContextMenu(e)));
    this._toDispose.add(this._editor.onMouseWheel((e) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const view = this._contextViewService.getContextViewElement();
        const target = e.srcElement;
        if (!(target.shadowRoot && getShadowRoot(view) === target.shadowRoot)) {
          this._contextViewService.hideContextView();
        }
      }
    }));
    this._toDispose.add(this._editor.onKeyDown((e) => {
      if (!this._editor.getOption(
        30
        /* EditorOption.contextmenu */
      )) {
        return;
      }
      if (e.keyCode === 58) {
        e.preventDefault();
        e.stopPropagation();
        this.showContextMenu();
      }
    }));
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._editor.getOption(
      30
      /* EditorOption.contextmenu */
    )) {
      this._editor.focus();
      if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
        this._editor.setPosition(e.target.position);
      }
      return;
    }
    if (e.target.type === 12) {
      return;
    }
    if (e.target.type === 6 && e.target.detail.injectedText) {
      return;
    }
    e.event.preventDefault();
    e.event.stopPropagation();
    if (e.target.type === 11) {
      return this._showScrollbarContextMenu(e.event);
    }
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1) {
      return;
    }
    this._editor.focus();
    if (e.target.position) {
      let hasSelectionAtPosition = false;
      for (const selection of this._editor.getSelections()) {
        if (selection.containsPosition(e.target.position)) {
          hasSelectionAtPosition = true;
          break;
        }
      }
      if (!hasSelectionAtPosition) {
        this._editor.setPosition(e.target.position);
      }
    }
    let anchor = null;
    if (e.target.type !== 1) {
      anchor = e.event;
    }
    this.showContextMenu(anchor);
  }
  showContextMenu(anchor) {
    if (!this._editor.getOption(
      30
      /* EditorOption.contextmenu */
    )) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const menuActions = this._getMenuActions(this._editor.getModel(), this._editor.contextMenuId);
    if (menuActions.length > 0) {
      this._doShowContextMenu(menuActions, anchor);
    }
  }
  _getMenuActions(model, menuId) {
    const result = [];
    const groups = this._menuService.getMenuActions(menuId, this._contextKeyService, { arg: model.uri });
    for (const group of groups) {
      const [, actions] = group;
      let addedItems = 0;
      for (const action of actions) {
        if (action instanceof SubmenuItemAction) {
          const subActions = this._getMenuActions(model, action.item.submenu);
          if (subActions.length > 0) {
            result.push(new SubmenuAction(action.id, action.label, subActions));
            addedItems++;
          }
        } else {
          result.push(action);
          addedItems++;
        }
      }
      if (addedItems) {
        result.push(new Separator());
      }
    }
    if (result.length) {
      result.pop();
    }
    return result;
  }
  _doShowContextMenu(actions, event = null) {
    if (!this._editor.hasModel()) {
      return;
    }
    let anchor = event;
    if (!anchor) {
      this._editor.revealPosition(
        this._editor.getPosition(),
        1
        /* ScrollType.Immediate */
      );
      this._editor.render();
      const cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
      const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
      const posx = editorCoords.left + cursorCoords.left;
      const posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
      anchor = { x: posx, y: posy };
    }
    const useShadowDOM = this._editor.getOption(
      144
      /* EditorOption.useShadowDOM */
    ) && !isIOS;
    this._contextMenuIsBeingShownCount++;
    this._contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? this._editor.getOverflowWidgetsDomNode() ?? this._editor.getDomNode() : void 0,
      getAnchor: () => anchor,
      getActions: () => actions,
      getActionViewItem: (action) => {
        const keybinding = this._keybindingFor(action);
        if (keybinding) {
          return new ActionViewItem(action, action, { label: true, keybinding: keybinding.getLabel(), isMenu: true });
        }
        const customActionViewItem = action;
        if (typeof customActionViewItem.getActionViewItem === "function") {
          return customActionViewItem.getActionViewItem();
        }
        return new ActionViewItem(action, action, { icon: true, label: true, isMenu: true });
      },
      getKeyBinding: (action) => {
        return this._keybindingFor(action);
      },
      onHide: (wasCancelled) => {
        this._contextMenuIsBeingShownCount--;
      }
    });
  }
  _showScrollbarContextMenu(anchor) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (isStandaloneEditorWorkspace(this._workspaceContextService.getWorkspace())) {
      return;
    }
    const minimapOptions = this._editor.getOption(
      81
      /* EditorOption.minimap */
    );
    let lastId = 0;
    const createAction = (opts) => {
      return {
        id: `menu-action-${++lastId}`,
        label: opts.label,
        tooltip: "",
        class: void 0,
        enabled: typeof opts.enabled === "undefined" ? true : opts.enabled,
        checked: opts.checked,
        run: opts.run
      };
    };
    const createSubmenuAction = (label, actions2) => {
      return new SubmenuAction(`menu-action-${++lastId}`, label, actions2, void 0);
    };
    const createEnumAction = (label, enabled, configName, configuredValue, options) => {
      if (!enabled) {
        return createAction({ label, enabled, run: () => {
        } });
      }
      const createRunner = (value) => {
        return () => {
          this._configurationService.updateValue(configName, value);
        };
      };
      const actions2 = [];
      for (const option2 of options) {
        actions2.push(createAction({
          label: option2.label,
          checked: configuredValue === option2.value,
          run: createRunner(option2.value)
        }));
      }
      return createSubmenuAction(label, actions2);
    };
    const actions = [];
    actions.push(createAction({
      label: localize(896, "Minimap"),
      checked: minimapOptions.enabled,
      run: () => {
        this._configurationService.updateValue(`editor.minimap.enabled`, !minimapOptions.enabled);
      }
    }));
    actions.push(new Separator());
    actions.push(createAction({
      label: localize(897, "Render Characters"),
      enabled: minimapOptions.enabled,
      checked: minimapOptions.renderCharacters,
      run: () => {
        this._configurationService.updateValue(`editor.minimap.renderCharacters`, !minimapOptions.renderCharacters);
      }
    }));
    actions.push(createEnumAction(localize(898, "Vertical size"), minimapOptions.enabled, "editor.minimap.size", minimapOptions.size, [{
      label: localize(899, "Proportional"),
      value: "proportional"
    }, {
      label: localize(900, "Fill"),
      value: "fill"
    }, {
      label: localize(901, "Fit"),
      value: "fit"
    }]));
    actions.push(createEnumAction(localize(902, "Slider"), minimapOptions.enabled, "editor.minimap.showSlider", minimapOptions.showSlider, [{
      label: localize(903, "Mouse Over"),
      value: "mouseover"
    }, {
      label: localize(904, "Always"),
      value: "always"
    }]));
    const useShadowDOM = this._editor.getOption(
      144
      /* EditorOption.useShadowDOM */
    ) && !isIOS;
    this._contextMenuIsBeingShownCount++;
    this._contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
      getAnchor: () => anchor,
      getActions: () => actions,
      onHide: (wasCancelled) => {
        this._contextMenuIsBeingShownCount--;
        this._editor.focus();
      }
    });
  }
  _keybindingFor(action) {
    return this._keybindingService.lookupKeybinding(action.id);
  }
  dispose() {
    if (this._contextMenuIsBeingShownCount > 0) {
      this._contextViewService.hideContextView();
    }
    this._toDispose.dispose();
  }
}, ContextMenuController_1 = _a28, _a28.ID = "editor.contrib.contextmenu", _a28);
ContextMenuController = ContextMenuController_1 = __decorate35([
  __param35(1, IContextMenuService),
  __param35(2, IContextViewService),
  __param35(3, IContextKeyService),
  __param35(4, IKeybindingService),
  __param35(5, IMenuService),
  __param35(6, IConfigurationService),
  __param35(7, IWorkspaceContextService)
], ContextMenuController);
var ShowContextMenu = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: localize2(905, "Show Editor Context Menu"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 68,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    ContextMenuController.get(editor2)?.showContextMenu();
  }
};
registerEditorContribution(
  ContextMenuController.ID,
  ContextMenuController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(ShowContextMenu);

// node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/browser/cursorUndo.js
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_nls();
var CursorState2 = class {
  constructor(selections) {
    this.selections = selections;
  }
  equals(other) {
    const thisLen = this.selections.length;
    const otherLen = other.selections.length;
    if (thisLen !== otherLen) {
      return false;
    }
    for (let i2 = 0; i2 < thisLen; i2++) {
      if (!this.selections[i2].equalsSelection(other.selections[i2])) {
        return false;
      }
    }
    return true;
  }
};
var StackElement = class {
  constructor(cursorState, scrollTop, scrollLeft) {
    this.cursorState = cursorState;
    this.scrollTop = scrollTop;
    this.scrollLeft = scrollLeft;
  }
};
var _CursorUndoRedoController = class _CursorUndoRedoController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_CursorUndoRedoController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._isCursorUndoRedo = false;
    this._undoStack = [];
    this._redoStack = [];
    this._register(editor2.onDidChangeModel((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (this._isCursorUndoRedo) {
        return;
      }
      if (!e.oldSelections) {
        return;
      }
      if (e.oldModelVersionId !== e.modelVersionId) {
        return;
      }
      const prevState = new CursorState2(e.oldSelections);
      const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
      if (!isEqualToLastUndoStack) {
        this._undoStack.push(new StackElement(prevState, editor2.getScrollTop(), editor2.getScrollLeft()));
        this._redoStack = [];
        if (this._undoStack.length > 50) {
          this._undoStack.shift();
        }
      }
    }));
  }
  cursorUndo() {
    if (!this._editor.hasModel() || this._undoStack.length === 0) {
      return;
    }
    this._redoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._undoStack.pop());
  }
  cursorRedo() {
    if (!this._editor.hasModel() || this._redoStack.length === 0) {
      return;
    }
    this._undoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._redoStack.pop());
  }
  _applyState(stackElement) {
    this._isCursorUndoRedo = true;
    this._editor.setSelections(stackElement.cursorState.selections);
    this._editor.setScrollPosition({
      scrollTop: stackElement.scrollTop,
      scrollLeft: stackElement.scrollLeft
    });
    this._isCursorUndoRedo = false;
  }
};
_CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
var CursorUndoRedoController = _CursorUndoRedoController;
var CursorUndo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorUndo",
      label: localize2(906, "Cursor Undo"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 51,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    CursorUndoRedoController.get(editor2)?.cursorUndo();
  }
};
var CursorRedo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorRedo",
      label: localize2(907, "Cursor Redo"),
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    CursorUndoRedoController.get(editor2)?.cursorRedo();
  }
};
registerEditorContribution(
  CursorUndoRedoController.ID,
  CursorUndoRedoController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
init_lifecycle();
init_platform();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_textModel();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dragAndDropCommand.js
init_range();
init_selection();
var DragAndDropCommand = class {
  constructor(selection, targetPosition, copy) {
    this.selection = selection;
    this.targetPosition = targetPosition;
    this.copy = copy;
    this.targetSelection = null;
  }
  getEditOperations(model, builder) {
    const text = model.getValueInRange(this.selection);
    if (!this.copy) {
      builder.addEditOperation(this.selection, null);
    }
    builder.addEditOperation(new Range(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
    if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.selection.endColumn <= this.targetPosition.column) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
    } else {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
  }
  computeCursorState(model, helper) {
    return this.targetSelection;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
var _DragAndDropController = class _DragAndDropController extends Disposable {
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._dndDecorationIds = this._editor.createDecorationsCollection();
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
    this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
    this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
    this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
    this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
    this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
    this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
    this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
    this._mouseDown = false;
    this._modifierPressed = false;
    this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
  }
  onEditorKeyDown(e) {
    if (!this._editor.getOption(
      42
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      28
      /* EditorOption.columnSelection */
    )) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = true;
    }
    if (this._mouseDown && hasTriggerModifier(e)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    }
  }
  onEditorKeyUp(e) {
    if (!this._editor.getOption(
      42
      /* EditorOption.dragAndDrop */
    ) || this._editor.getOption(
      28
      /* EditorOption.columnSelection */
    )) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = false;
    }
    if (this._mouseDown && e.keyCode === _DragAndDropController.TRIGGER_KEY_VALUE) {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._mouseDown = true;
  }
  _onEditorMouseUp(mouseEvent) {
    this._mouseDown = false;
    this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(mouseEvent) {
    const target = mouseEvent.target;
    if (this._dragSelection === null) {
      const selections = this._editor.getSelections() || [];
      const possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
      if (possibleSelections.length === 1) {
        this._dragSelection = possibleSelections[0];
      } else {
        return;
      }
    }
    if (hasTriggerModifier(mouseEvent.event)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    } else {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
    if (target.position) {
      if (this._dragSelection.containsPosition(target.position)) {
        this._removeDecoration();
      } else {
        this.showAt(target.position);
      }
    }
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  _onEditorMouseDrop(mouseEvent) {
    if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
      const newCursorPosition = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
      if (this._dragSelection === null) {
        let newSelections = null;
        if (mouseEvent.event.shiftKey) {
          const primarySelection = this._editor.getSelection();
          if (primarySelection) {
            const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
            newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
          }
        } else {
          newSelections = (this._editor.getSelections() || []).map((selection) => {
            if (selection.containsPosition(newCursorPosition)) {
              return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            } else {
              return selection;
            }
          });
        }
        this._editor.setSelections(
          newSelections || [],
          "mouse",
          3
          /* CursorChangeReason.Explicit */
        );
      } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
        this._editor.pushUndoStop();
        this._editor.executeCommand(_DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
        this._editor.pushUndoStop();
      }
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  showAt(position) {
    this._dndDecorationIds.set([{
      range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
      options: _DragAndDropController._DECORATION_OPTIONS
    }]);
    this._editor.revealPosition(
      position,
      1
      /* ScrollType.Immediate */
    );
  }
  _removeDecoration() {
    this._dndDecorationIds.clear();
  }
  _hitContent(target) {
    return target.type === 6 || target.type === 7;
  }
  _hitMargin(target) {
    return target.type === 2 || target.type === 3 || target.type === 4;
  }
  dispose() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
    super.dispose();
  }
};
_DragAndDropController.ID = "editor.contrib.dragAndDrop";
_DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
_DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "dnd-target",
  className: "dnd-target"
});
var DragAndDropController = _DragAndDropController;
registerEditorContribution(
  DragAndDropController.ID,
  DragAndDropController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/copyPasteContribution.js
init_nls();
init_editorExtensions();
init_editorContextKeys();
var pasteAsCommandId = "editor.action.pasteAs";
registerEditorContribution(
  CopyPasteController.ID,
  CopyPasteController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorFeature(DefaultPasteProvidersFeature);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: changePasteTypeCommandId,
      precondition: pasteWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 2048 | 89
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    return CopyPasteController.get(editor2)?.changePasteType();
  }
}());
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.hidePasteWidget",
      precondition: pasteWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    CopyPasteController.get(editor2)?.clearWidgets();
  }
}());
var _a29;
registerEditorAction((_a29 = class extends EditorAction {
  constructor() {
    super({
      id: pasteAsCommandId,
      label: localize2(910, "Paste As..."),
      precondition: EditorContextKeys.writable,
      metadata: {
        description: "Paste as",
        args: [{
          name: "args",
          schema: _a29.argsSchema
        }]
      }
    });
  }
  run(_accessor, editor2, args) {
    let preference;
    if (args) {
      if ("kind" in args) {
        preference = { only: new HierarchicalKind(args.kind) };
      } else if ("preferences" in args) {
        preference = { preferences: args.preferences.map((kind) => new HierarchicalKind(kind)) };
      }
    }
    return CopyPasteController.get(editor2)?.pasteAs(preference);
  }
}, _a29.argsSchema = {
  oneOf: [
    {
      type: "object",
      required: ["kind"],
      properties: {
        kind: {
          type: "string",
          description: localize(908, "The kind of the paste edit to try pasting with.\nIf there are multiple edits for this kind, the editor will show a picker. If there are no edits of this kind, the editor will show an error message.")
        }
      }
    },
    {
      type: "object",
      required: ["preferences"],
      properties: {
        preferences: {
          type: "array",
          description: localize(909, "List of preferred paste edit kind to try applying.\nThe first edit matching the preferences will be applied."),
          items: { type: "string" }
        }
      }
    }
  ]
}, _a29));
registerEditorAction(class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.pasteAsText",
      label: localize2(911, "Paste as Text"),
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    return CopyPasteController.get(editor2)?.pasteAs({ providerId: DefaultTextPasteOrDropEditProvider.id });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js
init_arrays();
init_async();
init_errors();
init_lifecycle();
init_nls();
init_configuration();
init_contextkey();
init_instantiation();
init_range();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js
var TreeViewsDnDService = class {
  constructor() {
    this._dragOperations = /* @__PURE__ */ new Map();
  }
  removeDragOperationTransfer(uuid) {
    if (uuid && this._dragOperations.has(uuid)) {
      const operation = this._dragOperations.get(uuid);
      this._dragOperations.delete(uuid);
      return operation;
    }
    return void 0;
  }
};
var DraggedTreeItemsIdentifier = class {
  constructor(identifier) {
    this.identifier = identifier;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js
init_extensions();
init_instantiation();
var ITreeViewsDnDService = createDecorator("treeViewsDndService");
registerSingleton(
  ITreeViewsDnDService,
  TreeViewsDnDService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorController.js
init_editorState();
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DropIntoEditorController_1;
var dropAsPreferenceConfig = "editor.dropIntoEditor.preferences";
var changeDropTypeCommandId = "editor.changeDropType";
var dropWidgetVisibleCtx = new RawContextKey("dropWidgetVisible", false, localize(929, "Whether the drop widget is showing"));
var _a30;
var DropIntoEditorController = (_a30 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(DropIntoEditorController_1.ID);
  }
  constructor(editor2, instantiationService, _configService, _languageFeaturesService, _treeViewsDragAndDropService) {
    super();
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._treeViewsDragAndDropService = _treeViewsDragAndDropService;
    this.treeItemsTransfer = LocalSelectionTransfer.getInstance();
    this._dropProgressManager = this._register(instantiationService.createInstance(InlineProgressManager, "dropIntoEditor", editor2));
    this._postDropWidgetManager = this._register(instantiationService.createInstance(PostEditWidgetManager, "dropIntoEditor", editor2, dropWidgetVisibleCtx, { id: changeDropTypeCommandId, label: localize(930, "Show drop options...") }, () => DropIntoEditorController_1._configureDefaultAction ? [DropIntoEditorController_1._configureDefaultAction] : []));
    this._register(editor2.onDropIntoEditor((e) => this.onDropIntoEditor(editor2, e.position, e.event)));
  }
  clearWidgets() {
    this._postDropWidgetManager.clear();
  }
  changeDropType() {
    this._postDropWidgetManager.tryShowSelector();
  }
  async onDropIntoEditor(editor2, position, dragEvent) {
    if (!dragEvent.dataTransfer || !editor2.hasModel()) {
      return;
    }
    DropIntoEditorController_1._currentDropOperation?.cancel();
    editor2.focus();
    editor2.setPosition(position);
    const p = createCancelablePromise(async (token) => {
      const disposables = new DisposableStore();
      const tokenSource = disposables.add(new EditorStateCancellationTokenSource(editor2, 1, void 0, token));
      try {
        const ourDataTransfer = await this.extractDataTransferData(dragEvent);
        if (ourDataTransfer.size === 0 || tokenSource.token.isCancellationRequested) {
          return;
        }
        const model = editor2.getModel();
        if (!model) {
          return;
        }
        const providers = this._languageFeaturesService.documentDropEditProvider.ordered(model).filter((provider) => {
          if (!provider.dropMimeTypes) {
            return true;
          }
          return provider.dropMimeTypes.some((mime) => ourDataTransfer.matches(mime));
        });
        const editSession = disposables.add(await this.getDropEdits(providers, model, position, ourDataTransfer, tokenSource.token));
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (editSession.edits.length) {
          const activeEditIndex = this.getInitialActiveEditIndex(model, editSession.edits);
          const canShowWidget = editor2.getOption(
            43
            /* EditorOption.dropIntoEditor */
          ).showDropSelector === "afterDrop";
          await this._postDropWidgetManager.applyEditAndShowIfNeeded([Range.fromPositions(position)], { activeEditIndex, allEdits: editSession.edits }, canShowWidget, async (edit) => edit, token);
        }
      } finally {
        disposables.dispose();
        if (DropIntoEditorController_1._currentDropOperation === p) {
          DropIntoEditorController_1._currentDropOperation = void 0;
        }
      }
    });
    this._dropProgressManager.showWhile(position, localize(931, "Running drop handlers. Click to cancel"), p, { cancel: () => p.cancel() });
    DropIntoEditorController_1._currentDropOperation = p;
  }
  async getDropEdits(providers, model, position, dataTransfer, token) {
    const disposables = new DisposableStore();
    const results = await raceCancellation(Promise.all(providers.map(async (provider) => {
      try {
        const edits2 = await provider.provideDocumentDropEdits(model, position, dataTransfer, token);
        if (edits2) {
          disposables.add(edits2);
        }
        return edits2?.edits.map((edit) => ({ ...edit, providerId: provider.id }));
      } catch (err) {
        if (!isCancellationError(err)) {
          console.error(err);
        }
        console.error(err);
      }
      return void 0;
    })), token);
    const edits = coalesce(results ?? []).flat();
    return {
      edits: sortEditsByYieldTo(edits),
      dispose: () => disposables.dispose()
    };
  }
  getInitialActiveEditIndex(model, edits) {
    const preferredProviders = this._configService.getValue(dropAsPreferenceConfig, { resource: model.uri });
    for (const config of Array.isArray(preferredProviders) ? preferredProviders : []) {
      const desiredKind = new HierarchicalKind(config);
      const editIndex = edits.findIndex((edit) => edit.kind && desiredKind.contains(edit.kind));
      if (editIndex >= 0) {
        return editIndex;
      }
    }
    return 0;
  }
  async extractDataTransferData(dragEvent) {
    if (!dragEvent.dataTransfer) {
      return new VSDataTransfer();
    }
    const dataTransfer = toExternalVSDataTransfer(dragEvent.dataTransfer);
    if (this.treeItemsTransfer.hasData(DraggedTreeItemsIdentifier.prototype)) {
      const data = this.treeItemsTransfer.getData(DraggedTreeItemsIdentifier.prototype);
      if (Array.isArray(data)) {
        for (const id of data) {
          const treeDataTransfer = await this._treeViewsDragAndDropService.removeDragOperationTransfer(id.identifier);
          if (treeDataTransfer) {
            for (const [type, value] of treeDataTransfer) {
              dataTransfer.replace(type, value);
            }
          }
        }
      }
    }
    return dataTransfer;
  }
}, DropIntoEditorController_1 = _a30, _a30.ID = "editor.contrib.dropIntoEditorController", _a30);
DropIntoEditorController = DropIntoEditorController_1 = __decorate36([
  __param36(1, IInstantiationService),
  __param36(2, IConfigurationService),
  __param36(3, ILanguageFeaturesService),
  __param36(4, ITreeViewsDnDService)
], DropIntoEditorController);

// node_modules/monaco-editor/esm/vs/editor/contrib/dropOrPasteInto/browser/dropIntoEditorContribution.js
registerEditorContribution(
  DropIntoEditorController.ID,
  DropIntoEditorController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorFeature(DefaultDropProvidersFeature);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: changeDropTypeCommandId,
      precondition: dropWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 2048 | 89
      }
    });
  }
  runEditorCommand(_accessor, editor2, _args) {
    DropIntoEditorController.get(editor2)?.changeDropType();
  }
}());
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.hideDropWidget",
      precondition: dropWidgetVisibleCtx,
      kbOpts: {
        weight: 100,
        primary: 9
      }
    });
  }
  runEditorCommand(_accessor, editor2, _args) {
    DropIntoEditorController.get(editor2)?.clearWidgets();
  }
}());

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
init_async();
init_lifecycle();
init_strings();
init_editorExtensions();
init_editorColorRegistry();
init_editorContextKeys();
init_model2();

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
init_arraysFind();
init_async();
init_lifecycle();
init_position();
init_range();
init_selection();
init_textModelSearch();

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findDecorations.js
init_range();
init_model2();
init_textModel();
init_colorRegistry();
init_themeService();
var _FindDecorations = class _FindDecorations {
  constructor(editor2) {
    this._editor = editor2;
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
    this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations());
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  /** @deprecated use getFindScopes to support multiple selections */
  getFindScope() {
    if (this._findScopeDecorationIds[0]) {
      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
    }
    return null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
      if (scopes.length) {
        return scopes;
      }
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(newStartPosition) {
    this._startPosition = newStartPosition;
    this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(decorationId) {
    const index = this._decorations.indexOf(decorationId);
    if (index >= 0) {
      return index + 1;
    }
    return 1;
  }
  getDecorationRangeAt(index) {
    const decorationId = index < this._decorations.length ? this._decorations[index] : null;
    if (decorationId) {
      return this._editor.getModel().getDecorationRange(decorationId);
    }
    return null;
  }
  getCurrentMatchesPosition(desiredRange) {
    const candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
    for (const candidate of candidates) {
      const candidateOpts = candidate.options;
      if (candidateOpts === _FindDecorations._FIND_MATCH_DECORATION || candidateOpts === _FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
        return this._getDecorationIndex(candidate.id);
      }
    }
    return 0;
  }
  setCurrentFindMatch(nextMatch) {
    let newCurrentDecorationId = null;
    let matchPosition = 0;
    if (nextMatch) {
      for (let i2 = 0, len = this._decorations.length; i2 < len; i2++) {
        const range = this._editor.getModel().getDecorationRange(this._decorations[i2]);
        if (nextMatch.equalsRange(range)) {
          newCurrentDecorationId = this._decorations[i2];
          matchPosition = i2 + 1;
          break;
        }
      }
    }
    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
      this._editor.changeDecorations((changeAccessor) => {
        if (this._highlightedDecorationId !== null) {
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, _FindDecorations._FIND_MATCH_DECORATION);
          this._highlightedDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          this._highlightedDecorationId = newCurrentDecorationId;
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, _FindDecorations._CURRENT_FIND_MATCH_DECORATION);
        }
        if (this._rangeHighlightDecorationId !== null) {
          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
          this._rangeHighlightDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
            const lineBeforeEnd = rng.endLineNumber - 1;
            const lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
            rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
          }
          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, _FindDecorations._RANGE_HIGHLIGHT_DECORATION);
        }
      });
    }
    return matchPosition;
  }
  set(findMatches, findScopes) {
    this._editor.changeDecorations((accessor) => {
      let findMatchesOptions = _FindDecorations._FIND_MATCH_DECORATION;
      const newOverviewRulerApproximateDecorations = [];
      if (findMatches.length > 1e3) {
        findMatchesOptions = _FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const lineCount = this._editor.getModel().getLineCount();
        const height = this._editor.getLayoutInfo().height;
        const approxPixelsPerLine = height / lineCount;
        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
        let prevStartLineNumber = findMatches[0].range.startLineNumber;
        let prevEndLineNumber = findMatches[0].range.endLineNumber;
        for (let i2 = 1, len = findMatches.length; i2 < len; i2++) {
          const range = findMatches[i2].range;
          if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
            if (range.endLineNumber > prevEndLineNumber) {
              prevEndLineNumber = range.endLineNumber;
            }
          } else {
            newOverviewRulerApproximateDecorations.push({
              range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: _FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
            prevStartLineNumber = range.startLineNumber;
            prevEndLineNumber = range.endLineNumber;
          }
        }
        newOverviewRulerApproximateDecorations.push({
          range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
          options: _FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const newFindMatchesDecorations = new Array(findMatches.length);
      for (let i2 = 0, len = findMatches.length; i2 < len; i2++) {
        newFindMatchesDecorations[i2] = {
          range: findMatches[i2].range,
          options: findMatchesOptions
        };
      }
      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
      if (this._rangeHighlightDecorationId) {
        accessor.removeDecoration(this._rangeHighlightDecorationId);
        this._rangeHighlightDecorationId = null;
      }
      if (this._findScopeDecorationIds.length) {
        this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
        this._findScopeDecorationIds = [];
      }
      if (findScopes?.length) {
        this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, _FindDecorations._FIND_SCOPE_DECORATION));
      }
    });
  }
  matchBeforePosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i2 = this._decorations.length - 1; i2 >= 0; i2--) {
      const decorationId = this._decorations[i2];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.endLineNumber > position.lineNumber) {
        continue;
      }
      if (r.endLineNumber < position.lineNumber) {
        return r;
      }
      if (r.endColumn > position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i2 = 0, len = this._decorations.length; i2 < len; i2++) {
      const decorationId = this._decorations[i2];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.startLineNumber < position.lineNumber) {
        continue;
      }
      if (r.startLineNumber > position.lineNumber) {
        return r;
      }
      if (r.startColumn < position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let result = [];
    result = result.concat(this._decorations);
    result = result.concat(this._overviewRulerApproximateDecorations);
    if (this._findScopeDecorationIds.length) {
      result.push(...this._findScopeDecorationIds);
    }
    if (this._rangeHighlightDecorationId) {
      result.push(this._rangeHighlightDecorationId);
    }
    return result;
  }
};
_FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  inlineClassName: "currentFindMatchInline",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: 1
    /* MinimapPosition.Inline */
  }
});
_FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  inlineClassName: "findMatchInline",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: 1
    /* MinimapPosition.Inline */
  }
});
_FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true
});
_FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  }
});
_FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
});
_FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: true
});
var FindDecorations = _FindDecorations;

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replaceAllCommand.js
init_range();
var ReplaceAllCommand = class {
  constructor(editorSelection, ranges, replaceStrings) {
    this._editorSelection = editorSelection;
    this._ranges = ranges;
    this._replaceStrings = replaceStrings;
    this._trackedEditorSelectionId = null;
  }
  getEditOperations(model, builder) {
    if (this._ranges.length > 0) {
      const ops = [];
      for (let i2 = 0; i2 < this._ranges.length; i2++) {
        ops.push({
          range: this._ranges[i2],
          text: this._replaceStrings[i2]
        });
      }
      ops.sort((o1, o2) => {
        return Range.compareRangesUsingStarts(o1.range, o2.range);
      });
      const resultOps = [];
      let previousOp = ops[0];
      for (let i2 = 1; i2 < ops.length; i2++) {
        if (previousOp.range.endLineNumber === ops[i2].range.startLineNumber && previousOp.range.endColumn === ops[i2].range.startColumn) {
          previousOp.range = previousOp.range.plusRange(ops[i2].range);
          previousOp.text = previousOp.text + ops[i2].text;
        } else {
          resultOps.push(previousOp);
          previousOp = ops[i2];
        }
      }
      resultOps.push(previousOp);
      for (const op of resultOps) {
        builder.addEditOperation(op.range, op.text);
      }
    }
    this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._trackedEditorSelectionId);
  }
};

// node_modules/monaco-editor/esm/vs/base/common/search.js
init_strings();
function buildReplaceStringWithCasePreserved(matches, pattern) {
  if (matches && matches[0] !== "") {
    const containsHyphens = validateSpecificSpecialCharacter(matches, pattern, "-");
    const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern, "_");
    if (containsHyphens && !containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "-");
    } else if (!containsHyphens && containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "_");
    }
    if (matches[0].toUpperCase() === matches[0]) {
      return pattern.toUpperCase();
    } else if (matches[0].toLowerCase() === matches[0]) {
      return pattern.toLowerCase();
    } else if (containsUppercaseCharacter(matches[0][0]) && pattern.length > 0) {
      return pattern[0].toUpperCase() + pattern.substr(1);
    } else if (matches[0][0].toUpperCase() !== matches[0][0] && pattern.length > 0) {
      return pattern[0].toLowerCase() + pattern.substr(1);
    } else {
      return pattern;
    }
  } else {
    return pattern;
  }
}
function validateSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const doesContainSpecialCharacter = matches[0].indexOf(specialCharacter) !== -1 && pattern.indexOf(specialCharacter) !== -1;
  return doesContainSpecialCharacter && matches[0].split(specialCharacter).length === pattern.split(specialCharacter).length;
}
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const splitPatternAtSpecialCharacter = pattern.split(specialCharacter);
  const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
  let replaceString = "";
  splitPatternAtSpecialCharacter.forEach((splitValue, index) => {
    replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index]], splitValue) + specialCharacter;
  });
  return replaceString.slice(0, -1);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js
var StaticValueReplacePattern = class {
  constructor(staticValue) {
    this.staticValue = staticValue;
    this.kind = 0;
  }
};
var DynamicPiecesReplacePattern = class {
  constructor(pieces) {
    this.pieces = pieces;
    this.kind = 1;
  }
};
var ReplacePattern = class _ReplacePattern {
  static fromStaticValue(value) {
    return new _ReplacePattern([ReplacePiece.staticValue(value)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(pieces) {
    if (!pieces || pieces.length === 0) {
      this._state = new StaticValueReplacePattern("");
    } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
      this._state = new StaticValueReplacePattern(pieces[0].staticValue);
    } else {
      this._state = new DynamicPiecesReplacePattern(pieces);
    }
  }
  buildReplaceString(matches, preserveCase) {
    if (this._state.kind === 0) {
      if (preserveCase) {
        return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
      } else {
        return this._state.staticValue;
      }
    }
    let result = "";
    for (let i2 = 0, len = this._state.pieces.length; i2 < len; i2++) {
      const piece = this._state.pieces[i2];
      if (piece.staticValue !== null) {
        result += piece.staticValue;
        continue;
      }
      let match = _ReplacePattern._substitute(piece.matchIndex, matches);
      if (piece.caseOps !== null && piece.caseOps.length > 0) {
        const repl = [];
        const lenOps = piece.caseOps.length;
        let opIdx = 0;
        for (let idx = 0, len2 = match.length; idx < len2; idx++) {
          if (opIdx >= lenOps) {
            repl.push(match.slice(idx));
            break;
          }
          switch (piece.caseOps[opIdx]) {
            case "U":
              repl.push(match[idx].toUpperCase());
              break;
            case "u":
              repl.push(match[idx].toUpperCase());
              opIdx++;
              break;
            case "L":
              repl.push(match[idx].toLowerCase());
              break;
            case "l":
              repl.push(match[idx].toLowerCase());
              opIdx++;
              break;
            default:
              repl.push(match[idx]);
          }
        }
        match = repl.join("");
      }
      result += match;
    }
    return result;
  }
  static _substitute(matchIndex, matches) {
    if (matches === null) {
      return "";
    }
    if (matchIndex === 0) {
      return matches[0];
    }
    let remainder = "";
    while (matchIndex > 0) {
      if (matchIndex < matches.length) {
        const match = matches[matchIndex] || "";
        return match + remainder;
      }
      remainder = String(matchIndex % 10) + remainder;
      matchIndex = Math.floor(matchIndex / 10);
    }
    return "$" + remainder;
  }
};
var ReplacePiece = class _ReplacePiece {
  static staticValue(value) {
    return new _ReplacePiece(value, -1, null);
  }
  static caseOps(index, caseOps) {
    return new _ReplacePiece(null, index, caseOps);
  }
  constructor(staticValue, matchIndex, caseOps) {
    this.staticValue = staticValue;
    this.matchIndex = matchIndex;
    if (!caseOps || caseOps.length === 0) {
      this.caseOps = null;
    } else {
      this.caseOps = caseOps.slice(0);
    }
  }
};
var ReplacePieceBuilder = class {
  constructor(source) {
    this._source = source;
    this._lastCharIndex = 0;
    this._result = [];
    this._resultLen = 0;
    this._currentStaticPiece = "";
  }
  emitUnchanged(toCharIndex) {
    this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
    this._lastCharIndex = toCharIndex;
  }
  emitStatic(value, toCharIndex) {
    this._emitStatic(value);
    this._lastCharIndex = toCharIndex;
  }
  _emitStatic(value) {
    if (value.length === 0) {
      return;
    }
    this._currentStaticPiece += value;
  }
  emitMatchIndex(index, toCharIndex, caseOps) {
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);
    this._lastCharIndex = toCharIndex;
  }
  finalize() {
    this.emitUnchanged(this._source.length);
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    return new ReplacePattern(this._result);
  }
};
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  const caseOps = [];
  const result = new ReplacePieceBuilder(replaceString);
  for (let i2 = 0, len = replaceString.length; i2 < len; i2++) {
    const chCode = replaceString.charCodeAt(i2);
    if (chCode === 92) {
      i2++;
      if (i2 >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i2);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i2 - 1);
          result.emitStatic("\\", i2 + 1);
          break;
        case 110:
          result.emitUnchanged(i2 - 1);
          result.emitStatic("\n", i2 + 1);
          break;
        case 116:
          result.emitUnchanged(i2 - 1);
          result.emitStatic("	", i2 + 1);
          break;
        // Case modification of string replacements, patterned after Boost, but only applied
        // to the replacement text, not subsequent content.
        case 117:
        // \u => upper-cases one character.
        case 85:
        // \U => upper-cases ALL following characters.
        case 108:
        // \l => lower-cases one character.
        case 76:
          result.emitUnchanged(i2 - 1);
          result.emitStatic("", i2 + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i2++;
      if (i2 >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i2);
      if (nextChCode === 36) {
        result.emitUnchanged(i2 - 1);
        result.emitStatic("$", i2 + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i2 - 1);
        result.emitMatchIndex(0, i2 + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i2 + 1 < len) {
          const nextNextChCode = replaceString.charCodeAt(i2 + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i2++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i2 - 2);
            result.emitMatchIndex(matchIndex, i2 + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i2 - 1);
        result.emitMatchIndex(matchIndex, i2 + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
init_contextkey();
var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
var CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
var ToggleCaseSensitiveKeybinding = {
  primary: 512 | 33,
  mac: {
    primary: 2048 | 512 | 33
    /* KeyCode.KeyC */
  }
};
var ToggleWholeWordKeybinding = {
  primary: 512 | 53,
  mac: {
    primary: 2048 | 512 | 53
    /* KeyCode.KeyW */
  }
};
var ToggleRegexKeybinding = {
  primary: 512 | 48,
  mac: {
    primary: 2048 | 512 | 48
    /* KeyCode.KeyR */
  }
};
var ToggleSearchScopeKeybinding = {
  primary: 512 | 42,
  mac: {
    primary: 2048 | 512 | 42
    /* KeyCode.KeyL */
  }
};
var TogglePreserveCaseKeybinding = {
  primary: 512 | 46,
  mac: {
    primary: 2048 | 512 | 46
    /* KeyCode.KeyP */
  }
};
var FIND_IDS = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  GoToMatchFindAction: "editor.action.goToMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
};
var MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = class _FindModelBoundToEditorModel {
  constructor(editor2, state) {
    this._toDispose = new DisposableStore();
    this._editor = editor2;
    this._state = state;
    this._isDisposed = false;
    this._startSearchingTimer = new TimeoutTimer();
    this._decorations = new FindDecorations(editor2);
    this._toDispose.add(this._decorations);
    this._updateDecorationsScheduler = new RunOnceScheduler(() => {
      if (!this._editor.hasModel()) {
        return;
      }
      return this.research(false);
    }, 100);
    this._toDispose.add(this._updateDecorationsScheduler);
    this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
        this._decorations.setStartPosition(this._editor.getPosition());
      }
    }));
    this._ignoreModelContentChanged = false;
    this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (this._ignoreModelContentChanged) {
        return;
      }
      if (e.isFlush) {
        this._decorations.reset();
      }
      this._decorations.setStartPosition(this._editor.getPosition());
      this._updateDecorationsScheduler.schedule();
    }));
    this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this.research(false, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = true;
    dispose(this._startSearchingTimer);
    this._toDispose.dispose();
  }
  _onStateChanged(e) {
    if (this._isDisposed) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
      const model = this._editor.getModel();
      if (model.isTooLargeForSyncing()) {
        this._startSearchingTimer.cancel();
        this._startSearchingTimer.setIfNotSet(() => {
          if (e.searchScope) {
            this.research(e.moveCursor, this._state.searchScope);
          } else {
            this.research(e.moveCursor);
          }
        }, RESEARCH_DELAY);
      } else {
        if (e.searchScope) {
          this.research(e.moveCursor, this._state.searchScope);
        } else {
          this.research(e.moveCursor);
        }
      }
    }
  }
  static _getSearchRange(model, findScope) {
    if (findScope) {
      return findScope;
    }
    return model.getFullModelRange();
  }
  research(moveCursor, newFindScope) {
    let findScopes = null;
    if (typeof newFindScope !== "undefined") {
      if (newFindScope !== null) {
        if (!Array.isArray(newFindScope)) {
          findScopes = [newFindScope];
        } else {
          findScopes = newFindScope;
        }
      }
    } else {
      findScopes = this._decorations.getFindScopes();
    }
    if (findScopes !== null) {
      findScopes = findScopes.map((findScope) => {
        if (findScope.startLineNumber !== findScope.endLineNumber) {
          let endLineNumber = findScope.endLineNumber;
          if (findScope.endColumn === 1) {
            endLineNumber = endLineNumber - 1;
          }
          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
        }
        return findScope;
      });
    }
    const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
    this._decorations.set(findMatches, findScopes);
    const editorSelection = this._editor.getSelection();
    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
    if (currentMatchesPosition === 0 && findMatches.length > 0) {
      const matchAfterSelection = findFirstIdxMonotonousOrArrLen(findMatches.map((match) => match.range), (range) => Range.compareRangesUsingStarts(range, editorSelection) >= 0);
      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
    }
    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
    if (moveCursor && this._editor.getOption(
      50
      /* EditorOption.find */
    ).cursorMoveOnType) {
      this._moveToNextMatch(this._decorations.getStartPosition());
    }
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const findScope = this._decorations.getFindScope();
      if (findScope) {
        this._editor.revealRangeInCenterIfOutsideViewport(
          findScope,
          0
          /* ScrollType.Smooth */
        );
      }
      return true;
    }
    return false;
  }
  _setCurrentFindMatch(match) {
    const matchesPosition = this._decorations.setCurrentFindMatch(match);
    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
    this._editor.setSelection(match);
    this._editor.revealRangeInCenterIfOutsideViewport(
      match,
      0
      /* ScrollType.Smooth */
    );
  }
  _prevSearchPosition(before) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = before;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === 1) {
      if (lineNumber === 1) {
        lineNumber = model.getLineCount();
      } else {
        lineNumber--;
      }
      column = model.getLineMaxColumn(lineNumber);
    } else {
      column--;
    }
    return new Position(lineNumber, column);
  }
  _moveToPrevMatch(before, isRecursed = false) {
    if (!this._state.canNavigateBack()) {
      const nextMatchRange = this._decorations.matchAfterPosition(before);
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let prevMatchRange = this._decorations.matchBeforePosition(before);
      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
        before = this._prevSearchPosition(before);
        prevMatchRange = this._decorations.matchBeforePosition(before);
      }
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._cannotFind()) {
      return;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(before)) {
      before = searchRange.getEndPosition();
    }
    if (before.isBefore(searchRange.getStartPosition())) {
      before = searchRange.getEndPosition();
    }
    const { lineNumber, column } = before;
    const model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
      position = this._prevSearchPosition(position);
      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
        148
        /* EditorOption.wordSeparators */
      ) : null, false);
    }
    if (!prevMatch) {
      return;
    }
    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
    }
    this._setCurrentFindMatch(prevMatch.range);
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(after) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = after;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
      if (lineNumber === model.getLineCount()) {
        lineNumber = 1;
      } else {
        lineNumber++;
      }
      column = 1;
    } else {
      column++;
    }
    return new Position(lineNumber, column);
  }
  _moveToNextMatch(after) {
    if (!this._state.canNavigateForward()) {
      const prevMatchRange = this._decorations.matchBeforePosition(after);
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let nextMatchRange = this._decorations.matchAfterPosition(after);
      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
        after = this._nextSearchPosition(after);
        nextMatchRange = this._decorations.matchAfterPosition(after);
      }
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    const nextMatch = this._getNextMatch(after, false, true);
    if (nextMatch) {
      this._setCurrentFindMatch(nextMatch.range);
    }
  }
  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
    if (this._cannotFind()) {
      return null;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(after)) {
      after = searchRange.getStartPosition();
    }
    if (after.isBefore(searchRange.getStartPosition())) {
      after = searchRange.getStartPosition();
    }
    const { lineNumber, column } = after;
    const model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null, captureMatches);
    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
      position = this._nextSearchPosition(position);
      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
        148
        /* EditorOption.wordSeparators */
      ) : null, captureMatches);
    }
    if (!nextMatch) {
      return null;
    }
    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
    }
    return nextMatch;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _moveToMatch(index) {
    const decorationRange = this._decorations.getDecorationRangeAt(index);
    if (decorationRange) {
      this._setCurrentFindMatch(decorationRange);
    }
  }
  moveToMatch(index) {
    this._moveToMatch(index);
  }
  _getReplacePattern() {
    if (this._state.isRegex) {
      return parseReplaceString(this._state.replaceString);
    }
    return ReplacePattern.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches()) {
      return;
    }
    const replacePattern = this._getReplacePattern();
    const selection = this._editor.getSelection();
    const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
    if (nextMatch) {
      if (selection.equalsRange(nextMatch.range)) {
        const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
        const command = new ReplaceCommand(selection, replaceString);
        this._executeEditorCommand("replace", command);
        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
        this.research(true);
      } else {
        this._decorations.setStartPosition(this._editor.getPosition());
        this._setCurrentFindMatch(nextMatch.range);
      }
    }
  }
  _findMatches(findScopes, captureMatches, limitResultCount) {
    const searchRanges = (findScopes || [null]).map((scope) => _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null, captureMatches, limitResultCount);
  }
  replaceAll() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
      this._largeReplaceAll();
    } else {
      this._regularReplaceAll(findScopes);
    }
    this.research(false);
  }
  _largeReplaceAll() {
    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return;
    }
    let searchRegex = searchData.regex;
    if (!searchRegex.multiline) {
      let mod = "mu";
      if (searchRegex.ignoreCase) {
        mod += "i";
      }
      if (searchRegex.global) {
        mod += "g";
      }
      searchRegex = new RegExp(searchRegex.source, mod);
    }
    const model = this._editor.getModel();
    const modelText = model.getValue(
      1
      /* EndOfLinePreference.LF */
    );
    const fullModelRange = model.getFullModelRange();
    const replacePattern = this._getReplacePattern();
    let resultText;
    const preserveCase = this._state.preserveCase;
    if (replacePattern.hasReplacementPatterns || preserveCase) {
      resultText = modelText.replace(searchRegex, function() {
        return replacePattern.buildReplaceString(arguments, preserveCase);
      });
    } else {
      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
    }
    const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", command);
  }
  _regularReplaceAll(findScopes) {
    const replacePattern = this._getReplacePattern();
    const matches = this._findMatches(
      findScopes,
      replacePattern.hasReplacementPatterns || this._state.preserveCase,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    const replaceStrings = [];
    for (let i2 = 0, len = matches.length; i2 < len; i2++) {
      replaceStrings[i2] = replacePattern.buildReplaceString(matches[i2].matches, this._state.preserveCase);
    }
    const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
    this._executeEditorCommand("replaceAll", command);
  }
  selectAllMatches() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    const matches = this._findMatches(
      findScopes,
      false,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
    const editorSelection = this._editor.getSelection();
    for (let i2 = 0, len = selections.length; i2 < len; i2++) {
      const sel = selections[i2];
      if (sel.equalsRange(editorSelection)) {
        selections = [editorSelection].concat(selections.slice(0, i2)).concat(selections.slice(i2 + 1));
        break;
      }
    }
    this._editor.setSelections(selections);
  }
  _executeEditorCommand(source, command) {
    try {
      this._ignoreModelContentChanged = true;
      this._editor.pushUndoStop();
      this._editor.executeCommand(source, command);
      this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = false;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.js
init_dom();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.css";
init_async();
init_colorRegistry();
var _FindOptionsWidget = class _FindOptionsWidget extends Widget {
  constructor(editor2, state, keybindingService) {
    super();
    this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
    this._isVisible = false;
    this._editor = editor2;
    this._state = state;
    this._keybindingService = keybindingService;
    this._domNode = document.createElement("div");
    this._domNode.className = "findOptionsWidget";
    this._domNode.style.display = "none";
    this._domNode.style.top = "10px";
    this._domNode.style.zIndex = "12";
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    const toggleStyles = {
      inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground),
      inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground)
    };
    const hoverDelegate = this._register(createInstantHoverDelegate());
    this.caseSensitive = this._register(new CaseSensitiveToggle({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      isChecked: this._state.matchCase,
      hoverDelegate,
      ...toggleStyles
    }));
    this._domNode.appendChild(this.caseSensitive.domNode);
    this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, false);
    }));
    this.wholeWords = this._register(new WholeWordsToggle({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      isChecked: this._state.wholeWord,
      hoverDelegate,
      ...toggleStyles
    }));
    this._domNode.appendChild(this.wholeWords.domNode);
    this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, false);
    }));
    this.regex = this._register(new RegexToggle({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      isChecked: this._state.isRegex,
      hoverDelegate,
      ...toggleStyles
    }));
    this._domNode.appendChild(this.regex.domNode);
    this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, false);
    }));
    this._editor.addOverlayWidget(this);
    this._register(this._state.onFindReplaceStateChange((e) => {
      let somethingChanged = false;
      if (e.isRegex) {
        this.regex.checked = this._state.isRegex;
        somethingChanged = true;
      }
      if (e.wholeWord) {
        this.wholeWords.checked = this._state.wholeWord;
        somethingChanged = true;
      }
      if (e.matchCase) {
        this.caseSensitive.checked = this._state.matchCase;
        somethingChanged = true;
      }
      if (!this._state.isRevealed && somethingChanged) {
        this._revealTemporarily();
      }
    }));
    this._register(addDisposableListener(this._domNode, EventType.MOUSE_LEAVE, (e) => this._onMouseLeave()));
    this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
  }
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return _FindOptionsWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show();
    this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._domNode.style.display = "block";
  }
  _hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._domNode.style.display = "none";
  }
};
_FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";
var FindOptionsWidget = _FindOptionsWidget;

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findState.js
init_event();
init_lifecycle();
init_range();
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
var FindReplaceState = class extends Disposable {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return effectiveOptionValue(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  constructor() {
    super();
    this._onFindReplaceStateChange = this._register(new Emitter());
    this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
    this._searchString = "";
    this._replaceString = "";
    this._isRevealed = false;
    this._isReplaceRevealed = false;
    this._isRegex = false;
    this._isRegexOverride = 0;
    this._wholeWord = false;
    this._wholeWordOverride = 0;
    this._matchCase = false;
    this._matchCaseOverride = 0;
    this._preserveCase = false;
    this._preserveCaseOverride = 0;
    this._searchScope = null;
    this._matchesPosition = 0;
    this._matchesCount = 0;
    this._currentMatch = null;
    this._loop = true;
    this._isSearching = false;
    this._filters = null;
  }
  changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
    const changeEvent = {
      moveCursor: false,
      updateHistory: false,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    if (matchesCount === 0) {
      matchesPosition = 0;
    }
    if (matchesPosition > matchesCount) {
      matchesPosition = matchesCount;
    }
    if (this._matchesPosition !== matchesPosition) {
      this._matchesPosition = matchesPosition;
      changeEvent.matchesPosition = true;
      somethingChanged = true;
    }
    if (this._matchesCount !== matchesCount) {
      this._matchesCount = matchesCount;
      changeEvent.matchesCount = true;
      somethingChanged = true;
    }
    if (typeof currentMatch !== "undefined") {
      if (!Range.equalsRange(this._currentMatch, currentMatch)) {
        this._currentMatch = currentMatch;
        changeEvent.currentMatch = true;
        somethingChanged = true;
      }
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  change(newState, moveCursor, updateHistory = true) {
    const changeEvent = {
      moveCursor,
      updateHistory,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    const oldEffectiveIsRegex = this.isRegex;
    const oldEffectiveWholeWords = this.wholeWord;
    const oldEffectiveMatchCase = this.matchCase;
    const oldEffectivePreserveCase = this.preserveCase;
    if (typeof newState.searchString !== "undefined") {
      if (this._searchString !== newState.searchString) {
        this._searchString = newState.searchString;
        changeEvent.searchString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.replaceString !== "undefined") {
      if (this._replaceString !== newState.replaceString) {
        this._replaceString = newState.replaceString;
        changeEvent.replaceString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRevealed !== "undefined") {
      if (this._isRevealed !== newState.isRevealed) {
        this._isRevealed = newState.isRevealed;
        changeEvent.isRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isReplaceRevealed !== "undefined") {
      if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
        this._isReplaceRevealed = newState.isReplaceRevealed;
        changeEvent.isReplaceRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRegex !== "undefined") {
      this._isRegex = newState.isRegex;
    }
    if (typeof newState.wholeWord !== "undefined") {
      this._wholeWord = newState.wholeWord;
    }
    if (typeof newState.matchCase !== "undefined") {
      this._matchCase = newState.matchCase;
    }
    if (typeof newState.preserveCase !== "undefined") {
      this._preserveCase = newState.preserveCase;
    }
    if (typeof newState.searchScope !== "undefined") {
      if (!newState.searchScope?.every((newSearchScope) => {
        return this._searchScope?.some((existingSearchScope) => {
          return !Range.equalsRange(existingSearchScope, newSearchScope);
        });
      })) {
        this._searchScope = newState.searchScope;
        changeEvent.searchScope = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.loop !== "undefined") {
      if (this._loop !== newState.loop) {
        this._loop = newState.loop;
        changeEvent.loop = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isSearching !== "undefined") {
      if (this._isSearching !== newState.isSearching) {
        this._isSearching = newState.isSearching;
        changeEvent.isSearching = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.filters !== "undefined") {
      if (this._filters) {
        this._filters.update(newState.filters);
      } else {
        this._filters = newState.filters;
      }
      changeEvent.filters = true;
      somethingChanged = true;
    }
    this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
    this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
    this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
    this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
    if (oldEffectiveIsRegex !== this.isRegex) {
      somethingChanged = true;
      changeEvent.isRegex = true;
    }
    if (oldEffectiveWholeWords !== this.wholeWord) {
      somethingChanged = true;
      changeEvent.wholeWord = true;
    }
    if (oldEffectiveMatchCase !== this.matchCase) {
      somethingChanged = true;
      changeEvent.matchCase = true;
    }
    if (oldEffectivePreserveCase !== this.preserveCase) {
      somethingChanged = true;
      changeEvent.preserveCase = true;
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= MATCHES_LIMIT;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js
init_dom();
init_async();
init_codicons();
init_errors();
init_lifecycle();
init_platform();
init_strings();
init_range();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.css";
init_nls();

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js
init_dom();
init_codicons();
init_event();
init_nls();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css";
var NLS_DEFAULT_LABEL = localize(5, "input");
var NLS_PRESERVE_CASE_LABEL = localize(6, "Preserve Case");
var PreserveCaseToggle = class extends Toggle {
  constructor(opts) {
    super({
      // TODO: does this need its own icon?
      icon: Codicon.preserveCase,
      title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      hoverDelegate: opts.hoverDelegate ?? getDefaultHoverDelegate("element"),
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var ReplaceInput = class extends Widget {
  get onDidOptionChange() {
    return this._onDidOptionChange.event;
  }
  get onKeyDown() {
    return this._onKeyDown.event;
  }
  get onPreserveCaseKeyDown() {
    return this._onPreserveCaseKeyDown.event;
  }
  constructor(parent, contextViewProvider, _showOptionButtons, options) {
    super();
    this._showOptionButtons = _showOptionButtons;
    this.fixFocusOnOptionClickEnabled = true;
    this.cachedOptionsWidth = 0;
    this._onDidOptionChange = this._register(new Emitter());
    this._onKeyDown = this._register(new Emitter());
    this._onMouseDown = this._register(new Emitter());
    this._onInput = this._register(new Emitter());
    this._onKeyUp = this._register(new Emitter());
    this._onPreserveCaseKeyDown = this._register(new Emitter());
    this.contextViewProvider = contextViewProvider;
    this.placeholder = options.placeholder || "";
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL;
    const appendPreserveCaseLabel = options.appendPreserveCaseLabel || "";
    const history = options.history || /* @__PURE__ */ new Set([]);
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      history,
      showHistoryHint: options.showHistoryHint,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight,
      inputBoxStyles: options.inputBoxStyles
    }));
    this.preserveCase = this._register(new PreserveCaseToggle({
      appendTitle: appendPreserveCaseLabel,
      isChecked: false,
      ...options.toggleStyles
    }));
    this._register(this.preserveCase.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.preserveCase.onKeyDown((e) => {
      this._onPreserveCaseKeyDown.fire(e);
    }));
    if (this._showOptionButtons) {
      this.cachedOptionsWidth = this.preserveCase.width();
    } else {
      this.cachedOptionsWidth = 0;
    }
    const indexes = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (event) => {
      if (event.equals(
        15
        /* KeyCode.LeftArrow */
      ) || event.equals(
        17
        /* KeyCode.RightArrow */
      ) || event.equals(
        9
        /* KeyCode.Escape */
      )) {
        const index = indexes.indexOf(this.domNode.ownerDocument.activeElement);
        if (index >= 0) {
          let newIndex = -1;
          if (event.equals(
            17
            /* KeyCode.RightArrow */
          )) {
            newIndex = (index + 1) % indexes.length;
          } else if (event.equals(
            15
            /* KeyCode.LeftArrow */
          )) {
            if (index === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index - 1;
            }
          }
          if (event.equals(
            9
            /* KeyCode.Escape */
          )) {
            indexes[index].blur();
            this.inputBox.focus();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }
          EventHelper.stop(event, true);
        }
      }
    });
    const controls = document.createElement("div");
    controls.className = "controls";
    controls.style.display = this._showOptionButtons ? "block" : "none";
    controls.appendChild(this.preserveCase.domNode);
    this.domNode.appendChild(controls);
    parent?.appendChild(this.domNode);
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  enable() {
    this.domNode.classList.remove("disabled");
    this.inputBox.enable();
    this.preserveCase.enable();
  }
  disable() {
    this.domNode.classList.add("disabled");
    this.inputBox.disable();
    this.preserveCase.disable();
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(value) {
    this.preserveCase.checked = value;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    this.inputBox?.validate();
  }
  set width(newWidth) {
    this.inputBox.paddingRight = this.cachedOptionsWidth;
    this.domNode.style.width = newWidth + "px";
  }
  dispose() {
    super.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/platform/history/browser/contextScopedHistoryWidget.js
init_contextkey();
init_keybindingsRegistry();
init_nls();
init_lifecycle();
init_dom();
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var historyNavigationVisible = new RawContextKey("suggestWidgetVisible", false, localize(1683, "Whether suggestion are visible"));
var HistoryNavigationWidgetFocusContext = "historyNavigationWidgetFocus";
var HistoryNavigationForwardsEnablementContext = "historyNavigationForwardsEnabled";
var HistoryNavigationBackwardsEnablementContext = "historyNavigationBackwardsEnabled";
var lastFocusedWidget = void 0;
var widgets = [];
function registerAndCreateHistoryNavigationContext(scopedContextKeyService, widget) {
  if (widgets.includes(widget)) {
    throw new Error("Cannot register the same widget multiple times");
  }
  widgets.push(widget);
  const disposableStore = new DisposableStore();
  const historyNavigationWidgetFocus = new RawContextKey(HistoryNavigationWidgetFocusContext, false).bindTo(scopedContextKeyService);
  const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const onDidFocus = () => {
    historyNavigationWidgetFocus.set(true);
    lastFocusedWidget = widget;
  };
  const onDidBlur = () => {
    historyNavigationWidgetFocus.set(false);
    if (lastFocusedWidget === widget) {
      lastFocusedWidget = void 0;
    }
  };
  if (isActiveElement(widget.element)) {
    onDidFocus();
  }
  disposableStore.add(widget.onDidFocus(() => onDidFocus()));
  disposableStore.add(widget.onDidBlur(() => onDidBlur()));
  disposableStore.add(toDisposable(() => {
    widgets.splice(widgets.indexOf(widget), 1);
    onDidBlur();
  }));
  return {
    historyNavigationForwardsEnablement,
    historyNavigationBackwardsEnablement,
    dispose() {
      disposableStore.dispose();
    }
  };
}
var ContextScopedFindInput = class ContextScopedFindInput2 extends FindInput {
  constructor(container, contextViewProvider, options, contextKeyService) {
    super(container, contextViewProvider, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.inputBox.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this.inputBox));
  }
};
ContextScopedFindInput = __decorate37([
  __param37(3, IContextKeyService)
], ContextScopedFindInput);
var ContextScopedReplaceInput = class ContextScopedReplaceInput2 extends ReplaceInput {
  constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
    super(container, contextViewProvider, showReplaceOptions, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.inputBox.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this.inputBox));
  }
};
ContextScopedReplaceInput = __decorate37([
  __param37(3, IContextKeyService)
], ContextScopedReplaceInput);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), ContextKeyExpr.not("isComposing"), historyNavigationVisible.isEqualTo(false)),
  primary: 16,
  secondary: [
    512 | 16
    /* KeyCode.UpArrow */
  ],
  handler: (accessor) => {
    lastFocusedWidget?.showPreviousValue();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), ContextKeyExpr.not("isComposing"), historyNavigationVisible.isEqualTo(false)),
  primary: 18,
  secondary: [
    512 | 18
    /* KeyCode.DownArrow */
  ],
  handler: (accessor) => {
    lastFocusedWidget?.showNextValue();
  }
});

// node_modules/monaco-editor/esm/vs/platform/history/browser/historyWidgetKeybindingHint.js
function showHistoryKeybindingHint(keybindingService) {
  return keybindingService.lookupKeybinding("history.showPrevious")?.getElectronAccelerator() === "Up" && keybindingService.lookupKeybinding("history.showNext")?.getElectronAccelerator() === "Down";
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js
init_colorRegistry();
init_themeService();
init_themables();
init_theme();
init_types();
var findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize(951, "Icon to indicate that the editor find widget is collapsed."));
var findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize(952, "Icon to indicate that the editor find widget is expanded."));
var findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize(953, "Icon for 'Find in Selection' in the editor find widget."));
var findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize(954, "Icon for 'Replace' in the editor find widget."));
var findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize(955, "Icon for 'Replace All' in the editor find widget."));
var findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize(956, "Icon for 'Find Previous' in the editor find widget."));
var findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize(957, "Icon for 'Find Next' in the editor find widget."));
var NLS_FIND_DIALOG_LABEL = localize(958, "Find / Replace");
var NLS_FIND_INPUT_LABEL = localize(959, "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize(960, "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize(961, "Previous Match");
var NLS_NEXT_MATCH_BTN_LABEL = localize(962, "Next Match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize(963, "Find in Selection");
var NLS_CLOSE_BTN_LABEL = localize(964, "Close");
var NLS_REPLACE_INPUT_LABEL = localize(965, "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize(966, "Replace");
var NLS_REPLACE_BTN_LABEL = localize(967, "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize(968, "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize(969, "Toggle Replace");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize(970, "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
var NLS_MATCHES_LOCATION = localize(971, "{0} of {1}");
var NLS_NO_RESULTS = localize(972, "No results");
var FIND_WIDGET_INITIAL_WIDTH = 419;
var PART_WIDTH = 275;
var FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_INPUT_AREA_HEIGHT = 33;
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var FindWidgetViewZone = class {
  constructor(afterLineNumber) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = FIND_INPUT_AREA_HEIGHT;
    this.suppressMouseDown = false;
    this.domNode = document.createElement("div");
    this.domNode.className = "dock-find-viewzone";
  }
};
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
var _FindWidget = class _FindWidget extends Widget {
  constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, _hoverService, _findWidgetSearchHistory, _replaceWidgetHistory) {
    super();
    this._hoverService = _hoverService;
    this._findWidgetSearchHistory = _findWidgetSearchHistory;
    this._replaceWidgetHistory = _replaceWidgetHistory;
    this._cachedHeight = null;
    this._revealTimeouts = [];
    this._codeEditor = codeEditor;
    this._controller = controller;
    this._state = state;
    this._contextViewProvider = contextViewProvider;
    this._keybindingService = keybindingService;
    this._contextKeyService = contextKeyService;
    this._isVisible = false;
    this._isReplaceVisible = false;
    this._ignoreChangeEvent = false;
    this._updateHistoryDelayer = new Delayer(500);
    this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._buildDomNode();
    this._updateButtons();
    this._tryUpdateWidgetWidth();
    this._findInput.inputBox.layout();
    this._register(this._codeEditor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        104
        /* EditorOption.readOnly */
      )) {
        if (this._codeEditor.getOption(
          104
          /* EditorOption.readOnly */
        )) {
          this._state.change({ isReplaceRevealed: false }, false);
        }
        this._updateButtons();
      }
      if (e.hasChanged(
        165
        /* EditorOption.layoutInfo */
      )) {
        this._tryUpdateWidgetWidth();
      }
      if (e.hasChanged(
        2
        /* EditorOption.accessibilitySupport */
      )) {
        this.updateAccessibilitySupport();
      }
      if (e.hasChanged(
        50
        /* EditorOption.find */
      )) {
        const supportLoop = this._codeEditor.getOption(
          50
          /* EditorOption.find */
        ).loop;
        this._state.change({ loop: supportLoop }, false);
        const addExtraSpaceOnTop = this._codeEditor.getOption(
          50
          /* EditorOption.find */
        ).addExtraSpaceOnTop;
        if (addExtraSpaceOnTop && !this._viewZone) {
          this._viewZone = new FindWidgetViewZone(0);
          this._showViewZone();
        }
        if (!addExtraSpaceOnTop && this._viewZone) {
          this._removeViewZone();
        }
      }
    }));
    this.updateAccessibilitySupport();
    this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      if (this._isVisible) {
        this._updateToggleSelectionFindButton();
      }
    }));
    this._register(this._codeEditor.onDidFocusEditorWidget(async () => {
      if (this._isVisible) {
        const globalBufferTerm = await this._controller.getGlobalBufferTerm();
        if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
          this._state.change({ searchString: globalBufferTerm }, false);
          this._findInput.select();
        }
      }
    }));
    this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
    this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
    this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(false);
    }));
    this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
    this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
    this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(false);
    }));
    this._codeEditor.addOverlayWidget(this);
    if (this._codeEditor.getOption(
      50
      /* EditorOption.find */
    ).addExtraSpaceOnTop) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    this._register(this._codeEditor.onDidChangeModel(() => {
      if (!this._isVisible) {
        return;
      }
      this._viewZoneId = void 0;
    }));
    this._register(this._codeEditor.onDidScrollChange((e) => {
      if (e.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  // ----- IOverlayWidget API
  getId() {
    return _FindWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    if (this._isVisible) {
      return {
        preference: 0
        /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
      };
    }
    return null;
  }
  // ----- React to state changes
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = true;
        this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = false;
      }
      this._updateButtons();
    }
    if (e.replaceString) {
      this._replaceInput.inputBox.value = this._state.replaceString;
    }
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._reveal();
      } else {
        this._hide(true);
      }
    }
    if (e.isReplaceRevealed) {
      if (this._state.isReplaceRevealed) {
        if (!this._codeEditor.getOption(
          104
          /* EditorOption.readOnly */
        ) && !this._isReplaceVisible) {
          this._isReplaceVisible = true;
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._updateButtons();
          this._replaceInput.inputBox.layout();
        }
      } else {
        if (this._isReplaceVisible) {
          this._isReplaceVisible = false;
          this._updateButtons();
        }
      }
    }
    if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }
    if (e.isRegex) {
      this._findInput.setRegex(this._state.isRegex);
    }
    if (e.wholeWord) {
      this._findInput.setWholeWords(this._state.wholeWord);
    }
    if (e.matchCase) {
      this._findInput.setCaseSensitive(this._state.matchCase);
    }
    if (e.preserveCase) {
      this._replaceInput.setPreserveCase(this._state.preserveCase);
    }
    if (e.searchScope) {
      if (this._state.searchScope) {
        this._toggleSelectionFind.checked = true;
      } else {
        this._toggleSelectionFind.checked = false;
      }
      this._updateToggleSelectionFindButton();
    }
    if (e.searchString || e.matchesCount || e.matchesPosition) {
      const showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", showRedOutline);
      this._updateMatchesCount();
      this._updateButtons();
    }
    if (e.searchString || e.currentMatch) {
      this._layoutViewZone();
    }
    if (e.updateHistory) {
      this._delayedUpdateHistory();
    }
    if (e.loop) {
      this._updateButtons();
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
  }
  _updateHistory() {
    if (this._state.searchString) {
      this._findInput.inputBox.addToHistory();
    }
    if (this._state.replaceString) {
      this._replaceInput.inputBox.addToHistory();
    }
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
    if (this._state.matchesCount >= MATCHES_LIMIT) {
      this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
    } else {
      this._matchesCount.title = "";
    }
    this._matchesCount.firstChild?.remove();
    let label;
    if (this._state.matchesCount > 0) {
      let matchesCount = String(this._state.matchesCount);
      if (this._state.matchesCount >= MATCHES_LIMIT) {
        matchesCount += "+";
      }
      let matchesPosition = String(this._state.matchesPosition);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    this._matchesCount.appendChild(document.createTextNode(label));
    alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
    MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
  }
  // ----- actions
  _getAriaLabel(label, currentMatch, searchString) {
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize(973, "{0} found", label) : localize(974, "{0} found for '{1}'", label, searchString);
    }
    if (currentMatch) {
      const ariaLabel = localize(975, "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
      const model = this._codeEditor.getModel();
      if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
        const lineContent = model.getLineContent(currentMatch.startLineNumber);
        return `${lineContent}, ${ariaLabel}`;
      }
      return ariaLabel;
    }
    return localize(976, "{0} found for '{1}'", label, searchString);
  }
  /**
   * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
   * If 'selection find' is OFF we enable the button only if there is a selection.
   */
  _updateToggleSelectionFindButton() {
    const selection = this._codeEditor.getSelection();
    const isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
    const isChecked = this._toggleSelectionFind.checked;
    if (this._isVisible && (isChecked || isSelection)) {
      this._toggleSelectionFind.enable();
    } else {
      this._toggleSelectionFind.disable();
    }
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible);
    this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
    this._updateToggleSelectionFindButton();
    this._closeBtn.setEnabled(this._isVisible);
    const findInputIsNonEmpty = this._state.searchString.length > 0;
    const matchesCount = this._state.matchesCount ? true : false;
    this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
    this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
    this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const canReplace = !this._codeEditor.getOption(
      104
      /* EditorOption.readOnly */
    );
    this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
  }
  _reveal() {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (!this._isVisible) {
      this._isVisible = true;
      const selection = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(
        50
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = true;
          break;
        case "never":
          this._toggleSelectionFind.checked = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          this._toggleSelectionFind.checked = isSelectionMultipleLine;
          break;
        }
        default:
          break;
      }
      this._tryUpdateWidgetWidth();
      this._updateButtons();
      this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible");
        this._domNode.setAttribute("aria-hidden", "false");
      }, 0));
      this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200));
      this._codeEditor.layoutOverlayWidget(this);
      let adjustEditorScrollTop = true;
      if (this._codeEditor.getOption(
        50
        /* EditorOption.find */
      ).seedSearchStringFromSelection && selection) {
        const domNode = this._codeEditor.getDomNode();
        if (domNode) {
          const editorCoords = getDomNodePagePosition(domNode);
          const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
          const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
          const startTop = startCoords ? startCoords.top : 0;
          if (this._viewZone && startTop < this._viewZone.heightInPx) {
            if (selection.endLineNumber > selection.startLineNumber) {
              adjustEditorScrollTop = false;
            }
            const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
            if (startLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
            if (endLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
          }
        }
      }
      this._showViewZone(adjustEditorScrollTop);
    }
  }
  _hide(focusTheEditor) {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (this._isVisible) {
      this._isVisible = false;
      this._updateButtons();
      this._domNode.classList.remove("visible");
      this._domNode.setAttribute("aria-hidden", "true");
      this._findInput.clearMessage();
      if (focusTheEditor) {
        this._codeEditor.focus();
      }
      this._codeEditor.layoutOverlayWidget(this);
      this._removeViewZone();
    }
  }
  _layoutViewZone(targetScrollTop) {
    const addExtraSpaceOnTop = this._codeEditor.getOption(
      50
      /* EditorOption.find */
    ).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible) {
      return;
    }
    const viewZone = this._viewZone;
    if (this._viewZoneId !== void 0 || !viewZone) {
      return;
    }
    this._codeEditor.changeViewZones((accessor) => {
      viewZone.heightInPx = this._getHeight();
      this._viewZoneId = accessor.addZone(viewZone);
      this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
    });
  }
  _showViewZone(adjustScroll = true) {
    if (!this._isVisible) {
      return;
    }
    const addExtraSpaceOnTop = this._codeEditor.getOption(
      50
      /* EditorOption.find */
    ).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      return;
    }
    if (this._viewZone === void 0) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    const viewZone = this._viewZone;
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        const newHeight = this._getHeight();
        if (newHeight === viewZone.heightInPx) {
          return;
        }
        const scrollAdjustment = newHeight - viewZone.heightInPx;
        viewZone.heightInPx = newHeight;
        accessor.layoutZone(this._viewZoneId);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
        return;
      } else {
        let scrollAdjustment = this._getHeight();
        scrollAdjustment -= this._codeEditor.getOption(
          96
          /* EditorOption.padding */
        ).top;
        if (scrollAdjustment <= 0) {
          return;
        }
        viewZone.heightInPx = scrollAdjustment;
        this._viewZoneId = accessor.addZone(viewZone);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        accessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
        if (this._viewZone) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
          this._viewZone = void 0;
        }
      }
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible) {
      return;
    }
    if (!this._domNode.isConnected) {
      return;
    }
    const layoutInfo = this._codeEditor.getLayoutInfo();
    const editorContentWidth = layoutInfo.contentWidth;
    if (editorContentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else if (this._domNode.classList.contains("hiddenEditor")) {
      this._domNode.classList.remove("hiddenEditor");
    }
    const editorWidth = layoutInfo.width;
    const minimapWidth = layoutInfo.minimap.minimapWidth;
    let collapsedFindWidget = false;
    let reducedFindWidget = false;
    let narrowFindWidget = false;
    if (this._resized) {
      const widgetWidth = getTotalWidth(this._domNode);
      if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
        this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        return;
      }
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
      reducedFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
      narrowFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
      collapsedFindWidget = true;
    }
    this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
    this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
    this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
    if (!narrowFindWidget && !collapsedFindWidget) {
      this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
    }
    this._findInput.layout({ collapsedFindWidget, narrowFindWidget, reducedFindWidget });
    if (this._resized) {
      const findInputWidth = this._findInput.inputBox.element.clientWidth;
      if (findInputWidth > 0) {
        this._replaceInput.width = findInputWidth;
      }
    } else if (this._isReplaceVisible) {
      this._replaceInput.width = getTotalWidth(this._findInput.domNode);
    }
  }
  _getHeight() {
    let totalheight = 0;
    totalheight += 4;
    totalheight += this._findInput.inputBox.height + 2;
    if (this._isReplaceVisible) {
      totalheight += 4;
      totalheight += this._replaceInput.inputBox.height + 2;
    }
    totalheight += 4;
    return totalheight;
  }
  _tryUpdateHeight() {
    const totalHeight = this._getHeight();
    if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
      return false;
    }
    this._cachedHeight = totalHeight;
    this._domNode.style.height = `${totalHeight}px`;
    return true;
  }
  // ----- Public
  focusFindInput() {
    this._findInput.select();
    this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select();
    this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (!this._codeEditor.hasModel()) {
      return;
    }
    if (this._toggleSelectionFind.checked) {
      const selections = this._codeEditor.getSelections();
      selections.map((selection) => {
        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
          selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
        }
        const currentMatch = this._state.currentMatch;
        if (selection.startLineNumber !== selection.endLineNumber) {
          if (!Range.equalsRange(selection, currentMatch)) {
            return selection;
          }
        }
        return null;
      }).filter((element) => !!element);
      if (selections.length) {
        this._state.change({ searchScope: selections }, true);
      }
    }
  }
  _onFindInputMouseDown(e) {
    if (e.middleButton) {
      e.stopPropagation();
    }
  }
  _onFindInputKeyDown(e) {
    if (e.equals(
      ctrlKeyMod | 3
      /* KeyCode.Enter */
    )) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      if (this._isReplaceVisible) {
        this._replaceInput.focus();
      } else {
        this._findInput.focusOnCaseSensitive();
      }
      e.preventDefault();
      return;
    }
    if (e.equals(
      2048 | 18
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    )) {
      return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    )) {
      return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(
      ctrlKeyMod | 3
      /* KeyCode.Enter */
    )) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._replaceInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._findInput.focusOnCaseSensitive();
      e.preventDefault();
      return;
    }
    if (e.equals(
      1024 | 2
      /* KeyCode.Tab */
    )) {
      this._findInput.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      2048 | 18
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    )) {
      return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    )) {
      return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
  }
  // ----- sash
  getVerticalSashLeft(_sash) {
    return 0;
  }
  // ----- initialization
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  _buildDomNode() {
    const flexibleHeight = true;
    const flexibleWidth = true;
    const findSearchHistoryConfig = this._codeEditor.getOption(
      50
      /* EditorOption.find */
    ).history;
    const replaceHistoryConfig = this._codeEditor.getOption(
      50
      /* EditorOption.find */
    ).replaceHistory;
    this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
      width: FIND_INPUT_AREA_WIDTH,
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          new RegExp(value, "gu");
          return null;
        } catch (e) {
          return { content: e.message };
        }
      },
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showCommonFindToggles: true,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles,
      history: findSearchHistoryConfig === "workspace" ? this._findWidgetSearchHistory : /* @__PURE__ */ new Set([])
    }, this._contextKeyService));
    this._findInput.setRegex(!!this._state.isRegex);
    this._findInput.setCaseSensitive(!!this._state.matchCase);
    this._findInput.setWholeWords(!!this._state.wholeWord);
    this._register(this._findInput.onKeyDown((e) => {
      if (e.equals(
        3
        /* KeyCode.Enter */
      ) && !this._codeEditor.getOption(
        50
        /* EditorOption.find */
      ).findOnType) {
        this._state.change({ searchString: this._findInput.getValue() }, true);
      }
      this._onFindInputKeyDown(e);
    }));
    this._register(this._findInput.inputBox.onDidChange(() => {
      if (this._ignoreChangeEvent || !this._codeEditor.getOption(
        50
        /* EditorOption.find */
      ).findOnType) {
        return;
      }
      this._state.change({ searchString: this._findInput.getValue() }, true);
    }));
    this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
      if (e.equals(
        1024 | 2
        /* KeyCode.Tab */
      )) {
        if (this._isReplaceVisible) {
          this._replaceInput.focus();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.onRegexKeyDown((e) => {
      if (e.equals(
        2
        /* KeyCode.Tab */
      )) {
        if (this._isReplaceVisible) {
          this._replaceInput.focusOnPreserve();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.inputBox.onDidHeightChange((e) => {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    if (isLinux) {
      this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
    }
    this._matchesCount = document.createElement("div");
    this._matchesCount.className = "matchesCount";
    this._updateMatchesCount();
    const hoverDelegate = this._register(createInstantHoverDelegate());
    this._prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
      icon: findPreviousMatchIcon,
      hoverDelegate,
      onTrigger: () => {
        assertReturnsDefined(this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }, this._hoverService));
    this._nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
      icon: findNextMatchIcon,
      hoverDelegate,
      onTrigger: () => {
        assertReturnsDefined(this._codeEditor.getAction(FIND_IDS.NextMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }, this._hoverService));
    const findPart = document.createElement("div");
    findPart.className = "find-part";
    findPart.appendChild(this._findInput.domNode);
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "find-actions";
    findPart.appendChild(actionsContainer);
    actionsContainer.appendChild(this._matchesCount);
    actionsContainer.appendChild(this._prevBtn.domNode);
    actionsContainer.appendChild(this._nextBtn.domNode);
    this._toggleSelectionFind = this._register(new Toggle({
      icon: findSelectionIcon,
      title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
      isChecked: false,
      hoverDelegate,
      inputActiveOptionBackground: asCssVariable(inputActiveOptionBackground),
      inputActiveOptionBorder: asCssVariable(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssVariable(inputActiveOptionForeground)
    }));
    this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          let selections = this._codeEditor.getSelections();
          selections = selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            if (!selection.isEmpty()) {
              return selection;
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({ searchScope: selections }, true);
          }
        }
      } else {
        this._state.change({ searchScope: null }, true);
      }
    }));
    actionsContainer.appendChild(this._toggleSelectionFind.domNode);
    this._closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
      icon: widgetClose,
      hoverDelegate,
      onTrigger: () => {
        this._state.change({ isRevealed: false, searchScope: null }, false);
      },
      onKeyDown: (e) => {
        if (e.equals(
          2
          /* KeyCode.Tab */
        )) {
          if (this._isReplaceVisible) {
            if (this._replaceBtn.isEnabled()) {
              this._replaceBtn.focus();
            } else {
              this._codeEditor.focus();
            }
            e.preventDefault();
          }
        }
      }
    }, this._hoverService));
    this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
      label: NLS_REPLACE_INPUT_LABEL,
      placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
      appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
      history: replaceHistoryConfig === "workspace" ? this._replaceWidgetHistory : /* @__PURE__ */ new Set([]),
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService, true));
    this._replaceInput.setPreserveCase(!!this._state.preserveCase);
    this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
    this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
    }));
    this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
      if (this._isReplaceVisible && this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, true);
    }));
    this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
      if (e.equals(
        2
        /* KeyCode.Tab */
      )) {
        if (this._prevBtn.isEnabled()) {
          this._prevBtn.focus();
        } else if (this._nextBtn.isEnabled()) {
          this._nextBtn.focus();
        } else if (this._toggleSelectionFind.enabled) {
          this._toggleSelectionFind.focus();
        } else if (this._closeBtn.isEnabled()) {
          this._closeBtn.focus();
        }
        e.preventDefault();
      }
    }));
    const replaceHoverDelegate = this._register(createInstantHoverDelegate());
    this._replaceBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
      icon: findReplaceIcon,
      hoverDelegate: replaceHoverDelegate,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (e) => {
        if (e.equals(
          1024 | 2
          /* KeyCode.Tab */
        )) {
          this._closeBtn.focus();
          e.preventDefault();
        }
      }
    }, this._hoverService));
    this._replaceAllBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
      icon: findReplaceAllIcon,
      hoverDelegate: replaceHoverDelegate,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }, this._hoverService));
    const replacePart = document.createElement("div");
    replacePart.className = "replace-part";
    replacePart.appendChild(this._replaceInput.domNode);
    const replaceActionsContainer = document.createElement("div");
    replaceActionsContainer.className = "replace-actions";
    replacePart.appendChild(replaceActionsContainer);
    replaceActionsContainer.appendChild(this._replaceBtn.domNode);
    replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
    this._toggleReplaceBtn = this._register(new SimpleButton({
      label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
        if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._replaceInput.inputBox.layout();
        }
        this._showViewZone();
      }
    }, this._hoverService));
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    this._domNode = document.createElement("div");
    this._domNode.className = "editor-widget find-widget";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.ariaLabel = NLS_FIND_DIALOG_LABEL;
    this._domNode.role = "dialog";
    this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
    this._domNode.appendChild(this._toggleReplaceBtn.domNode);
    this._domNode.appendChild(findPart);
    this._domNode.appendChild(this._closeBtn.domNode);
    this._domNode.appendChild(replacePart);
    this._resizeSash = this._register(new Sash(this._domNode, this, { orientation: 0, size: 2 }));
    this._resized = false;
    let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
    this._register(this._resizeSash.onDidStart(() => {
      originalWidth = getTotalWidth(this._domNode);
    }));
    this._register(this._resizeSash.onDidChange((evt) => {
      this._resized = true;
      const width = originalWidth + evt.startX - evt.currentX;
      if (width < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
      if (width > maxWidth) {
        return;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
      this._tryUpdateHeight();
    }));
    this._register(this._resizeSash.onDidReset(() => {
      const currentWidth = getTotalWidth(this._domNode);
      if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      let width = FIND_WIDGET_INITIAL_WIDTH;
      if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
        const layoutInfo = this._codeEditor.getLayoutInfo();
        width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
        this._resized = true;
      } else {
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const value = this._codeEditor.getOption(
      2
      /* EditorOption.accessibilitySupport */
    );
    this._findInput.setFocusInputOnOptionClick(
      value !== 2
      /* AccessibilitySupport.Enabled */
    );
  }
  getViewState() {
    let widgetViewZoneVisible = false;
    if (this._viewZone && this._viewZoneId) {
      widgetViewZoneVisible = this._viewZone.heightInPx > this._codeEditor.getScrollTop();
    }
    return {
      widgetViewZoneVisible,
      scrollTop: this._codeEditor.getScrollTop()
    };
  }
  setViewState(state) {
    if (!state) {
      return;
    }
    if (state.widgetViewZoneVisible) {
      this._layoutViewZone(state.scrollTop);
    }
  }
};
_FindWidget.ID = "editor.contrib.findWidget";
var FindWidget = _FindWidget;
var SimpleButton = class extends Widget {
  constructor(opts, hoverService) {
    super();
    this._opts = opts;
    let className = "button";
    if (this._opts.className) {
      className = className + " " + this._opts.className;
    }
    if (this._opts.icon) {
      className = className + " " + ThemeIcon.asClassName(this._opts.icon);
    }
    this._domNode = document.createElement("div");
    this._domNode.tabIndex = 0;
    this._domNode.className = className;
    this._domNode.setAttribute("role", "button");
    this._domNode.setAttribute("aria-label", this._opts.label);
    this._register(hoverService.setupManagedHover(opts.hoverDelegate ?? getDefaultHoverDelegate("element"), this._domNode, this._opts.label));
    this.onclick(this._domNode, (e) => {
      this._opts.onTrigger();
      e.preventDefault();
    });
    this.onkeydown(this._domNode, (e) => {
      if (e.equals(
        10
        /* KeyCode.Space */
      ) || e.equals(
        3
        /* KeyCode.Enter */
      )) {
        this._opts.onTrigger();
        e.preventDefault();
        return;
      }
      this._opts.onKeyDown?.(e);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(enabled) {
    this._domNode.classList.toggle("disabled", !enabled);
    this._domNode.setAttribute("aria-disabled", String(!enabled));
    this._domNode.tabIndex = enabled ? 0 : -1;
  }
  setExpanded(expanded2) {
    this._domNode.setAttribute("aria-expanded", String(!!expanded2));
    if (expanded2) {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
    } else {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
    }
  }
};
registerThemingParticipant((theme, collector) => {
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
  const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
  if (findRangeHighlightBorder) {
    collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
  }
  const findMatchForeground = theme.getColor(editorFindMatchForeground);
  if (findMatchForeground) {
    collector.addRule(`.monaco-editor .findMatchInline { color: ${findMatchForeground}; }`);
  }
  const findMatchHighlightForeground = theme.getColor(editorFindMatchHighlightForeground);
  if (findMatchHighlightForeground) {
    collector.addRule(`.monaco-editor .currentFindMatchInline { color: ${findMatchHighlightForeground}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
init_nls();
init_actions2();
init_contextkey();
init_themeService();

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidgetSearchHistory.js
init_event();
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var FindWidgetSearchHistory_1;
var _a31;
var FindWidgetSearchHistory = (_a31 = class {
  static getOrCreate(storageService) {
    if (!FindWidgetSearchHistory_1._instance) {
      FindWidgetSearchHistory_1._instance = new FindWidgetSearchHistory_1(storageService);
    }
    return FindWidgetSearchHistory_1._instance;
  }
  constructor(storageService) {
    this.storageService = storageService;
    this.inMemoryValues = /* @__PURE__ */ new Set();
    this._onDidChangeEmitter = new Emitter();
    this.onDidChange = this._onDidChangeEmitter.event;
    this.load();
  }
  delete(t) {
    const result = this.inMemoryValues.delete(t);
    this.save();
    return result;
  }
  add(t) {
    this.inMemoryValues.add(t);
    this.save();
    return this;
  }
  has(t) {
    return this.inMemoryValues.has(t);
  }
  forEach(callbackfn, thisArg) {
    this.load();
    return this.inMemoryValues.forEach(callbackfn);
  }
  replace(t) {
    this.inMemoryValues = new Set(t);
    this.save();
  }
  load() {
    let result;
    const raw = this.storageService.get(
      FindWidgetSearchHistory_1.FIND_HISTORY_KEY,
      1
      /* StorageScope.WORKSPACE */
    );
    if (raw) {
      try {
        result = JSON.parse(raw);
      } catch (e) {
      }
    }
    this.inMemoryValues = new Set(result || []);
  }
  // Run saves async
  save() {
    const elements = [];
    this.inMemoryValues.forEach((e) => elements.push(e));
    return new Promise((resolve) => {
      this.storageService.store(
        FindWidgetSearchHistory_1.FIND_HISTORY_KEY,
        JSON.stringify(elements),
        1,
        0
        /* StorageTarget.USER */
      );
      this._onDidChangeEmitter.fire(elements);
      resolve();
    });
  }
}, FindWidgetSearchHistory_1 = _a31, _a31.FIND_HISTORY_KEY = "workbench.find.history", _a31._instance = null, _a31);
FindWidgetSearchHistory = FindWidgetSearchHistory_1 = __decorate38([
  __param38(0, IStorageService)
], FindWidgetSearchHistory);

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replaceWidgetHistory.js
init_event();
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ReplaceWidgetHistory_1;
var _a32;
var ReplaceWidgetHistory = (_a32 = class {
  static getOrCreate(storageService) {
    if (!ReplaceWidgetHistory_1._instance) {
      ReplaceWidgetHistory_1._instance = new ReplaceWidgetHistory_1(storageService);
    }
    return ReplaceWidgetHistory_1._instance;
  }
  constructor(storageService) {
    this.storageService = storageService;
    this.inMemoryValues = /* @__PURE__ */ new Set();
    this._onDidChangeEmitter = new Emitter();
    this.onDidChange = this._onDidChangeEmitter.event;
    this.load();
  }
  delete(t) {
    const result = this.inMemoryValues.delete(t);
    this.save();
    return result;
  }
  add(t) {
    this.inMemoryValues.add(t);
    this.save();
    return this;
  }
  has(t) {
    return this.inMemoryValues.has(t);
  }
  forEach(callbackfn, thisArg) {
    this.load();
    return this.inMemoryValues.forEach(callbackfn);
  }
  replace(t) {
    this.inMemoryValues = new Set(t);
    this.save();
  }
  load() {
    let result;
    const raw = this.storageService.get(
      ReplaceWidgetHistory_1.FIND_HISTORY_KEY,
      1
      /* StorageScope.WORKSPACE */
    );
    if (raw) {
      try {
        result = JSON.parse(raw);
      } catch (e) {
      }
    }
    this.inMemoryValues = new Set(result || []);
  }
  // Run saves async
  save() {
    const elements = [];
    this.inMemoryValues.forEach((e) => elements.push(e));
    return new Promise((resolve) => {
      this.storageService.store(
        ReplaceWidgetHistory_1.FIND_HISTORY_KEY,
        JSON.stringify(elements),
        1,
        0
        /* StorageTarget.USER */
      );
      this._onDidChangeEmitter.fire(elements);
      resolve();
    });
  }
}, ReplaceWidgetHistory_1 = _a32, _a32.FIND_HISTORY_KEY = "workbench.replace.history", _a32._instance = null, _a32);
ReplaceWidgetHistory = ReplaceWidgetHistory_1 = __decorate39([
  __param39(0, IStorageService)
], ReplaceWidgetHistory);

// node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CommonFindController_1;
var SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor2, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
  if (!editor2.hasModel()) {
    return null;
  }
  const selection = editor2.getSelection();
  if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
    if (selection.isEmpty()) {
      const wordAtPosition = editor2.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition && false === seedSearchStringFromNonEmptySelection) {
        return wordAtPosition.word;
      }
    } else {
      if (editor2.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor2.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
var _a33;
var CommonFindController = (_a33 = class extends Disposable {
  get editor() {
    return this._editor;
  }
  static get(editor2) {
    return editor2.getContribution(CommonFindController_1.ID);
  }
  constructor(editor2, contextKeyService, storageService, clipboardService, notificationService, hoverService) {
    super();
    this._editor = editor2;
    this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._clipboardService = clipboardService;
    this._notificationService = notificationService;
    this._hoverService = hoverService;
    this._updateHistoryDelayer = new Delayer(500);
    this._state = this._register(new FindReplaceState());
    this.loadQueryState();
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._model = null;
    this._register(this._editor.onDidChangeModel(() => {
      const shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel();
      this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
      }, false);
      if (shouldRestartFind) {
        this._start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: false,
          updateSearchScope: false,
          loop: this._editor.getOption(
            50
            /* EditorOption.find */
          ).loop
        });
      }
    }));
  }
  dispose() {
    this.disposeModel();
    super.dispose();
  }
  disposeModel() {
    if (this._model) {
      this._model.dispose();
      this._model = null;
    }
  }
  _onStateChanged(e) {
    this.saveQueryState(e);
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._findWidgetVisible.set(true);
      } else {
        this._findWidgetVisible.reset();
        this.disposeModel();
      }
    }
    if (e.searchString) {
      this.setGlobalBufferTerm(this._state.searchString);
    }
  }
  saveQueryState(e) {
    if (e.isRegex) {
      this._storageService.store(
        "editor.isRegex",
        this._state.actualIsRegex,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.wholeWord) {
      this._storageService.store(
        "editor.wholeWord",
        this._state.actualWholeWord,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.matchCase) {
      this._storageService.store(
        "editor.matchCase",
        this._state.actualMatchCase,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
    if (e.preserveCase) {
      this._storageService.store(
        "editor.preserveCase",
        this._state.actualPreserveCase,
        1,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, false);
  }
  isFindInputFocused() {
    return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: false,
      searchScope: null
    }, false);
    this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleSearchScope() {
    if (this._state.searchScope) {
      this._state.change({ searchScope: null }, true);
    } else {
      if (this._editor.hasModel()) {
        let selections = this._editor.getSelections();
        selections = selections.map((selection) => {
          if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
            selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
          }
          if (!selection.isEmpty()) {
            return selection;
          }
          return null;
        }).filter((element) => !!element);
        if (selections.length) {
          this._state.change({ searchScope: selections }, true);
        }
      }
    }
  }
  setSearchString(searchString) {
    if (this._state.isRegex) {
      searchString = escapeRegExpCharacters(searchString);
    }
    this._state.change({ searchString }, false);
  }
  highlightFindOptions(ignoreWhenVisible = false) {
  }
  async _start(opts, newState) {
    this.disposeModel();
    if (!this._editor.hasModel()) {
      return;
    }
    const stateChanges = {
      ...newState,
      isRevealed: true
    };
    if (opts.seedSearchStringFromSelection === "single") {
      const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
      if (selectionSearchString) {
        if (this._state.isRegex) {
          stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
        } else {
          stateChanges.searchString = selectionSearchString;
        }
      }
    } else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
      const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
      if (selectionSearchString) {
        stateChanges.searchString = selectionSearchString;
      }
    }
    if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
      const selectionSearchString = await this.getGlobalBufferTerm();
      if (!this._editor.hasModel()) {
        return;
      }
      if (selectionSearchString) {
        stateChanges.searchString = selectionSearchString;
      }
    }
    if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
      stateChanges.isReplaceRevealed = true;
    } else if (!this._findWidgetVisible.get()) {
      stateChanges.isReplaceRevealed = false;
    }
    if (opts.updateSearchScope) {
      const currentSelections = this._editor.getSelections();
      if (currentSelections.some((selection) => !selection.isEmpty())) {
        stateChanges.searchScope = currentSelections;
      }
    }
    stateChanges.loop = opts.loop;
    this._state.change(stateChanges, false);
    if (!this._model) {
      this._model = new FindModelBoundToEditorModel(this._editor, this._state);
    }
  }
  start(opts, newState) {
    return this._start(opts, newState);
  }
  moveToNextMatch() {
    if (this._model) {
      this._model.moveToNextMatch();
      return true;
    }
    return false;
  }
  moveToPrevMatch() {
    if (this._model) {
      this._model.moveToPrevMatch();
      return true;
    }
    return false;
  }
  goToMatch(index) {
    if (this._model) {
      this._model.moveToMatch(index);
      return true;
    }
    return false;
  }
  replace() {
    if (this._model) {
      this._model.replace();
      return true;
    }
    return false;
  }
  replaceAll() {
    if (this._model) {
      if (this._editor.getModel()?.isTooLargeForHeapOperation()) {
        this._notificationService.warn(localize(935, "The file is too large to perform a replace all operation."));
        return false;
      }
      this._model.replaceAll();
      return true;
    }
    return false;
  }
  selectAllMatches() {
    if (this._model) {
      this._model.selectAllMatches();
      this._editor.focus();
      return true;
    }
    return false;
  }
  async getGlobalBufferTerm() {
    if (this._editor.getOption(
      50
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      return this._clipboardService.readFindText();
    }
    return "";
  }
  setGlobalBufferTerm(text) {
    if (this._editor.getOption(
      50
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      this._clipboardService.writeFindText(text);
    }
  }
}, CommonFindController_1 = _a33, _a33.ID = "editor.contrib.findController", _a33);
CommonFindController = CommonFindController_1 = __decorate40([
  __param40(1, IContextKeyService),
  __param40(2, IStorageService),
  __param40(3, IClipboardService),
  __param40(4, INotificationService),
  __param40(5, IHoverService)
], CommonFindController);
var FindController = class FindController2 extends CommonFindController {
  constructor(editor2, _contextViewService, _contextKeyService, _keybindingService, notificationService, _storageService, clipboardService, hoverService) {
    super(editor2, _contextKeyService, _storageService, clipboardService, notificationService, hoverService);
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._widget = null;
    this._findOptionsWidget = null;
    this._findWidgetSearchHistory = FindWidgetSearchHistory.getOrCreate(_storageService);
    this._replaceWidgetHistory = ReplaceWidgetHistory.getOrCreate(_storageService);
  }
  async _start(opts, newState) {
    if (!this._widget) {
      this._createFindWidget();
    }
    const selection = this._editor.getSelection();
    let updateSearchScope = false;
    switch (this._editor.getOption(
      50
      /* EditorOption.find */
    ).autoFindInSelection) {
      case "always":
        updateSearchScope = true;
        break;
      case "never":
        updateSearchScope = false;
        break;
      case "multiline": {
        const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
        updateSearchScope = isSelectionMultipleLine;
        break;
      }
      default:
        break;
    }
    opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
    await super._start(opts, newState);
    if (this._widget) {
      if (opts.shouldFocus === 2) {
        this._widget.focusReplaceInput();
      } else if (opts.shouldFocus === 1) {
        this._widget.focusFindInput();
      }
    }
  }
  highlightFindOptions(ignoreWhenVisible = false) {
    if (!this._widget) {
      this._createFindWidget();
    }
    if (this._state.isRevealed && !ignoreWhenVisible) {
      this._widget.highlightFindOptions();
    } else {
      this._findOptionsWidget.highlightFindOptions();
    }
  }
  _createFindWidget() {
    this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._hoverService, this._findWidgetSearchHistory, this._replaceWidgetHistory));
    this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService));
  }
  saveViewState() {
    return this._widget?.getViewState();
  }
  restoreViewState(state) {
    this._widget?.setViewState(state);
  }
};
FindController = __decorate40([
  __param40(1, IContextViewService),
  __param40(2, IContextKeyService),
  __param40(3, IKeybindingService),
  __param40(4, INotificationService),
  __param40(5, IStorageService),
  __param40(6, IClipboardService),
  __param40(7, IHoverService)
], FindController);
var StartFindAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindAction,
  label: localize2(942, "Find"),
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 36,
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize(936, "&&Find"),
    order: 1
  }
}));
StartFindAction.addImplementation(0, (accessor, editor2, args) => {
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  return controller.start({
    forceRevealReplace: false,
    seedSearchStringFromSelection: editor2.getOption(
      50
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(
      50
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(
      50
      /* EditorOption.find */
    ).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(
      50
      /* EditorOption.find */
    ).loop
  });
});
var findArgDescription = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        isRegex: { type: "boolean" },
        matchWholeWord: { type: "boolean" },
        isCaseSensitive: { type: "boolean" },
        preserveCase: { type: "boolean" },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
var StartFindWithArgsAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithArgs,
      label: localize2(943, "Find with Arguments"),
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: findArgDescription
    });
  }
  async run(accessor, editor2, args) {
    const controller = CommonFindController.get(editor2);
    if (controller) {
      const newState = args ? {
        searchString: args.searchString,
        replaceString: args.replaceString,
        isReplaceRevealed: args.replaceString !== void 0,
        isRegex: args.isRegex,
        // isRegexOverride: args.regexOverride,
        wholeWord: args.matchWholeWord,
        // wholeWordOverride: args.wholeWordOverride,
        matchCase: args.isCaseSensitive,
        // matchCaseOverride: args.matchCaseOverride,
        preserveCase: args.preserveCase
        // preserveCaseOverride: args.preserveCaseOverride,
      } : {};
      await controller.start({
        forceRevealReplace: false,
        seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
          50
          /* EditorOption.find */
        ).seedSearchStringFromSelection !== "never" ? "single" : "none",
        seedSearchStringFromNonEmptySelection: editor2.getOption(
          50
          /* EditorOption.find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: true,
        shouldFocus: 1,
        shouldAnimate: true,
        updateSearchScope: args?.findInSelection || false,
        loop: editor2.getOption(
          50
          /* EditorOption.find */
        ).loop
      }, newState);
      controller.setGlobalBufferTerm(controller.getState().searchString);
    }
  }
};
var StartFindWithSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithSelection,
      label: localize2(944, "Find with Selection"),
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2048 | 35
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(accessor, editor2) {
    const controller = CommonFindController.get(editor2);
    if (controller) {
      await controller.start({
        forceRevealReplace: false,
        seedSearchStringFromSelection: "multiple",
        seedSearchStringFromNonEmptySelection: false,
        seedSearchStringFromGlobalClipboard: false,
        shouldFocus: 0,
        shouldAnimate: true,
        updateSearchScope: false,
        loop: editor2.getOption(
          50
          /* EditorOption.find */
        ).loop
      });
      controller.setGlobalBufferTerm(controller.getState().searchString);
    }
  }
};
var MatchFindAction = class extends EditorAction {
  async run(accessor, editor2) {
    const controller = CommonFindController.get(editor2);
    if (controller && !this._run(controller)) {
      await controller.start({
        forceRevealReplace: false,
        seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
          50
          /* EditorOption.find */
        ).seedSearchStringFromSelection !== "never" ? "single" : "none",
        seedSearchStringFromNonEmptySelection: editor2.getOption(
          50
          /* EditorOption.find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: true,
        shouldFocus: 0,
        shouldAnimate: true,
        updateSearchScope: false,
        loop: editor2.getOption(
          50
          /* EditorOption.find */
        ).loop
      });
      this._run(controller);
    }
  }
};
var NextMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize2(945, "Find Next"),
      precondition: void 0,
      kbOpts: [{
        kbExpr: EditorContextKeys.focus,
        primary: 61,
        mac: { primary: 2048 | 37, secondary: [
          61
          /* KeyCode.F3 */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
  }
  _run(controller) {
    const result = controller.moveToNextMatch();
    if (result) {
      controller.editor.pushUndoStop();
      return true;
    }
    return false;
  }
};
var PreviousMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize2(946, "Find Previous"),
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: EditorContextKeys.focus,
          primary: 1024 | 61,
          mac: { primary: 2048 | 1024 | 37, secondary: [
            1024 | 61
            /* KeyCode.F3 */
          ] },
          weight: 100
          /* KeybindingWeight.EditorContrib */
        },
        {
          kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
          primary: 1024 | 3,
          weight: 100
          /* KeybindingWeight.EditorContrib */
        }
      ]
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var MoveToMatchFindAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.GoToMatchFindAction,
      label: localize2(947, "Go to Match..."),
      precondition: CONTEXT_FIND_WIDGET_VISIBLE
    });
    this._highlightDecorations = [];
  }
  run(accessor, editor2, args) {
    const controller = CommonFindController.get(editor2);
    if (!controller) {
      return;
    }
    const matchesCount = controller.getState().matchesCount;
    if (matchesCount < 1) {
      const notificationService = accessor.get(INotificationService);
      notificationService.notify({
        severity: Severity.Warning,
        message: localize(937, "No matches. Try searching for something else.")
      });
      return;
    }
    const quickInputService = accessor.get(IQuickInputService);
    const disposables = new DisposableStore();
    const inputBox = disposables.add(quickInputService.createInputBox());
    inputBox.placeholder = localize(938, "Type a number to go to a specific match (between 1 and {0})", matchesCount);
    const toFindMatchIndex = (value) => {
      const index = parseInt(value);
      if (isNaN(index)) {
        return void 0;
      }
      const matchCount = controller.getState().matchesCount;
      if (index > 0 && index <= matchCount) {
        return index - 1;
      } else if (index < 0 && index >= -matchCount) {
        return matchCount + index;
      }
      return void 0;
    };
    const updatePickerAndEditor = (value) => {
      const index = toFindMatchIndex(value);
      if (typeof index === "number") {
        inputBox.validationMessage = void 0;
        controller.goToMatch(index);
        const currentMatch = controller.getState().currentMatch;
        if (currentMatch) {
          this.addDecorations(editor2, currentMatch);
        }
      } else {
        inputBox.validationMessage = localize(939, "Please type a number between 1 and {0}", controller.getState().matchesCount);
        this.clearDecorations(editor2);
      }
    };
    disposables.add(inputBox.onDidChangeValue((value) => {
      updatePickerAndEditor(value);
    }));
    disposables.add(inputBox.onDidAccept(() => {
      const index = toFindMatchIndex(inputBox.value);
      if (typeof index === "number") {
        controller.goToMatch(index);
        inputBox.hide();
      } else {
        inputBox.validationMessage = localize(940, "Please type a number between 1 and {0}", controller.getState().matchesCount);
      }
    }));
    disposables.add(inputBox.onDidHide(() => {
      this.clearDecorations(editor2);
      disposables.dispose();
    }));
    inputBox.show();
  }
  clearDecorations(editor2) {
    editor2.changeDecorations((changeAccessor) => {
      this._highlightDecorations = changeAccessor.deltaDecorations(this._highlightDecorations, []);
    });
  }
  addDecorations(editor2, range) {
    editor2.changeDecorations((changeAccessor) => {
      this._highlightDecorations = changeAccessor.deltaDecorations(this._highlightDecorations, [
        {
          range,
          options: {
            description: "find-match-quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        {
          range,
          options: {
            description: "find-match-quick-access-range-highlight-overview",
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ]);
    });
  }
};
var SelectionMatchFindAction = class extends EditorAction {
  async run(accessor, editor2) {
    const controller = CommonFindController.get(editor2);
    if (!controller) {
      return;
    }
    const selectionSearchString = getSelectionSearchString(editor2, "single", false);
    if (selectionSearchString) {
      controller.setSearchString(selectionSearchString);
    }
    if (!this._run(controller)) {
      await controller.start({
        forceRevealReplace: false,
        seedSearchStringFromSelection: "none",
        seedSearchStringFromNonEmptySelection: false,
        seedSearchStringFromGlobalClipboard: false,
        shouldFocus: 0,
        shouldAnimate: true,
        updateSearchScope: false,
        loop: editor2.getOption(
          50
          /* EditorOption.find */
        ).loop
      });
      this._run(controller);
    }
  }
};
var NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextSelectionMatchFindAction,
      label: localize2(948, "Find Next Selection"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 61,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
var PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousSelectionMatchFindAction,
      label: localize2(949, "Find Previous Selection"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 61,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindReplaceAction,
  label: localize2(950, "Replace"),
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 38,
    mac: {
      primary: 2048 | 512 | 36
      /* KeyCode.KeyF */
    },
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize(941, "&&Replace"),
    order: 2
  }
}));
StartFindReplaceAction.addImplementation(0, (accessor, editor2, args) => {
  if (!editor2.hasModel() || editor2.getOption(
    104
    /* EditorOption.readOnly */
  )) {
    return false;
  }
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  const currentSelection = editor2.getSelection();
  const findInputFocused = controller.isFindInputFocused();
  const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor2.getOption(
    50
    /* EditorOption.find */
  ).seedSearchStringFromSelection !== "never" && !findInputFocused;
  const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
  return controller.start({
    forceRevealReplace: true,
    seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(
      50
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(
      50
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never",
    shouldFocus,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(
      50
      /* EditorOption.find */
    ).loop
  });
});
registerEditorContribution(
  CommonFindController.ID,
  FindController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(StartFindWithArgsAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(MoveToMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
  id: FIND_IDS.CloseFindWidgetCommand,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.closeFindWidget(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (x) => x.toggleCaseSensitive(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleCaseSensitiveKeybinding.primary,
    mac: ToggleCaseSensitiveKeybinding.mac,
    win: ToggleCaseSensitiveKeybinding.win,
    linux: ToggleCaseSensitiveKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (x) => x.toggleWholeWords(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleWholeWordKeybinding.primary,
    mac: ToggleWholeWordKeybinding.mac,
    win: ToggleWholeWordKeybinding.win,
    linux: ToggleWholeWordKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleRegexCommand,
  precondition: void 0,
  handler: (x) => x.toggleRegex(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleRegexKeybinding.primary,
    mac: ToggleRegexKeybinding.mac,
    win: ToggleRegexKeybinding.win,
    linux: ToggleRegexKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (x) => x.toggleSearchScope(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleSearchScopeKeybinding.primary,
    mac: ToggleSearchScopeKeybinding.mac,
    win: ToggleSearchScopeKeybinding.win,
    linux: ToggleSearchScopeKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (x) => x.togglePreserveCase(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: TogglePreserveCaseKeybinding.primary,
    mac: TogglePreserveCaseKeybinding.mac,
    win: TogglePreserveCaseKeybinding.win,
    linux: TogglePreserveCaseKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 1024 | 22
    /* KeyCode.Digit1 */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 512 | 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: void 0,
    mac: {
      primary: 2048 | 3
    }
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.SelectAllMatchesAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.selectAllMatches(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 512 | 3
    /* KeyCode.Enter */
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
init_async();
init_cancellation();
init_errors();
init_keyCodes();
init_lifecycle();
init_strings();
init_types();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.css";
init_editorExtensions();
init_editorContextKeys();
init_languages();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js
init_event();

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js
var foldSourceAbbr = {
  [
    0
    /* FoldSource.provider */
  ]: " ",
  [
    1
    /* FoldSource.userDefined */
  ]: "u",
  [
    2
    /* FoldSource.recovered */
  ]: "r"
};
var MAX_FOLDING_REGIONS = 65535;
var MAX_LINE_NUMBER = 16777215;
var MASK_INDENT = 4278190080;
var BitField = class {
  constructor(size2) {
    const numWords = Math.ceil(size2 / 32);
    this._states = new Uint32Array(numWords);
  }
  get(index) {
    const arrayIndex = index / 32 | 0;
    const bit = index % 32;
    return (this._states[arrayIndex] & 1 << bit) !== 0;
  }
  set(index, newState) {
    const arrayIndex = index / 32 | 0;
    const bit = index % 32;
    const value = this._states[arrayIndex];
    if (newState) {
      this._states[arrayIndex] = value | 1 << bit;
    } else {
      this._states[arrayIndex] = value & ~(1 << bit);
    }
  }
};
var FoldingRegions = class _FoldingRegions {
  constructor(startIndexes, endIndexes, types) {
    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
      throw new Error("invalid startIndexes or endIndexes size");
    }
    this._startIndexes = startIndexes;
    this._endIndexes = endIndexes;
    this._collapseStates = new BitField(startIndexes.length);
    this._userDefinedStates = new BitField(startIndexes.length);
    this._recoveredStates = new BitField(startIndexes.length);
    this._types = types;
    this._parentsComputed = false;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = true;
      const parentIndexes = [];
      const isInsideLast = (startLineNumber, endLineNumber) => {
        const index = parentIndexes[parentIndexes.length - 1];
        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;
      };
      for (let i2 = 0, len = this._startIndexes.length; i2 < len; i2++) {
        const startLineNumber = this._startIndexes[i2];
        const endLineNumber = this._endIndexes[i2];
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
        }
        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
          parentIndexes.pop();
        }
        const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
        parentIndexes.push(i2);
        this._startIndexes[i2] = startLineNumber + ((parentIndex & 255) << 24);
        this._endIndexes[i2] = endLineNumber + ((parentIndex & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(index) {
    return this._startIndexes[index] & MAX_LINE_NUMBER;
  }
  getEndLineNumber(index) {
    return this._endIndexes[index] & MAX_LINE_NUMBER;
  }
  getType(index) {
    return this._types ? this._types[index] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(index) {
    return this._collapseStates.get(index);
  }
  setCollapsed(index, newState) {
    this._collapseStates.set(index, newState);
  }
  isUserDefined(index) {
    return this._userDefinedStates.get(index);
  }
  setUserDefined(index, newState) {
    return this._userDefinedStates.set(index, newState);
  }
  isRecovered(index) {
    return this._recoveredStates.get(index);
  }
  setRecovered(index, newState) {
    return this._recoveredStates.set(index, newState);
  }
  getSource(index) {
    if (this.isUserDefined(index)) {
      return 1;
    } else if (this.isRecovered(index)) {
      return 2;
    }
    return 0;
  }
  setSource(index, source) {
    if (source === 1) {
      this.setUserDefined(index, true);
      this.setRecovered(index, false);
    } else if (source === 2) {
      this.setUserDefined(index, false);
      this.setRecovered(index, true);
    } else {
      this.setUserDefined(index, false);
      this.setRecovered(index, false);
    }
  }
  setCollapsedAllOfType(type, newState) {
    let hasChanged = false;
    if (this._types) {
      for (let i2 = 0; i2 < this._types.length; i2++) {
        if (this._types[i2] === type) {
          this.setCollapsed(i2, newState);
          hasChanged = true;
        }
      }
    }
    return hasChanged;
  }
  toRegion(index) {
    return new FoldingRegion(this, index);
  }
  getParentIndex(index) {
    this.ensureParentIndices();
    const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
    if (parent === MAX_FOLDING_REGIONS) {
      return -1;
    }
    return parent;
  }
  contains(index, line) {
    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
  }
  findIndex(line) {
    let low = 0, high = this._startIndexes.length;
    if (high === 0) {
      return -1;
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (line < this.getStartLineNumber(mid)) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low - 1;
  }
  findRange(line) {
    let index = this.findIndex(line);
    if (index >= 0) {
      const endLineNumber = this.getEndLineNumber(index);
      if (endLineNumber >= line) {
        return index;
      }
      index = this.getParentIndex(index);
      while (index !== -1) {
        if (this.contains(index, line)) {
          return index;
        }
        index = this.getParentIndex(index);
      }
    }
    return -1;
  }
  toString() {
    const res = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      res[i2] = `[${foldSourceAbbr[this.getSource(i2)]}${this.isCollapsed(i2) ? "+" : "-"}] ${this.getStartLineNumber(i2)}/${this.getEndLineNumber(i2)}`;
    }
    return res.join(", ");
  }
  toFoldRange(index) {
    return {
      startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,
      endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,
      type: this._types ? this._types[index] : void 0,
      isCollapsed: this.isCollapsed(index),
      source: this.getSource(index)
    };
  }
  static fromFoldRanges(ranges) {
    const rangesLength = ranges.length;
    const startIndexes = new Uint32Array(rangesLength);
    const endIndexes = new Uint32Array(rangesLength);
    let types = [];
    let gotTypes = false;
    for (let i2 = 0; i2 < rangesLength; i2++) {
      const range = ranges[i2];
      startIndexes[i2] = range.startLineNumber;
      endIndexes[i2] = range.endLineNumber;
      types.push(range.type);
      if (range.type) {
        gotTypes = true;
      }
    }
    if (!gotTypes) {
      types = void 0;
    }
    const regions = new _FoldingRegions(startIndexes, endIndexes, types);
    for (let i2 = 0; i2 < rangesLength; i2++) {
      if (ranges[i2].isCollapsed) {
        regions.setCollapsed(i2, true);
      }
      regions.setSource(i2, ranges[i2].source);
    }
    return regions;
  }
  /**
   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
   * Each input must be pre-sorted on startLineNumber.
   * The first list is assumed to always include all regions currently defined by range providers.
   * The second list only contains the previously collapsed and all manual ranges.
   * If the line position matches, the range of the new range is taken, and the range is no longer manual
   * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
   * overlapping entries in the first list are discarded.
   * Invalid entries are discarded. An entry is invalid if:
   * 		the start and end line numbers aren't a valid range of line numbers,
   * 		it is out of sequence or has the same start line as a preceding entry,
   * 		it overlaps a preceding entry and is not fully contained by that entry.
   */
  static sanitizeAndMerge(rangesA, rangesB, maxLineNumber, selection) {
    maxLineNumber = maxLineNumber ?? Number.MAX_VALUE;
    const getIndexedFunction = (r, limit) => {
      return Array.isArray(r) ? ((i2) => {
        return i2 < limit ? r[i2] : void 0;
      }) : ((i2) => {
        return i2 < limit ? r.toFoldRange(i2) : void 0;
      });
    };
    const getA = getIndexedFunction(rangesA, rangesA.length);
    const getB = getIndexedFunction(rangesB, rangesB.length);
    let indexA = 0;
    let indexB = 0;
    let nextA = getA(0);
    let nextB = getB(0);
    const stackedRanges = [];
    let topStackedRange;
    let prevLineNumber = 0;
    const resultRanges = [];
    while (nextA || nextB) {
      let useRange = void 0;
      if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {
        if (nextA && nextA.startLineNumber === nextB.startLineNumber) {
          if (nextB.source === 1) {
            useRange = nextB;
          } else {
            useRange = nextA;
            useRange.isCollapsed = nextB.isCollapsed && (nextA.endLineNumber === nextB.endLineNumber || !selection?.startsInside(nextA.startLineNumber + 1, nextA.endLineNumber + 1));
            useRange.source = 0;
          }
          nextA = getA(++indexA);
        } else {
          useRange = nextB;
          if (nextB.isCollapsed && nextB.source === 0) {
            useRange.source = 2;
          }
        }
        nextB = getB(++indexB);
      } else {
        let scanIndex = indexB;
        let prescanB = nextB;
        while (true) {
          if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {
            useRange = nextA;
            break;
          }
          if (prescanB.source === 1 && prescanB.endLineNumber > nextA.endLineNumber) {
            break;
          }
          prescanB = getB(++scanIndex);
        }
        nextA = getA(++indexA);
      }
      if (useRange) {
        while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) {
          topStackedRange = stackedRanges.pop();
        }
        if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {
          resultRanges.push(useRange);
          prevLineNumber = useRange.startLineNumber;
          if (topStackedRange) {
            stackedRanges.push(topStackedRange);
          }
          topStackedRange = useRange;
        }
      }
    }
    return resultRanges;
  }
};
var FoldingRegion = class {
  constructor(ranges, index) {
    this.ranges = ranges;
    this.index = index;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(range) {
    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
  }
  containsLine(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js
init_hash();
var FoldingModel = class {
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  constructor(textModel, decorationProvider) {
    this._updateEventEmitter = new Emitter();
    this.onDidChange = this._updateEventEmitter.event;
    this._textModel = textModel;
    this._decorationProvider = decorationProvider;
    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
    this._editorDecorationIds = [];
  }
  toggleCollapseState(toggledRegions) {
    if (!toggledRegions.length) {
      return;
    }
    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
    const processed = {};
    this._decorationProvider.changeDecorations((accessor) => {
      let k = 0;
      let dirtyRegionEndLine = -1;
      let lastHiddenLine = -1;
      const updateDecorationsUntil = (index) => {
        while (k < index) {
          const endLineNumber = this._regions.getEndLineNumber(k);
          const isCollapsed = this._regions.isCollapsed(k);
          if (endLineNumber <= dirtyRegionEndLine) {
            const isManual = this.regions.getSource(k) !== 0;
            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));
          }
          if (isCollapsed && endLineNumber > lastHiddenLine) {
            lastHiddenLine = endLineNumber;
          }
          k++;
        }
      };
      for (const region of toggledRegions) {
        const index = region.regionIndex;
        const editorDecorationId = this._editorDecorationIds[index];
        if (editorDecorationId && !processed[editorDecorationId]) {
          processed[editorDecorationId] = true;
          updateDecorationsUntil(index);
          const newCollapseState = !this._regions.isCollapsed(index);
          this._regions.setCollapsed(index, newCollapseState);
          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));
        }
      }
      updateDecorationsUntil(this._regions.length);
    });
    this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });
  }
  removeManualRanges(ranges) {
    const newFoldingRanges = new Array();
    const intersects = (foldRange) => {
      for (const range of ranges) {
        if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {
          return true;
        }
      }
      return false;
    };
    for (let i2 = 0; i2 < this._regions.length; i2++) {
      const foldRange = this._regions.toFoldRange(i2);
      if (foldRange.source === 0 || !intersects(foldRange)) {
        newFoldingRanges.push(foldRange);
      }
    }
    this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));
  }
  update(newRegions, selection) {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges(selection);
    const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount(), selection);
    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
  }
  updatePost(newRegions) {
    const newEditorDecorations = [];
    let lastHiddenLine = -1;
    for (let index = 0, limit = newRegions.length; index < limit; index++) {
      const startLineNumber = newRegions.getStartLineNumber(index);
      const endLineNumber = newRegions.getEndLineNumber(index);
      const isCollapsed = newRegions.isCollapsed(index);
      const isManual = newRegions.getSource(index) !== 0;
      const decorationRange = {
        startLineNumber,
        startColumn: this._textModel.getLineMaxColumn(startLineNumber),
        endLineNumber,
        endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1
      };
      newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });
      if (isCollapsed && endLineNumber > lastHiddenLine) {
        lastHiddenLine = endLineNumber;
      }
    }
    this._decorationProvider.changeDecorations((accessor) => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));
    this._regions = newRegions;
    this._updateEventEmitter.fire({ model: this });
  }
  _currentFoldedOrManualRanges(selection) {
    const foldedRanges = [];
    for (let i2 = 0, limit = this._regions.length; i2 < limit; i2++) {
      let isCollapsed = this.regions.isCollapsed(i2);
      const source = this.regions.getSource(i2);
      if (isCollapsed || source !== 0) {
        const foldRange = this._regions.toFoldRange(i2);
        const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i2]);
        if (decRange) {
          if (isCollapsed && selection?.startsInside(decRange.startLineNumber + 1, decRange.endLineNumber)) {
            isCollapsed = false;
          }
          foldedRanges.push({
            startLineNumber: decRange.startLineNumber,
            endLineNumber: decRange.endLineNumber,
            type: foldRange.type,
            isCollapsed,
            source
          });
        }
      }
    }
    return foldedRanges;
  }
  /**
   * Collapse state memento, for persistence only
   */
  getMemento() {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges();
    const result = [];
    const maxLineNumber = this._textModel.getLineCount();
    for (let i2 = 0, limit = foldedOrManualRanges.length; i2 < limit; i2++) {
      const range = foldedOrManualRanges[i2];
      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {
        continue;
      }
      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
      result.push({
        startLineNumber: range.startLineNumber,
        endLineNumber: range.endLineNumber,
        isCollapsed: range.isCollapsed,
        source: range.source,
        checksum
      });
    }
    return result.length > 0 ? result : void 0;
  }
  /**
   * Apply persisted state, for persistence only
   */
  applyMemento(state) {
    if (!Array.isArray(state)) {
      return;
    }
    const rangesToRestore = [];
    const maxLineNumber = this._textModel.getLineCount();
    for (const range of state) {
      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {
        continue;
      }
      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
      if (!range.checksum || checksum === range.checksum) {
        rangesToRestore.push({
          startLineNumber: range.startLineNumber,
          endLineNumber: range.endLineNumber,
          type: void 0,
          isCollapsed: range.isCollapsed ?? true,
          source: range.source ?? 0
          /* FoldSource.provider */
        });
      }
    }
    const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);
    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
  }
  _getLinesChecksum(lineNumber1, lineNumber2) {
    const h2 = hash(this._textModel.getLineContent(lineNumber1) + this._textModel.getLineContent(lineNumber2));
    return h2 % 1e6;
  }
  dispose() {
    this._decorationProvider.removeDecorations(this._editorDecorationIds);
  }
  getAllRegionsAtLine(lineNumber, filter) {
    const result = [];
    if (this._regions) {
      let index = this._regions.findRange(lineNumber);
      let level = 1;
      while (index >= 0) {
        const current = this._regions.toRegion(index);
        if (!filter || filter(current, level)) {
          result.push(current);
        }
        level++;
        index = current.parentIndex;
      }
    }
    return result;
  }
  getRegionAtLine(lineNumber) {
    if (this._regions) {
      const index = this._regions.findRange(lineNumber);
      if (index >= 0) {
        return this._regions.toRegion(index);
      }
    }
    return null;
  }
  getRegionsInside(region, filter) {
    const result = [];
    const index = region ? region.regionIndex + 1 : 0;
    const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
    if (filter && filter.length === 2) {
      const levelStack = [];
      for (let i2 = index, len = this._regions.length; i2 < len; i2++) {
        const current = this._regions.toRegion(i2);
        if (this._regions.getStartLineNumber(i2) < endLineNumber) {
          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
            levelStack.pop();
          }
          levelStack.push(current);
          if (filter(current, levelStack.length)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    } else {
      for (let i2 = index, len = this._regions.length; i2 < len; i2++) {
        const current = this._regions.toRegion(i2);
        if (this._regions.getStartLineNumber(i2) < endLineNumber) {
          if (!filter || filter(current)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    }
    return result;
  }
};
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
  const toToggle = [];
  if (lineNumbers && lineNumbers.length > 0) {
    for (const lineNumber of lineNumbers) {
      const region = foldingModel.getRegionAtLine(lineNumber);
      if (region) {
        if (region.isCollapsed !== doCollapse) {
          toToggle.push(region);
        }
        if (levels > 1) {
          const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
          toToggle.push(...regionsInside);
        }
      }
    }
  } else {
    const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
    toToggle.push(...regionsInside);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
    toToggle.push(...regions);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
    if (regions.length > 0) {
      toToggle.push(regions[0]);
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
  const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line));
  const toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {
  const filteredRegions = [];
  for (const lineNumber of blockedLineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, void 0);
    if (regions.length > 0) {
      filteredRegions.push(regions[0]);
    }
  }
  const filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;
  const toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
  const editorModel = foldingModel.textModel;
  const regions = foldingModel.regions;
  const toToggle = [];
  for (let i2 = regions.length - 1; i2 >= 0; i2--) {
    if (doCollapse !== regions.isCollapsed(i2)) {
      const startLineNumber = regions.getStartLineNumber(i2);
      if (regExp.test(editorModel.getLineContent(startLineNumber))) {
        toToggle.push(regions.toRegion(i2));
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForType(foldingModel, type, doCollapse) {
  const regions = foldingModel.regions;
  const toToggle = [];
  for (let i2 = regions.length - 1; i2 >= 0; i2--) {
    if (doCollapse !== regions.isCollapsed(i2) && type === regions.getType(i2)) {
      toToggle.push(regions.toRegion(i2));
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function getParentFoldLine(lineNumber, foldingModel) {
  let startLineNumber = null;
  const foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null) {
    startLineNumber = foldingRegion.startLineNumber;
    if (lineNumber === startLineNumber) {
      const parentFoldingIdx = foldingRegion.parentIndex;
      if (parentFoldingIdx !== -1) {
        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);
      } else {
        startLineNumber = null;
      }
    }
  }
  return startLineNumber;
}
function getPreviousFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    if (lineNumber !== foldingRegion.startLineNumber) {
      return foldingRegion.startLineNumber;
    } else {
      const expectedParentIndex = foldingRegion.parentIndex;
      let minLineNumber = 0;
      if (expectedParentIndex !== -1) {
        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);
      }
      while (foldingRegion !== null) {
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
          if (foldingRegion.startLineNumber <= minLineNumber) {
            return null;
          } else if (foldingRegion.parentIndex === expectedParentIndex) {
            return foldingRegion.startLineNumber;
          }
        } else {
          return null;
        }
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber < lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
function getNextFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    const expectedParentIndex = foldingRegion.parentIndex;
    let maxLineNumber = 0;
    if (expectedParentIndex !== -1) {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);
    } else if (foldingModel.regions.length === 0) {
      return null;
    } else {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);
    }
    while (foldingRegion !== null) {
      if (foldingRegion.regionIndex < foldingModel.regions.length) {
        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        if (foldingRegion.startLineNumber >= maxLineNumber) {
          return null;
        } else if (foldingRegion.parentIndex === expectedParentIndex) {
          return foldingRegion.startLineNumber;
        }
      } else {
        return null;
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(0);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber > lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex < foldingModel.regions.length) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/hiddenRangeModel.js
init_arraysFind();
init_event();
init_range();
init_eolCounter();
var HiddenRangeModel = class {
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  constructor(model) {
    this._updateEventEmitter = new Emitter();
    this._hasLineChanges = false;
    this._foldingModel = model;
    this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
    this._hiddenRanges = [];
    if (model.regions.length) {
      this.updateHiddenRanges();
    }
  }
  notifyChangeModelContent(e) {
    if (this._hiddenRanges.length && !this._hasLineChanges) {
      this._hasLineChanges = e.changes.some((change) => {
        return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;
      });
    }
  }
  updateHiddenRanges() {
    let updateHiddenAreas = false;
    const newHiddenAreas = [];
    let i2 = 0;
    let k = 0;
    let lastCollapsedStart = Number.MAX_VALUE;
    let lastCollapsedEnd = -1;
    const ranges = this._foldingModel.regions;
    for (; i2 < ranges.length; i2++) {
      if (!ranges.isCollapsed(i2)) {
        continue;
      }
      const startLineNumber = ranges.getStartLineNumber(i2) + 1;
      const endLineNumber = ranges.getEndLineNumber(i2);
      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
        continue;
      }
      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
        newHiddenAreas.push(this._hiddenRanges[k]);
        k++;
      } else {
        updateHiddenAreas = true;
        newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));
      }
      lastCollapsedStart = startLineNumber;
      lastCollapsedEnd = endLineNumber;
    }
    if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {
      this.applyHiddenRanges(newHiddenAreas);
    }
  }
  applyHiddenRanges(newHiddenAreas) {
    this._hiddenRanges = newHiddenAreas;
    this._hasLineChanges = false;
    this._updateEventEmitter.fire(newHiddenAreas);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(line) {
    return findRange(this._hiddenRanges, line) !== null;
  }
  adjustSelections(selections) {
    let hasChanges = false;
    const editorModel = this._foldingModel.textModel;
    let lastRange = null;
    const adjustLine = (line) => {
      if (!lastRange || !isInside(line, lastRange)) {
        lastRange = findRange(this._hiddenRanges, line);
      }
      if (lastRange) {
        return lastRange.startLineNumber - 1;
      }
      return null;
    };
    for (let i2 = 0, len = selections.length; i2 < len; i2++) {
      let selection = selections[i2];
      const adjustedStartLine = adjustLine(selection.startLineNumber);
      if (adjustedStartLine) {
        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
        hasChanges = true;
      }
      const adjustedEndLine = adjustLine(selection.endLineNumber);
      if (adjustedEndLine) {
        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
        hasChanges = true;
      }
      selections[i2] = selection;
    }
    return hasChanges;
  }
  dispose() {
    if (this.hiddenRanges.length > 0) {
      this._hiddenRanges = [];
      this._updateEventEmitter.fire(this._hiddenRanges);
    }
    if (this._foldingModelListener) {
      this._foldingModelListener.dispose();
      this._foldingModelListener = null;
    }
  }
};
function isInside(line, range) {
  return line >= range.startLineNumber && line <= range.endLineNumber;
}
function findRange(ranges, line) {
  const i2 = findFirstIdxMonotonousOrArrLen(ranges, (r) => line < r.startLineNumber) - 1;
  if (i2 >= 0 && ranges[i2].endLineNumber >= line) {
    return ranges[i2];
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js
init_utils();
var MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5e3;
var ID_INDENT_PROVIDER = "indent";
var IndentRangeProvider = class {
  constructor(editorModel, languageConfigurationService, foldingRangesLimit) {
    this.editorModel = editorModel;
    this.languageConfigurationService = languageConfigurationService;
    this.foldingRangesLimit = foldingRangesLimit;
    this.id = ID_INDENT_PROVIDER;
  }
  dispose() {
  }
  compute(cancelationToken) {
    const foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;
    const offSide = foldingRules && !!foldingRules.offSide;
    const markers = foldingRules && foldingRules.markers;
    return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.foldingRangesLimit));
  }
};
var RangesCollector = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._indentOccurrences = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  insertFirst(startLineNumber, endLineNumber, indent) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    const index = this._length;
    this._startIndexes[index] = startLineNumber;
    this._endIndexes[index] = endLineNumber;
    this._length++;
    if (indent < 1e3) {
      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
    }
  }
  toIndentRanges(model) {
    const limit = this._foldingRangesLimit.limit;
    if (this._length <= limit) {
      this._foldingRangesLimit.update(this._length, false);
      const startIndexes = new Uint32Array(this._length);
      const endIndexes = new Uint32Array(this._length);
      for (let i2 = this._length - 1, k = 0; i2 >= 0; i2--, k++) {
        startIndexes[k] = this._startIndexes[i2];
        endIndexes[k] = this._endIndexes[i2];
      }
      return new FoldingRegions(startIndexes, endIndexes);
    } else {
      this._foldingRangesLimit.update(this._length, limit);
      let entries = 0;
      let maxIndent = this._indentOccurrences.length;
      for (let i2 = 0; i2 < this._indentOccurrences.length; i2++) {
        const n2 = this._indentOccurrences[i2];
        if (n2) {
          if (n2 + entries > limit) {
            maxIndent = i2;
            break;
          }
          entries += n2;
        }
      }
      const tabSize = model.getOptions().tabSize;
      const startIndexes = new Uint32Array(limit);
      const endIndexes = new Uint32Array(limit);
      for (let i2 = this._length - 1, k = 0; i2 >= 0; i2--) {
        const startIndex = this._startIndexes[i2];
        const lineContent = model.getLineContent(startIndex);
        const indent = computeIndentLevel(lineContent, tabSize);
        if (indent < maxIndent || indent === maxIndent && entries++ < limit) {
          startIndexes[k] = startIndex;
          endIndexes[k] = this._endIndexes[i2];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes);
    }
  }
};
var foldingRangesLimitDefault = {
  limit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,
  update: () => {
  }
};
function computeRanges(model, offSide, markers, foldingRangesLimit = foldingRangesLimitDefault) {
  const tabSize = model.getOptions().tabSize;
  const result = new RangesCollector(foldingRangesLimit);
  let pattern = void 0;
  if (markers) {
    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
  }
  const previousRegions = [];
  const line = model.getLineCount() + 1;
  previousRegions.push({ indent: -1, endAbove: line, line });
  for (let line2 = model.getLineCount(); line2 > 0; line2--) {
    const lineContent = model.getLineContent(line2);
    const indent = computeIndentLevel(lineContent, tabSize);
    let previous = previousRegions[previousRegions.length - 1];
    if (indent === -1) {
      if (offSide) {
        previous.endAbove = line2;
      }
      continue;
    }
    let m;
    if (pattern && (m = lineContent.match(pattern))) {
      if (m[1]) {
        let i2 = previousRegions.length - 1;
        while (i2 > 0 && previousRegions[i2].indent !== -2) {
          i2--;
        }
        if (i2 > 0) {
          previousRegions.length = i2 + 1;
          previous = previousRegions[i2];
          result.insertFirst(line2, previous.line, indent);
          previous.line = line2;
          previous.indent = indent;
          previous.endAbove = line2;
          continue;
        } else {
        }
      } else {
        previousRegions.push({ indent: -2, endAbove: line2, line: line2 });
        continue;
      }
    }
    if (previous.indent > indent) {
      do {
        previousRegions.pop();
        previous = previousRegions[previousRegions.length - 1];
      } while (previous.indent > indent);
      const endLineNumber = previous.endAbove - 1;
      if (endLineNumber - line2 >= 1) {
        result.insertFirst(line2, endLineNumber, indent);
      }
    }
    if (previous.indent === indent) {
      previous.endAbove = line2;
    } else {
      previousRegions.push({ indent, endAbove: line2, line: line2 });
    }
  }
  return result.toIndentRanges(model);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
init_nls();
init_contextkey();

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingDecorations.js
init_codicons();
init_textModel();
init_nls();
init_colorRegistry();
init_themeService();
init_themables();
var foldBackground = registerColor("editor.foldBackground", { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, localize(997, "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.foldPlaceholderForeground", { light: "#808080", dark: "#808080", hcDark: null, hcLight: null }, localize(998, "Color of the collapsed text after the first line of a folded range."));
registerColor("editorGutter.foldingControlForeground", iconForeground, localize(999, "Color of the folding control in the editor gutter."));
var foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown, localize(1e3, "Icon for expanded ranges in the editor glyph margin."));
var foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight, localize(1001, "Icon for collapsed ranges in the editor glyph margin."));
var foldingManualCollapsedIcon = registerIcon("folding-manual-collapsed", foldingCollapsedIcon, localize(1002, "Icon for manually collapsed ranges in the editor glyph margin."));
var foldingManualExpandedIcon = registerIcon("folding-manual-expanded", foldingExpandedIcon, localize(1003, "Icon for manually expanded ranges in the editor glyph margin."));
var foldedBackgroundMinimap = {
  color: themeColorFromId(foldBackground),
  position: 1
  /* MinimapPosition.Inline */
};
var collapsed = localize(1004, "Click to expand the range.");
var expanded = localize(1005, "Click to collapse the range.");
var _FoldingDecorationProvider = class _FoldingDecorationProvider {
  constructor(editor2) {
    this.editor = editor2;
    this.showFoldingControls = "mouseover";
    this.showFoldingHighlights = true;
  }
  getDecorationOption(isCollapsed, isHidden, isManual) {
    if (isHidden) {
      return _FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
    }
    if (this.showFoldingControls === "never") {
      if (isCollapsed) {
        return this.showFoldingHighlights ? _FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : _FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION;
      }
      return _FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION;
    }
    if (isCollapsed) {
      return isManual ? this.showFoldingHighlights ? _FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : _FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? _FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : _FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
    } else if (this.showFoldingControls === "mouseover") {
      return isManual ? _FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : _FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
    } else {
      return isManual ? _FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION : _FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
    }
  }
  changeDecorations(callback) {
    return this.editor.changeDecorations(callback);
  }
  removeDecorations(decorationIds) {
    this.editor.removeDecorations(decorationIds);
  }
};
_FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  linesDecorationsTooltip: collapsed,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
_FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  linesDecorationsTooltip: collapsed,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
_FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  linesDecorationsTooltip: collapsed,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
_FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  linesDecorationsTooltip: collapsed,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
_FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  linesDecorationsTooltip: collapsed
});
_FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  linesDecorationsTooltip: collapsed
});
_FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon),
  linesDecorationsTooltip: expanded
});
_FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon),
  linesDecorationsTooltip: expanded
});
_FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-expanded-visual-decoration",
  stickiness: 0,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingManualExpandedIcon),
  linesDecorationsTooltip: expanded
});
_FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-expanded-auto-hide-visual-decoration",
  stickiness: 0,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualExpandedIcon),
  linesDecorationsTooltip: expanded
});
_FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  isWholeLine: true
});
_FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
  /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
});
var FoldingDecorationProvider = _FoldingDecorationProvider;

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js
init_errors();
init_lifecycle();
var foldingContext = {};
var ID_SYNTAX_PROVIDER = "syntax";
var SyntaxRangeProvider = class {
  constructor(editorModel, providers, handleFoldingRangesChange, foldingRangesLimit, fallbackRangeProvider) {
    this.editorModel = editorModel;
    this.providers = providers;
    this.handleFoldingRangesChange = handleFoldingRangesChange;
    this.foldingRangesLimit = foldingRangesLimit;
    this.fallbackRangeProvider = fallbackRangeProvider;
    this.id = ID_SYNTAX_PROVIDER;
    this.disposables = new DisposableStore();
    if (fallbackRangeProvider) {
      this.disposables.add(fallbackRangeProvider);
    }
    for (const provider of providers) {
      if (typeof provider.onDidChange === "function") {
        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));
      }
    }
  }
  compute(cancellationToken) {
    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
      if (this.editorModel.isDisposed()) {
        return null;
      }
      if (ranges) {
        const res = sanitizeRanges(ranges, this.foldingRangesLimit);
        return res;
      }
      return this.fallbackRangeProvider?.compute(cancellationToken) ?? null;
    });
  }
  dispose() {
    this.disposables.dispose();
  }
};
function collectSyntaxRanges(providers, model, cancellationToken) {
  let rangeData = null;
  const promises = providers.map((provider, i2) => {
    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
      if (cancellationToken.isCancellationRequested) {
        return;
      }
      if (Array.isArray(ranges)) {
        if (!Array.isArray(rangeData)) {
          rangeData = [];
        }
        const nLines = model.getLineCount();
        for (const r of ranges) {
          if (r.start > 0 && r.end > r.start && r.end <= nLines) {
            rangeData.push({ start: r.start, end: r.end, rank: i2, kind: r.kind });
          }
        }
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then((_) => {
    return rangeData;
  });
}
var RangesCollector2 = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._nestingLevels = [];
    this._nestingLevelCounts = [];
    this._types = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  add(startLineNumber, endLineNumber, type, nestingLevel) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    const index = this._length;
    this._startIndexes[index] = startLineNumber;
    this._endIndexes[index] = endLineNumber;
    this._nestingLevels[index] = nestingLevel;
    this._types[index] = type;
    this._length++;
    if (nestingLevel < 30) {
      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
    }
  }
  toIndentRanges() {
    const limit = this._foldingRangesLimit.limit;
    if (this._length <= limit) {
      this._foldingRangesLimit.update(this._length, false);
      const startIndexes = new Uint32Array(this._length);
      const endIndexes = new Uint32Array(this._length);
      for (let i2 = 0; i2 < this._length; i2++) {
        startIndexes[i2] = this._startIndexes[i2];
        endIndexes[i2] = this._endIndexes[i2];
      }
      return new FoldingRegions(startIndexes, endIndexes, this._types);
    } else {
      this._foldingRangesLimit.update(this._length, limit);
      let entries = 0;
      let maxLevel = this._nestingLevelCounts.length;
      for (let i2 = 0; i2 < this._nestingLevelCounts.length; i2++) {
        const n2 = this._nestingLevelCounts[i2];
        if (n2) {
          if (n2 + entries > limit) {
            maxLevel = i2;
            break;
          }
          entries += n2;
        }
      }
      const startIndexes = new Uint32Array(limit);
      const endIndexes = new Uint32Array(limit);
      const types = [];
      for (let i2 = 0, k = 0; i2 < this._length; i2++) {
        const level = this._nestingLevels[i2];
        if (level < maxLevel || level === maxLevel && entries++ < limit) {
          startIndexes[k] = this._startIndexes[i2];
          endIndexes[k] = this._endIndexes[i2];
          types[k] = this._types[i2];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes, types);
    }
  }
};
function sanitizeRanges(rangeData, foldingRangesLimit) {
  const sorted = rangeData.sort((d1, d2) => {
    let diff = d1.start - d2.start;
    if (diff === 0) {
      diff = d1.rank - d2.rank;
    }
    return diff;
  });
  const collector = new RangesCollector2(foldingRangesLimit);
  let top = void 0;
  const previous = [];
  for (const entry of sorted) {
    if (!top) {
      top = entry;
      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
    } else {
      if (entry.start > top.start) {
        if (entry.end <= top.end) {
          previous.push(top);
          top = entry;
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        } else {
          if (entry.start > top.end) {
            do {
              top = previous.pop();
            } while (top && entry.start > top.end);
            if (top) {
              previous.push(top);
            }
            top = entry;
          }
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
      }
    }
  }
  return collector.toIndentRanges();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
init_languageFeatureDebounce();
init_stopwatch();
init_languageFeatures();
init_event();
init_commands();
init_uri();
init_model();
init_configuration();
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var FoldingController_1;
var CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
var _a34;
var FoldingController = (_a34 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(FoldingController_1.ID);
  }
  static getFoldingRangeProviders(languageFeaturesService, model) {
    const foldingRangeProviders = languageFeaturesService.foldingRangeProvider.ordered(model);
    return FoldingController_1._foldingRangeSelector?.(foldingRangeProviders, model) ?? foldingRangeProviders;
  }
  constructor(editor2, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this.contextKeyService = contextKeyService;
    this.languageConfigurationService = languageConfigurationService;
    this.languageFeaturesService = languageFeaturesService;
    this.localToDispose = this._register(new DisposableStore());
    this.editor = editor2;
    this._foldingLimitReporter = this._register(new RangesLimitReporter(editor2));
    const options = this.editor.getOptions();
    this._isEnabled = options.get(
      52
      /* EditorOption.folding */
    );
    this._useFoldingProviders = options.get(
      53
      /* EditorOption.foldingStrategy */
    ) !== "indentation";
    this._unfoldOnClickAfterEndOfLine = options.get(
      57
      /* EditorOption.unfoldOnClickAfterEndOfLine */
    );
    this._restoringViewState = false;
    this._currentModelHasFoldedImports = false;
    this._foldingImportsByDefault = options.get(
      55
      /* EditorOption.foldingImportsByDefault */
    );
    this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, "Folding", { min: 200 });
    this.foldingModel = null;
    this.hiddenRangeModel = null;
    this.rangeProvider = null;
    this.foldingRegionPromise = null;
    this.foldingModelPromise = null;
    this.updateScheduler = null;
    this.cursorChangedScheduler = null;
    this.mouseDownInfo = null;
    this.foldingDecorationProvider = new FoldingDecorationProvider(editor2);
    this.foldingDecorationProvider.showFoldingControls = options.get(
      126
      /* EditorOption.showFoldingControls */
    );
    this.foldingDecorationProvider.showFoldingHighlights = options.get(
      54
      /* EditorOption.foldingHighlight */
    );
    this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
    this.foldingEnabled.set(this._isEnabled);
    this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        52
        /* EditorOption.folding */
      )) {
        this._isEnabled = this.editor.getOptions().get(
          52
          /* EditorOption.folding */
        );
        this.foldingEnabled.set(this._isEnabled);
        this.onModelChanged();
      }
      if (e.hasChanged(
        56
        /* EditorOption.foldingMaximumRegions */
      )) {
        this.onModelChanged();
      }
      if (e.hasChanged(
        126
        /* EditorOption.showFoldingControls */
      ) || e.hasChanged(
        54
        /* EditorOption.foldingHighlight */
      )) {
        const options2 = this.editor.getOptions();
        this.foldingDecorationProvider.showFoldingControls = options2.get(
          126
          /* EditorOption.showFoldingControls */
        );
        this.foldingDecorationProvider.showFoldingHighlights = options2.get(
          54
          /* EditorOption.foldingHighlight */
        );
        this.triggerFoldingModelChanged();
      }
      if (e.hasChanged(
        53
        /* EditorOption.foldingStrategy */
      )) {
        this._useFoldingProviders = this.editor.getOptions().get(
          53
          /* EditorOption.foldingStrategy */
        ) !== "indentation";
        this.onFoldingStrategyChanged();
      }
      if (e.hasChanged(
        57
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      )) {
        this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(
          57
          /* EditorOption.unfoldOnClickAfterEndOfLine */
        );
      }
      if (e.hasChanged(
        55
        /* EditorOption.foldingImportsByDefault */
      )) {
        this._foldingImportsByDefault = this.editor.getOptions().get(
          55
          /* EditorOption.foldingImportsByDefault */
        );
      }
    }));
    this.onModelChanged();
  }
  /**
   * Store view state.
   */
  saveViewState() {
    const model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
      return {};
    }
    if (this.foldingModel) {
      const collapsedRegions = this.foldingModel.getMemento();
      const provider = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };
    }
    return void 0;
  }
  /**
   * Restore view state.
   */
  restoreViewState(state) {
    const model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {
      return;
    }
    if (!state) {
      return;
    }
    this._currentModelHasFoldedImports = !!state.foldedImports;
    if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {
      this._restoringViewState = true;
      try {
        this.foldingModel.applyMemento(state.collapsedRegions);
      } finally {
        this._restoringViewState = false;
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    const model = this.editor.getModel();
    if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
      return;
    }
    this._currentModelHasFoldedImports = false;
    this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
    this.localToDispose.add(this.foldingModel);
    this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
    this.localToDispose.add(this.hiddenRangeModel);
    this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
    this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));
    this.localToDispose.add(this.updateScheduler);
    this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
    this.localToDispose.add(this.cursorChangedScheduler);
    this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelContent((e) => this.onDidChangeModelContent(e)));
    this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
    this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
    this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
    this.localToDispose.add({
      dispose: () => {
        if (this.foldingRegionPromise) {
          this.foldingRegionPromise.cancel();
          this.foldingRegionPromise = null;
        }
        this.updateScheduler?.cancel();
        this.updateScheduler = null;
        this.foldingModel = null;
        this.foldingModelPromise = null;
        this.hiddenRangeModel = null;
        this.cursorChangedScheduler = null;
        this.rangeProvider?.dispose();
        this.rangeProvider = null;
      }
    });
    this.triggerFoldingModelChanged();
  }
  onFoldingStrategyChanged() {
    this.rangeProvider?.dispose();
    this.rangeProvider = null;
    this.triggerFoldingModelChanged();
  }
  getRangeProvider(editorModel) {
    if (this.rangeProvider) {
      return this.rangeProvider;
    }
    const indentRangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._foldingLimitReporter);
    this.rangeProvider = indentRangeProvider;
    if (this._useFoldingProviders && this.foldingModel) {
      const selectedProviders = FoldingController_1.getFoldingRangeProviders(this.languageFeaturesService, editorModel);
      if (selectedProviders.length > 0) {
        this.rangeProvider = new SyntaxRangeProvider(editorModel, selectedProviders, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, indentRangeProvider);
      }
    }
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    this.hiddenRangeModel?.notifyChangeModelContent(e);
    this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    if (this.updateScheduler) {
      if (this.foldingRegionPromise) {
        this.foldingRegionPromise.cancel();
        this.foldingRegionPromise = null;
      }
      this.foldingModelPromise = this.updateScheduler.trigger(() => {
        const foldingModel = this.foldingModel;
        if (!foldingModel) {
          return null;
        }
        const sw = new StopWatch();
        const provider = this.getRangeProvider(foldingModel.textModel);
        const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => provider.compute(token));
        return foldingRegionPromise.then((foldingRanges) => {
          if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
            let scrollState;
            if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
              const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);
              if (hasChanges) {
                scrollState = StableEditorScrollState.capture(this.editor);
                this._currentModelHasFoldedImports = hasChanges;
              }
            }
            const selections = this.editor.getSelections();
            foldingModel.update(foldingRanges, toSelectedLines(selections));
            scrollState?.restore(this.editor);
            const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());
            if (this.updateScheduler) {
              this.updateScheduler.defaultDelay = newValue;
            }
          }
          return foldingModel;
        });
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return null;
      });
    }
  }
  onHiddenRangesChanges(hiddenRanges) {
    if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {
      const selections = this.editor.getSelections();
      if (selections) {
        if (this.hiddenRangeModel.adjustSelections(selections)) {
          this.editor.setSelections(selections);
        }
      }
    }
    this.editor.setHiddenAreas(hiddenRanges, this);
  }
  onCursorPositionChanged() {
    if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {
      this.cursorChangedScheduler.schedule();
    }
  }
  revealCursor() {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel) {
      return;
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        const selections = this.editor.getSelections();
        if (selections && selections.length > 0) {
          const toToggle = [];
          for (const selection of selections) {
            const lineNumber = selection.selectionStartLineNumber;
            if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {
              toToggle.push(...foldingModel2.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
            }
          }
          if (toToggle.length) {
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal(selections[0].getPosition());
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    if (!this.hiddenRangeModel || !e.target || !e.target.range) {
      return;
    }
    if (!e.event.leftButton && !e.event.middleButton) {
      return;
    }
    const range = e.target.range;
    let iconClicked = false;
    switch (e.target.type) {
      case 4: {
        const data = e.target.detail;
        const offsetLeftInGutter = e.target.element.offsetLeft;
        const gutterOffsetX = data.offsetX - offsetLeftInGutter;
        if (gutterOffsetX < 4) {
          return;
        }
        iconClicked = true;
        break;
      }
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
          const data = e.target.detail;
          if (!data.isAfterLines) {
            break;
          }
        }
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          const model = this.editor.getModel();
          if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
            break;
          }
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };
  }
  onEditorMouseUp(e) {
    const foldingModel = this.foldingModel;
    if (!foldingModel || !this.mouseDownInfo || !e.target) {
      return;
    }
    const lineNumber = this.mouseDownInfo.lineNumber;
    const iconClicked = this.mouseDownInfo.iconClicked;
    const range = e.target.range;
    if (!range || range.startLineNumber !== lineNumber) {
      return;
    }
    if (iconClicked) {
      if (e.target.type !== 4) {
        return;
      }
    } else {
      const model = this.editor.getModel();
      if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {
        return;
      }
    }
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region && region.startLineNumber === lineNumber) {
      const isCollapsed = region.isCollapsed;
      if (iconClicked || isCollapsed) {
        const surrounding = e.event.altKey;
        let toToggle = [];
        if (surrounding) {
          const filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);
          const toMaybeToggle = foldingModel.getRegionsInside(null, filter);
          for (const r of toMaybeToggle) {
            if (r.isCollapsed) {
              toToggle.push(r);
            }
          }
          if (toToggle.length === 0) {
            toToggle = toMaybeToggle;
          }
        } else {
          const recursive = e.event.middleButton || e.event.shiftKey;
          if (recursive) {
            for (const r of foldingModel.getRegionsInside(region)) {
              if (r.isCollapsed === isCollapsed) {
                toToggle.push(r);
              }
            }
          }
          if (isCollapsed || !recursive || toToggle.length === 0) {
            toToggle.push(region);
          }
        }
        foldingModel.toggleCollapseState(toToggle);
        this.reveal({ lineNumber, column: 1 });
      }
    }
  }
  reveal(position) {
    this.editor.revealPositionInCenterIfOutsideViewport(
      position,
      0
      /* ScrollType.Smooth */
    );
  }
}, FoldingController_1 = _a34, _a34.ID = "editor.contrib.folding", _a34);
FoldingController = FoldingController_1 = __decorate41([
  __param41(1, IContextKeyService),
  __param41(2, ILanguageConfigurationService),
  __param41(3, INotificationService),
  __param41(4, ILanguageFeatureDebounceService),
  __param41(5, ILanguageFeaturesService)
], FoldingController);
var RangesLimitReporter = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._onDidChange = this._register(new Emitter());
    this._computed = 0;
    this._limited = false;
  }
  get limit() {
    return this.editor.getOptions().get(
      56
      /* EditorOption.foldingMaximumRegions */
    );
  }
  update(computed, limited) {
    if (computed !== this._computed || limited !== this._limited) {
      this._computed = computed;
      this._limited = limited;
      this._onDidChange.fire();
    }
  }
};
var FoldingAction = class extends EditorAction {
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const foldingController = FoldingController.get(editor2);
    if (!foldingController) {
      return;
    }
    const foldingModelPromise = foldingController.getFoldingModel();
    if (foldingModelPromise) {
      this.reportTelemetry(accessor, editor2);
      return foldingModelPromise.then((foldingModel) => {
        if (foldingModel) {
          this.invoke(foldingController, foldingModel, editor2, args, languageConfigurationService);
          const selection = editor2.getSelection();
          if (selection) {
            foldingController.reveal(selection.getStartPosition());
          }
        }
      });
    }
  }
  getSelectedLines(editor2) {
    const selections = editor2.getSelections();
    return selections ? selections.map((s) => s.startLineNumber) : [];
  }
  getLineNumbers(args, editor2) {
    if (args && args.selectionLines) {
      return args.selectionLines.map((l) => l + 1);
    }
    return this.getSelectedLines(editor2);
  }
  run(_accessor, _editor) {
  }
};
function toSelectedLines(selections) {
  if (!selections || selections.length === 0) {
    return {
      startsInside: () => false
    };
  }
  return {
    startsInside(startLine, endLine) {
      for (const s of selections) {
        const line = s.startLineNumber;
        if (line >= startLine && line <= endLine) {
          return true;
        }
      }
      return false;
    }
  };
}
function foldingArgumentsConstraint(args) {
  if (!isUndefined(args)) {
    if (!isObject(args)) {
      return false;
    }
    const foldingArgs = args;
    if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
      return false;
    }
    if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
      return false;
    }
    if (!isUndefined(foldingArgs.selectionLines) && (!Array.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
      return false;
    }
  }
  return true;
}
var UnfoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfold",
      label: localize2(977, "Unfold"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 94,
        mac: {
          primary: 2048 | 512 | 94
          /* KeyCode.BracketRight */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number",
                  "default": 1
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"],
                  "default": "down"
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    const levels = args && args.levels || 1;
    const lineNumbers = this.getLineNumbers(args, editor2);
    if (args && args.direction === "up") {
      setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
    } else {
      setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
    }
  }
};
var UnFoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: localize2(978, "Unfold Recursively"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 94
          /* KeyCode.BracketRight */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, _args) {
    setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor2));
  }
};
var FoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.fold",
      label: localize2(979, "Fold"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 92,
        mac: {
          primary: 2048 | 512 | 92
          /* KeyCode.BracketLeft */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number"
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"]
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    const lineNumbers = this.getLineNumbers(args, editor2);
    const levels = args && args.levels;
    const direction = args && args.direction;
    if (typeof levels !== "number" && typeof direction !== "string") {
      setCollapseStateUp(foldingModel, true, lineNumbers);
    } else {
      if (direction === "up") {
        setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
      } else {
        setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
      }
    }
  }
};
var ToggleFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: localize2(980, "Toggle Fold"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 42
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    toggleCollapseState(foldingModel, 1, selectedLines);
  }
};
var FoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: localize2(981, "Fold Recursively"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 92
          /* KeyCode.BracketLeft */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
  }
};
var ToggleFoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleFoldRecursively",
      label: localize2(982, "Toggle Fold Recursively"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 1024 | 42
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    toggleCollapseState(foldingModel, Number.MAX_VALUE, selectedLines);
  }
};
var FoldAllBlockCommentsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: localize2(983, "Fold All Block Comments"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 90
          /* KeyCode.Slash */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;
      if (comments && comments.blockCommentStartToken) {
        const regExp = new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken));
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
var FoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: localize2(984, "Fold All Regions"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 29
          /* KeyCode.Digit8 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        const regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
var UnfoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: localize2(985, "Unfold All Regions"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 30
          /* KeyCode.Digit9 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        const regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, false);
      }
    }
  }
};
var FoldAllExceptAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: localize2(986, "Fold All Except Selected"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 88
          /* KeyCode.Minus */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, true, selectedLines);
  }
};
var UnfoldAllExceptAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: localize2(987, "Unfold All Except Selected"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 86
          /* KeyCode.Equal */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, false, selectedLines);
  }
};
var FoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAll",
      label: localize2(988, "Fold All"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 21
          /* KeyCode.Digit0 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, true);
  }
};
var UnfoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: localize2(989, "Unfold All"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 40
          /* KeyCode.KeyJ */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, false);
  }
};
var _FoldLevelAction = class _FoldLevelAction extends FoldingAction {
  getFoldingLevel() {
    return parseInt(this.id.substr(_FoldLevelAction.ID_PREFIX.length));
  }
  invoke(_foldingController, foldingModel, editor2) {
    setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor2));
  }
};
_FoldLevelAction.ID_PREFIX = "editor.foldLevel";
_FoldLevelAction.ID = (level) => _FoldLevelAction.ID_PREFIX + level;
var FoldLevelAction = _FoldLevelAction;
var GotoParentFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: localize2(990, "Go to Parent Fold"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
var GotoPreviousFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: localize2(991, "Go to Previous Folding Range"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
var GotoNextFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: localize2(992, "Go to Next Folding Range"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
var FoldRangeFromSelectionAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.createFoldingRangeFromSelection",
      label: localize2(993, "Create Folding Range from Selection"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 87
          /* KeyCode.Comma */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const collapseRanges = [];
    const selections = editor2.getSelections();
    if (selections) {
      for (const selection of selections) {
        let endLineNumber = selection.endLineNumber;
        if (selection.endColumn === 1) {
          --endLineNumber;
        }
        if (endLineNumber > selection.startLineNumber) {
          collapseRanges.push({
            startLineNumber: selection.startLineNumber,
            endLineNumber,
            type: void 0,
            isCollapsed: true,
            source: 1
            /* FoldSource.userDefined */
          });
          editor2.setSelection({
            startLineNumber: selection.startLineNumber,
            startColumn: 1,
            endLineNumber: selection.startLineNumber,
            endColumn: 1
          });
        }
      }
      if (collapseRanges.length > 0) {
        collapseRanges.sort((a, b) => {
          return a.startLineNumber - b.startLineNumber;
        });
        const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, editor2.getModel()?.getLineCount());
        foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));
      }
    }
  }
};
var RemoveFoldRangeFromSelectionAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.removeManualFoldingRanges",
      label: localize2(994, "Remove Manual Folding Ranges"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 89
          /* KeyCode.Period */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(foldingController, foldingModel, editor2) {
    const selections = editor2.getSelections();
    if (selections) {
      const ranges = [];
      for (const selection of selections) {
        const { startLineNumber, endLineNumber } = selection;
        ranges.push(endLineNumber >= startLineNumber ? { startLineNumber, endLineNumber } : { endLineNumber, startLineNumber });
      }
      foldingModel.removeManualRanges(ranges);
      foldingController.triggerFoldingModelChanged();
    }
  }
};
var ToggleImportFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleImportFold",
      label: localize2(995, "Toggle Import Fold"),
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async invoke(foldingController, foldingModel) {
    const regionsToToggle = [];
    const regions = foldingModel.regions;
    for (let i2 = regions.length - 1; i2 >= 0; i2--) {
      if (regions.getType(i2) === FoldingRangeKind.Imports.value) {
        regionsToToggle.push(regions.toRegion(i2));
      }
    }
    foldingModel.toggleCollapseState(regionsToToggle);
    foldingController.triggerFoldingModelChanged();
  }
};
registerEditorContribution(
  FoldingController.ID,
  FoldingController,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(ToggleFoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
registerEditorAction(FoldAllExceptAction);
registerEditorAction(UnfoldAllExceptAction);
registerEditorAction(ToggleFoldAction);
registerEditorAction(GotoParentFoldAction);
registerEditorAction(GotoPreviousFoldAction);
registerEditorAction(GotoNextFoldAction);
registerEditorAction(FoldRangeFromSelectionAction);
registerEditorAction(RemoveFoldRangeFromSelectionAction);
registerEditorAction(ToggleImportFoldAction);
for (let i2 = 1; i2 <= 7; i2++) {
  registerInstantiatedEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(i2),
    label: localize2(996, "Fold Level {0}", i2),
    precondition: CONTEXT_FOLDING_ENABLED,
    kbOpts: {
      kbExpr: EditorContextKeys.editorTextFocus,
      primary: KeyChord(2048 | 41, 2048 | 21 + i2),
      weight: 100
      /* KeybindingWeight.EditorContrib */
    }
  }));
}
CommandsRegistry.registerCommand("_executeFoldingRangeProvider", async function(accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const configurationService = accessor.get(IConfigurationService);
  if (!configurationService.getValue("editor.folding", { resource })) {
    return [];
  }
  const languageConfigurationService = accessor.get(ILanguageConfigurationService);
  const strategy = configurationService.getValue("editor.foldingStrategy", { resource });
  const foldingLimitReporter = {
    get limit() {
      return configurationService.getValue("editor.foldingMaximumRegions", { resource });
    },
    update: (computed, limited) => {
    }
  };
  const indentRangeProvider = new IndentRangeProvider(model, languageConfigurationService, foldingLimitReporter);
  let rangeProvider = indentRangeProvider;
  if (strategy !== "indentation") {
    const providers = FoldingController.getFoldingRangeProviders(languageFeaturesService, model);
    if (providers.length) {
      rangeProvider = new SyntaxRangeProvider(model, providers, () => {
      }, foldingLimitReporter, indentRangeProvider);
    }
  }
  const ranges = await rangeProvider.compute(CancellationToken.None);
  const result = [];
  try {
    if (ranges) {
      for (let i2 = 0; i2 < ranges.length; i2++) {
        const type = ranges.getType(i2);
        result.push({ start: ranges.getStartLineNumber(i2), end: ranges.getEndLineNumber(i2), kind: type ? FoldingRangeKind.fromValue(type) : void 0 });
      }
    }
    return result;
  } finally {
    rangeProvider.dispose();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/browser/fontZoom.js
init_editorExtensions();
init_nls();
var EditorFontZoomIn = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: localize2(1006, "Increase Editor Font Size"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
  }
};
var EditorFontZoomOut = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: localize2(1007, "Decrease Editor Font Size"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
  }
};
var EditorFontZoomReset = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: localize2(1008, "Reset Editor Font Size"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(0);
  }
};
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);

// node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/formatActions.js
init_arrays();
init_cancellation();
init_errors();
init_keyCodes();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_characterClassifier();
init_range();
init_editorContextKeys();
init_editorWorker();
init_languageFeatures();
init_nls();
init_commands();
init_contextkey();
init_instantiation();
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a35;
var FormatOnType = (_a35 = class {
  constructor(_editor, _languageFeaturesService, _workerService, _accessibilitySignalService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._workerService = _workerService;
    this._accessibilitySignalService = _accessibilitySignalService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._disposables.add(_languageFeaturesService.onTypeFormattingEditProvider.onDidChange(this._update, this));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        65
        /* EditorOption.formatOnType */
      )) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._disposables.dispose();
    this._sessionDisposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    if (!this._editor.getOption(
      65
      /* EditorOption.formatOnType */
    )) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const [support] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
    if (!support || !support.autoFormatTriggerCharacters) {
      return;
    }
    const triggerChars = new CharacterSet();
    for (const ch of support.autoFormatTriggerCharacters) {
      triggerChars.add(ch.charCodeAt(0));
    }
    this._sessionDisposables.add(this._editor.onDidType((text) => {
      const lastCharCode = text.charCodeAt(text.length - 1);
      if (triggerChars.has(lastCharCode)) {
        this._trigger(String.fromCharCode(lastCharCode));
      }
    }));
  }
  _trigger(ch) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) {
      return;
    }
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    const cts = new CancellationTokenSource();
    const unbind = this._editor.onDidChangeModelContent((e) => {
      if (e.isFlush) {
        cts.cancel();
        unbind.dispose();
        return;
      }
      for (let i2 = 0, len = e.changes.length; i2 < len; i2++) {
        const change = e.changes[i2];
        if (change.range.endLineNumber <= position.lineNumber) {
          cts.cancel();
          unbind.dispose();
          return;
        }
      }
    });
    getOnTypeFormattingEdits(this._workerService, this._languageFeaturesService, model, position, ch, model.getFormattingOptions(), cts.token).then((edits) => {
      if (cts.token.isCancellationRequested) {
        return;
      }
      if (isNonEmptyArray(edits)) {
        this._accessibilitySignalService.playSignal(AccessibilitySignal.format, { userGesture: false });
        FormattingEdit.execute(this._editor, edits, true);
      }
    }).finally(() => {
      unbind.dispose();
    });
  }
}, _a35.ID = "editor.contrib.autoFormat", _a35);
FormatOnType = __decorate42([
  __param42(1, ILanguageFeaturesService),
  __param42(2, IEditorWorkerService),
  __param42(3, IAccessibilitySignalService)
], FormatOnType);
var _a36;
var FormatOnPaste = (_a36 = class {
  constructor(editor2, _languageFeaturesService, _instantiationService) {
    this.editor = editor2;
    this._languageFeaturesService = _languageFeaturesService;
    this._instantiationService = _instantiationService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this.editor.getOption(
      64
      /* EditorOption.formatOnPaste */
    )) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    if (!this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel())) {
      return;
    }
    this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
  }
  _trigger(range) {
    if (!this.editor.hasModel()) {
      return;
    }
    if (this.editor.getSelections().length > 1) {
      return;
    }
    this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None, false).catch(onUnexpectedError);
  }
}, _a36.ID = "editor.contrib.formatOnPaste", _a36);
FormatOnPaste = __decorate42([
  __param42(1, ILanguageFeaturesService),
  __param42(2, IInstantiationService)
], FormatOnPaste);
var FormatDocumentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatDocument",
      label: localize2(1009, "Format Document"),
      precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 36,
        linux: {
          primary: 2048 | 1024 | 39
          /* KeyCode.KeyI */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.3
      }
    });
  }
  async run(accessor, editor2) {
    if (editor2.hasModel()) {
      const instaService = accessor.get(IInstantiationService);
      const progressService = accessor.get(IEditorProgressService);
      await progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor2, 1, Progress.None, CancellationToken.None, true), 250);
    }
  }
};
var FormatSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatSelection",
      label: localize2(1010, "Format Selection"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 36
          /* KeyCode.KeyF */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        when: EditorContextKeys.hasNonEmptySelection,
        group: "1_modification",
        order: 1.31
      }
    });
  }
  async run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const instaService = accessor.get(IInstantiationService);
    const model = editor2.getModel();
    const ranges = editor2.getSelections().map((range) => {
      return range.isEmpty() ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
    });
    const progressService = accessor.get(IEditorProgressService);
    await progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None, true), 250);
  }
};
registerEditorContribution(
  FormatOnType.ID,
  FormatOnType,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorContribution(
  FormatOnPaste.ID,
  FormatOnPaste,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
CommandsRegistry.registerCommand("editor.action.format", async (accessor) => {
  const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (!editor2 || !editor2.hasModel()) {
    return;
  }
  const commandService = accessor.get(ICommandService);
  if (editor2.getSelection().isEmpty()) {
    await commandService.executeCommand("editor.action.formatDocument");
  } else {
    await commandService.executeCommand("editor.action.formatSelection");
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/documentSymbols.js
init_cancellation();
init_types();
init_uri();
init_resolverService();
init_outlineModel();
init_commands();
CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", async function(accessor, ...args) {
  const [resource] = args;
  assertType(URI.isUri(resource));
  const outlineService = accessor.get(IOutlineModelService);
  const modelService = accessor.get(ITextModelService);
  const reference = await modelService.createModelReference(resource);
  try {
    return (await outlineService.getOrCreate(reference.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
  } finally {
    reference.dispose();
  }
});

// node_modules/monaco-editor/esm/vs/platform/accessibility/browser/accessibleViewRegistry.js
var AccessibleViewRegistry = new class AccessibleViewRegistry2 {
  constructor() {
    this._implementations = [];
  }
  register(implementation) {
    this._implementations.push(implementation);
    return {
      dispose: () => {
        const idx = this._implementations.indexOf(implementation);
        if (idx !== -1) {
          this._implementations.splice(idx, 1);
        }
      }
    };
  }
  getImplementations() {
    return this._implementations;
  }
}();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletions.contribution.js
init_actions2();

// node_modules/monaco-editor/esm/vs/platform/observable/common/wrapInHotClass.js
init_observable();
init_instantiation();
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function hotClassGetOriginalInstance(value) {
  if (value instanceof BaseClass) {
    return value._instance;
  }
  return value;
}
var BaseClass = class {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
  }
  init(...params) {
  }
};
function createWrapper(clazz, B) {
  return class ReloadableWrapper extends B {
    constructor() {
      super(...arguments);
      this._autorun = void 0;
    }
    init(...params) {
      this._autorun = autorunWithStore((reader, store) => {
        const clazz_ = clazz.read(reader);
        this._instance = store.add(this.instantiationService.createInstance(clazz_, ...params));
      });
    }
    dispose() {
      this._autorun?.dispose();
    }
  };
}
function wrapInHotClass1(clazz) {
  return !isHotReloadEnabled() ? clazz.get() : createWrapper(clazz, BaseClass1);
}
var BaseClass1 = class BaseClass12 extends BaseClass {
  constructor(param1, i2) {
    super(i2);
    this.init(param1);
  }
};
BaseClass1 = __decorate44([
  __param44(1, IInstantiationService)
], BaseClass1);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletions.contribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/commands.js
init_observable();
init_strings();
init_nls();
init_actions2();
init_configuration();
init_contextkey();
init_keybindingsRegistry();
init_editorExtensions();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js
init_cancellation();
init_errors();
init_filters();
init_lifecycle();
init_stopwatch();
init_types();
init_uri();
init_position();
init_range();
init_resolverService();
init_nls();
init_actions2();
init_commands();
init_contextkey();
init_languageFeatures();
var Context = {
  Visible: historyNavigationVisible,
  HasFocusedSuggestion: new RawContextKey("suggestWidgetHasFocusedSuggestion", false, localize(1440, "Whether any suggestion is focused")),
  DetailsVisible: new RawContextKey("suggestWidgetDetailsVisible", false, localize(1441, "Whether suggestion details are visible")),
  MultipleSuggestions: new RawContextKey("suggestWidgetMultipleSuggestions", false, localize(1442, "Whether there are multiple suggestions to pick from")),
  MakesTextEdit: new RawContextKey("suggestionMakesTextEdit", true, localize(1443, "Whether inserting the current suggestion yields in a change or has everything already been typed")),
  AcceptSuggestionsOnEnter: new RawContextKey("acceptSuggestionOnEnter", true, localize(1444, "Whether suggestions are inserted when pressing Enter")),
  HasInsertAndReplaceRange: new RawContextKey("suggestionHasInsertAndReplaceRange", false, localize(1445, "Whether the current suggestion has insert and replace behaviour")),
  InsertMode: new RawContextKey("suggestionInsertMode", void 0, { type: "string", description: localize(1446, "Whether the default behaviour is to insert or replace") }),
  CanResolve: new RawContextKey("suggestionCanResolve", false, localize(1447, "Whether the current suggestion supports to resolve further details"))
};
var suggestWidgetStatusbarMenu = new MenuId("suggestWidgetStatusBar");
var CompletionItem = class {
  constructor(position, completion, container, provider) {
    this.position = position;
    this.completion = completion;
    this.container = container;
    this.provider = provider;
    this.isInvalid = false;
    this.score = FuzzyScore.Default;
    this.distance = 0;
    this.textLabel = typeof completion.label === "string" ? completion.label : completion.label?.label;
    this.labelLow = this.textLabel.toLowerCase();
    this.isInvalid = !this.textLabel;
    this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();
    this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();
    this.extensionId = completion.extensionId;
    if (Range.isIRange(completion.range)) {
      this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);
      this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;
    } else {
      this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);
      this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);
      this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);
      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;
    }
    if (typeof provider.resolveCompletionItem !== "function") {
      this._resolveCache = Promise.resolve();
      this._resolveDuration = 0;
    }
  }
  // ---- resolving
  get isResolved() {
    return this._resolveDuration !== void 0;
  }
  get resolveDuration() {
    return this._resolveDuration !== void 0 ? this._resolveDuration : -1;
  }
  async resolve(token) {
    if (!this._resolveCache) {
      const sub = token.onCancellationRequested(() => {
        this._resolveCache = void 0;
        this._resolveDuration = void 0;
      });
      const sw = new StopWatch(true);
      this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then((value) => {
        Object.assign(this.completion, value);
        this._resolveDuration = sw.elapsed();
      }, (err) => {
        if (isCancellationError(err)) {
          this._resolveCache = void 0;
          this._resolveDuration = void 0;
        }
      }).finally(() => {
        sub.dispose();
      });
    }
    return this._resolveCache;
  }
};
var _CompletionOptions = class _CompletionOptions {
  constructor(snippetSortOrder = 2, kindFilter = /* @__PURE__ */ new Set(), providerFilter = /* @__PURE__ */ new Set(), providerItemsToReuse = /* @__PURE__ */ new Map(), showDeprecated = true) {
    this.snippetSortOrder = snippetSortOrder;
    this.kindFilter = kindFilter;
    this.providerFilter = providerFilter;
    this.providerItemsToReuse = providerItemsToReuse;
    this.showDeprecated = showDeprecated;
  }
};
_CompletionOptions.default = new _CompletionOptions();
var CompletionOptions = _CompletionOptions;
var _snippetSuggestSupport;
function getSnippetSuggestSupport() {
  return _snippetSuggestSupport;
}
var CompletionItemModel = class {
  constructor(items, needsClipboard, durations, disposable) {
    this.items = items;
    this.needsClipboard = needsClipboard;
    this.durations = durations;
    this.disposable = disposable;
  }
};
async function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = {
  triggerKind: 0
  /* languages.CompletionTriggerKind.Invoke */
}, token = CancellationToken.None) {
  const sw = new StopWatch();
  position = position.clone();
  const word = model.getWordAtPosition(position);
  const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);
  const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };
  const result = [];
  const disposables = new DisposableStore();
  const durations = [];
  let needsClipboard = false;
  const onCompletionList = (provider, container, sw2) => {
    let didAddResult = false;
    if (!container) {
      return didAddResult;
    }
    for (const suggestion of container.suggestions) {
      if (!options.kindFilter.has(suggestion.kind)) {
        if (!options.showDeprecated && suggestion?.tags?.includes(
          1
          /* languages.CompletionItemTag.Deprecated */
        )) {
          continue;
        }
        if (!suggestion.range) {
          suggestion.range = defaultRange;
        }
        if (!suggestion.sortText) {
          suggestion.sortText = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.label;
        }
        if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4) {
          needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
        }
        result.push(new CompletionItem(position, suggestion, container, provider));
        didAddResult = true;
      }
    }
    if (isDisposable(container)) {
      disposables.add(container);
    }
    durations.push({
      providerName: provider._debugDisplayName ?? "unknown_provider",
      elapsedProvider: container.duration ?? -1,
      elapsedOverall: sw2.elapsed()
    });
    return didAddResult;
  };
  const snippetCompletions = (async () => {
    if (!_snippetSuggestSupport || options.kindFilter.has(
      28
      /* languages.CompletionItemKind.Snippet */
    )) {
      return;
    }
    const reuseItems = options.providerItemsToReuse.get(_snippetSuggestSupport);
    if (reuseItems) {
      reuseItems.forEach((item) => result.push(item));
      return;
    }
    if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
      return;
    }
    const sw2 = new StopWatch();
    const list = await _snippetSuggestSupport.provideCompletionItems(model, position, context, token);
    onCompletionList(_snippetSuggestSupport, list, sw2);
  })();
  for (const providerGroup of registry.orderedGroups(model)) {
    let didAddResult = false;
    await Promise.all(providerGroup.map(async (provider) => {
      if (options.providerItemsToReuse.has(provider)) {
        const items = options.providerItemsToReuse.get(provider);
        items.forEach((item) => result.push(item));
        didAddResult = didAddResult || items.length > 0;
        return;
      }
      if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
        return;
      }
      try {
        const sw2 = new StopWatch();
        const list = await provider.provideCompletionItems(model, position, context, token);
        didAddResult = onCompletionList(provider, list, sw2) || didAddResult;
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    if (didAddResult || token.isCancellationRequested) {
      break;
    }
  }
  await snippetCompletions;
  if (token.isCancellationRequested) {
    disposables.dispose();
    return Promise.reject(new CancellationError());
  }
  return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);
}
function defaultComparator(a, b) {
  if (a.sortTextLow && b.sortTextLow) {
    if (a.sortTextLow < b.sortTextLow) {
      return -1;
    } else if (a.sortTextLow > b.sortTextLow) {
      return 1;
    }
  }
  if (a.textLabel < b.textLabel) {
    return -1;
  } else if (a.textLabel > b.textLabel) {
    return 1;
  }
  return a.completion.kind - b.completion.kind;
}
function snippetUpComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 28) {
      return -1;
    } else if (b.completion.kind === 28) {
      return 1;
    }
  }
  return defaultComparator(a, b);
}
function snippetDownComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 28) {
      return 1;
    } else if (b.completion.kind === 28) {
      return -1;
    }
  }
  return defaultComparator(a, b);
}
var _snippetComparators = /* @__PURE__ */ new Map();
_snippetComparators.set(0, snippetUpComparator);
_snippetComparators.set(2, snippetDownComparator);
_snippetComparators.set(1, defaultComparator);
function getSuggestionComparator(snippetConfig) {
  return _snippetComparators.get(snippetConfig);
}
CommandsRegistry.registerCommand("_executeCompletionItemProvider", async (accessor, ...args) => {
  const [uri, position, triggerCharacter, maxItemsToResolve] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  assertType(typeof maxItemsToResolve === "number" || !maxItemsToResolve);
  const { completionProvider } = accessor.get(ILanguageFeaturesService);
  const ref = await accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = {
      incomplete: false,
      suggestions: []
    };
    const resolving = [];
    const actualPosition = ref.object.textEditorModel.validatePosition(position);
    const completions = await provideSuggestionItems(completionProvider, ref.object.textEditorModel, actualPosition, void 0, {
      triggerCharacter: triggerCharacter ?? void 0,
      triggerKind: triggerCharacter ? 1 : 0
      /* languages.CompletionTriggerKind.Invoke */
    });
    for (const item of completions.items) {
      if (resolving.length < (maxItemsToResolve ?? 0)) {
        resolving.push(item.resolve(CancellationToken.None));
      }
      result.incomplete = result.incomplete || item.container.incomplete;
      result.suggestions.push(item.completion);
    }
    try {
      await Promise.all(resolving);
      return result;
    } finally {
      setTimeout(() => completions.disposable.dispose(), 100);
    }
  } finally {
    ref.dispose();
  }
});
function showSimpleSuggestions(editor2, provider) {
  editor2.getContribution("editor.contrib.suggestController")?.triggerSuggest((/* @__PURE__ */ new Set()).add(provider), void 0, true);
}
var QuickSuggestionsOptions = class {
  static isAllOff(config) {
    return config.other === "off" && config.comments === "off" && config.strings === "off";
  }
  static isAllOn(config) {
    return config.other === "on" && config.comments === "on" && config.strings === "on";
  }
  static valueFor(config, tokenType) {
    switch (tokenType) {
      case 1:
        return config.comments;
      case 2:
        return config.strings;
      default:
        return config.other;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/inlineCompletionContextKeys.js
init_contextkey();
init_nls();
init_nls();
var _InlineCompletionContextKeys = class _InlineCompletionContextKeys {
};
_InlineCompletionContextKeys.inlineSuggestionVisible = new RawContextKey("inlineSuggestionVisible", false, localize(1184, "Whether an inline suggestion is visible"));
_InlineCompletionContextKeys.inlineSuggestionHasIndentation = new RawContextKey("inlineSuggestionHasIndentation", false, localize(1185, "Whether the inline suggestion starts with whitespace"));
_InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize = new RawContextKey("inlineSuggestionHasIndentationLessThanTabSize", true, localize(1186, "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
_InlineCompletionContextKeys.suppressSuggestions = new RawContextKey("inlineSuggestionSuppressSuggestions", void 0, localize(1187, "Whether suggestions should be suppressed for the current suggestion"));
_InlineCompletionContextKeys.cursorBeforeGhostText = new RawContextKey("cursorBeforeGhostText", false, localize(1188, "Whether the cursor is at ghost text"));
_InlineCompletionContextKeys.cursorInIndentation = new RawContextKey("cursorInIndentation", false, localize(1189, "Whether the cursor is in indentation"));
_InlineCompletionContextKeys.hasSelection = new RawContextKey("editor.hasSelection", false, localize(1190, "Whether the editor has a selection"));
_InlineCompletionContextKeys.cursorAtInlineEdit = new RawContextKey("cursorAtInlineEdit", false, localize(1191, "Whether the cursor is at an inline edit"));
_InlineCompletionContextKeys.inlineEditVisible = new RawContextKey("inlineEditIsVisible", false, localize(1192, "Whether an inline edit is visible"));
_InlineCompletionContextKeys.tabShouldJumpToInlineEdit = new RawContextKey("tabShouldJumpToInlineEdit", false, localize(1193, "Whether tab should jump to an inline edit."));
_InlineCompletionContextKeys.tabShouldAcceptInlineEdit = new RawContextKey("tabShouldAcceptInlineEdit", false, localize(1194, "Whether tab should accept the inline edit."));
_InlineCompletionContextKeys.inInlineEditsPreviewEditor = new RawContextKey("inInlineEditsPreviewEditor", true, localize(1195, "Whether the current code editor is showing an inline edits preview"));
var InlineCompletionContextKeys = _InlineCompletionContextKeys;

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/inlineCompletionsController.js
init_async();
init_cancellation();
init_lifecycle();
init_observable();
init_resources();
init_types();
init_nls();
init_commands();
init_configuration();
init_contextkey();
init_instantiation();
init_observableCodeEditor();
init_position();
init_languageFeatureDebounce();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/changeRecorder.js
init_lifecycle();
init_observable();
init_instantiation();
init_log();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/structuredLogger.js
init_lifecycle();
init_observable();
init_contextkey();
var __decorate45 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StructuredLogger_1;
function formatRecordableLogEntry(entry) {
  return entry.sourceId + " @@ " + JSON.stringify({ ...entry, modelUri: entry.modelUri?.toString(), sourceId: void 0 });
}
var StructuredLogger = StructuredLogger_1 = class StructuredLogger2 extends Disposable {
  static cast() {
    return this;
  }
  constructor(_key, _contextKeyService, _dataChannelService) {
    super();
    this._key = _key;
    this._contextKeyService = _contextKeyService;
    this._dataChannelService = _dataChannelService;
    this._isEnabledContextKeyValue = observableContextKey("structuredLogger.enabled:" + this._key, this._contextKeyService).recomputeInitiallyAndOnChange(this._store);
    this.isEnabled = this._isEnabledContextKeyValue.map((v) => v !== void 0);
  }
  log(data) {
    const enabled = this._isEnabledContextKeyValue.get();
    if (!enabled) {
      return false;
    }
    this._dataChannelService.getDataChannel("structuredLogger:" + this._key).sendData(data);
    return true;
  }
};
StructuredLogger = StructuredLogger_1 = __decorate45([
  __param45(1, IContextKeyService),
  __param45(2, IDataChannelService)
], StructuredLogger);
function observableContextKey(key, contextKeyService) {
  return observableFromEvent(contextKeyService.onDidChangeContext, () => contextKeyService.getContextKeyValue(key));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/changeRecorder.js
var __decorate46 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var TextModelChangeRecorder = class TextModelChangeRecorder2 extends Disposable {
  constructor(_editor, _instantiationService, _loggerService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._loggerService = _loggerService;
    this._structuredLogger = this._register(this._instantiationService.createInstance(StructuredLogger.cast(), "editor.inlineSuggest.logChangeReason.commandId"));
    const logger = this._loggerService?.createLogger("textModelChanges", { hidden: false, name: "Text Model Changes Reason" });
    const loggingLevel = observableFromEvent(this, logger.onDidChangeLogLevel, () => logger.getLevel());
    this._register(autorun((reader) => {
      if (!canLog(loggingLevel.read(reader), LogLevel.Trace)) {
        return;
      }
      reader.store.add(this._editor.onDidChangeModelContent((e) => {
        if (this._editor.getModel()?.uri.scheme === "output") {
          return;
        }
        logger.trace("onDidChangeModelContent: " + e.detailedReasons.map((r) => r.toKey(Number.MAX_VALUE)).join(", "));
      }));
    }));
    this._register(autorun((reader) => {
      if (!(this._editor instanceof CodeEditorWidget)) {
        return;
      }
      if (!this._structuredLogger.isEnabled.read(reader)) {
        return;
      }
      reader.store.add(this._editor.onDidChangeModelContent((e) => {
        const tm = this._editor.getModel();
        if (!tm) {
          return;
        }
        const reason = e.detailedReasons[0];
        const data = {
          ...reason.metadata,
          sourceId: "TextModel.setChangeReason",
          source: reason.metadata.source,
          time: Date.now(),
          modelUri: tm.uri,
          modelVersion: tm.getVersionId()
        };
        setTimeout(() => {
          this._structuredLogger.log(data);
        }, 0);
      }));
    }));
  }
};
TextModelChangeRecorder = __decorate46([
  __param46(1, IInstantiationService),
  __param46(2, ILoggerService)
], TextModelChangeRecorder);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsModel.js
init_arraysFind();
init_equals();
init_errors();
init_event();
init_lifecycle();
init_observable();
init_strings();
init_types();
init_commands();
init_instantiation();
init_observableCodeEditor();
init_cursorColumns();
init_lineRange();
init_position();
init_range();
init_selection();
init_textLength();
init_languages();
init_languageConfigurationRegistry();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js
init_lifecycle();
init_types();
init_editorExtensions();
init_position();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_languageFeatures();
init_nls();
init_contextkey();
init_log();

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js
init_arrays();
init_lifecycle();
init_strings();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.css";
init_range();
init_selection();
init_languageConfigurationRegistry();
init_textModel();

// node_modules/monaco-editor/esm/vs/base/common/labels.js
init_extpath();
init_platform();
function normalizeDriveLetter(path, isWindowsOS = isWindows) {
  if (hasDriveLetter(path, isWindowsOS)) {
    return path.charAt(0).toUpperCase() + path.slice(1);
  }
  return path;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetVariables.js
init_path();
init_resources();
init_strings();
init_uuid();
init_languageConfigurationRegistry();
init_nls();
var __decorate47 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var KnownSnippetVariableNames = Object.freeze({
  "CURRENT_YEAR": true,
  "CURRENT_YEAR_SHORT": true,
  "CURRENT_MONTH": true,
  "CURRENT_DATE": true,
  "CURRENT_HOUR": true,
  "CURRENT_MINUTE": true,
  "CURRENT_SECOND": true,
  "CURRENT_DAY_NAME": true,
  "CURRENT_DAY_NAME_SHORT": true,
  "CURRENT_MONTH_NAME": true,
  "CURRENT_MONTH_NAME_SHORT": true,
  "CURRENT_SECONDS_UNIX": true,
  "CURRENT_TIMEZONE_OFFSET": true,
  "SELECTION": true,
  "CLIPBOARD": true,
  "TM_SELECTED_TEXT": true,
  "TM_CURRENT_LINE": true,
  "TM_CURRENT_WORD": true,
  "TM_LINE_INDEX": true,
  "TM_LINE_NUMBER": true,
  "TM_FILENAME": true,
  "TM_FILENAME_BASE": true,
  "TM_DIRECTORY": true,
  "TM_FILEPATH": true,
  "CURSOR_INDEX": true,
  // 0-offset
  "CURSOR_NUMBER": true,
  // 1-offset
  "RELATIVE_FILEPATH": true,
  "BLOCK_COMMENT_START": true,
  "BLOCK_COMMENT_END": true,
  "LINE_COMMENT": true,
  "WORKSPACE_NAME": true,
  "WORKSPACE_FOLDER": true,
  "RANDOM": true,
  "RANDOM_HEX": true,
  "UUID": true
});
var CompositeSnippetVariableResolver = class {
  constructor(_delegates) {
    this._delegates = _delegates;
  }
  resolve(variable) {
    for (const delegate of this._delegates) {
      const value = delegate.resolve(variable);
      if (value !== void 0) {
        return value;
      }
    }
    return void 0;
  }
};
var SelectionBasedVariableResolver = class {
  constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {
    this._model = _model;
    this._selection = _selection;
    this._selectionIdx = _selectionIdx;
    this._overtypingCapturer = _overtypingCapturer;
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "SELECTION" || name === "TM_SELECTED_TEXT") {
      let value = this._model.getValueInRange(this._selection) || void 0;
      let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!value && this._overtypingCapturer) {
        const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        if (info) {
          value = info.value;
          isMultiline = info.multiline;
        }
      }
      if (value && isMultiline && variable.snippet) {
        const line = this._model.getLineContent(this._selection.startLineNumber);
        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, this._selection.startColumn - 1);
        let varLeadingWhitespace = lineLeadingWhitespace;
        variable.snippet.walk((marker) => {
          if (marker === variable) {
            return false;
          }
          if (marker instanceof Text) {
            varLeadingWhitespace = getLeadingWhitespace(splitLines(marker.value).pop());
          }
          return true;
        });
        const whitespaceCommonLength = commonPrefixLength(varLeadingWhitespace, lineLeadingWhitespace);
        value = value.replace(/(\r\n|\r|\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);
      }
      return value;
    } else if (name === "TM_CURRENT_LINE") {
      return this._model.getLineContent(this._selection.positionLineNumber);
    } else if (name === "TM_CURRENT_WORD") {
      const info = this._model.getWordAtPosition({
        lineNumber: this._selection.positionLineNumber,
        column: this._selection.positionColumn
      });
      return info && info.word || void 0;
    } else if (name === "TM_LINE_INDEX") {
      return String(this._selection.positionLineNumber - 1);
    } else if (name === "TM_LINE_NUMBER") {
      return String(this._selection.positionLineNumber);
    } else if (name === "CURSOR_INDEX") {
      return String(this._selectionIdx);
    } else if (name === "CURSOR_NUMBER") {
      return String(this._selectionIdx + 1);
    }
    return void 0;
  }
};
var ModelBasedVariableResolver = class {
  constructor(_labelService, _model) {
    this._labelService = _labelService;
    this._model = _model;
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "TM_FILENAME") {
      return basename(this._model.uri.fsPath);
    } else if (name === "TM_FILENAME_BASE") {
      const name2 = basename(this._model.uri.fsPath);
      const idx = name2.lastIndexOf(".");
      if (idx <= 0) {
        return name2;
      } else {
        return name2.slice(0, idx);
      }
    } else if (name === "TM_DIRECTORY") {
      if (dirname(this._model.uri.fsPath) === ".") {
        return "";
      }
      return this._labelService.getUriLabel(dirname2(this._model.uri));
    } else if (name === "TM_FILEPATH") {
      return this._labelService.getUriLabel(this._model.uri);
    } else if (name === "RELATIVE_FILEPATH") {
      return this._labelService.getUriLabel(this._model.uri, { relative: true, noPrefix: true });
    }
    return void 0;
  }
};
var ClipboardBasedVariableResolver = class {
  constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {
    this._readClipboardText = _readClipboardText;
    this._selectionIdx = _selectionIdx;
    this._selectionCount = _selectionCount;
    this._spread = _spread;
  }
  resolve(variable) {
    if (variable.name !== "CLIPBOARD") {
      return void 0;
    }
    const clipboardText = this._readClipboardText();
    if (!clipboardText) {
      return void 0;
    }
    if (this._spread) {
      const lines = clipboardText.split(/\r\n|\n|\r/).filter((s) => !isFalsyOrWhitespace(s));
      if (lines.length === this._selectionCount) {
        return lines[this._selectionIdx];
      }
    }
    return clipboardText;
  }
};
var CommentBasedVariableResolver = class CommentBasedVariableResolver2 {
  constructor(_model, _selection, _languageConfigurationService) {
    this._model = _model;
    this._selection = _selection;
    this._languageConfigurationService = _languageConfigurationService;
  }
  resolve(variable) {
    const { name } = variable;
    const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);
    const config = this._languageConfigurationService.getLanguageConfiguration(langId).comments;
    if (!config) {
      return void 0;
    }
    if (name === "LINE_COMMENT") {
      return config.lineCommentToken || void 0;
    } else if (name === "BLOCK_COMMENT_START") {
      return config.blockCommentStartToken || void 0;
    } else if (name === "BLOCK_COMMENT_END") {
      return config.blockCommentEndToken || void 0;
    }
    return void 0;
  }
};
CommentBasedVariableResolver = __decorate47([
  __param47(2, ILanguageConfigurationService)
], CommentBasedVariableResolver);
var _TimeBasedVariableResolver = class _TimeBasedVariableResolver {
  constructor() {
    this._date = /* @__PURE__ */ new Date();
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "CURRENT_YEAR") {
      return String(this._date.getFullYear());
    } else if (name === "CURRENT_YEAR_SHORT") {
      return String(this._date.getFullYear()).slice(-2);
    } else if (name === "CURRENT_MONTH") {
      return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
    } else if (name === "CURRENT_DATE") {
      return String(this._date.getDate().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_HOUR") {
      return String(this._date.getHours().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_MINUTE") {
      return String(this._date.getMinutes().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_SECOND") {
      return String(this._date.getSeconds().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_DAY_NAME") {
      return _TimeBasedVariableResolver.dayNames[this._date.getDay()];
    } else if (name === "CURRENT_DAY_NAME_SHORT") {
      return _TimeBasedVariableResolver.dayNamesShort[this._date.getDay()];
    } else if (name === "CURRENT_MONTH_NAME") {
      return _TimeBasedVariableResolver.monthNames[this._date.getMonth()];
    } else if (name === "CURRENT_MONTH_NAME_SHORT") {
      return _TimeBasedVariableResolver.monthNamesShort[this._date.getMonth()];
    } else if (name === "CURRENT_SECONDS_UNIX") {
      return String(Math.floor(this._date.getTime() / 1e3));
    } else if (name === "CURRENT_TIMEZONE_OFFSET") {
      const rawTimeOffset = this._date.getTimezoneOffset();
      const sign = rawTimeOffset > 0 ? "-" : "+";
      const hours = Math.trunc(Math.abs(rawTimeOffset / 60));
      const hoursString = hours < 10 ? "0" + hours : hours;
      const minutes = Math.abs(rawTimeOffset) - hours * 60;
      const minutesString = minutes < 10 ? "0" + minutes : minutes;
      return sign + hoursString + ":" + minutesString;
    }
    return void 0;
  }
};
_TimeBasedVariableResolver.dayNames = [localize(1391, "Sunday"), localize(1392, "Monday"), localize(1393, "Tuesday"), localize(1394, "Wednesday"), localize(1395, "Thursday"), localize(1396, "Friday"), localize(1397, "Saturday")];
_TimeBasedVariableResolver.dayNamesShort = [localize(1398, "Sun"), localize(1399, "Mon"), localize(1400, "Tue"), localize(1401, "Wed"), localize(1402, "Thu"), localize(1403, "Fri"), localize(1404, "Sat")];
_TimeBasedVariableResolver.monthNames = [localize(1405, "January"), localize(1406, "February"), localize(1407, "March"), localize(1408, "April"), localize(1409, "May"), localize(1410, "June"), localize(1411, "July"), localize(1412, "August"), localize(1413, "September"), localize(1414, "October"), localize(1415, "November"), localize(1416, "December")];
_TimeBasedVariableResolver.monthNamesShort = [localize(1417, "Jan"), localize(1418, "Feb"), localize(1419, "Mar"), localize(1420, "Apr"), localize(1421, "May"), localize(1422, "Jun"), localize(1423, "Jul"), localize(1424, "Aug"), localize(1425, "Sep"), localize(1426, "Oct"), localize(1427, "Nov"), localize(1428, "Dec")];
var TimeBasedVariableResolver = _TimeBasedVariableResolver;
var WorkspaceBasedVariableResolver = class {
  constructor(_workspaceService) {
    this._workspaceService = _workspaceService;
  }
  resolve(variable) {
    if (!this._workspaceService) {
      return void 0;
    }
    const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());
    if (isEmptyWorkspaceIdentifier(workspaceIdentifier)) {
      return void 0;
    }
    if (variable.name === "WORKSPACE_NAME") {
      return this._resolveWorkspaceName(workspaceIdentifier);
    } else if (variable.name === "WORKSPACE_FOLDER") {
      return this._resoveWorkspacePath(workspaceIdentifier);
    }
    return void 0;
  }
  _resolveWorkspaceName(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return basename(workspaceIdentifier.uri.path);
    }
    let filename = basename(workspaceIdentifier.configPath.path);
    if (filename.endsWith(WORKSPACE_EXTENSION)) {
      filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
    }
    return filename;
  }
  _resoveWorkspacePath(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return normalizeDriveLetter(workspaceIdentifier.uri.fsPath);
    }
    const filename = basename(workspaceIdentifier.configPath.path);
    let folderpath = workspaceIdentifier.configPath.fsPath;
    if (folderpath.endsWith(filename)) {
      folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);
    }
    return folderpath ? normalizeDriveLetter(folderpath) : "/";
  }
};
var RandomBasedVariableResolver = class {
  resolve(variable) {
    const { name } = variable;
    if (name === "RANDOM") {
      return Math.random().toString().slice(-6);
    } else if (name === "RANDOM_HEX") {
      return Math.random().toString(16).slice(-6);
    } else if (name === "UUID") {
      return generateUuid();
    }
    return void 0;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js
init_textModelEditSource();
var __decorate48 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SnippetSession_1;
var _OneSnippet = class _OneSnippet {
  constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {
    this._editor = _editor;
    this._snippet = _snippet;
    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;
    this._offset = -1;
    this._nestingLevel = 1;
    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);
    this._placeholderGroupsIdx = -1;
  }
  initialize(textChange) {
    this._offset = textChange.newPosition;
  }
  dispose() {
    if (this._placeholderDecorations) {
      this._editor.removeDecorations([...this._placeholderDecorations.values()]);
    }
    this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._offset === -1) {
      throw new Error(`Snippet not initialized!`);
    }
    if (this._placeholderDecorations) {
      return;
    }
    this._placeholderDecorations = /* @__PURE__ */ new Map();
    const model = this._editor.getModel();
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._snippet.placeholders) {
        const placeholderOffset = this._snippet.offset(placeholder);
        const placeholderLen = this._snippet.fullLen(placeholder);
        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));
        const options = placeholder.isFinalTabstop ? _OneSnippet._decor.inactiveFinal : _OneSnippet._decor.inactive;
        const handle = accessor.addDecoration(range, options);
        this._placeholderDecorations.set(placeholder, handle);
      }
    });
  }
  move(fwd) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this._initDecorations();
    if (this._placeholderGroupsIdx >= 0) {
      const operations = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        if (placeholder.transform) {
          const id = this._placeholderDecorations.get(placeholder);
          const range = this._editor.getModel().getDecorationRange(id);
          const currentValue = this._editor.getModel().getValueInRange(range);
          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\r\n|\r|\n/);
          for (let i2 = 1; i2 < transformedValueLines.length; i2++) {
            transformedValueLines[i2] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i2]);
          }
          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));
        }
      }
      if (operations.length > 0) {
        this._editor.executeEdits("snippet.placeholderTransform", operations);
      }
    }
    let couldSkipThisPlaceholder = false;
    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
      this._placeholderGroupsIdx += 1;
      couldSkipThisPlaceholder = true;
    } else if (fwd === false && this._placeholderGroupsIdx > 0) {
      this._placeholderGroupsIdx -= 1;
      couldSkipThisPlaceholder = true;
    } else {
    }
    const newSelections = this._editor.getModel().changeDecorations((accessor) => {
      const activePlaceholders = /* @__PURE__ */ new Set();
      const selections = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const id = this._placeholderDecorations.get(placeholder);
        const range = this._editor.getModel().getDecorationRange(id);
        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));
        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);
        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? _OneSnippet._decor.activeFinal : _OneSnippet._decor.active);
        activePlaceholders.add(placeholder);
        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {
          const id2 = this._placeholderDecorations.get(enclosingPlaceholder);
          accessor.changeDecorationOptions(id2, enclosingPlaceholder.isFinalTabstop ? _OneSnippet._decor.activeFinal : _OneSnippet._decor.active);
          activePlaceholders.add(enclosingPlaceholder);
        }
      }
      for (const [placeholder, id] of this._placeholderDecorations) {
        if (!activePlaceholders.has(placeholder)) {
          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? _OneSnippet._decor.inactiveFinal : _OneSnippet._decor.inactive);
        }
      }
      return selections;
    });
    return !couldSkipThisPlaceholder ? newSelections ?? [] : this.move(fwd);
  }
  _hasPlaceholderBeenCollapsed(placeholder) {
    let marker = placeholder;
    while (marker) {
      if (marker instanceof Placeholder) {
        const id = this._placeholderDecorations.get(marker);
        const range = this._editor.getModel().getDecorationRange(id);
        if (range.isEmpty() && marker.toString().length > 0) {
          return true;
        }
      }
      marker = marker.parent;
    }
    return false;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  /**
   * A snippet is trivial when it has no placeholder or only a final placeholder at
   * its very end
   */
  get isTrivialSnippet() {
    if (this._snippet.placeholders.length === 0) {
      return true;
    }
    if (this._snippet.placeholders.length === 1) {
      const [placeholder] = this._snippet.placeholders;
      if (placeholder.isFinalTabstop) {
        if (this._snippet.rightMostDescendant === placeholder) {
          return true;
        }
      }
    }
    return false;
  }
  computePossibleSelections() {
    const result = /* @__PURE__ */ new Map();
    for (const placeholdersWithEqualIndex of this._placeholderGroups) {
      let ranges;
      for (const placeholder of placeholdersWithEqualIndex) {
        if (placeholder.isFinalTabstop) {
          break;
        }
        if (!ranges) {
          ranges = [];
          result.set(placeholder.index, ranges);
        }
        const id = this._placeholderDecorations.get(placeholder);
        const range = this._editor.getModel().getDecorationRange(id);
        if (!range) {
          result.delete(placeholder.index);
          break;
        }
        ranges.push(range);
      }
    }
    return result;
  }
  get activeChoice() {
    if (!this._placeholderDecorations) {
      return void 0;
    }
    const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];
    if (!placeholder?.choice) {
      return void 0;
    }
    const id = this._placeholderDecorations.get(placeholder);
    if (!id) {
      return void 0;
    }
    const range = this._editor.getModel().getDecorationRange(id);
    if (!range) {
      return void 0;
    }
    return { range, choice: placeholder.choice };
  }
  get hasChoice() {
    let result = false;
    this._snippet.walk((marker) => {
      result = marker instanceof Choice;
      return !result;
    });
    return result;
  }
  merge(others) {
    const model = this._editor.getModel();
    this._nestingLevel *= 10;
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const nested = others.shift();
        console.assert(nested._offset !== -1);
        console.assert(!nested._placeholderDecorations);
        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;
        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {
          if (nestedPlaceholder.isFinalTabstop) {
            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;
          } else {
            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;
          }
        }
        this._snippet.replace(placeholder, nested._snippet.children);
        const id = this._placeholderDecorations.get(placeholder);
        accessor.removeDecoration(id);
        this._placeholderDecorations.delete(placeholder);
        for (const placeholder2 of nested._snippet.placeholders) {
          const placeholderOffset = nested._snippet.offset(placeholder2);
          const placeholderLen = nested._snippet.fullLen(placeholder2);
          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
          const handle = accessor.addDecoration(range, _OneSnippet._decor.inactive);
          this._placeholderDecorations.set(placeholder2, handle);
        }
      }
      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
    });
  }
};
_OneSnippet._decor = {
  active: ModelDecorationOptions.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
  inactive: ModelDecorationOptions.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
  activeFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
  inactiveFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
};
var OneSnippet = _OneSnippet;
var _defaultOptions = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetSession = SnippetSession_1 = class SnippetSession2 {
  static adjustWhitespace(model, position, adjustIndentation, snippet, filter) {
    const line = model.getLineContent(position.lineNumber);
    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);
    let snippetTextString;
    snippet.walk((marker) => {
      if (!(marker instanceof Text) || marker.parent instanceof Choice) {
        return true;
      }
      if (filter && !filter.has(marker)) {
        return true;
      }
      const lines = marker.value.split(/\r\n|\r|\n/);
      if (adjustIndentation) {
        const offset = snippet.offset(marker);
        if (offset === 0) {
          lines[0] = model.normalizeIndentation(lines[0]);
        } else {
          snippetTextString = snippetTextString ?? snippet.toString();
          const prevChar = snippetTextString.charCodeAt(offset - 1);
          if (prevChar === 10 || prevChar === 13) {
            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);
          }
        }
        for (let i2 = 1; i2 < lines.length; i2++) {
          lines[i2] = model.normalizeIndentation(lineLeadingWhitespace + lines[i2]);
        }
      }
      const newValue = lines.join(model.getEOL());
      if (newValue !== marker.value) {
        marker.parent.replace(marker, [new Text(newValue)]);
        snippetTextString = void 0;
      }
      return true;
    });
    return lineLeadingWhitespace;
  }
  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {
    if (overwriteBefore !== 0 || overwriteAfter !== 0) {
      const { positionLineNumber, positionColumn } = selection;
      const positionColumnBefore = positionColumn - overwriteBefore;
      const positionColumnAfter = positionColumn + overwriteAfter;
      const range = model.validateRange({
        startLineNumber: positionLineNumber,
        startColumn: positionColumnBefore,
        endLineNumber: positionLineNumber,
        endColumn: positionColumnAfter
      });
      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());
    }
    return selection;
  }
  static createEditsAndSnippetsFromSelections(editor2, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {
    const edits = [];
    const snippets = [];
    if (!editor2.hasModel()) {
      return { edits, snippets };
    }
    const model = editor2.getModel();
    const workspaceService = editor2.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService));
    const modelBasedVariableResolver = editor2.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model));
    const readClipboardText = () => clipboardText;
    const firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor2.getSelection(), overwriteBefore, 0));
    const firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor2.getSelection(), 0, overwriteAfter));
    const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor2.getSelection().positionLineNumber);
    const indexedSelections = editor2.getSelections().map((selection, idx) => ({ selection, idx })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    for (const { selection, idx } of indexedSelections) {
      let extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);
      let extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);
      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {
        extensionBefore = selection;
      }
      if (firstAfterText !== model.getValueInRange(extensionAfter)) {
        extensionAfter = selection;
      }
      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);
      const start = snippetSelection.getStartPosition();
      const snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), snippet);
      snippet.resolveVariables(new CompositeSnippetVariableResolver([
        modelBasedVariableResolver,
        new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor2.getOption(
          88
          /* EditorOption.multiCursorPaste */
        ) === "spread"),
        new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),
        new CommentBasedVariableResolver(model, selection, languageConfigurationService),
        new TimeBasedVariableResolver(),
        new WorkspaceBasedVariableResolver(workspaceService),
        new RandomBasedVariableResolver()
      ]));
      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
      edits[idx].identifier = { major: idx, minor: 0 };
      edits[idx]._isTracked = true;
      snippets[idx] = new OneSnippet(editor2, snippet, snippetLineLeadingWhitespace);
    }
    return { edits, snippets };
  }
  static createEditsAndSnippetsFromEdits(editor2, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {
    if (!editor2.hasModel() || snippetEdits.length === 0) {
      return { edits: [], snippets: [] };
    }
    const edits = [];
    const model = editor2.getModel();
    const parser = new SnippetParser();
    const snippet = new TextmateSnippet();
    const resolver = new CompositeSnippetVariableResolver([
      editor2.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model)),
      new ClipboardBasedVariableResolver(() => clipboardText, 0, editor2.getSelections().length, editor2.getOption(
        88
        /* EditorOption.multiCursorPaste */
      ) === "spread"),
      new SelectionBasedVariableResolver(model, editor2.getSelection(), 0, overtypingCapturer),
      new CommentBasedVariableResolver(model, editor2.getSelection(), languageConfigurationService),
      new TimeBasedVariableResolver(),
      new WorkspaceBasedVariableResolver(editor2.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService))),
      new RandomBasedVariableResolver()
    ]);
    snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
    let offset = 0;
    for (let i2 = 0; i2 < snippetEdits.length; i2++) {
      const { range, template, keepWhitespace } = snippetEdits[i2];
      if (i2 > 0) {
        const lastRange = snippetEdits[i2 - 1].range;
        const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());
        const textNode = new Text(model.getValueInRange(textRange));
        snippet.appendChild(textNode);
        offset += textNode.value.length;
      }
      const newNodes = parser.parseFragment(template, snippet);
      SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), keepWhitespace !== void 0 ? !keepWhitespace : adjustWhitespace, snippet, new Set(newNodes));
      snippet.resolveVariables(resolver);
      const snippetText = snippet.toString();
      const snippetFragmentText = snippetText.slice(offset);
      offset = snippetText.length;
      const edit = EditOperation.replace(range, snippetFragmentText);
      edit.identifier = { major: i2, minor: 0 };
      edit._isTracked = true;
      edits.push(edit);
    }
    parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);
    return {
      edits,
      snippets: [new OneSnippet(editor2, snippet, "")]
    };
  }
  constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {
    this._editor = _editor;
    this._template = _template;
    this._options = _options;
    this._languageConfigurationService = _languageConfigurationService;
    this._templateMerges = [];
    this._snippets = [];
  }
  dispose() {
    dispose(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert(editReason) {
    if (!this._editor.hasModel()) {
      return;
    }
    const { edits, snippets } = typeof this._template === "string" ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);
    this._snippets = snippets;
    this._editor.executeEdits(editReason ?? EditSources.snippet(), edits, (_undoEdits) => {
      const undoEdits = _undoEdits.filter((edit) => !!edit.identifier);
      for (let idx = 0; idx < snippets.length; idx++) {
        snippets[idx].initialize(undoEdits[idx].textChange);
      }
      if (this._snippets[0].hasPlaceholder) {
        return this._move(true);
      } else {
        return undoEdits.map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
      }
    });
    this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(template, options = _defaultOptions) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);
    const { edits, snippets } = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);
    this._editor.executeEdits("snippet", edits, (_undoEdits) => {
      const undoEdits = _undoEdits.filter((edit) => !!edit.identifier);
      for (let idx = 0; idx < snippets.length; idx++) {
        snippets[idx].initialize(undoEdits[idx].textChange);
      }
      const isTrivialSnippet = snippets[0].isTrivialSnippet;
      if (!isTrivialSnippet) {
        for (const snippet of this._snippets) {
          snippet.merge(snippets);
        }
        console.assert(snippets.length === 0);
      }
      if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {
        return this._move(void 0);
      } else {
        return undoEdits.map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
      }
    });
  }
  next() {
    const newSelections = this._move(true);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  prev() {
    const newSelections = this._move(false);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  _move(fwd) {
    const selections = [];
    for (const snippet of this._snippets) {
      const oneSelection = snippet.move(fwd);
      selections.push(...oneSelection);
    }
    return selections;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get hasChoice() {
    return this._snippets[0].hasChoice;
  }
  get activeChoice() {
    return this._snippets[0].activeChoice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder) {
      return false;
    }
    const selections = this._editor.getSelections();
    if (selections.length < this._snippets.length) {
      return false;
    }
    const allPossibleSelections = /* @__PURE__ */ new Map();
    for (const snippet of this._snippets) {
      const possibleSelections = snippet.computePossibleSelections();
      if (allPossibleSelections.size === 0) {
        for (const [index, ranges] of possibleSelections) {
          ranges.sort(Range.compareRangesUsingStarts);
          for (const selection of selections) {
            if (ranges[0].containsRange(selection)) {
              allPossibleSelections.set(index, []);
              break;
            }
          }
        }
      }
      if (allPossibleSelections.size === 0) {
        return false;
      }
      allPossibleSelections.forEach((array2, index) => {
        array2.push(...possibleSelections.get(index));
      });
    }
    selections.sort(Range.compareRangesUsingStarts);
    for (const [index, ranges] of allPossibleSelections) {
      if (ranges.length !== selections.length) {
        allPossibleSelections.delete(index);
        continue;
      }
      ranges.sort(Range.compareRangesUsingStarts);
      for (let i2 = 0; i2 < ranges.length; i2++) {
        if (!ranges[i2].containsRange(selections[i2])) {
          allPossibleSelections.delete(index);
          continue;
        }
      }
    }
    return allPossibleSelections.size > 0;
  }
};
SnippetSession = SnippetSession_1 = __decorate48([
  __param48(3, ILanguageConfigurationService)
], SnippetSession);

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js
init_observable();
var __decorate49 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SnippetController2_1;
var _defaultOptions2 = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: true,
  undoStopAfter: true,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var _a37;
var SnippetController2 = (_a37 = class {
  static get(editor2) {
    return editor2.getContribution(SnippetController2_1.ID);
  }
  constructor(_editor, _logService, _languageFeaturesService, contextKeyService, _languageConfigurationService) {
    this._editor = _editor;
    this._logService = _logService;
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this._inSnippetObservable = observableValue(this, false);
    this._snippetListener = new DisposableStore();
    this._modelVersionId = -1;
    this._inSnippet = SnippetController2_1.InSnippetMode.bindTo(contextKeyService);
    this._hasNextTabstop = SnippetController2_1.HasNextTabstop.bindTo(contextKeyService);
    this._hasPrevTabstop = SnippetController2_1.HasPrevTabstop.bindTo(contextKeyService);
  }
  dispose() {
    this._inSnippet.reset();
    this._inSnippetObservable.set(false, void 0);
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    this._session?.dispose();
    this._snippetListener.dispose();
  }
  insert(template, opts) {
    try {
      this._doInsert(template, typeof opts === "undefined" ? _defaultOptions2 : { ..._defaultOptions2, ...opts });
    } catch (e) {
      this.cancel();
      this._logService.error(e);
      this._logService.error("snippet_error");
      this._logService.error("insert_template=", template);
      this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(template, opts) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._snippetListener.clear();
    if (opts.undoStopBefore) {
      this._editor.getModel().pushStackElement();
    }
    if (this._session && typeof template !== "string") {
      this.cancel();
    }
    if (!this._session) {
      this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
      this._session = new SnippetSession(this._editor, template, opts, this._languageConfigurationService);
      this._session.insert(opts.reason);
    } else {
      assertType(typeof template === "string");
      this._session.merge(template, opts);
    }
    if (opts.undoStopAfter) {
      this._editor.getModel().pushStackElement();
    }
    if (this._session?.hasChoice) {
      const provider = {
        _debugDisplayName: "snippetChoiceCompletions",
        provideCompletionItems: (model2, position) => {
          if (!this._session || model2 !== this._editor.getModel() || !Position.equals(this._editor.getPosition(), position)) {
            return void 0;
          }
          const { activeChoice } = this._session;
          if (!activeChoice || activeChoice.choice.options.length === 0) {
            return void 0;
          }
          const word = model2.getValueInRange(activeChoice.range);
          const isAnyOfOptions = Boolean(activeChoice.choice.options.find((o) => o.value === word));
          const suggestions = [];
          for (let i2 = 0; i2 < activeChoice.choice.options.length; i2++) {
            const option2 = activeChoice.choice.options[i2];
            suggestions.push({
              kind: 13,
              label: option2.value,
              insertText: option2.value,
              sortText: "a".repeat(i2 + 1),
              range: activeChoice.range,
              filterText: isAnyOfOptions ? `${word}_${option2.value}` : void 0,
              command: { id: "jumpToNextSnippetPlaceholder", title: localize(1390, "Go to next placeholder...") }
            });
          }
          return { suggestions };
        }
      };
      const model = this._editor.getModel();
      let registration;
      let isRegistered = false;
      const disable = () => {
        registration?.dispose();
        isRegistered = false;
      };
      const enable = () => {
        if (!isRegistered) {
          registration = this._languageFeaturesService.completionProvider.register({
            language: model.getLanguageId(),
            pattern: model.uri.fsPath,
            scheme: model.uri.scheme,
            exclusive: true
          }, provider);
          this._snippetListener.add(registration);
          isRegistered = true;
        }
      };
      this._choiceCompletions = { provider, enable, disable };
    }
    this._updateState();
    this._snippetListener.add(this._editor.onDidChangeModelContent((e) => e.isFlush && this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
  }
  _updateState() {
    if (!this._session || !this._editor.hasModel()) {
      return;
    }
    if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {
      return this.cancel();
    }
    if (!this._session.hasPlaceholder) {
      return this.cancel();
    }
    if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
      this._editor.getModel().pushStackElement();
      return this.cancel();
    }
    this._inSnippet.set(true);
    this._inSnippetObservable.set(true, void 0);
    this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
    this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
    this._handleChoice();
  }
  _handleChoice() {
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const { activeChoice } = this._session;
    if (!activeChoice || !this._choiceCompletions) {
      this._choiceCompletions?.disable();
      this._currentChoice = void 0;
      return;
    }
    if (this._currentChoice !== activeChoice.choice) {
      this._currentChoice = activeChoice.choice;
      this._choiceCompletions.enable();
      queueMicrotask(() => {
        showSimpleSuggestions(this._editor, this._choiceCompletions.provider);
      });
    }
  }
  finish() {
    while (this._inSnippet.get()) {
      this.next();
    }
  }
  cancel(resetSelection = false) {
    this._inSnippet.reset();
    this._inSnippetObservable.set(false, void 0);
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    this._snippetListener.clear();
    this._currentChoice = void 0;
    this._session?.dispose();
    this._session = void 0;
    this._modelVersionId = -1;
    if (resetSelection) {
      this._editor.setSelections([this._editor.getSelection()]);
    }
  }
  prev() {
    this._session?.prev();
    this._updateState();
  }
  next() {
    this._session?.next();
    this._updateState();
  }
  isInSnippet() {
    return Boolean(this._inSnippet.get());
  }
  get isInSnippetObservable() {
    return this._inSnippetObservable;
  }
}, SnippetController2_1 = _a37, _a37.ID = "snippetController2", _a37.InSnippetMode = new RawContextKey("inSnippetMode", false, localize(1387, "Whether the editor in current in snippet mode")), _a37.HasNextTabstop = new RawContextKey("hasNextTabstop", false, localize(1388, "Whether there is a next tab stop when in snippet mode")), _a37.HasPrevTabstop = new RawContextKey("hasPrevTabstop", false, localize(1389, "Whether there is a previous tab stop when in snippet mode")), _a37);
SnippetController2 = SnippetController2_1 = __decorate49([
  __param49(1, ILogService),
  __param49(2, ILanguageFeaturesService),
  __param49(3, IContextKeyService),
  __param49(4, ILanguageConfigurationService)
], SnippetController2);
registerEditorContribution(
  SnippetController2.ID,
  SnippetController2,
  4
  /* EditorContributionInstantiation.Lazy */
);
var CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
registerEditorCommand(new CommandCtor({
  id: "jumpToNextSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
  handler: (ctrl) => ctrl.next(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
registerEditorCommand(new CommandCtor({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
  handler: (ctrl) => ctrl.prev(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 2
    /* KeyCode.Tab */
  }
}));
registerEditorCommand(new CommandCtor({
  id: "leaveSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.cancel(true),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new CommandCtor({
  id: "acceptSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.finish()
  // kbOpts: {
  // 	weight: KeybindingWeight.EditorContrib + 30,
  // 	kbExpr: EditorContextKeys.textFocus,
  // 	primary: KeyCode.Enter,
  // }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/utils.js
init_arrays();
init_observable();
init_range();

// node_modules/monaco-editor/esm/vs/editor/common/core/text/getPositionOffsetTransformerFromTextModel.js
function getPositionOffsetTransformerFromTextModel(textModel) {
  return new PositionOffsetTransformerWithTextModel(textModel);
}
var PositionOffsetTransformerWithTextModel = class extends PositionOffsetTransformerBase {
  constructor(_textModel) {
    super();
    this._textModel = _textModel;
  }
  getOffset(position) {
    return this._textModel.getOffsetAt(position);
  }
  getPosition(offset) {
    return this._textModel.getPositionAt(offset);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/utils.js
var array = [];
function getReadonlyEmptyArray() {
  return array;
}
function getEndPositionsAfterApplying(edits) {
  const newRanges = getModifiedRangesAfterApplying(edits);
  return newRanges.map((range) => range.getEndPosition());
}
function getModifiedRangesAfterApplying(edits) {
  const sortPerm = Permutation.createSortPermutation(edits, compareBy((e) => e.range, Range.compareRangesUsingStarts));
  const edit = new TextEdit(sortPerm.apply(edits));
  const sortedNewRanges = edit.getNewRanges();
  return sortPerm.inverse().apply(sortedNewRanges);
}
function removeTextReplacementCommonSuffixPrefix(edits, textModel) {
  const transformer = getPositionOffsetTransformerFromTextModel(textModel);
  const text = textModel.getValue();
  const stringReplacements = edits.map((edit) => transformer.getStringReplacement(edit));
  const minimalStringReplacements = stringReplacements.map((replacement) => replacement.removeCommonSuffixPrefix(text));
  return minimalStringReplacements.map((replacement) => transformer.getTextReplacement(replacement));
}
function convertItemsToStableObservables(items, store) {
  const result = observableValue("result", []);
  const innerObservables = [];
  store.add(autorun((reader) => {
    const itemsValue = items.read(reader);
    transaction((tx) => {
      if (itemsValue.length !== innerObservables.length) {
        innerObservables.length = itemsValue.length;
        for (let i2 = 0; i2 < innerObservables.length; i2++) {
          if (!innerObservables[i2]) {
            innerObservables[i2] = observableValue("item", itemsValue[i2]);
          }
        }
        result.set([...innerObservables], tx);
      }
      innerObservables.forEach((o, i2) => o.set(itemsValue[i2], tx));
    });
  }));
  return result;
}
var ObservableContextKeyService = class {
  constructor(_contextKeyService) {
    this._contextKeyService = _contextKeyService;
  }
  bind(key, obs) {
    return bindContextKey(key, this._contextKeyService, obs instanceof Function ? obs : (reader) => obs.read(reader));
  }
};
function wait(ms, cancellationToken) {
  return new Promise((resolve) => {
    let d = void 0;
    const handle = setTimeout(() => {
      if (d) {
        d.dispose();
      }
      resolve();
    }, ms);
    if (cancellationToken) {
      d = cancellationToken.onCancellationRequested(() => {
        clearTimeout(handle);
        if (d) {
          d.dispose();
        }
        resolve();
      });
    }
  });
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/animation.js
init_dom();
init_observable();
var AnimatedValue = class {
  constructor(startValue, endValue, durationMs, _interpolationFunction = easeOutExpo) {
    this.startValue = startValue;
    this.endValue = endValue;
    this.durationMs = durationMs;
    this._interpolationFunction = _interpolationFunction;
    this.startTimeMs = Date.now();
    if (startValue === endValue) {
      this.durationMs = 0;
    }
  }
  isFinished() {
    return Date.now() >= this.startTimeMs + this.durationMs;
  }
  getValue() {
    const timePassed = Date.now() - this.startTimeMs;
    if (timePassed >= this.durationMs) {
      return this.endValue;
    }
    const value = this._interpolationFunction(timePassed, this.startValue, this.endValue - this.startValue, this.durationMs);
    return value;
  }
};
function easeOutExpo(passedTime, start, length, totalDuration) {
  return passedTime === totalDuration ? start + length : length * (-Math.pow(2, -10 * passedTime / totalDuration) + 1) + start;
}
function easeOutCubic(passedTime, start, length, totalDuration) {
  return length * ((passedTime = passedTime / totalDuration - 1) * passedTime * passedTime + 1) + start;
}
var ObservableAnimatedValue = class {
  constructor(initialValue) {
    this._value = observableValue(this, initialValue);
  }
  getValue(reader) {
    const value = this._value.read(reader);
    if (!value.isFinished()) {
      AnimationFrameScheduler.instance.invalidateOnNextAnimationFrame(reader);
    }
    return value.getValue();
  }
};
var _AnimationFrameScheduler = class _AnimationFrameScheduler {
  constructor() {
    this._counter = observableSignal(this);
    this._isScheduled = false;
  }
  invalidateOnNextAnimationFrame(reader) {
    this._counter.read(reader);
    if (!this._isScheduled) {
      this._isScheduled = true;
      getActiveWindow().requestAnimationFrame(() => {
        this._isScheduled = false;
        this._update();
      });
    }
  }
  _update() {
    this._counter.trigger(void 0);
  }
};
_AnimationFrameScheduler.instance = new _AnimationFrameScheduler();
var AnimationFrameScheduler = _AnimationFrameScheduler;

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/computeGhostText.js
init_strings();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/ghostText.js
init_arrays();
init_strings();
init_position();
init_range();
init_assert();
var GhostText = class {
  constructor(lineNumber, parts) {
    this.lineNumber = lineNumber;
    this.parts = parts;
    assertFn(() => checkAdjacentItems(parts, (p1, p2) => p1.column <= p2.column));
  }
  equals(other) {
    return this.lineNumber === other.lineNumber && this.parts.length === other.parts.length && this.parts.every((part, index) => part.equals(other.parts[index]));
  }
  renderForScreenReader(lineText) {
    if (this.parts.length === 0) {
      return "";
    }
    const lastPart = this.parts[this.parts.length - 1];
    const cappedLineText = lineText.substr(0, lastPart.column - 1);
    const text = new TextEdit([
      ...this.parts.map((p) => new TextReplacement(Range.fromPositions(new Position(1, p.column)), p.lines.map((line) => line.line).join("\n")))
    ]).applyToString(cappedLineText);
    return text.substring(this.parts[0].column - 1);
  }
  isEmpty() {
    return this.parts.every((p) => p.lines.length === 0);
  }
  get lineCount() {
    return 1 + this.parts.reduce((r, p) => r + p.lines.length - 1, 0);
  }
};
var GhostTextPart = class {
  constructor(column, text, preview, _inlineDecorations = []) {
    this.column = column;
    this.text = text;
    this.preview = preview;
    this._inlineDecorations = _inlineDecorations;
    this.lines = splitLines(this.text).map((line, i2) => ({
      line,
      lineDecorations: LineDecoration.filter(this._inlineDecorations, i2 + 1, 1, line.length + 1)
    }));
  }
  equals(other) {
    return this.column === other.column && this.lines.length === other.lines.length && this.lines.every((line, index) => line.line === other.lines[index].line && LineDecoration.equalsArr(line.lineDecorations, other.lines[index].lineDecorations));
  }
};
var GhostTextReplacement = class {
  constructor(lineNumber, columnRange, text, additionalReservedLineCount = 0) {
    this.lineNumber = lineNumber;
    this.columnRange = columnRange;
    this.text = text;
    this.additionalReservedLineCount = additionalReservedLineCount;
    this.parts = [
      new GhostTextPart(this.columnRange.endColumnExclusive, this.text, false)
    ];
    this.newLines = splitLines(this.text);
  }
  renderForScreenReader(_lineText) {
    return this.newLines.join("\n");
  }
  get lineCount() {
    return this.newLines.length;
  }
  isEmpty() {
    return this.parts.every((p) => p.lines.length === 0);
  }
  equals(other) {
    return this.lineNumber === other.lineNumber && this.columnRange.equals(other.columnRange) && this.newLines.length === other.newLines.length && this.newLines.every((line, index) => line === other.newLines[index]) && this.additionalReservedLineCount === other.additionalReservedLineCount;
  }
};
function ghostTextsOrReplacementsEqual(a, b) {
  return equals(a, b, ghostTextOrReplacementEquals);
}
function ghostTextOrReplacementEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  if (a instanceof GhostText && b instanceof GhostText) {
    return a.equals(b);
  }
  if (a instanceof GhostTextReplacement && b instanceof GhostTextReplacement) {
    return a.equals(b);
  }
  return false;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/singleTextEditHelpers.js
init_strings();
init_range();
init_textLength();
function singleTextRemoveCommonPrefix(edit, model, validModelRange) {
  const modelRange = validModelRange ? edit.range.intersectRanges(validModelRange) : edit.range;
  if (!modelRange) {
    return edit;
  }
  const normalizedText = edit.text.replaceAll("\r\n", "\n");
  const valueToReplace = model.getValueInRange(
    modelRange,
    1
    /* EndOfLinePreference.LF */
  );
  const commonPrefixLen = commonPrefixLength(valueToReplace, normalizedText);
  const start = TextLength.ofText(valueToReplace.substring(0, commonPrefixLen)).addToPosition(edit.range.getStartPosition());
  const text = normalizedText.substring(commonPrefixLen);
  const range = Range.fromPositions(start, edit.range.getEndPosition());
  return new TextReplacement(range, text);
}
function singleTextEditAugments(edit, base) {
  return edit.text.startsWith(base.text) && rangeExtends(edit.range, base.range);
}
function rangeExtends(extendingRange, rangeToExtend) {
  return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition()) && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/computeGhostText.js
function computeGhostText(edit, model, mode, cursorPosition, previewSuffixLength = 0) {
  let e = singleTextRemoveCommonPrefix(edit, model);
  if (e.range.endLineNumber !== e.range.startLineNumber) {
    return void 0;
  }
  const sourceLine = model.getLineContent(e.range.startLineNumber);
  const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;
  const suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;
  if (suggestionTouchesIndentation) {
    const suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;
    const replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);
    const [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];
    const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column ? startPosition.delta(0, replacedIndentation.length) : endPosition;
    const rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);
    const suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation) ? e.text.substring(replacedIndentation.length) : e.text.substring(suggestionAddedIndentationLength);
    e = new TextReplacement(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);
  }
  const valueToBeReplaced = model.getValueInRange(e.range);
  const changes = cachingDiff(valueToBeReplaced, e.text);
  if (!changes) {
    return void 0;
  }
  const lineNumber = e.range.startLineNumber;
  const parts = new Array();
  if (mode === "prefix") {
    const filteredChanges = changes.filter((c) => c.originalLength === 0);
    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {
      return void 0;
    }
  }
  const previewStartInCompletionText = e.text.length - previewSuffixLength;
  for (const c of changes) {
    const insertColumn = e.range.startColumn + c.originalStart + c.originalLength;
    if (mode === "subwordSmart" && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {
      return void 0;
    }
    if (c.originalLength > 0) {
      return void 0;
    }
    if (c.modifiedLength === 0) {
      continue;
    }
    const modifiedEnd = c.modifiedStart + c.modifiedLength;
    const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));
    const nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);
    const italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));
    if (nonPreviewText.length > 0) {
      parts.push(new GhostTextPart(insertColumn, nonPreviewText, false));
    }
    if (italicText.length > 0) {
      parts.push(new GhostTextPart(insertColumn, italicText, true));
    }
  }
  return new GhostText(lineNumber, parts);
}
var lastRequest = void 0;
function cachingDiff(originalValue, newValue) {
  if (lastRequest?.originalValue === originalValue && lastRequest?.newValue === newValue) {
    return lastRequest?.changes;
  } else {
    let changes = smartDiff(originalValue, newValue, true);
    if (changes) {
      const deletedChars = deletedCharacters(changes);
      if (deletedChars > 0) {
        const newChanges = smartDiff(originalValue, newValue, false);
        if (newChanges && deletedCharacters(newChanges) < deletedChars) {
          changes = newChanges;
        }
      }
    }
    lastRequest = {
      originalValue,
      newValue,
      changes
    };
    return changes;
  }
}
function deletedCharacters(changes) {
  let sum2 = 0;
  for (const c of changes) {
    sum2 += c.originalLength;
  }
  return sum2;
}
function smartDiff(originalValue, newValue, smartBracketMatching) {
  if (originalValue.length > 5e3 || newValue.length > 5e3) {
    return void 0;
  }
  function getMaxCharCode(val) {
    let maxCharCode2 = 0;
    for (let i2 = 0, len = val.length; i2 < len; i2++) {
      const charCode = val.charCodeAt(i2);
      if (charCode > maxCharCode2) {
        maxCharCode2 = charCode;
      }
    }
    return maxCharCode2;
  }
  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));
  function getUniqueCharCode(id) {
    if (id < 0) {
      throw new Error("unexpected");
    }
    return maxCharCode + id + 1;
  }
  function getElements(source) {
    let level = 0;
    let group = 0;
    const characters = new Int32Array(source.length);
    for (let i2 = 0, len = source.length; i2 < len; i2++) {
      if (smartBracketMatching && source[i2] === "(") {
        const id = group * 100 + level;
        characters[i2] = getUniqueCharCode(2 * id);
        level++;
      } else if (smartBracketMatching && source[i2] === ")") {
        level = Math.max(level - 1, 0);
        const id = group * 100 + level;
        characters[i2] = getUniqueCharCode(2 * id + 1);
        if (level === 0) {
          group++;
        }
      } else {
        characters[i2] = source.charCodeAt(i2);
      }
    }
    return characters;
  }
  const elements1 = getElements(originalValue);
  const elements2 = getElements(newValue);
  return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsSource.js
init_arrays();
init_arraysFind();
init_cancellation();
init_equals();
init_lifecycle();
init_observable();

// node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/reducer.js
init_deps();
init_transaction();
init_debugName();
init_derivedImpl();
init_debugLocation();
function observableReducerSettable(owner, options) {
  let prevValue = void 0;
  let hasValue = false;
  const d = new DerivedWithSetter(new DebugNameData(owner, void 0, options.update), (reader, changeSummary) => {
    if (!hasValue) {
      prevValue = options.initial instanceof Function ? options.initial() : options.initial;
      hasValue = true;
    }
    const newValue = options.update(reader, prevValue, changeSummary);
    prevValue = newValue;
    return newValue;
  }, options.changeTracker, () => {
    if (hasValue) {
      options.disposeFinal?.(prevValue);
      hasValue = false;
    }
  }, options.equalityComparer ?? strictEquals, (value, tx, change) => {
    if (!hasValue) {
      throw new BugIndicatingError("Can only set when there is a listener! This is to prevent leaks.");
    }
    subtransaction(tx, (tx2) => {
      prevValue = value;
      d.setValue(value, tx2, change);
    });
  }, DebugLocation.ofCaller());
  return d;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsSource.js
init_types();
init_configuration();

// node_modules/monaco-editor/esm/vs/platform/dataChannel/browser/forwardingTelemetryService.js
init_telemetry();
var __decorate50 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InterceptingTelemetryService = class {
  constructor(_baseService, _intercept) {
    this._baseService = _baseService;
    this._intercept = _intercept;
  }
  publicLog2(eventName, data) {
    this._intercept(eventName, data);
    this._baseService.publicLog2(eventName, data);
  }
};
var DataChannelForwardingTelemetryService = class DataChannelForwardingTelemetryService2 extends InterceptingTelemetryService {
  constructor(telemetryService, dataChannelService) {
    super(telemetryService, (eventName, data) => {
      let forward = true;
      if (data && shouldForwardToChannel in data) {
        forward = Boolean(data[shouldForwardToChannel]);
      }
      if (forward) {
        dataChannelService.getDataChannel("editTelemetry").sendData({ eventName, data });
      }
    });
  }
};
DataChannelForwardingTelemetryService = __decorate50([
  __param50(0, ITelemetryService),
  __param50(1, IDataChannelService)
], DataChannelForwardingTelemetryService);
var shouldForwardToChannel = Symbol("shouldForwardToChannel");
function forwardToChannelIf(value) {
  return {
    // This will not be sent via telemetry, it is just a marker
    [shouldForwardToChannel]: value
  };
}
function isCopilotLikeExtension(extensionId) {
  if (!extensionId) {
    return false;
  }
  const extIdLowerCase = extensionId.toLowerCase();
  return extIdLowerCase === "github.copilot" || extIdLowerCase === "github.copilot-chat";
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsSource.js
init_instantiation();
init_log();
init_languages();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/common/model/textModelStringEdit.js
init_offsetRange();
function offsetEditFromContentChanges(contentChanges) {
  const editsArr = contentChanges.map((c) => new StringReplacement(OffsetRange.ofStartAndLength(c.rangeOffset, c.rangeLength), c.text));
  editsArr.reverse();
  const edits = new StringEdit(editsArr);
  return edits;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/telemetry.js
function sendInlineCompletionsEndOfLifeTelemetry(dataChannel, endOfLifeSummary) {
  dataChannel.publicLog2("inlineCompletion.endOfLife", endOfLifeSummary);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineSuggestionItem.js
init_errors();
init_filters();
init_observable();
init_strings();
init_offsetRange();
init_range();
init_textLength();
init_languages();
var InlineSuggestionItem;
(function(InlineSuggestionItem2) {
  function create(data, textModel) {
    if (!data.isInlineEdit) {
      return InlineCompletionItem.create(data, textModel);
    } else {
      return InlineEditItem.create(data, textModel);
    }
  }
  InlineSuggestionItem2.create = create;
})(InlineSuggestionItem || (InlineSuggestionItem = {}));
var InlineSuggestionItemBase = class {
  constructor(_data, identity, displayLocation) {
    this._data = _data;
    this.identity = identity;
    this.displayLocation = displayLocation;
  }
  /**
   * A reference to the original inline completion list this inline completion has been constructed from.
   * Used for event data to ensure referential equality.
  */
  get source() {
    return this._data.source;
  }
  get isFromExplicitRequest() {
    return this._data.context.triggerKind === InlineCompletionTriggerKind.Explicit;
  }
  get forwardStable() {
    return this.source.inlineSuggestions.enableForwardStability ?? false;
  }
  get editRange() {
    return this.getSingleTextEdit().range;
  }
  get targetRange() {
    return this.displayLocation?.range ?? this.editRange;
  }
  get insertText() {
    return this.getSingleTextEdit().text;
  }
  get semanticId() {
    return this.hash;
  }
  get action() {
    return this._sourceInlineCompletion.action;
  }
  get command() {
    return this._sourceInlineCompletion.command;
  }
  get warning() {
    return this._sourceInlineCompletion.warning;
  }
  get showInlineEditMenu() {
    return !!this._sourceInlineCompletion.showInlineEditMenu;
  }
  get hash() {
    return JSON.stringify([
      this.getSingleTextEdit().text,
      this.getSingleTextEdit().range.getStartPosition().toString()
    ]);
  }
  get requestUuid() {
    return this._data.context.requestUuid;
  }
  get partialAccepts() {
    return this._data.partialAccepts;
  }
  /**
   * A reference to the original inline completion this inline completion has been constructed from.
   * Used for event data to ensure referential equality.
  */
  get _sourceInlineCompletion() {
    return this._data.sourceInlineCompletion;
  }
  addRef() {
    this.identity.addRef();
    this.source.addRef();
  }
  removeRef() {
    this.identity.removeRef();
    this.source.removeRef();
  }
  reportInlineEditShown(commandService, viewKind, viewData) {
    this._data.reportInlineEditShown(commandService, this.insertText, viewKind, viewData);
  }
  reportPartialAccept(acceptedCharacters, info, partialAcceptance) {
    this._data.reportPartialAccept(acceptedCharacters, info, partialAcceptance);
  }
  reportEndOfLife(reason) {
    this._data.reportEndOfLife(reason);
  }
  setEndOfLifeReason(reason) {
    this._data.setEndOfLifeReason(reason);
  }
  reportInlineEditError(reason) {
    this._data.reportInlineEditError(reason);
  }
  setIsPreceeded(item) {
    this._data.setIsPreceeded(item.partialAccepts);
  }
  setNotShownReasonIfNotSet(reason) {
    this._data.setNotShownReason(reason);
  }
  /**
   * Avoid using this method. Instead introduce getters for the needed properties.
  */
  getSourceCompletion() {
    return this._sourceInlineCompletion;
  }
};
var _InlineSuggestionIdentity = class _InlineSuggestionIdentity {
  constructor() {
    this._onDispose = observableSignal(this);
    this._refCount = 1;
    this.id = "InlineCompletionIdentity" + _InlineSuggestionIdentity.idCounter++;
  }
  addRef() {
    this._refCount++;
  }
  removeRef() {
    this._refCount--;
    if (this._refCount === 0) {
      this._onDispose.trigger(void 0);
    }
  }
};
_InlineSuggestionIdentity.idCounter = 0;
var InlineSuggestionIdentity = _InlineSuggestionIdentity;
var InlineSuggestDisplayLocation = class _InlineSuggestDisplayLocation {
  static create(displayLocation) {
    return new _InlineSuggestDisplayLocation(displayLocation.range, displayLocation.label, displayLocation.kind);
  }
  constructor(range, label, kind) {
    this.range = range;
    this.label = label;
    this.kind = kind;
  }
  withEdit(edit, positionOffsetTransformer) {
    const offsetRange = new OffsetRange(positionOffsetTransformer.getOffset(this.range.getStartPosition()), positionOffsetTransformer.getOffset(this.range.getEndPosition()));
    const newOffsetRange = applyEditsToRanges([offsetRange], edit)[0];
    if (!newOffsetRange) {
      return void 0;
    }
    const newRange = positionOffsetTransformer.getRange(newOffsetRange);
    return new _InlineSuggestDisplayLocation(newRange, this.label, this.kind);
  }
};
var InlineCompletionItem = class _InlineCompletionItem extends InlineSuggestionItemBase {
  static create(data, textModel) {
    const identity = new InlineSuggestionIdentity();
    const transformer = getPositionOffsetTransformerFromTextModel(textModel);
    const insertText = data.insertText.replace(/\r\n|\r|\n/g, textModel.getEOL());
    const edit = reshapeInlineCompletion(new StringReplacement(transformer.getOffsetRange(data.range), insertText), textModel);
    const trimmedEdit = edit.removeCommonSuffixAndPrefix(textModel.getValue());
    const textEdit = transformer.getTextReplacement(edit);
    const displayLocation = data.displayLocation ? InlineSuggestDisplayLocation.create(data.displayLocation) : void 0;
    return new _InlineCompletionItem(edit, trimmedEdit, textEdit, textEdit.range, data.snippetInfo, data.additionalTextEdits, data, identity, displayLocation);
  }
  constructor(_edit, _trimmedEdit, _textEdit, _originalRange, snippetInfo, additionalTextEdits, data, identity, displayLocation) {
    super(data, identity, displayLocation);
    this._edit = _edit;
    this._trimmedEdit = _trimmedEdit;
    this._textEdit = _textEdit;
    this._originalRange = _originalRange;
    this.snippetInfo = snippetInfo;
    this.additionalTextEdits = additionalTextEdits;
    this.isInlineEdit = false;
  }
  get hash() {
    return JSON.stringify(this._trimmedEdit.toJson());
  }
  getSingleTextEdit() {
    return this._textEdit;
  }
  withIdentity(identity) {
    return new _InlineCompletionItem(this._edit, this._trimmedEdit, this._textEdit, this._originalRange, this.snippetInfo, this.additionalTextEdits, this._data, identity, this.displayLocation);
  }
  withEdit(textModelEdit, textModel) {
    const newEditRange = applyEditsToRanges([this._edit.replaceRange], textModelEdit);
    if (newEditRange.length === 0) {
      return void 0;
    }
    const newEdit = new StringReplacement(newEditRange[0], this._textEdit.text);
    const positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);
    const newTextEdit = positionOffsetTransformer.getTextReplacement(newEdit);
    let newDisplayLocation = this.displayLocation;
    if (newDisplayLocation) {
      newDisplayLocation = newDisplayLocation.withEdit(textModelEdit, positionOffsetTransformer);
      if (!newDisplayLocation) {
        return void 0;
      }
    }
    const trimmedEdit = newEdit.removeCommonSuffixAndPrefix(textModel.getValue());
    return new _InlineCompletionItem(newEdit, trimmedEdit, newTextEdit, this._originalRange, this.snippetInfo, this.additionalTextEdits, this._data, this.identity, newDisplayLocation);
  }
  canBeReused(model, position) {
    const updatedRange = this._textEdit.range;
    const result = !!updatedRange && updatedRange.containsPosition(position) && this.isVisible(model, position) && TextLength.ofRange(updatedRange).isGreaterThanOrEqualTo(TextLength.ofRange(this._originalRange));
    return result;
  }
  isVisible(model, cursorPosition) {
    const singleTextEdit = this.getSingleTextEdit();
    return inlineCompletionIsVisible(singleTextEdit, this._originalRange, model, cursorPosition);
  }
};
function inlineCompletionIsVisible(singleTextEdit, originalRange, model, cursorPosition) {
  const minimizedReplacement = singleTextRemoveCommonPrefix(singleTextEdit, model);
  const editRange = singleTextEdit.range;
  if (!editRange || originalRange && !originalRange.getStartPosition().equals(editRange.getStartPosition()) || cursorPosition.lineNumber !== minimizedReplacement.range.startLineNumber || minimizedReplacement.isEmpty) {
    return false;
  }
  const originalValue = model.getValueInRange(
    minimizedReplacement.range,
    1
    /* EndOfLinePreference.LF */
  );
  const filterText = minimizedReplacement.text;
  const cursorPosIndex = Math.max(0, cursorPosition.column - minimizedReplacement.range.startColumn);
  let filterTextBefore = filterText.substring(0, cursorPosIndex);
  let filterTextAfter = filterText.substring(cursorPosIndex);
  let originalValueBefore = originalValue.substring(0, cursorPosIndex);
  let originalValueAfter = originalValue.substring(cursorPosIndex);
  const originalValueIndent = model.getLineIndentColumn(minimizedReplacement.range.startLineNumber);
  if (minimizedReplacement.range.startColumn <= originalValueIndent) {
    originalValueBefore = originalValueBefore.trimStart();
    if (originalValueBefore.length === 0) {
      originalValueAfter = originalValueAfter.trimStart();
    }
    filterTextBefore = filterTextBefore.trimStart();
    if (filterTextBefore.length === 0) {
      filterTextAfter = filterTextAfter.trimStart();
    }
  }
  return filterTextBefore.startsWith(originalValueBefore) && !!matchesSubString(originalValueAfter, filterTextAfter);
}
var InlineEditItem = class _InlineEditItem extends InlineSuggestionItemBase {
  static create(data, textModel) {
    const offsetEdit = getStringEdit(textModel, data.range, data.insertText);
    const text = new TextModelText(textModel);
    const textEdit = TextEdit.fromStringEdit(offsetEdit, text);
    const singleTextEdit = textEdit.toReplacement(text);
    const identity = new InlineSuggestionIdentity();
    const edits = offsetEdit.replacements.map((edit) => {
      const replacedRange = Range.fromPositions(textModel.getPositionAt(edit.replaceRange.start), textModel.getPositionAt(edit.replaceRange.endExclusive));
      const replacedText = textModel.getValueInRange(replacedRange);
      return SingleUpdatedNextEdit.create(edit, replacedText);
    });
    const displayLocation = data.displayLocation ? InlineSuggestDisplayLocation.create(data.displayLocation) : void 0;
    return new _InlineEditItem(offsetEdit, singleTextEdit, data, identity, edits, displayLocation, false, textModel.getVersionId());
  }
  constructor(_edit, _textEdit, data, identity, _edits, displayLocation, _lastChangePartOfInlineEdit = false, _inlineEditModelVersion) {
    super(data, identity, displayLocation);
    this._edit = _edit;
    this._textEdit = _textEdit;
    this._edits = _edits;
    this._lastChangePartOfInlineEdit = _lastChangePartOfInlineEdit;
    this._inlineEditModelVersion = _inlineEditModelVersion;
    this.snippetInfo = void 0;
    this.additionalTextEdits = [];
    this.isInlineEdit = true;
  }
  get updatedEditModelVersion() {
    return this._inlineEditModelVersion;
  }
  get updatedEdit() {
    return this._edit;
  }
  getSingleTextEdit() {
    return this._textEdit;
  }
  withIdentity(identity) {
    return new _InlineEditItem(this._edit, this._textEdit, this._data, identity, this._edits, this.displayLocation, this._lastChangePartOfInlineEdit, this._inlineEditModelVersion);
  }
  canBeReused(model, position) {
    return this._lastChangePartOfInlineEdit && this.updatedEditModelVersion === model.getVersionId();
  }
  withEdit(textModelChanges, textModel) {
    const edit = this._applyTextModelChanges(textModelChanges, this._edits, textModel);
    return edit;
  }
  _applyTextModelChanges(textModelChanges, edits, textModel) {
    edits = edits.map((innerEdit) => innerEdit.applyTextModelChanges(textModelChanges));
    if (edits.some((edit) => edit.edit === void 0)) {
      return void 0;
    }
    const newTextModelVersion = textModel.getVersionId();
    let inlineEditModelVersion = this._inlineEditModelVersion;
    const lastChangePartOfInlineEdit = edits.some((edit) => edit.lastChangeUpdatedEdit);
    if (lastChangePartOfInlineEdit) {
      inlineEditModelVersion = newTextModelVersion ?? -1;
    }
    if (newTextModelVersion === null || inlineEditModelVersion + 20 < newTextModelVersion) {
      return void 0;
    }
    edits = edits.filter((innerEdit) => !innerEdit.edit.isEmpty);
    if (edits.length === 0) {
      return void 0;
    }
    const newEdit = new StringEdit(edits.map((edit) => edit.edit));
    const positionOffsetTransformer = getPositionOffsetTransformerFromTextModel(textModel);
    const newTextEdit = positionOffsetTransformer.getTextEdit(newEdit).toReplacement(new TextModelText(textModel));
    let newDisplayLocation = this.displayLocation;
    if (newDisplayLocation) {
      newDisplayLocation = newDisplayLocation.withEdit(textModelChanges, positionOffsetTransformer);
      if (!newDisplayLocation) {
        return void 0;
      }
    }
    return new _InlineEditItem(newEdit, newTextEdit, this._data, this.identity, edits, newDisplayLocation, lastChangePartOfInlineEdit, inlineEditModelVersion);
  }
};
function getStringEdit(textModel, editRange, replaceText) {
  const eol = textModel.getEOL();
  const editOriginalText = textModel.getValueInRange(editRange);
  const editReplaceText = replaceText.replace(/\r\n|\r|\n/g, eol);
  const diffAlgorithm = linesDiffComputers.getDefault();
  const lineDiffs = diffAlgorithm.computeDiff(splitLines(editOriginalText), splitLines(editReplaceText), {
    ignoreTrimWhitespace: false,
    computeMoves: false,
    extendToSubwords: true,
    maxComputationTimeMs: 500
  });
  const innerChanges = lineDiffs.changes.flatMap((c) => c.innerChanges ?? []);
  function addRangeToPos(pos, range) {
    const start = TextLength.fromPosition(range.getStartPosition());
    return TextLength.ofRange(range).createRange(start.addToPosition(pos));
  }
  const modifiedText = new StringText(editReplaceText);
  const offsetEdit = new StringEdit(innerChanges.map((c) => {
    const rangeInModel = addRangeToPos(editRange.getStartPosition(), c.originalRange);
    const originalRange = getPositionOffsetTransformerFromTextModel(textModel).getOffsetRange(rangeInModel);
    const replaceText2 = modifiedText.getValueOfRange(c.modifiedRange);
    const edit = new StringReplacement(originalRange, replaceText2);
    const originalText = textModel.getValueInRange(rangeInModel);
    return reshapeInlineEdit(edit, originalText, innerChanges.length, textModel);
  }));
  return offsetEdit;
}
var SingleUpdatedNextEdit = class _SingleUpdatedNextEdit {
  static create(edit, replacedText) {
    const prefixLength = commonPrefixLength(edit.newText, replacedText);
    const suffixLength = commonSuffixLength(edit.newText, replacedText);
    const trimmedNewText = edit.newText.substring(prefixLength, edit.newText.length - suffixLength);
    return new _SingleUpdatedNextEdit(edit, trimmedNewText, prefixLength, suffixLength);
  }
  get edit() {
    return this._edit;
  }
  get lastChangeUpdatedEdit() {
    return this._lastChangeUpdatedEdit;
  }
  constructor(_edit, _trimmedNewText, _prefixLength, _suffixLength, _lastChangeUpdatedEdit = false) {
    this._edit = _edit;
    this._trimmedNewText = _trimmedNewText;
    this._prefixLength = _prefixLength;
    this._suffixLength = _suffixLength;
    this._lastChangeUpdatedEdit = _lastChangeUpdatedEdit;
  }
  applyTextModelChanges(textModelChanges) {
    const c = this._clone();
    c._applyTextModelChanges(textModelChanges);
    return c;
  }
  _clone() {
    return new _SingleUpdatedNextEdit(this._edit, this._trimmedNewText, this._prefixLength, this._suffixLength, this._lastChangeUpdatedEdit);
  }
  _applyTextModelChanges(textModelChanges) {
    this._lastChangeUpdatedEdit = false;
    if (!this._edit) {
      throw new BugIndicatingError("UpdatedInnerEdits: No edit to apply changes to");
    }
    const result = this._applyChanges(this._edit, textModelChanges);
    if (!result) {
      this._edit = void 0;
      return;
    }
    this._edit = result.edit;
    this._lastChangeUpdatedEdit = result.editHasChanged;
  }
  _applyChanges(edit, textModelChanges) {
    let editStart = edit.replaceRange.start;
    let editEnd = edit.replaceRange.endExclusive;
    let editReplaceText = edit.newText;
    let editHasChanged = false;
    const shouldPreserveEditShape = this._prefixLength > 0 || this._suffixLength > 0;
    for (let i2 = textModelChanges.replacements.length - 1; i2 >= 0; i2--) {
      const change = textModelChanges.replacements[i2];
      const isInsertion = change.newText.length > 0 && change.replaceRange.isEmpty;
      if (isInsertion && !shouldPreserveEditShape && change.replaceRange.start === editStart && editReplaceText.startsWith(change.newText)) {
        editStart += change.newText.length;
        editReplaceText = editReplaceText.substring(change.newText.length);
        editEnd = Math.max(editStart, editEnd);
        editHasChanged = true;
        continue;
      }
      if (isInsertion && shouldPreserveEditShape && change.replaceRange.start === editStart + this._prefixLength && this._trimmedNewText.startsWith(change.newText)) {
        editEnd += change.newText.length;
        editHasChanged = true;
        this._prefixLength += change.newText.length;
        this._trimmedNewText = this._trimmedNewText.substring(change.newText.length);
        continue;
      }
      const isDeletion2 = change.newText.length === 0 && change.replaceRange.length > 0;
      if (isDeletion2 && change.replaceRange.start >= editStart + this._prefixLength && change.replaceRange.endExclusive <= editEnd - this._suffixLength) {
        editEnd -= change.replaceRange.length;
        editHasChanged = true;
        continue;
      }
      if (change.equals(edit)) {
        editHasChanged = true;
        editStart = change.replaceRange.endExclusive;
        editReplaceText = "";
        continue;
      }
      if (change.replaceRange.start > editEnd) {
        continue;
      }
      if (change.replaceRange.endExclusive < editStart) {
        editStart += change.newText.length - change.replaceRange.length;
        editEnd += change.newText.length - change.replaceRange.length;
        continue;
      }
      return void 0;
    }
    if (this._trimmedNewText.length === 0 && editStart + this._prefixLength === editEnd - this._suffixLength) {
      return { edit: new StringReplacement(new OffsetRange(editStart + this._prefixLength, editStart + this._prefixLength), ""), editHasChanged: true };
    }
    return { edit: new StringReplacement(new OffsetRange(editStart, editEnd), editReplaceText), editHasChanged };
  }
};
function reshapeInlineCompletion(edit, textModel) {
  const eol = textModel.getEOL();
  if (edit.replaceRange.isEmpty && edit.newText.includes(eol)) {
    edit = reshapeMultiLineInsertion(edit, textModel);
  }
  return edit;
}
function reshapeInlineEdit(edit, originalText, totalInnerEdits, textModel) {
  const eol = textModel.getEOL();
  if (edit.newText.endsWith(eol) && originalText.endsWith(eol)) {
    edit = new StringReplacement(edit.replaceRange.deltaEnd(-eol.length), edit.newText.slice(0, -eol.length));
  }
  if (totalInnerEdits === 1 && edit.replaceRange.isEmpty && edit.newText.includes(eol)) {
    const startPosition = textModel.getPositionAt(edit.replaceRange.start);
    const hasTextOnInsertionLine = textModel.getLineLength(startPosition.lineNumber) !== 0;
    if (hasTextOnInsertionLine) {
      edit = reshapeMultiLineInsertion(edit, textModel);
    }
  }
  if (totalInnerEdits === 1) {
    const prefixLength = commonPrefixLength(originalText, edit.newText);
    const suffixLength = commonSuffixLength(originalText.slice(prefixLength), edit.newText.slice(prefixLength));
    if (prefixLength + suffixLength === originalText.length) {
      return new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), edit.newText.substring(prefixLength, edit.newText.length - suffixLength));
    }
    if (prefixLength + suffixLength === edit.newText.length) {
      return new StringReplacement(edit.replaceRange.deltaStart(prefixLength).deltaEnd(-suffixLength), "");
    }
  }
  return edit;
}
function reshapeMultiLineInsertion(edit, textModel) {
  if (!edit.replaceRange.isEmpty) {
    throw new BugIndicatingError("Unexpected original range");
  }
  if (edit.replaceRange.start === 0) {
    return edit;
  }
  const eol = textModel.getEOL();
  const startPosition = textModel.getPositionAt(edit.replaceRange.start);
  const startColumn = startPosition.column;
  const startLineNumber = startPosition.lineNumber;
  if (startColumn === 1 && startLineNumber > 1 && edit.newText.endsWith(eol) && !edit.newText.startsWith(eol)) {
    return new StringReplacement(edit.replaceRange.delta(-1), eol + edit.newText.slice(0, -eol.length));
  }
  return edit;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/provideInlineCompletions.js
init_assert();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_uuid();
init_offsetRange();
init_range();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js
init_brackets();
init_length();
init_parser();
init_smallImmutableSet();
init_tokenizer();
function fixBracketsInLine(tokens, languageConfigurationService) {
  const denseKeyProvider = new DenseKeyProvider();
  const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));
  const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);
  const node = parseDocument(tokenizer, [], void 0, true);
  let str = "";
  const line = tokens.getLineContent();
  function processNode(node2, offset) {
    if (node2.kind === 2) {
      processNode(node2.openingBracket, offset);
      offset = lengthAdd(offset, node2.openingBracket.length);
      if (node2.child) {
        processNode(node2.child, offset);
        offset = lengthAdd(offset, node2.child.length);
      }
      if (node2.closingBracket) {
        processNode(node2.closingBracket, offset);
        offset = lengthAdd(offset, node2.closingBracket.length);
      } else {
        const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node2.openingBracket.languageId);
        const closingTokenText = singleLangBracketTokens.findClosingTokenText(node2.openingBracket.bracketIds);
        str += closingTokenText;
      }
    } else if (node2.kind === 3) {
    } else if (node2.kind === 0 || node2.kind === 1) {
      str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node2.length)));
    } else if (node2.kind === 4) {
      for (const child of node2.children) {
        processNode(child, offset);
        offset = lengthAdd(offset, child.length);
      }
    }
  }
  processNode(node, lengthZero);
  return str;
}
var StaticTokenizerSource = class {
  constructor(lines) {
    this.lines = lines;
    this.tokenization = {
      getLineTokens: (lineNumber) => {
        return this.lines[lineNumber - 1];
      }
    };
  }
  getLineCount() {
    return this.lines.length;
  }
  getLineLength(lineNumber) {
    return this.lines[lineNumber - 1].getLineContent().length;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/provideInlineCompletions.js
init_collections();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/graph.js
var DirectedGraph = class _DirectedGraph {
  constructor() {
    this._nodes = /* @__PURE__ */ new Set();
    this._outgoingEdges = /* @__PURE__ */ new Map();
  }
  static from(nodes, getOutgoing) {
    const graph = new _DirectedGraph();
    for (const node of nodes) {
      graph._nodes.add(node);
    }
    for (const node of nodes) {
      const outgoing = getOutgoing(node);
      if (outgoing.length > 0) {
        const outgoingSet = /* @__PURE__ */ new Set();
        for (const target of outgoing) {
          outgoingSet.add(target);
        }
        graph._outgoingEdges.set(node, outgoingSet);
      }
    }
    return graph;
  }
  /**
   * After this, the graph is guaranteed to have no cycles.
   */
  removeCycles() {
    const foundCycles = [];
    const visited = /* @__PURE__ */ new Set();
    const recursionStack = /* @__PURE__ */ new Set();
    const toRemove = [];
    const dfs = (node) => {
      visited.add(node);
      recursionStack.add(node);
      const outgoing = this._outgoingEdges.get(node);
      if (outgoing) {
        for (const neighbor of outgoing) {
          if (!visited.has(neighbor)) {
            dfs(neighbor);
          } else if (recursionStack.has(neighbor)) {
            foundCycles.push(neighbor);
            toRemove.push({ from: node, to: neighbor });
          }
        }
      }
      recursionStack.delete(node);
    };
    for (const node of this._nodes) {
      if (!visited.has(node)) {
        dfs(node);
      }
    }
    for (const { from, to } of toRemove) {
      const outgoingSet = this._outgoingEdges.get(from);
      if (outgoingSet) {
        outgoingSet.delete(to);
      }
    }
    return { foundCycles };
  }
  getOutgoing(node) {
    const outgoing = this._outgoingEdges.get(node);
    return outgoing ? Array.from(outgoing) : [];
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/provideInlineCompletions.js
init_cache();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViewInterface.js
var InlineEditTabAction;
(function(InlineEditTabAction2) {
  InlineEditTabAction2["Jump"] = "jump";
  InlineEditTabAction2["Accept"] = "accept";
  InlineEditTabAction2["Inactive"] = "inactive";
})(InlineEditTabAction || (InlineEditTabAction = {}));
var InlineCompletionViewKind;
(function(InlineCompletionViewKind2) {
  InlineCompletionViewKind2["GhostText"] = "ghostText";
  InlineCompletionViewKind2["Custom"] = "custom";
  InlineCompletionViewKind2["SideBySide"] = "sideBySide";
  InlineCompletionViewKind2["Deletion"] = "deletion";
  InlineCompletionViewKind2["InsertionInline"] = "insertionInline";
  InlineCompletionViewKind2["InsertionMultiLine"] = "insertionMultiLine";
  InlineCompletionViewKind2["WordReplacements"] = "wordReplacements";
  InlineCompletionViewKind2["LineReplacement"] = "lineReplacement";
  InlineCompletionViewKind2["Collapsed"] = "collapsed";
})(InlineCompletionViewKind || (InlineCompletionViewKind = {}));

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/provideInlineCompletions.js
init_types();
init_textModelEditSource();
function provideInlineCompletions(providers, position, model, context, requestInfo, languageConfigurationService) {
  const requestUuid = prefixedUuid("icr");
  const cancellationTokenSource = new CancellationTokenSource();
  let cancelReason = void 0;
  const contextWithUuid = { ...context, requestUuid };
  const defaultReplaceRange = getDefaultRange(position, model);
  const providersByGroupId = groupByMap(providers, (p) => p.groupId);
  const yieldsToGraph = DirectedGraph.from(providers, (p) => {
    return p.yieldsToGroupIds?.flatMap((groupId) => providersByGroupId.get(groupId) ?? []) ?? [];
  });
  const { foundCycles } = yieldsToGraph.removeCycles();
  if (foundCycles.length > 0) {
    onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${foundCycles.map((s) => s.toString ? s.toString() : "" + s).join(" -> ")}`));
  }
  let runningCount = 0;
  const queryProvider = new CachedFunction(async (provider) => {
    try {
      runningCount++;
      if (cancellationTokenSource.token.isCancellationRequested) {
        return void 0;
      }
      const yieldsTo = yieldsToGraph.getOutgoing(provider);
      for (const p of yieldsTo) {
        const result2 = await queryProvider.get(p);
        if (result2) {
          for (const item of result2.inlineSuggestions.items) {
            if (item.isInlineEdit || typeof item.insertText !== "string") {
              return void 0;
            }
            const t = new TextReplacement(Range.lift(item.range) ?? defaultReplaceRange, item.insertText);
            if (inlineCompletionIsVisible(t, void 0, model, position)) {
              return void 0;
            }
          }
        }
      }
      let result;
      const providerStartTime = Date.now();
      try {
        result = await provider.provideInlineCompletions(model, position, contextWithUuid, cancellationTokenSource.token);
      } catch (e) {
        onUnexpectedExternalError(e);
        return void 0;
      }
      const providerEndTime = Date.now();
      if (!result) {
        return void 0;
      }
      const data = [];
      const list = new InlineSuggestionList(result, data, provider);
      list.addRef();
      runWhenCancelled(cancellationTokenSource.token, () => {
        return list.removeRef(cancelReason);
      });
      if (cancellationTokenSource.token.isCancellationRequested) {
        return void 0;
      }
      for (const item of result.items) {
        data.push(toInlineSuggestData(item, list, defaultReplaceRange, model, languageConfigurationService, contextWithUuid, requestInfo, { startTime: providerStartTime, endTime: providerEndTime }));
      }
      return list;
    } finally {
      runningCount--;
    }
  });
  const inlineCompletionLists = AsyncIterableProducer.fromPromisesResolveOrder(providers.map((p) => queryProvider.get(p))).filter(isDefined);
  return {
    contextWithUuid,
    get didAllProvidersReturn() {
      return runningCount === 0;
    },
    lists: inlineCompletionLists,
    cancelAndDispose: (reason) => {
      if (cancelReason !== void 0) {
        return;
      }
      cancelReason = reason;
      cancellationTokenSource.dispose(true);
    }
  };
}
function runWhenCancelled(token, callback) {
  if (token.isCancellationRequested) {
    callback();
    return Disposable.None;
  } else {
    const listener = token.onCancellationRequested(() => {
      listener.dispose();
      callback();
    });
    return { dispose: () => listener.dispose() };
  }
}
function toInlineSuggestData(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService, context, requestInfo, providerRequestInfo) {
  let insertText;
  let snippetInfo;
  let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;
  if (typeof inlineCompletion.insertText === "string") {
    insertText = inlineCompletion.insertText;
    if (languageConfigurationService && inlineCompletion.completeBracketPairs) {
      insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);
      const diff = insertText.length - inlineCompletion.insertText.length;
      if (diff !== 0) {
        range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
      }
    }
    snippetInfo = void 0;
  } else if ("snippet" in inlineCompletion.insertText) {
    const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;
    if (languageConfigurationService && inlineCompletion.completeBracketPairs) {
      inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);
      const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;
      if (diff !== 0) {
        range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
      }
    }
    const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);
    if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {
      insertText = snippet.children[0].value;
      snippetInfo = void 0;
    } else {
      insertText = snippet.toString();
      snippetInfo = {
        snippet: inlineCompletion.insertText.snippet,
        range
      };
    }
  } else {
    assertNever(inlineCompletion.insertText);
  }
  const displayLocation = inlineCompletion.displayLocation ? {
    range: Range.lift(inlineCompletion.displayLocation.range),
    label: inlineCompletion.displayLocation.label,
    kind: inlineCompletion.displayLocation.kind
  } : void 0;
  return new InlineSuggestData(range, insertText, snippetInfo, displayLocation, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source, context, inlineCompletion.isInlineEdit ?? false, requestInfo, providerRequestInfo, inlineCompletion.correlationId);
}
var InlineSuggestData = class {
  constructor(range, insertText, snippetInfo, displayLocation, additionalTextEdits, sourceInlineCompletion, source, context, isInlineEdit, _requestInfo, _providerRequestInfo, _correlationId) {
    this.range = range;
    this.insertText = insertText;
    this.snippetInfo = snippetInfo;
    this.displayLocation = displayLocation;
    this.additionalTextEdits = additionalTextEdits;
    this.sourceInlineCompletion = sourceInlineCompletion;
    this.source = source;
    this.context = context;
    this.isInlineEdit = isInlineEdit;
    this._requestInfo = _requestInfo;
    this._providerRequestInfo = _providerRequestInfo;
    this._correlationId = _correlationId;
    this._didShow = false;
    this._timeUntilShown = void 0;
    this._showStartTime = void 0;
    this._shownDuration = 0;
    this._showUncollapsedStartTime = void 0;
    this._showUncollapsedDuration = 0;
    this._notShownReason = void 0;
    this._didReportEndOfLife = false;
    this._lastSetEndOfLifeReason = void 0;
    this._isPreceeded = false;
    this._partiallyAcceptedCount = 0;
    this._partiallyAcceptedSinceOriginal = { characters: 0, ratio: 0, count: 0 };
    this._viewData = { editorType: _requestInfo.editorType };
  }
  get showInlineEditMenu() {
    return this.sourceInlineCompletion.showInlineEditMenu ?? false;
  }
  get partialAccepts() {
    return this._partiallyAcceptedSinceOriginal;
  }
  async reportInlineEditShown(commandService, updatedInsertText, viewKind, viewData) {
    this.updateShownDuration(viewKind);
    if (this._didShow) {
      return;
    }
    this._didShow = true;
    this._viewData.viewKind = viewKind;
    this._viewData.renderData = viewData;
    this._timeUntilShown = Date.now() - this._requestInfo.startTime;
    const editDeltaInfo = new EditDeltaInfo(viewData.lineCountModified, viewData.lineCountOriginal, viewData.characterCountModified, viewData.characterCountOriginal);
    this.source.provider.handleItemDidShow?.(this.source.inlineSuggestions, this.sourceInlineCompletion, updatedInsertText, editDeltaInfo);
    if (this.sourceInlineCompletion.shownCommand) {
      await commandService.executeCommand(this.sourceInlineCompletion.shownCommand.id, ...this.sourceInlineCompletion.shownCommand.arguments || []);
    }
  }
  reportPartialAccept(acceptedCharacters, info, partialAcceptance) {
    this._partiallyAcceptedCount++;
    this._partiallyAcceptedSinceOriginal.characters += partialAcceptance.characters;
    this._partiallyAcceptedSinceOriginal.ratio = Math.min(this._partiallyAcceptedSinceOriginal.ratio + (1 - this._partiallyAcceptedSinceOriginal.ratio) * partialAcceptance.ratio, 1);
    this._partiallyAcceptedSinceOriginal.count += partialAcceptance.count;
    this.source.provider.handlePartialAccept?.(this.source.inlineSuggestions, this.sourceInlineCompletion, acceptedCharacters, info);
  }
  /**
   * Sends the end of life event to the provider.
   * If no reason is provided, the last set reason is used.
   * If no reason was set, the default reason is used.
  */
  reportEndOfLife(reason) {
    if (this._didReportEndOfLife) {
      return;
    }
    this._didReportEndOfLife = true;
    this.reportInlineEditHidden();
    if (!reason) {
      reason = this._lastSetEndOfLifeReason ?? { kind: InlineCompletionEndOfLifeReasonKind.Ignored, userTypingDisagreed: false, supersededBy: void 0 };
    }
    if (reason.kind === InlineCompletionEndOfLifeReasonKind.Rejected && this.source.provider.handleRejection) {
      this.source.provider.handleRejection(this.source.inlineSuggestions, this.sourceInlineCompletion);
    }
    if (this.source.provider.handleEndOfLifetime) {
      const summary = {
        requestUuid: this.context.requestUuid,
        correlationId: this._correlationId,
        selectedSuggestionInfo: !!this.context.selectedSuggestionInfo,
        partiallyAccepted: this._partiallyAcceptedCount,
        partiallyAcceptedCountSinceOriginal: this._partiallyAcceptedSinceOriginal.count,
        partiallyAcceptedRatioSinceOriginal: this._partiallyAcceptedSinceOriginal.ratio,
        partiallyAcceptedCharactersSinceOriginal: this._partiallyAcceptedSinceOriginal.characters,
        shown: this._didShow,
        shownDuration: this._shownDuration,
        shownDurationUncollapsed: this._showUncollapsedDuration,
        preceeded: this._isPreceeded,
        timeUntilShown: this._timeUntilShown,
        timeUntilProviderRequest: this._providerRequestInfo.startTime - this._requestInfo.startTime,
        timeUntilProviderResponse: this._providerRequestInfo.endTime - this._requestInfo.startTime,
        editorType: this._viewData.editorType,
        languageId: this._requestInfo.languageId,
        requestReason: this._requestInfo.reason,
        viewKind: this._viewData.viewKind,
        notShownReason: this._notShownReason,
        error: this._viewData.error,
        typingInterval: this._requestInfo.typingInterval,
        typingIntervalCharacterCount: this._requestInfo.typingIntervalCharacterCount,
        availableProviders: this._requestInfo.availableProviders.map((p) => p.toString()).join(","),
        ...this._viewData.renderData
      };
      this.source.provider.handleEndOfLifetime(this.source.inlineSuggestions, this.sourceInlineCompletion, reason, summary);
    }
  }
  reportInlineEditError(message) {
    if (this._viewData.error) {
      this._viewData.error += `; ${message}`;
    } else {
      this._viewData.error = message;
    }
  }
  setIsPreceeded(partialAccepts) {
    this._isPreceeded = true;
    if (this._partiallyAcceptedSinceOriginal.characters !== 0 || this._partiallyAcceptedSinceOriginal.ratio !== 0 || this._partiallyAcceptedSinceOriginal.count !== 0) {
      console.warn("Expected partiallyAcceptedCountSinceOriginal to be { characters: 0, rate: 0, partialAcceptances: 0 } before setIsPreceeded.");
    }
    this._partiallyAcceptedSinceOriginal = partialAccepts;
  }
  setNotShownReason(reason) {
    this._notShownReason ??= reason;
  }
  /**
   * Sets the end of life reason, but does not send the event to the provider yet.
  */
  setEndOfLifeReason(reason) {
    this.reportInlineEditHidden();
    this._lastSetEndOfLifeReason = reason;
  }
  updateShownDuration(viewKind) {
    const timeNow = Date.now();
    if (!this._showStartTime) {
      this._showStartTime = timeNow;
    }
    const isCollapsed = viewKind === InlineCompletionViewKind.Collapsed;
    if (!isCollapsed && this._showUncollapsedStartTime === void 0) {
      this._showUncollapsedStartTime = timeNow;
    }
    if (isCollapsed && this._showUncollapsedStartTime !== void 0) {
      this._showUncollapsedDuration += timeNow - this._showUncollapsedStartTime;
    }
  }
  reportInlineEditHidden() {
    if (this._showStartTime === void 0) {
      return;
    }
    const timeNow = Date.now();
    this._shownDuration += timeNow - this._showStartTime;
    this._showStartTime = void 0;
    if (this._showUncollapsedStartTime === void 0) {
      return;
    }
    this._showUncollapsedDuration += timeNow - this._showUncollapsedStartTime;
    this._showUncollapsedStartTime = void 0;
  }
};
var InlineCompletionEditorType;
(function(InlineCompletionEditorType2) {
  InlineCompletionEditorType2["TextEditor"] = "textEditor";
  InlineCompletionEditorType2["DiffEditor"] = "diffEditor";
  InlineCompletionEditorType2["Notebook"] = "notebook";
})(InlineCompletionEditorType || (InlineCompletionEditorType = {}));
var InlineSuggestionList = class {
  constructor(inlineSuggestions, inlineSuggestionsData, provider) {
    this.inlineSuggestions = inlineSuggestions;
    this.inlineSuggestionsData = inlineSuggestionsData;
    this.provider = provider;
    this.refCount = 0;
  }
  addRef() {
    this.refCount++;
  }
  removeRef(reason = { kind: "other" }) {
    this.refCount--;
    if (this.refCount === 0) {
      for (const item of this.inlineSuggestionsData) {
        item.reportEndOfLife();
      }
      this.provider.disposeInlineCompletions(this.inlineSuggestions, reason);
    }
  }
};
function getDefaultRange(position, model) {
  const word = model.getWordAtPosition(position);
  const maxColumn = model.getLineMaxColumn(position.lineNumber);
  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(void 0, maxColumn));
}
function closeBrackets(text, position, model, languageConfigurationService) {
  const currentLine = model.getLineContent(position.lineNumber);
  const edit = StringReplacement.replace(new OffsetRange(position.column - 1, currentLine.length), text);
  const proposedLineTokens = model.tokenization.tokenizeLinesAt(position.lineNumber, [edit.replace(currentLine)]);
  const textTokens = proposedLineTokens?.[0].sliceZeroCopy(edit.getRangeAfterReplace());
  if (!textTokens) {
    return text;
  }
  const fixedText = fixBracketsInLine(textTokens, languageConfigurationService);
  return fixedText;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsSource.js
var __decorate51 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsSource_1;
var _a38;
var InlineCompletionsSource = (_a38 = class extends Disposable {
  constructor(_textModel, _versionId, _debounceValue, _cursorPosition, _languageConfigurationService, _logService, _configurationService, _instantiationService) {
    super();
    this._textModel = _textModel;
    this._versionId = _versionId;
    this._debounceValue = _debounceValue;
    this._cursorPosition = _cursorPosition;
    this._languageConfigurationService = _languageConfigurationService;
    this._logService = _logService;
    this._configurationService = _configurationService;
    this._instantiationService = _instantiationService;
    this._updateOperation = this._register(new MutableDisposable());
    this._state = observableReducerSettable(this, {
      initial: () => ({
        inlineCompletions: InlineCompletionsState.createEmpty(),
        suggestWidgetInlineCompletions: InlineCompletionsState.createEmpty()
      }),
      disposeFinal: (values) => {
        values.inlineCompletions.dispose();
        values.suggestWidgetInlineCompletions.dispose();
      },
      changeTracker: recordChangesLazy(() => ({ versionId: this._versionId })),
      update: (reader, previousValue, changes) => {
        const edit = StringEdit.compose(changes.changes.map((c) => c.change ? offsetEditFromContentChanges(c.change.changes) : StringEdit.empty).filter(isDefined));
        if (edit.isEmpty()) {
          return previousValue;
        }
        try {
          return {
            inlineCompletions: previousValue.inlineCompletions.createStateWithAppliedEdit(edit, this._textModel),
            suggestWidgetInlineCompletions: previousValue.suggestWidgetInlineCompletions.createStateWithAppliedEdit(edit, this._textModel)
          };
        } finally {
          previousValue.inlineCompletions.dispose();
          previousValue.suggestWidgetInlineCompletions.dispose();
        }
      }
    });
    this.inlineCompletions = this._state.map(this, (v) => v.inlineCompletions);
    this.suggestWidgetInlineCompletions = this._state.map(this, (v) => v.suggestWidgetInlineCompletions);
    this.clearOperationOnTextModelChange = derived(this, (reader) => {
      this._versionId.read(reader);
      this._updateOperation.clear();
      return void 0;
    });
    this._loadingCount = observableValue(this, 0);
    this._loggingEnabled = observableConfigValue("editor.inlineSuggest.logFetch", false, this._configurationService).recomputeInitiallyAndOnChange(this._store);
    this._sendRequestData = observableConfigValue("editor.inlineSuggest.emptyResponseInformation", true, this._configurationService).recomputeInitiallyAndOnChange(this._store);
    this._structuredFetchLogger = this._register(this._instantiationService.createInstance(StructuredLogger.cast(), "editor.inlineSuggest.logFetch.commandId"));
    this.clearOperationOnTextModelChange.recomputeInitiallyAndOnChange(this._store);
  }
  _log(entry) {
    if (this._loggingEnabled.get()) {
      this._logService.info(formatRecordableLogEntry(entry));
    }
    this._structuredFetchLogger.log(entry);
  }
  fetch(providers, providersLabel, context, activeInlineCompletion, withDebounce, userJumpedToActiveCompletion, requestInfo) {
    const position = this._cursorPosition.get();
    const request = new UpdateRequest(position, context, this._textModel.getVersionId(), new Set(providers));
    const target = context.selectedSuggestionInfo ? this.suggestWidgetInlineCompletions.get() : this.inlineCompletions.get();
    if (this._updateOperation.value?.request.satisfies(request)) {
      return this._updateOperation.value.promise;
    } else if (target?.request?.satisfies(request)) {
      return Promise.resolve(true);
    }
    const updateOngoing = !!this._updateOperation.value;
    this._updateOperation.clear();
    const source = new CancellationTokenSource();
    const promise = (async () => {
      this._loadingCount.set(this._loadingCount.get() + 1, void 0);
      const store = new DisposableStore();
      const inlineSuggestionsProviders = providers.filter((p) => p.providerId);
      const requestResponseInfo = new RequestResponseData(context, requestInfo, inlineSuggestionsProviders);
      try {
        const recommendedDebounceValue = this._debounceValue.get(this._textModel);
        const debounceValue = findLastMax(providers.map((p) => p.debounceDelayMs), compareUndefinedSmallest(numberComparator)) ?? recommendedDebounceValue;
        const shouldDebounce = updateOngoing || withDebounce && context.triggerKind === InlineCompletionTriggerKind.Automatic;
        if (shouldDebounce) {
          await wait(debounceValue, source.token);
        }
        if (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {
          requestResponseInfo.setNoSuggestionReasonIfNotSet("canceled:beforeFetch");
          return false;
        }
        const requestId = InlineCompletionsSource_1._requestId++;
        if (this._loggingEnabled.get() || this._structuredFetchLogger.isEnabled.get()) {
          this._log({
            sourceId: "InlineCompletions.fetch",
            kind: "start",
            requestId,
            modelUri: this._textModel.uri,
            modelVersion: this._textModel.getVersionId(),
            context: { triggerKind: context.triggerKind, suggestInfo: context.selectedSuggestionInfo ? true : void 0 },
            time: Date.now(),
            provider: providersLabel
          });
        }
        const startTime = /* @__PURE__ */ new Date();
        const providerResult = provideInlineCompletions(providers, this._cursorPosition.get(), this._textModel, context, requestInfo, this._languageConfigurationService);
        runWhenCancelled(source.token, () => providerResult.cancelAndDispose({ kind: "tokenCancellation" }));
        let shouldStopEarly = false;
        let producedSuggestion = false;
        const suggestions = [];
        for await (const list of providerResult.lists) {
          if (!list) {
            continue;
          }
          list.addRef();
          store.add(toDisposable(() => list.removeRef(list.inlineSuggestionsData.length === 0 ? { kind: "empty" } : { kind: "notTaken" })));
          for (const item of list.inlineSuggestionsData) {
            producedSuggestion = true;
            if (!context.includeInlineEdits && (item.isInlineEdit || item.showInlineEditMenu)) {
              item.setNotShownReason("notInlineEditRequested");
              continue;
            }
            if (!context.includeInlineCompletions && !(item.isInlineEdit || item.showInlineEditMenu)) {
              item.setNotShownReason("notInlineCompletionRequested");
              continue;
            }
            const i2 = InlineSuggestionItem.create(item, this._textModel);
            suggestions.push(i2);
            if (!i2.isInlineEdit && !i2.showInlineEditMenu && context.triggerKind === InlineCompletionTriggerKind.Automatic) {
              if (i2.isVisible(this._textModel, this._cursorPosition.get())) {
                shouldStopEarly = true;
              }
            }
          }
          if (shouldStopEarly) {
            break;
          }
        }
        providerResult.cancelAndDispose({ kind: "lostRace" });
        if (this._loggingEnabled.get() || this._structuredFetchLogger.isEnabled.get()) {
          const didAllProvidersReturn = providerResult.didAllProvidersReturn;
          let error = void 0;
          if (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId) {
            error = "canceled";
          }
          const result = suggestions.map((c) => ({
            range: c.editRange.toString(),
            text: c.insertText,
            isInlineEdit: !!c.isInlineEdit,
            source: c.source.provider.groupId
          }));
          this._log({ sourceId: "InlineCompletions.fetch", kind: "end", requestId, durationMs: Date.now() - startTime.getTime(), error, result, time: Date.now(), didAllProvidersReturn });
        }
        requestResponseInfo.setRequestUuid(providerResult.contextWithUuid.requestUuid);
        if (producedSuggestion) {
          requestResponseInfo.setHasProducedSuggestion();
          if (suggestions.length > 0 && source.token.isCancellationRequested) {
            suggestions.forEach((s) => s.setNotShownReasonIfNotSet("canceled:whileAwaitingOtherProviders"));
          }
        } else {
          if (source.token.isCancellationRequested) {
            requestResponseInfo.setNoSuggestionReasonIfNotSet("canceled:whileFetching");
          } else {
            requestResponseInfo.setNoSuggestionReasonIfNotSet("noSuggestion");
          }
        }
        const remainingTimeToWait = context.earliestShownDateTime - Date.now();
        if (remainingTimeToWait > 0) {
          await wait(remainingTimeToWait, source.token);
        }
        if (source.token.isCancellationRequested || this._store.isDisposed || this._textModel.getVersionId() !== request.versionId || userJumpedToActiveCompletion.get()) {
          const notShownReason = source.token.isCancellationRequested ? "canceled:afterMinShowDelay" : this._store.isDisposed ? "canceled:disposed" : this._textModel.getVersionId() !== request.versionId ? "canceled:documentChanged" : userJumpedToActiveCompletion.get() ? "canceled:userJumped" : "unknown";
          suggestions.forEach((s) => s.setNotShownReasonIfNotSet(notShownReason));
          return false;
        }
        const endTime = /* @__PURE__ */ new Date();
        this._debounceValue.update(this._textModel, endTime.getTime() - startTime.getTime());
        const cursorPosition = this._cursorPosition.get();
        this._updateOperation.clear();
        transaction((tx) => {
          const v = this._state.get();
          if (context.selectedSuggestionInfo) {
            this._state.set({
              inlineCompletions: InlineCompletionsState.createEmpty(),
              suggestWidgetInlineCompletions: v.suggestWidgetInlineCompletions.createStateWithAppliedResults(suggestions, request, this._textModel, cursorPosition, activeInlineCompletion)
            }, tx);
          } else {
            this._state.set({
              inlineCompletions: v.inlineCompletions.createStateWithAppliedResults(suggestions, request, this._textModel, cursorPosition, activeInlineCompletion),
              suggestWidgetInlineCompletions: InlineCompletionsState.createEmpty()
            }, tx);
          }
          v.inlineCompletions.dispose();
          v.suggestWidgetInlineCompletions.dispose();
        });
      } finally {
        this._loadingCount.set(this._loadingCount.get() - 1, void 0);
        store.dispose();
        this.sendInlineCompletionsRequestTelemetry(requestResponseInfo);
      }
      return true;
    })();
    const updateOperation = new UpdateOperation(request, source, promise);
    this._updateOperation.value = updateOperation;
    return promise;
  }
  clear(tx) {
    this._updateOperation.clear();
    const v = this._state.get();
    this._state.set({
      inlineCompletions: InlineCompletionsState.createEmpty(),
      suggestWidgetInlineCompletions: InlineCompletionsState.createEmpty()
    }, tx);
    v.inlineCompletions.dispose();
    v.suggestWidgetInlineCompletions.dispose();
  }
  seedInlineCompletionsWithSuggestWidget() {
    const inlineCompletions = this.inlineCompletions.get();
    const suggestWidgetInlineCompletions = this.suggestWidgetInlineCompletions.get();
    if (!suggestWidgetInlineCompletions) {
      return;
    }
    transaction((tx) => {
      if (!inlineCompletions || (suggestWidgetInlineCompletions.request?.versionId ?? -1) > (inlineCompletions.request?.versionId ?? -1)) {
        inlineCompletions?.dispose();
        const s = this._state.get();
        this._state.set({
          inlineCompletions: suggestWidgetInlineCompletions.clone(),
          suggestWidgetInlineCompletions: InlineCompletionsState.createEmpty()
        }, tx);
        s.inlineCompletions.dispose();
        s.suggestWidgetInlineCompletions.dispose();
      }
      this.clearSuggestWidgetInlineCompletions(tx);
    });
  }
  sendInlineCompletionsRequestTelemetry(requestResponseInfo) {
    if (!this._sendRequestData.get()) {
      return;
    }
    if (requestResponseInfo.requestUuid === void 0 || requestResponseInfo.hasProducedSuggestion) {
      return;
    }
    const emptyEndOfLifeEvent = {
      id: requestResponseInfo.requestUuid,
      opportunityId: requestResponseInfo.requestUuid,
      noSuggestionReason: requestResponseInfo.noSuggestionReason ?? "unknown",
      extensionId: "vscode-core",
      extensionVersion: "0.0.0",
      groupId: "empty",
      shown: false,
      editorType: requestResponseInfo.requestInfo.editorType,
      requestReason: requestResponseInfo.requestInfo.reason,
      typingInterval: requestResponseInfo.requestInfo.typingInterval,
      typingIntervalCharacterCount: requestResponseInfo.requestInfo.typingIntervalCharacterCount,
      languageId: requestResponseInfo.requestInfo.languageId,
      selectedSuggestionInfo: !!requestResponseInfo.context.selectedSuggestionInfo,
      availableProviders: requestResponseInfo.providers.map((p) => p.providerId?.toString()).filter(isDefined).join(","),
      ...forwardToChannelIf(requestResponseInfo.providers.some((p) => isCopilotLikeExtension(p.providerId?.extensionId))),
      timeUntilProviderRequest: void 0,
      timeUntilProviderResponse: void 0,
      viewKind: void 0,
      preceeded: void 0,
      error: void 0,
      superseded: void 0,
      reason: void 0,
      correlationId: void 0,
      shownDuration: void 0,
      shownDurationUncollapsed: void 0,
      timeUntilShown: void 0,
      partiallyAccepted: void 0,
      partiallyAcceptedCountSinceOriginal: void 0,
      partiallyAcceptedRatioSinceOriginal: void 0,
      partiallyAcceptedCharactersSinceOriginal: void 0,
      cursorColumnDistance: void 0,
      cursorLineDistance: void 0,
      lineCountOriginal: void 0,
      lineCountModified: void 0,
      characterCountOriginal: void 0,
      characterCountModified: void 0,
      disjointReplacements: void 0,
      sameShapeReplacements: void 0,
      notShownReason: void 0
    };
    const dataChannel = this._instantiationService.createInstance(DataChannelForwardingTelemetryService);
    sendInlineCompletionsEndOfLifeTelemetry(dataChannel, emptyEndOfLifeEvent);
  }
  clearSuggestWidgetInlineCompletions(tx) {
    if (this._updateOperation.value?.request.context.selectedSuggestionInfo) {
      this._updateOperation.clear();
    }
  }
  cancelUpdate() {
    this._updateOperation.clear();
  }
}, InlineCompletionsSource_1 = _a38, _a38._requestId = 0, _a38);
InlineCompletionsSource = InlineCompletionsSource_1 = __decorate51([
  __param51(4, ILanguageConfigurationService),
  __param51(5, ILogService),
  __param51(6, IConfigurationService),
  __param51(7, IInstantiationService)
], InlineCompletionsSource);
var UpdateRequest = class {
  constructor(position, context, versionId, providers) {
    this.position = position;
    this.context = context;
    this.versionId = versionId;
    this.providers = providers;
  }
  satisfies(other) {
    return this.position.equals(other.position) && equalsIfDefined(this.context.selectedSuggestionInfo, other.context.selectedSuggestionInfo, itemEquals()) && (other.context.triggerKind === InlineCompletionTriggerKind.Automatic || this.context.triggerKind === InlineCompletionTriggerKind.Explicit) && this.versionId === other.versionId && isSubset(other.providers, this.providers);
  }
};
var RequestResponseData = class {
  constructor(context, requestInfo, providers) {
    this.context = context;
    this.requestInfo = requestInfo;
    this.providers = providers;
    this.hasProducedSuggestion = false;
  }
  setRequestUuid(uuid) {
    this.requestUuid = uuid;
  }
  setNoSuggestionReasonIfNotSet(type) {
    this.noSuggestionReason ??= type;
  }
  setHasProducedSuggestion() {
    this.hasProducedSuggestion = true;
  }
};
function isSubset(set1, set2) {
  return [...set1].every((item) => set2.has(item));
}
var UpdateOperation = class {
  constructor(request, cancellationTokenSource, promise) {
    this.request = request;
    this.cancellationTokenSource = cancellationTokenSource;
    this.promise = promise;
  }
  dispose() {
    this.cancellationTokenSource.cancel();
  }
};
var InlineCompletionsState = class _InlineCompletionsState extends Disposable {
  static createEmpty() {
    return new _InlineCompletionsState([], void 0);
  }
  constructor(inlineCompletions, request) {
    for (const inlineCompletion of inlineCompletions) {
      inlineCompletion.addRef();
    }
    super();
    this.inlineCompletions = inlineCompletions;
    this.request = request;
    this._register({
      dispose: () => {
        for (const inlineCompletion of this.inlineCompletions) {
          inlineCompletion.removeRef();
        }
      }
    });
  }
  _findById(id) {
    return this.inlineCompletions.find((i2) => i2.identity === id);
  }
  _findByHash(hash2) {
    return this.inlineCompletions.find((i2) => i2.hash === hash2);
  }
  /**
   * Applies the edit on the state.
  */
  createStateWithAppliedEdit(edit, textModel) {
    const newInlineCompletions = this.inlineCompletions.map((i2) => i2.withEdit(edit, textModel)).filter(isDefined);
    return new _InlineCompletionsState(newInlineCompletions, this.request);
  }
  createStateWithAppliedResults(updatedSuggestions, request, textModel, cursorPosition, itemIdToPreserveAtTop) {
    let itemToPreserve = void 0;
    if (itemIdToPreserveAtTop) {
      const itemToPreserveCandidate = this._findById(itemIdToPreserveAtTop);
      if (itemToPreserveCandidate && itemToPreserveCandidate.canBeReused(textModel, request.position)) {
        itemToPreserve = itemToPreserveCandidate;
        const updatedItemToPreserve = updatedSuggestions.find((i2) => i2.hash === itemToPreserveCandidate.hash);
        if (updatedItemToPreserve) {
          updatedSuggestions = moveToFront(updatedItemToPreserve, updatedSuggestions);
        } else {
          updatedSuggestions = [itemToPreserveCandidate, ...updatedSuggestions];
        }
      }
    }
    const preferInlineCompletions = itemToPreserve ? !itemToPreserve.isInlineEdit : updatedSuggestions.some((i2) => !i2.isInlineEdit && i2.isVisible(textModel, cursorPosition));
    let updatedItems = [];
    for (const i2 of updatedSuggestions) {
      const oldItem = this._findByHash(i2.hash);
      let item;
      if (oldItem && oldItem !== i2) {
        item = i2.withIdentity(oldItem.identity);
        i2.setIsPreceeded(oldItem);
        oldItem.setEndOfLifeReason({ kind: InlineCompletionEndOfLifeReasonKind.Ignored, userTypingDisagreed: false, supersededBy: i2.getSourceCompletion() });
      } else {
        item = i2;
      }
      if (preferInlineCompletions !== item.isInlineEdit) {
        updatedItems.push(item);
      }
    }
    updatedItems.sort(compareBy((i2) => i2.showInlineEditMenu, booleanComparator));
    updatedItems = distinctByKey(updatedItems, (i2) => i2.semanticId);
    return new _InlineCompletionsState(updatedItems, request);
  }
  clone() {
    return new _InlineCompletionsState(this.inlineCompletions, this.request);
  }
};
function distinctByKey(items, key) {
  const seen = /* @__PURE__ */ new Set();
  return items.filter((item) => {
    const k = key(item);
    if (seen.has(k)) {
      return false;
    }
    seen.add(k);
    return true;
  });
}
function moveToFront(item, items) {
  const index = items.indexOf(item);
  if (index > -1) {
    return [item, ...items.slice(0, index), ...items.slice(index + 1)];
  }
  return items;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineEdit.js
var InlineEdit = class {
  constructor(edit, commands, inlineCompletion) {
    this.edit = edit;
    this.commands = commands;
    this.inlineCompletion = inlineCompletion;
  }
  equals(other) {
    return this.edit.equals(other.edit) && this.inlineCompletion === other.inlineCompletion;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsModel.js
init_textModelEditSource();
init_codeEditorService();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/typingSpeed.js
init_arrays();
init_lifecycle();
var _TypingInterval = class _TypingInterval extends Disposable {
  // Minimum characters needed for reliable speed calculation
  /**
   * Gets the current typing interval as average milliseconds between keystrokes
   * and the number of characters involved in the computation.
   * Higher interval values indicate slower typing.
   * Returns { interval: 0, characterCount: 0 } if no typing data is available.
   */
  getTypingInterval() {
    if (this._cacheInvalidated || this._cachedTypingIntervalResult === null) {
      this._cachedTypingIntervalResult = this._calculateTypingInterval();
      this._cacheInvalidated = false;
    }
    return this._cachedTypingIntervalResult;
  }
  constructor(_textModel) {
    super();
    this._textModel = _textModel;
    this._typingSessions = [];
    this._currentSession = null;
    this._lastChangeTime = 0;
    this._cachedTypingIntervalResult = null;
    this._cacheInvalidated = true;
    this._register(this._textModel.onDidChangeContent((e) => this._updateTypingSpeed(e)));
  }
  _updateTypingSpeed(change) {
    const now = Date.now();
    if (!this._isUserTyping(change)) {
      this._finalizeCurrentSession();
      return;
    }
    if (this._currentSession && now - this._lastChangeTime > _TypingInterval.MAX_SESSION_GAP_MS) {
      this._finalizeCurrentSession();
    }
    if (!this._currentSession) {
      this._currentSession = {
        startTime: now,
        endTime: now,
        characterCount: 0
      };
    }
    this._currentSession.endTime = now;
    this._currentSession.characterCount += this._getActualCharacterCount(change);
    this._lastChangeTime = now;
    this._cacheInvalidated = true;
  }
  _getActualCharacterCount(change) {
    let totalChars = 0;
    for (const c of change.changes) {
      totalChars += Math.max(c.text.length, c.rangeLength);
    }
    return totalChars;
  }
  _isUserTyping(change) {
    if (!change.detailedReasons || change.detailedReasons.length === 0) {
      return false;
    }
    for (const reason of change.detailedReasons) {
      if (this._isUserTypingReason(reason)) {
        return true;
      }
    }
    return false;
  }
  _isUserTypingReason(reason) {
    if (reason.metadata.isUndoing || reason.metadata.isRedoing) {
      return false;
    }
    switch (reason.metadata.source) {
      case "cursor": {
        const kind = reason.metadata.kind;
        return kind === "type" || kind === "compositionType" || kind === "compositionEnd";
      }
      default:
        return false;
    }
  }
  _finalizeCurrentSession() {
    if (!this._currentSession) {
      return;
    }
    const sessionDuration = this._currentSession.endTime - this._currentSession.startTime;
    if (sessionDuration >= _TypingInterval.MIN_SESSION_DURATION_MS && this._currentSession.characterCount > 0) {
      this._typingSessions.push(this._currentSession);
      if (this._typingSessions.length > _TypingInterval.SESSION_HISTORY_LIMIT) {
        this._typingSessions.shift();
      }
    }
    this._currentSession = null;
  }
  _calculateTypingInterval() {
    if (this._currentSession) {
      const tempSession = { ...this._currentSession };
      const sessionDuration = tempSession.endTime - tempSession.startTime;
      if (sessionDuration >= _TypingInterval.MIN_SESSION_DURATION_MS && tempSession.characterCount > 0) {
        const allSessions = [...this._typingSessions, tempSession];
        return this._calculateSpeedFromSessions(allSessions);
      }
    }
    return this._calculateSpeedFromSessions(this._typingSessions);
  }
  _calculateSpeedFromSessions(sessions) {
    if (sessions.length === 0) {
      return { averageInterval: 0, characterCount: 0 };
    }
    const sortedSessions = [...sessions].sort((a, b) => b.endTime - a.endTime);
    const cutoffTime = Date.now() - _TypingInterval.TYPING_SPEED_WINDOW_MS;
    const recentSessions = sortedSessions.filter((session) => session.endTime > cutoffTime);
    const olderSessions = sortedSessions.splice(recentSessions.length);
    let totalChars = sum(recentSessions.map((session) => session.characterCount));
    for (let i2 = 0; i2 < olderSessions.length && totalChars < _TypingInterval.MIN_CHARS_FOR_RELIABLE_SPEED; i2++) {
      recentSessions.push(olderSessions[i2]);
      totalChars += olderSessions[i2].characterCount;
    }
    const totalTime = sum(recentSessions.map((session) => session.endTime - session.startTime));
    if (totalTime === 0 || totalChars <= 1) {
      return { averageInterval: 0, characterCount: totalChars };
    }
    const keystrokeIntervals = Math.max(1, totalChars - 1);
    const avgMsBetweenKeystrokes = totalTime / keystrokeIntervals;
    return {
      averageInterval: Math.round(avgMsBetweenKeystrokes),
      characterCount: totalChars
    };
  }
  dispose() {
    this._finalizeCurrentSession();
    super.dispose();
  }
};
_TypingInterval.MAX_SESSION_GAP_MS = 3e3;
_TypingInterval.MIN_SESSION_DURATION_MS = 1e3;
_TypingInterval.SESSION_HISTORY_LIMIT = 50;
_TypingInterval.TYPING_SPEED_WINDOW_MS = 3e5;
_TypingInterval.MIN_CHARS_FOR_RELIABLE_SPEED = 20;
var TypingInterval = _TypingInterval;

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/inlineCompletionsModel.js
init_offsetRange();
init_uri();
var __decorate52 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param52 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsModel = class InlineCompletionsModel2 extends Disposable {
  get isAcceptingPartially() {
    return this._isAcceptingPartially;
  }
  constructor(textModel, _selectedSuggestItem, _textModelVersionId, _positions, _debounceValue, _enabled, _editor, _instantiationService, _commandService, _languageConfigurationService, _accessibilityService, _languageFeaturesService, _codeEditorService, _inlineCompletionsService) {
    super();
    this.textModel = textModel;
    this._selectedSuggestItem = _selectedSuggestItem;
    this._textModelVersionId = _textModelVersionId;
    this._positions = _positions;
    this._debounceValue = _debounceValue;
    this._enabled = _enabled;
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._commandService = _commandService;
    this._languageConfigurationService = _languageConfigurationService;
    this._accessibilityService = _accessibilityService;
    this._languageFeaturesService = _languageFeaturesService;
    this._codeEditorService = _codeEditorService;
    this._inlineCompletionsService = _inlineCompletionsService;
    this._isActive = observableValue(this, false);
    this._onlyRequestInlineEditsSignal = observableSignal(this);
    this._forceUpdateExplicitlySignal = observableSignal(this);
    this._noDelaySignal = observableSignal(this);
    this._fetchSpecificProviderSignal = observableSignal(this);
    this._selectedInlineCompletionId = observableValue(this, void 0);
    this.primaryPosition = derived(this, (reader) => this._positions.read(reader)[0] ?? new Position(1, 1));
    this._isAcceptingPartially = false;
    this._appearedInsideViewport = derived(this, (reader) => {
      const state = this.state.read(reader);
      if (!state || !state.inlineCompletion) {
        return false;
      }
      const targetRange = state.inlineCompletion.targetRange;
      const visibleRanges = this._editorObs.editor.getVisibleRanges();
      if (visibleRanges.length < 1) {
        return false;
      }
      const viewportRange = new Range(visibleRanges[0].startLineNumber, visibleRanges[0].startColumn, visibleRanges[visibleRanges.length - 1].endLineNumber, visibleRanges[visibleRanges.length - 1].endColumn);
      return viewportRange.containsRange(targetRange);
    });
    this._onDidAccept = new Emitter();
    this.onDidAccept = this._onDidAccept.event;
    this._lastShownInlineCompletionInfo = void 0;
    this._lastAcceptedInlineCompletionInfo = void 0;
    this._didUndoInlineEdits = derivedHandleChanges({
      owner: this,
      changeTracker: {
        createChangeSummary: () => ({ didUndo: false }),
        handleChange: (ctx, changeSummary) => {
          changeSummary.didUndo = ctx.didChange(this._textModelVersionId) && !!ctx.change?.isUndoing;
          return true;
        }
      }
    }, (reader, changeSummary) => {
      const versionId = this._textModelVersionId.read(reader);
      if (versionId !== null && this._lastAcceptedInlineCompletionInfo && this._lastAcceptedInlineCompletionInfo.textModelVersionIdAfter === versionId - 1 && this._lastAcceptedInlineCompletionInfo.inlineCompletion.isInlineEdit && changeSummary.didUndo) {
        this._lastAcceptedInlineCompletionInfo = void 0;
        return true;
      }
      return false;
    });
    this._preserveCurrentCompletionReasons = /* @__PURE__ */ new Set([
      VersionIdChangeReason.Redo,
      VersionIdChangeReason.Undo,
      VersionIdChangeReason.AcceptWord
    ]);
    this.dontRefetchSignal = observableSignal(this);
    this._fetchInlineCompletionsPromise = derivedHandleChanges({
      owner: this,
      changeTracker: {
        createChangeSummary: () => ({
          dontRefetch: false,
          preserveCurrentCompletion: false,
          inlineCompletionTriggerKind: InlineCompletionTriggerKind.Automatic,
          onlyRequestInlineEdits: false,
          shouldDebounce: true,
          provider: void 0,
          textChange: false,
          changeReason: ""
        }),
        handleChange: (ctx, changeSummary) => {
          if (ctx.didChange(this._textModelVersionId)) {
            if (this._preserveCurrentCompletionReasons.has(this._getReason(ctx.change))) {
              changeSummary.preserveCurrentCompletion = true;
            }
            const detailedReasons = ctx.change?.detailedReasons ?? [];
            changeSummary.changeReason = detailedReasons.length > 0 ? detailedReasons[0].getType() : "";
            changeSummary.textChange = true;
          } else if (ctx.didChange(this._forceUpdateExplicitlySignal)) {
            changeSummary.preserveCurrentCompletion = true;
            changeSummary.inlineCompletionTriggerKind = InlineCompletionTriggerKind.Explicit;
          } else if (ctx.didChange(this.dontRefetchSignal)) {
            changeSummary.dontRefetch = true;
          } else if (ctx.didChange(this._onlyRequestInlineEditsSignal)) {
            changeSummary.onlyRequestInlineEdits = true;
          } else if (ctx.didChange(this._fetchSpecificProviderSignal)) {
            changeSummary.provider = ctx.change;
          }
          return true;
        }
      }
    }, (reader, changeSummary) => {
      this._source.clearOperationOnTextModelChange.read(reader);
      this._noDelaySignal.read(reader);
      this.dontRefetchSignal.read(reader);
      this._onlyRequestInlineEditsSignal.read(reader);
      this._forceUpdateExplicitlySignal.read(reader);
      this._fetchSpecificProviderSignal.read(reader);
      const shouldUpdate = (this._enabled.read(reader) && this._selectedSuggestItem.read(reader) || this._isActive.read(reader)) && (!this._inlineCompletionsService.isSnoozing() || changeSummary.inlineCompletionTriggerKind === InlineCompletionTriggerKind.Explicit);
      if (!shouldUpdate) {
        this._source.cancelUpdate();
        return void 0;
      }
      this._textModelVersionId.read(reader);
      const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(void 0);
      let suggestItem = this._selectedSuggestItem.read(reader);
      if (this._shouldShowOnSuggestConflict.read(void 0)) {
        suggestItem = void 0;
      }
      if (suggestWidgetInlineCompletions && !suggestItem) {
        this._source.seedInlineCompletionsWithSuggestWidget();
      }
      if (changeSummary.dontRefetch) {
        return Promise.resolve(true);
      }
      if (this._didUndoInlineEdits.read(reader) && changeSummary.inlineCompletionTriggerKind !== InlineCompletionTriggerKind.Explicit) {
        transaction((tx) => {
          this._source.clear(tx);
        });
        return void 0;
      }
      let reason = "";
      if (changeSummary.provider) {
        reason += "providerOnDidChange";
      } else if (changeSummary.inlineCompletionTriggerKind === InlineCompletionTriggerKind.Explicit) {
        reason += "explicit";
      }
      if (changeSummary.changeReason) {
        reason += reason.length > 0 ? `:${changeSummary.changeReason}` : changeSummary.changeReason;
      }
      const typingInterval = this._typing.getTypingInterval();
      const requestInfo = {
        editorType: this.editorType,
        startTime: Date.now(),
        languageId: this.textModel.getLanguageId(),
        reason,
        typingInterval: typingInterval.averageInterval,
        typingIntervalCharacterCount: typingInterval.characterCount,
        availableProviders: []
      };
      let context = {
        triggerKind: changeSummary.inlineCompletionTriggerKind,
        selectedSuggestionInfo: suggestItem?.toSelectedSuggestionInfo(),
        includeInlineCompletions: !changeSummary.onlyRequestInlineEdits,
        includeInlineEdits: this._inlineEditsEnabled.read(reader),
        requestIssuedDateTime: requestInfo.startTime,
        earliestShownDateTime: requestInfo.startTime + (changeSummary.inlineCompletionTriggerKind === InlineCompletionTriggerKind.Explicit || this.inAcceptFlow.read(void 0) ? 0 : this._minShowDelay.read(void 0))
      };
      if (context.triggerKind === InlineCompletionTriggerKind.Automatic && changeSummary.textChange) {
        if (this.textModel.getAlternativeVersionId() === this._lastShownInlineCompletionInfo?.alternateTextModelVersionId) {
          context = {
            ...context,
            includeInlineCompletions: !this._lastShownInlineCompletionInfo.inlineCompletion.isInlineEdit,
            includeInlineEdits: this._lastShownInlineCompletionInfo.inlineCompletion.isInlineEdit
          };
        }
      }
      const itemToPreserveCandidate = this.selectedInlineCompletion.read(void 0) ?? this._inlineCompletionItems.read(void 0)?.inlineEdit;
      const itemToPreserve = changeSummary.preserveCurrentCompletion || itemToPreserveCandidate?.forwardStable ? itemToPreserveCandidate : void 0;
      const userJumpedToActiveCompletion = this._jumpedToId.map((jumpedTo) => !!jumpedTo && jumpedTo === this._inlineCompletionItems.read(void 0)?.inlineEdit?.semanticId);
      const providers = changeSummary.provider ? { providers: [changeSummary.provider], label: "single:" + changeSummary.provider.providerId?.toString() } : { providers: this._languageFeaturesService.inlineCompletionsProvider.all(this.textModel), label: void 0 };
      const availableProviders = this.getAvailableProviders(providers.providers);
      requestInfo.availableProviders = availableProviders.map((p) => p.providerId).filter(isDefined);
      return this._source.fetch(availableProviders, providers.label, context, itemToPreserve?.identity, changeSummary.shouldDebounce, userJumpedToActiveCompletion, requestInfo);
    });
    this._inlineCompletionItems = derivedOpts({ owner: this }, (reader) => {
      const c = this._source.inlineCompletions.read(reader);
      if (!c) {
        return void 0;
      }
      const cursorPosition = this.primaryPosition.read(reader);
      let inlineEdit = void 0;
      const visibleCompletions = [];
      for (const completion of c.inlineCompletions) {
        if (!completion.isInlineEdit) {
          if (completion.isVisible(this.textModel, cursorPosition)) {
            visibleCompletions.push(completion);
          }
        } else {
          inlineEdit = completion;
        }
      }
      if (visibleCompletions.length !== 0) {
        inlineEdit = void 0;
      }
      return {
        inlineCompletions: visibleCompletions,
        inlineEdit
      };
    });
    this._filteredInlineCompletionItems = derivedOpts({ owner: this, equalsFn: itemsEquals() }, (reader) => {
      const c = this._inlineCompletionItems.read(reader);
      return c?.inlineCompletions ?? [];
    });
    this.selectedInlineCompletionIndex = derived(this, (reader) => {
      const selectedInlineCompletionId = this._selectedInlineCompletionId.read(reader);
      const filteredCompletions = this._filteredInlineCompletionItems.read(reader);
      const idx = this._selectedInlineCompletionId === void 0 ? -1 : filteredCompletions.findIndex((v) => v.semanticId === selectedInlineCompletionId);
      if (idx === -1) {
        this._selectedInlineCompletionId.set(void 0, void 0);
        return 0;
      }
      return idx;
    });
    this.selectedInlineCompletion = derived(this, (reader) => {
      const filteredCompletions = this._filteredInlineCompletionItems.read(reader);
      const idx = this.selectedInlineCompletionIndex.read(reader);
      return filteredCompletions[idx];
    });
    this.activeCommands = derivedOpts({ owner: this, equalsFn: itemsEquals() }, (r) => this.selectedInlineCompletion.read(r)?.source.inlineSuggestions.commands ?? []);
    this.inlineCompletionsCount = derived(this, (reader) => {
      if (this.lastTriggerKind.read(reader) === InlineCompletionTriggerKind.Explicit) {
        return this._filteredInlineCompletionItems.read(reader).length;
      } else {
        return void 0;
      }
    });
    this._hasVisiblePeekWidgets = derived(this, (reader) => this._editorObs.openedPeekWidgets.read(reader) > 0);
    this._shouldShowOnSuggestConflict = derived(this, (reader) => {
      const showOnSuggestConflict = this._showOnSuggestConflict.read(reader);
      if (showOnSuggestConflict !== "never") {
        const hasInlineCompletion = !!this.selectedInlineCompletion.read(reader);
        if (hasInlineCompletion) {
          const item = this._selectedSuggestItem.read(reader);
          if (!item) {
            return false;
          }
          if (showOnSuggestConflict === "whenSuggestListIsIncomplete") {
            return item.listIncomplete;
          }
          return true;
        }
      }
      return false;
    });
    this.state = derivedOpts({
      owner: this,
      equalsFn: (a, b) => {
        if (!a || !b) {
          return a === b;
        }
        if (a.kind === "ghostText" && b.kind === "ghostText") {
          return ghostTextsOrReplacementsEqual(a.ghostTexts, b.ghostTexts) && a.inlineCompletion === b.inlineCompletion && a.suggestItem === b.suggestItem;
        } else if (a.kind === "inlineEdit" && b.kind === "inlineEdit") {
          return a.inlineEdit.equals(b.inlineEdit);
        }
        return false;
      }
    }, (reader) => {
      const model = this.textModel;
      if (this._suppressInSnippetMode.read(reader) && this._isInSnippetMode.read(reader)) {
        return void 0;
      }
      const item = this._inlineCompletionItems.read(reader);
      const inlineEditResult = item?.inlineEdit;
      if (inlineEditResult) {
        if (this._hasVisiblePeekWidgets.read(reader)) {
          return void 0;
        }
        let edit = inlineEditResult.getSingleTextEdit();
        edit = singleTextRemoveCommonPrefix(edit, model);
        const cursorAtInlineEdit = this.primaryPosition.map((cursorPos) => LineRange.fromRangeInclusive(inlineEditResult.targetRange).addMargin(1, 1).contains(cursorPos.lineNumber));
        const commands = inlineEditResult.source.inlineSuggestions.commands;
        const inlineEdit = new InlineEdit(edit, commands ?? [], inlineEditResult);
        const edits = inlineEditResult.updatedEdit;
        const e = edits ? TextEdit.fromStringEdit(edits, new TextModelText(this.textModel)).replacements : [edit];
        const nextEditUri = (item.inlineEdit?.command?.id === "vscode.open" || item.inlineEdit?.command?.id === "_workbench.open") && item.inlineEdit?.command.arguments?.length ? URI.from(item.inlineEdit?.command.arguments[0]) : void 0;
        return { kind: "inlineEdit", inlineEdit, inlineCompletion: inlineEditResult, edits: e, cursorAtInlineEdit, nextEditUri };
      }
      const suggestItem = this._selectedSuggestItem.read(reader);
      if (!this._shouldShowOnSuggestConflict.read(reader) && suggestItem) {
        const suggestCompletionEdit = singleTextRemoveCommonPrefix(suggestItem.getSingleTextEdit(), model);
        const augmentation = this._computeAugmentation(suggestCompletionEdit, reader);
        const isSuggestionPreviewEnabled = this._suggestPreviewEnabled.read(reader);
        if (!isSuggestionPreviewEnabled && !augmentation) {
          return void 0;
        }
        const fullEdit = augmentation?.edit ?? suggestCompletionEdit;
        const fullEditPreviewLength = augmentation ? augmentation.edit.text.length - suggestCompletionEdit.text.length : 0;
        const mode = this._suggestPreviewMode.read(reader);
        const positions = this._positions.read(reader);
        const allPotentialEdits = [fullEdit, ...getSecondaryEdits(this.textModel, positions, fullEdit)];
        const validEditsAndGhostTexts = allPotentialEdits.map((edit, idx) => ({ edit, ghostText: edit ? computeGhostText(edit, model, mode, positions[idx], fullEditPreviewLength) : void 0 })).filter(({ edit, ghostText }) => edit !== void 0 && ghostText !== void 0);
        const edits = validEditsAndGhostTexts.map(({ edit }) => edit);
        const ghostTexts = validEditsAndGhostTexts.map(({ ghostText }) => ghostText);
        const primaryGhostText = ghostTexts[0] ?? new GhostText(fullEdit.range.endLineNumber, []);
        return { kind: "ghostText", edits, primaryGhostText, ghostTexts, inlineCompletion: augmentation?.completion, suggestItem };
      } else {
        if (!this._isActive.read(reader)) {
          return void 0;
        }
        const inlineCompletion = this.selectedInlineCompletion.read(reader);
        if (!inlineCompletion) {
          return void 0;
        }
        const replacement = inlineCompletion.getSingleTextEdit();
        const mode = this._inlineSuggestMode.read(reader);
        const positions = this._positions.read(reader);
        const allPotentialEdits = [replacement, ...getSecondaryEdits(this.textModel, positions, replacement)];
        const validEditsAndGhostTexts = allPotentialEdits.map((edit, idx) => ({ edit, ghostText: edit ? computeGhostText(edit, model, mode, positions[idx], 0) : void 0 })).filter(({ edit, ghostText }) => edit !== void 0 && ghostText !== void 0);
        const edits = validEditsAndGhostTexts.map(({ edit }) => edit);
        const ghostTexts = validEditsAndGhostTexts.map(({ ghostText }) => ghostText);
        if (!ghostTexts[0]) {
          return void 0;
        }
        return { kind: "ghostText", edits, primaryGhostText: ghostTexts[0], ghostTexts, inlineCompletion, suggestItem: void 0 };
      }
    });
    this.inlineCompletionState = derived(this, (reader) => {
      const s = this.state.read(reader);
      if (!s || s.kind !== "ghostText") {
        return void 0;
      }
      if (this._editorObs.inComposition.read(reader)) {
        return void 0;
      }
      return s;
    });
    this.inlineEditState = derived(this, (reader) => {
      const s = this.state.read(reader);
      if (!s || s.kind !== "inlineEdit") {
        return void 0;
      }
      return s;
    });
    this.inlineEditAvailable = derived(this, (reader) => {
      const s = this.inlineEditState.read(reader);
      return !!s;
    });
    this.warning = derived(this, (reader) => {
      return this.inlineCompletionState.read(reader)?.inlineCompletion?.warning;
    });
    this.ghostTexts = derivedOpts({ owner: this, equalsFn: ghostTextsOrReplacementsEqual }, (reader) => {
      const v = this.inlineCompletionState.read(reader);
      if (!v) {
        return void 0;
      }
      return v.ghostTexts;
    });
    this.primaryGhostText = derivedOpts({ owner: this, equalsFn: ghostTextOrReplacementEquals }, (reader) => {
      const v = this.inlineCompletionState.read(reader);
      if (!v) {
        return void 0;
      }
      return v?.primaryGhostText;
    });
    this.showCollapsed = derived(this, (reader) => {
      const state = this.state.read(reader);
      if (!state || state.kind !== "inlineEdit") {
        return false;
      }
      if (state.inlineCompletion.displayLocation) {
        return false;
      }
      const isCurrentModelVersion = state.inlineCompletion.updatedEditModelVersion === this._textModelVersionId.read(reader);
      return (this._inlineEditsShowCollapsedEnabled.read(reader) || !isCurrentModelVersion) && this._jumpedToId.read(reader) !== state.inlineCompletion.semanticId && !this._inAcceptFlow.read(reader);
    });
    this._tabShouldIndent = derived(this, (reader) => {
      if (this._inAcceptFlow.read(reader)) {
        return false;
      }
      function isMultiLine(range) {
        return range.startLineNumber !== range.endLineNumber;
      }
      function getNonIndentationRange(model, lineNumber) {
        const columnStart = model.getLineIndentColumn(lineNumber);
        const lastNonWsColumn = model.getLineLastNonWhitespaceColumn(lineNumber);
        const columnEnd = Math.max(lastNonWsColumn, columnStart);
        return new Range(lineNumber, columnStart, lineNumber, columnEnd);
      }
      const selections = this._editorObs.selections.read(reader);
      return selections?.some((s) => {
        if (s.isEmpty()) {
          return this.textModel.getLineLength(s.startLineNumber) === 0;
        } else {
          return isMultiLine(s) || s.containsRange(getNonIndentationRange(this.textModel, s.startLineNumber));
        }
      });
    });
    this.tabShouldJumpToInlineEdit = derived(this, (reader) => {
      if (this._tabShouldIndent.read(reader)) {
        return false;
      }
      const s = this.inlineEditState.read(reader);
      if (!s) {
        return false;
      }
      if (this.showCollapsed.read(reader)) {
        return true;
      }
      if (this._inAcceptFlow.read(reader) && this._appearedInsideViewport.read(reader)) {
        return false;
      }
      return !s.cursorAtInlineEdit.read(reader);
    });
    this.tabShouldAcceptInlineEdit = derived(this, (reader) => {
      const s = this.inlineEditState.read(reader);
      if (!s) {
        return false;
      }
      if (this.showCollapsed.read(reader)) {
        return false;
      }
      if (this._inAcceptFlow.read(reader) && this._appearedInsideViewport.read(reader)) {
        return true;
      }
      if (s.inlineCompletion.targetRange.startLineNumber === this._editorObs.cursorLineNumber.read(reader)) {
        return true;
      }
      if (this._jumpedToId.read(reader) === s.inlineCompletion.semanticId) {
        return true;
      }
      if (this._tabShouldIndent.read(reader)) {
        return false;
      }
      return s.cursorAtInlineEdit.read(reader);
    });
    this._jumpedToId = observableValue(this, void 0);
    this._inAcceptFlow = observableValue(this, false);
    this.inAcceptFlow = this._inAcceptFlow;
    this._source = this._register(this._instantiationService.createInstance(InlineCompletionsSource, this.textModel, this._textModelVersionId, this._debounceValue, this.primaryPosition));
    this.lastTriggerKind = this._source.inlineCompletions.map(this, (v) => v?.request?.context.triggerKind);
    this._editorObs = observableCodeEditor(this._editor);
    const suggest = this._editorObs.getOption(
      134
      /* EditorOption.suggest */
    );
    this._suggestPreviewEnabled = suggest.map((v) => v.preview);
    this._suggestPreviewMode = suggest.map((v) => v.previewMode);
    const inlineSuggest = this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    );
    this._inlineSuggestMode = inlineSuggest.map((v) => v.mode);
    this._suppressedInlineCompletionGroupIds = inlineSuggest.map((v) => new Set(v.experimental.suppressInlineSuggestions.split(",")));
    this._inlineEditsEnabled = inlineSuggest.map((v) => !!v.edits.enabled);
    this._inlineEditsShowCollapsedEnabled = inlineSuggest.map((s) => s.edits.showCollapsed);
    this._triggerCommandOnProviderChange = inlineSuggest.map((s) => s.triggerCommandOnProviderChange);
    this._minShowDelay = inlineSuggest.map((s) => s.minShowDelay);
    this._showOnSuggestConflict = inlineSuggest.map((s) => s.experimental.showOnSuggestConflict);
    this._suppressInSnippetMode = inlineSuggest.map((s) => s.suppressInSnippetMode);
    const snippetController = SnippetController2.get(this._editor);
    this._isInSnippetMode = snippetController?.isInSnippetObservable ?? constObservable(false);
    this._typing = this._register(new TypingInterval(this.textModel));
    this._register(this._inlineCompletionsService.onDidChangeIsSnoozing((isSnoozing) => {
      if (isSnoozing) {
        this.stop();
      }
    }));
    {
      const isNotebook = this.textModel.uri.scheme === "vscode-notebook-cell";
      const [diffEditor] = this._codeEditorService.listDiffEditors().filter((d) => d.getOriginalEditor().getId() === this._editor.getId() || d.getModifiedEditor().getId() === this._editor.getId());
      this.isInDiffEditor = !!diffEditor;
      this.editorType = isNotebook ? InlineCompletionEditorType.Notebook : this.isInDiffEditor ? InlineCompletionEditorType.DiffEditor : InlineCompletionEditorType.TextEditor;
    }
    this._register(recomputeInitiallyAndOnChange(this.state, (s) => {
      if (s && s.inlineCompletion) {
        this._inlineCompletionsService.reportNewCompletion(s.inlineCompletion.requestUuid);
      }
    }));
    this._register(recomputeInitiallyAndOnChange(this._fetchInlineCompletionsPromise));
    this._register(autorun((reader) => {
      this._editorObs.versionId.read(reader);
      this._inAcceptFlow.set(false, void 0);
    }));
    this._register(autorun((reader) => {
      const jumpToReset = this.state.map((s, reader2) => !s || s.kind === "inlineEdit" && !s.cursorAtInlineEdit.read(reader2)).read(reader);
      if (jumpToReset) {
        this._jumpedToId.set(void 0, void 0);
      }
    }));
    const inlineEditSemanticId = this.inlineEditState.map((s) => s?.inlineCompletion.semanticId);
    this._register(autorun((reader) => {
      const id = inlineEditSemanticId.read(reader);
      if (id) {
        this._editor.pushUndoStop();
        this._lastShownInlineCompletionInfo = {
          alternateTextModelVersionId: this.textModel.getAlternativeVersionId(),
          inlineCompletion: this.state.get().inlineCompletion
        };
      }
    }));
    const inlineCompletionProviders = observableFromEvent(this._languageFeaturesService.inlineCompletionsProvider.onDidChange, () => this._languageFeaturesService.inlineCompletionsProvider.all(textModel));
    mapObservableArrayCached(this, inlineCompletionProviders, (provider, store) => {
      if (!provider.onDidChangeInlineCompletions) {
        return;
      }
      store.add(provider.onDidChangeInlineCompletions(() => {
        if (!this._enabled.get()) {
          return;
        }
        const activeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
        if (activeEditor !== this._editor) {
          return;
        }
        if (this._triggerCommandOnProviderChange.get()) {
          this.trigger(void 0, { onlyFetchInlineEdits: true });
          return;
        }
        const activeState = this.state.get();
        if (activeState && (activeState.inlineCompletion || activeState.edits) && activeState.inlineCompletion?.source.provider !== provider) {
          return;
        }
        transaction((tx) => {
          this._fetchSpecificProviderSignal.trigger(tx, provider);
          this.trigger(tx);
        });
      }));
    }).recomputeInitiallyAndOnChange(this._store);
    this._didUndoInlineEdits.recomputeInitiallyAndOnChange(this._store);
  }
  getIndentationInfo(reader) {
    let startsWithIndentation = false;
    let startsWithIndentationLessThanTabSize = true;
    const ghostText = this?.primaryGhostText.read(reader);
    if (!!this?._selectedSuggestItem && ghostText && ghostText.parts.length > 0) {
      const { column, lines } = ghostText.parts[0];
      const firstLine = lines[0].line;
      const indentationEndColumn = this.textModel.getLineIndentColumn(ghostText.lineNumber);
      const inIndentation = column <= indentationEndColumn;
      if (inIndentation) {
        let firstNonWsIdx = firstNonWhitespaceIndex(firstLine);
        if (firstNonWsIdx === -1) {
          firstNonWsIdx = firstLine.length - 1;
        }
        startsWithIndentation = firstNonWsIdx > 0;
        const tabSize = this.textModel.getOptions().tabSize;
        const visibleColumnIndentation = CursorColumns.visibleColumnFromColumn(firstLine, firstNonWsIdx + 1, tabSize);
        startsWithIndentationLessThanTabSize = visibleColumnIndentation < tabSize;
      }
    }
    return {
      startsWithIndentation,
      startsWithIndentationLessThanTabSize
    };
  }
  _getReason(e) {
    if (e?.isUndoing) {
      return VersionIdChangeReason.Undo;
    }
    if (e?.isRedoing) {
      return VersionIdChangeReason.Redo;
    }
    if (this.isAcceptingPartially) {
      return VersionIdChangeReason.AcceptWord;
    }
    return VersionIdChangeReason.Other;
  }
  // TODO: This is not an ideal implementation of excludesGroupIds, however as this is currently still behind proposed API
  // and due to the time constraints, we are using a simplified approach
  getAvailableProviders(providers) {
    const suppressedProviderGroupIds = this._suppressedInlineCompletionGroupIds.get();
    const unsuppressedProviders = providers.filter((provider) => !(provider.groupId && suppressedProviderGroupIds.has(provider.groupId)));
    const excludedGroupIds = /* @__PURE__ */ new Set();
    for (const provider of unsuppressedProviders) {
      provider.excludesGroupIds?.forEach((p) => excludedGroupIds.add(p));
    }
    const availableProviders = [];
    for (const provider of unsuppressedProviders) {
      if (provider.groupId && excludedGroupIds.has(provider.groupId)) {
        continue;
      }
      availableProviders.push(provider);
    }
    return availableProviders;
  }
  async trigger(tx, options) {
    subtransaction(tx, (tx2) => {
      if (options?.onlyFetchInlineEdits) {
        this._onlyRequestInlineEditsSignal.trigger(tx2);
      }
      if (options?.noDelay) {
        this._noDelaySignal.trigger(tx2);
      }
      this._isActive.set(true, tx2);
    });
    await this._fetchInlineCompletionsPromise.get();
  }
  async triggerExplicitly(tx, onlyFetchInlineEdits = false) {
    subtransaction(tx, (tx2) => {
      if (onlyFetchInlineEdits) {
        this._onlyRequestInlineEditsSignal.trigger(tx2);
      }
      this._isActive.set(true, tx2);
      this._inAcceptFlow.set(true, tx2);
      this._forceUpdateExplicitlySignal.trigger(tx2);
    });
    await this._fetchInlineCompletionsPromise.get();
  }
  stop(stopReason = "automatic", tx) {
    subtransaction(tx, (tx2) => {
      if (stopReason === "explicitCancel") {
        const inlineCompletion = this.state.get()?.inlineCompletion;
        if (inlineCompletion) {
          inlineCompletion.reportEndOfLife({ kind: InlineCompletionEndOfLifeReasonKind.Rejected });
        }
      }
      this._isActive.set(false, tx2);
      this._source.clear(tx2);
    });
  }
  _computeAugmentation(suggestCompletion, reader) {
    const model = this.textModel;
    const suggestWidgetInlineCompletions = this._source.suggestWidgetInlineCompletions.read(reader);
    const candidateInlineCompletions = suggestWidgetInlineCompletions ? suggestWidgetInlineCompletions.inlineCompletions.filter((c) => !c.isInlineEdit) : [this.selectedInlineCompletion.read(reader)].filter(isDefined);
    const augmentedCompletion = mapFindFirst(candidateInlineCompletions, (completion) => {
      let r = completion.getSingleTextEdit();
      r = singleTextRemoveCommonPrefix(r, model, Range.fromPositions(r.range.getStartPosition(), suggestCompletion.range.getEndPosition()));
      return singleTextEditAugments(r, suggestCompletion) ? { completion, edit: r } : void 0;
    });
    return augmentedCompletion;
  }
  async _deltaSelectedInlineCompletionIndex(delta) {
    await this.triggerExplicitly();
    const completions = this._filteredInlineCompletionItems.get() || [];
    if (completions.length > 0) {
      const newIdx = (this.selectedInlineCompletionIndex.get() + delta + completions.length) % completions.length;
      this._selectedInlineCompletionId.set(completions[newIdx].semanticId, void 0);
    } else {
      this._selectedInlineCompletionId.set(void 0, void 0);
    }
  }
  async next() {
    await this._deltaSelectedInlineCompletionIndex(1);
  }
  async previous() {
    await this._deltaSelectedInlineCompletionIndex(-1);
  }
  _getMetadata(completion, languageId, type = void 0) {
    if (type) {
      return EditSources.inlineCompletionPartialAccept({
        nes: completion.isInlineEdit,
        requestUuid: completion.requestUuid,
        providerId: completion.source.provider.providerId,
        languageId,
        type
      });
    } else {
      return EditSources.inlineCompletionAccept({
        nes: completion.isInlineEdit,
        requestUuid: completion.requestUuid,
        providerId: completion.source.provider.providerId,
        languageId
      });
    }
  }
  async accept(editor2 = this._editor) {
    if (editor2.getModel() !== this.textModel) {
      throw new BugIndicatingError();
    }
    let completion;
    let isNextEditUri = false;
    const state = this.state.get();
    if (state?.kind === "ghostText") {
      if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {
        return;
      }
      completion = state.inlineCompletion;
    } else if (state?.kind === "inlineEdit") {
      completion = state.inlineCompletion;
      isNextEditUri = !!state.nextEditUri;
    } else {
      return;
    }
    completion.addRef();
    try {
      editor2.pushUndoStop();
      if (isNextEditUri) {
      } else if (completion.snippetInfo) {
        const mainEdit = TextReplacement.delete(completion.editRange);
        const additionalEdits = completion.additionalTextEdits.map((e) => new TextReplacement(Range.lift(e.range), e.text ?? ""));
        const edit = TextEdit.fromParallelReplacementsUnsorted([mainEdit, ...additionalEdits]);
        editor2.edit(edit, this._getMetadata(completion, this.textModel.getLanguageId()));
        editor2.setPosition(completion.snippetInfo.range.getStartPosition(), "inlineCompletionAccept");
        SnippetController2.get(editor2)?.insert(completion.snippetInfo.snippet, { undoStopBefore: false });
      } else {
        const edits = state.edits;
        let minimalEdits = edits;
        if (state.kind === "ghostText") {
          minimalEdits = removeTextReplacementCommonSuffixPrefix(edits, this.textModel);
        }
        const selections = getEndPositionsAfterApplying(minimalEdits).map((p) => Selection.fromPositions(p));
        const additionalEdits = completion.additionalTextEdits.map((e) => new TextReplacement(Range.lift(e.range), e.text ?? ""));
        const edit = TextEdit.fromParallelReplacementsUnsorted([...edits, ...additionalEdits]);
        editor2.edit(edit, this._getMetadata(completion, this.textModel.getLanguageId()));
        if (completion.displayLocation === void 0) {
          editor2.setSelections(state.kind === "inlineEdit" ? selections.slice(-1) : selections, "inlineCompletionAccept");
        }
        if (state.kind === "inlineEdit" && !this._accessibilityService.isMotionReduced()) {
          const editRanges = edit.getNewRanges();
          const dec = this._store.add(new FadeoutDecoration(editor2, editRanges, () => {
            this._store.delete(dec);
          }));
        }
      }
      this._onDidAccept.fire();
      this.stop();
      if (completion.command) {
        await this._commandService.executeCommand(completion.command.id, ...completion.command.arguments || []).then(void 0, onUnexpectedExternalError);
      }
      completion.reportEndOfLife({ kind: InlineCompletionEndOfLifeReasonKind.Accepted });
    } finally {
      completion.removeRef();
      this._inAcceptFlow.set(true, void 0);
      this._lastAcceptedInlineCompletionInfo = { textModelVersionIdAfter: this.textModel.getVersionId(), inlineCompletion: completion };
    }
  }
  async acceptNextWord() {
    await this._acceptNext(
      this._editor,
      "word",
      (pos, text) => {
        const langId = this.textModel.getLanguageIdAtPosition(pos.lineNumber, pos.column);
        const config = this._languageConfigurationService.getLanguageConfiguration(langId);
        const wordRegExp = new RegExp(config.wordDefinition.source, config.wordDefinition.flags.replace("g", ""));
        const m1 = text.match(wordRegExp);
        let acceptUntilIndexExclusive = 0;
        if (m1 && m1.index !== void 0) {
          if (m1.index === 0) {
            acceptUntilIndexExclusive = m1[0].length;
          } else {
            acceptUntilIndexExclusive = m1.index;
          }
        } else {
          acceptUntilIndexExclusive = text.length;
        }
        const wsRegExp = /\s+/g;
        const m2 = wsRegExp.exec(text);
        if (m2 && m2.index !== void 0) {
          if (m2.index + m2[0].length < acceptUntilIndexExclusive) {
            acceptUntilIndexExclusive = m2.index + m2[0].length;
          }
        }
        return acceptUntilIndexExclusive;
      },
      0
      /* PartialAcceptTriggerKind.Word */
    );
  }
  async acceptNextLine() {
    await this._acceptNext(
      this._editor,
      "line",
      (pos, text) => {
        const m = text.match(/\n/);
        if (m && m.index !== void 0) {
          return m.index + 1;
        }
        return text.length;
      },
      1
      /* PartialAcceptTriggerKind.Line */
    );
  }
  async _acceptNext(editor2, type, getAcceptUntilIndex, kind) {
    if (editor2.getModel() !== this.textModel) {
      throw new BugIndicatingError();
    }
    const state = this.inlineCompletionState.get();
    if (!state || state.primaryGhostText.isEmpty() || !state.inlineCompletion) {
      return;
    }
    const ghostText = state.primaryGhostText;
    const completion = state.inlineCompletion;
    if (completion.snippetInfo) {
      await this.accept(editor2);
      return;
    }
    const firstPart = ghostText.parts[0];
    const ghostTextPos = new Position(ghostText.lineNumber, firstPart.column);
    const ghostTextVal = firstPart.text;
    const acceptUntilIndexExclusive = getAcceptUntilIndex(ghostTextPos, ghostTextVal);
    if (acceptUntilIndexExclusive === ghostTextVal.length && ghostText.parts.length === 1) {
      this.accept(editor2);
      return;
    }
    const partialGhostTextVal = ghostTextVal.substring(0, acceptUntilIndexExclusive);
    const positions = this._positions.get();
    const cursorPosition = positions[0];
    completion.addRef();
    try {
      this._isAcceptingPartially = true;
      try {
        editor2.pushUndoStop();
        const replaceRange = Range.fromPositions(cursorPosition, ghostTextPos);
        const newText = editor2.getModel().getValueInRange(replaceRange) + partialGhostTextVal;
        const primaryEdit = new TextReplacement(replaceRange, newText);
        const edits = [primaryEdit, ...getSecondaryEdits(this.textModel, positions, primaryEdit)].filter(isDefined);
        const selections = getEndPositionsAfterApplying(edits).map((p) => Selection.fromPositions(p));
        editor2.edit(TextEdit.fromParallelReplacementsUnsorted(edits), this._getMetadata(completion, type));
        editor2.setSelections(selections, "inlineCompletionPartialAccept");
        editor2.revealPositionInCenterIfOutsideViewport(
          editor2.getPosition(),
          1
          /* ScrollType.Immediate */
        );
      } finally {
        this._isAcceptingPartially = false;
      }
      const acceptedRange = Range.fromPositions(completion.editRange.getStartPosition(), TextLength.ofText(partialGhostTextVal).addToPosition(ghostTextPos));
      const text = editor2.getModel().getValueInRange(
        acceptedRange,
        1
        /* EndOfLinePreference.LF */
      );
      const acceptedLength = text.length;
      completion.reportPartialAccept(acceptedLength, { kind, acceptedLength }, { characters: acceptUntilIndexExclusive, ratio: acceptUntilIndexExclusive / ghostTextVal.length, count: 1 });
    } finally {
      completion.removeRef();
    }
  }
  handleSuggestAccepted(item) {
    const itemEdit = singleTextRemoveCommonPrefix(item.getSingleTextEdit(), this.textModel);
    const augmentedCompletion = this._computeAugmentation(itemEdit, void 0);
    if (!augmentedCompletion) {
      return;
    }
    const alreadyAcceptedLength = this.textModel.getValueInRange(
      augmentedCompletion.completion.editRange,
      1
      /* EndOfLinePreference.LF */
    ).length;
    const acceptedLength = alreadyAcceptedLength + itemEdit.text.length;
    augmentedCompletion.completion.reportPartialAccept(itemEdit.text.length, {
      kind: 2,
      acceptedLength
    }, {
      characters: itemEdit.text.length,
      count: 1,
      ratio: 1
    });
  }
  extractReproSample() {
    const value = this.textModel.getValue();
    const item = this.state.get()?.inlineCompletion;
    return {
      documentValue: value,
      inlineCompletion: item?.getSourceCompletion()
    };
  }
  jump() {
    const s = this.inlineEditState.get();
    if (!s) {
      return;
    }
    transaction((tx) => {
      this._jumpedToId.set(s.inlineCompletion.semanticId, tx);
      this.dontRefetchSignal.trigger(tx);
      const targetRange = s.inlineCompletion.targetRange;
      const targetPosition = targetRange.getStartPosition();
      this._editor.setPosition(targetPosition, "inlineCompletions.jump");
      const isSingleLineChange = targetRange.isSingleLine() && (s.inlineCompletion.displayLocation || !s.inlineCompletion.insertText.includes("\n"));
      if (isSingleLineChange) {
        this._editor.revealPosition(targetPosition);
      } else {
        const revealRange = new Range(targetRange.startLineNumber - 1, 1, targetRange.endLineNumber + 1, 1);
        this._editor.revealRange(
          revealRange,
          1
          /* ScrollType.Immediate */
        );
      }
      this._editor.focus();
    });
  }
  async handleInlineSuggestionShown(inlineCompletion, viewKind, viewData) {
    await inlineCompletion.reportInlineEditShown(this._commandService, viewKind, viewData);
  }
};
InlineCompletionsModel = __decorate52([
  __param52(7, IInstantiationService),
  __param52(8, ICommandService),
  __param52(9, ILanguageConfigurationService),
  __param52(10, IAccessibilityService),
  __param52(11, ILanguageFeaturesService),
  __param52(12, ICodeEditorService),
  __param52(13, IInlineCompletionsService)
], InlineCompletionsModel);
var VersionIdChangeReason;
(function(VersionIdChangeReason2) {
  VersionIdChangeReason2[VersionIdChangeReason2["Undo"] = 0] = "Undo";
  VersionIdChangeReason2[VersionIdChangeReason2["Redo"] = 1] = "Redo";
  VersionIdChangeReason2[VersionIdChangeReason2["AcceptWord"] = 2] = "AcceptWord";
  VersionIdChangeReason2[VersionIdChangeReason2["Other"] = 3] = "Other";
})(VersionIdChangeReason || (VersionIdChangeReason = {}));
function getSecondaryEdits(textModel, positions, primaryTextRepl) {
  if (positions.length === 1) {
    return [];
  }
  const text = new TextModelText(textModel);
  const textTransformer = text.getTransformer();
  const primaryOffset = textTransformer.getOffset(positions[0]);
  const secondaryOffsets = positions.slice(1).map((pos) => textTransformer.getOffset(pos));
  primaryTextRepl = primaryTextRepl.removeCommonPrefixAndSuffix(text);
  const primaryStringRepl = textTransformer.getStringReplacement(primaryTextRepl);
  const deltaFromOffsetToRangeStart = primaryStringRepl.replaceRange.start - primaryOffset;
  const primaryContextRange = primaryStringRepl.replaceRange.join(OffsetRange.emptyAt(primaryOffset));
  const primaryContextValue = text.getValueOfOffsetRange(primaryContextRange);
  const replacements = secondaryOffsets.map((secondaryOffset) => {
    const newRangeStart = secondaryOffset + deltaFromOffsetToRangeStart;
    const newRangeEnd = newRangeStart + primaryStringRepl.replaceRange.length;
    const range = new OffsetRange(newRangeStart, newRangeEnd);
    const contextRange = range.join(OffsetRange.emptyAt(secondaryOffset));
    const contextValue = text.getValueOfOffsetRange(contextRange);
    if (contextValue !== primaryContextValue) {
      return void 0;
    }
    const stringRepl = new StringReplacement(range, primaryStringRepl.newText);
    const repl = textTransformer.getTextReplacement(stringRepl);
    return repl;
  }).filter(isDefined);
  return replacements;
}
var FadeoutDecoration = class extends Disposable {
  constructor(editor2, ranges, onDispose) {
    super();
    if (onDispose) {
      this._register({ dispose: () => onDispose() });
    }
    this._register(observableCodeEditor(editor2).setDecorations(constObservable(ranges.map((range) => ({
      range,
      options: {
        description: "animation",
        className: "edits-fadeout-decoration",
        zIndex: 1
      }
    })))));
    const animation = new AnimatedValue(1, 0, 1e3, easeOutCubic);
    const val = new ObservableAnimatedValue(animation);
    this._register(autorun((reader) => {
      const opacity = val.getValue(reader);
      editor2.getContainerDomNode().style.setProperty("--animation-opacity", opacity.toString());
      if (animation.isFinished()) {
        this.dispose();
      }
    }));
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/suggestWidgetAdapter.js
init_arrays();
init_arraysFind();
init_event();
init_lifecycle();
init_position();
init_range();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
init_arrays();
init_cancellation();
init_errors();
init_event();
init_keybindings();
init_lifecycle();
init_platform();
init_stopwatch();
init_types();
init_editorExtensions();
init_position();
init_range();
init_editorContextKeys();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestMemory.js
init_async();
init_lifecycle();
init_map();
init_languages();
init_configuration();
init_extensions();
init_instantiation();
var __decorate53 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param53 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestMemoryService_1;
var Memory = class {
  constructor(name) {
    this.name = name;
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    const topScore = items[0].score[0];
    for (let i2 = 0; i2 < items.length; i2++) {
      const { score: score2, completion: suggestion } = items[i2];
      if (score2[0] !== topScore) {
        break;
      }
      if (suggestion.preselect) {
        return i2;
      }
    }
    return 0;
  }
};
var NoMemory = class extends Memory {
  constructor() {
    super("first");
  }
  memorize(model, pos, item) {
  }
  toJSON() {
    return void 0;
  }
  fromJSON() {
  }
};
var LRUMemory = class extends Memory {
  constructor() {
    super("recentlyUsed");
    this._cache = new LRUCache(300, 0.66);
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const key = `${model.getLanguageId()}/${item.textLabel}`;
    this._cache.set(key, {
      touch: this._seq++,
      type: item.completion.kind,
      insertText: item.completion.insertText
    });
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
    if (/\s$/.test(lineSuffix)) {
      return super.select(model, pos, items);
    }
    const topScore = items[0].score[0];
    let indexPreselect = -1;
    let indexRecency = -1;
    let seq = -1;
    for (let i2 = 0; i2 < items.length; i2++) {
      if (items[i2].score[0] !== topScore) {
        break;
      }
      const key = `${model.getLanguageId()}/${items[i2].textLabel}`;
      const item = this._cache.peek(key);
      if (item && item.touch > seq && item.type === items[i2].completion.kind && item.insertText === items[i2].completion.insertText) {
        seq = item.touch;
        indexRecency = i2;
      }
      if (items[i2].completion.preselect && indexPreselect === -1) {
        return indexPreselect = i2;
      }
    }
    if (indexRecency !== -1) {
      return indexRecency;
    } else if (indexPreselect !== -1) {
      return indexPreselect;
    } else {
      return 0;
    }
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(data) {
    this._cache.clear();
    const seq = 0;
    for (const [key, value] of data) {
      value.touch = seq;
      value.type = typeof value.type === "number" ? value.type : CompletionItemKinds.fromString(value.type);
      this._cache.set(key, value);
    }
    this._seq = this._cache.size;
  }
};
var PrefixMemory = class extends Memory {
  constructor() {
    super("recentlyUsedByPrefix");
    this._trie = TernarySearchTree.forStrings();
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const { word } = model.getWordUntilPosition(pos);
    const key = `${model.getLanguageId()}/${word}`;
    this._trie.set(key, {
      type: item.completion.kind,
      insertText: item.completion.insertText,
      touch: this._seq++
    });
  }
  select(model, pos, items) {
    const { word } = model.getWordUntilPosition(pos);
    if (!word) {
      return super.select(model, pos, items);
    }
    const key = `${model.getLanguageId()}/${word}`;
    let item = this._trie.get(key);
    if (!item) {
      item = this._trie.findSubstr(key);
    }
    if (item) {
      for (let i2 = 0; i2 < items.length; i2++) {
        const { kind, insertText } = items[i2].completion;
        if (kind === item.type && insertText === item.insertText) {
          return i2;
        }
      }
    }
    return super.select(model, pos, items);
  }
  toJSON() {
    const entries = [];
    this._trie.forEach((value, key) => entries.push([key, value]));
    entries.sort((a, b) => -(a[1].touch - b[1].touch)).forEach((value, i2) => value[1].touch = i2);
    return entries.slice(0, 200);
  }
  fromJSON(data) {
    this._trie.clear();
    if (data.length > 0) {
      this._seq = data[0][1].touch + 1;
      for (const [key, value] of data) {
        value.type = typeof value.type === "number" ? value.type : CompletionItemKinds.fromString(value.type);
        this._trie.set(key, value);
      }
    }
  }
};
var _a39;
var SuggestMemoryService = (_a39 = class {
  constructor(_storageService, _configService) {
    this._storageService = _storageService;
    this._configService = _configService;
    this._disposables = new DisposableStore();
    this._persistSoon = new RunOnceScheduler(() => this._saveState(), 500);
    this._disposables.add(_storageService.onWillSaveState((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        this._saveState();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._persistSoon.dispose();
  }
  memorize(model, pos, item) {
    this._withStrategy(model, pos).memorize(model, pos, item);
    this._persistSoon.schedule();
  }
  select(model, pos, items) {
    return this._withStrategy(model, pos).select(model, pos, items);
  }
  _withStrategy(model, pos) {
    const mode = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: model.getLanguageIdAtPosition(pos.lineNumber, pos.column),
      resource: model.uri
    });
    if (this._strategy?.name !== mode) {
      this._saveState();
      const ctor = SuggestMemoryService_1._strategyCtors.get(mode) || NoMemory;
      this._strategy = new ctor();
      try {
        const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
        const scope = share ? 0 : 1;
        const raw = this._storageService.get(`${SuggestMemoryService_1._storagePrefix}/${mode}`, scope);
        if (raw) {
          this._strategy.fromJSON(JSON.parse(raw));
        }
      } catch (e) {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
      const scope = share ? 0 : 1;
      const raw = JSON.stringify(this._strategy);
      this._storageService.store(
        `${SuggestMemoryService_1._storagePrefix}/${this._strategy.name}`,
        raw,
        scope,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
}, SuggestMemoryService_1 = _a39, _a39._strategyCtors = /* @__PURE__ */ new Map([
  ["recentlyUsedByPrefix", PrefixMemory],
  ["recentlyUsed", LRUMemory],
  ["first", NoMemory]
]), _a39._storagePrefix = "suggest/memories", _a39);
SuggestMemoryService = SuggestMemoryService_1 = __decorate53([
  __param53(0, IStorageService),
  __param53(1, IConfigurationService)
], SuggestMemoryService);
var ISuggestMemoryService = createDecorator("ISuggestMemories");
registerSingleton(
  ISuggestMemoryService,
  SuggestMemoryService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordContextKey.js
init_contextkey();
init_nls();
var __decorate54 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param54 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WordContextKey_1;
var _a40;
var WordContextKey = (_a40 = class {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._enabled = false;
    this._ckAtEnd = WordContextKey_1.AtEnd.bindTo(contextKeyService);
    this._configListener = this._editor.onDidChangeConfiguration((e) => e.hasChanged(
      139
      /* EditorOption.tabCompletion */
    ) && this._update());
    this._update();
  }
  dispose() {
    this._configListener.dispose();
    this._selectionListener?.dispose();
    this._ckAtEnd.reset();
  }
  _update() {
    const enabled = this._editor.getOption(
      139
      /* EditorOption.tabCompletion */
    ) === "on";
    if (this._enabled === enabled) {
      return;
    }
    this._enabled = enabled;
    if (this._enabled) {
      const checkForWordEnd = () => {
        if (!this._editor.hasModel()) {
          this._ckAtEnd.set(false);
          return;
        }
        const model = this._editor.getModel();
        const selection = this._editor.getSelection();
        const word = model.getWordAtPosition(selection.getStartPosition());
        if (!word) {
          this._ckAtEnd.set(false);
          return;
        }
        this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column && selection.getStartPosition().lineNumber === selection.getEndPosition().lineNumber);
      };
      this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);
      checkForWordEnd();
    } else if (this._selectionListener) {
      this._ckAtEnd.reset();
      this._selectionListener.dispose();
      this._selectionListener = void 0;
    }
  }
}, WordContextKey_1 = _a40, _a40.AtEnd = new RawContextKey("atEndOfWord", false, { type: "boolean", description: localize(1479, "A context key that is true when at the end of a word. Note that this is only defined when tab-completions are enabled") }), _a40);
WordContextKey = WordContextKey_1 = __decorate54([
  __param54(1, IContextKeyService)
], WordContextKey);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
init_nls();
init_commands();
init_contextkey();
init_instantiation();
init_log();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestAlternatives.js
init_contextkey();
var __decorate55 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param55 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestAlternatives_1;
var _a41;
var SuggestAlternatives = (_a41 = class {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._index = 0;
    this._ckOtherSuggestions = SuggestAlternatives_1.OtherSuggestions.bindTo(contextKeyService);
  }
  dispose() {
    this.reset();
  }
  reset() {
    this._ckOtherSuggestions.reset();
    this._listener?.dispose();
    this._model = void 0;
    this._acceptNext = void 0;
    this._ignore = false;
  }
  set({ model, index }, acceptNext) {
    if (model.items.length === 0) {
      this.reset();
      return;
    }
    const nextIndex = SuggestAlternatives_1._moveIndex(true, model, index);
    if (nextIndex === index) {
      this.reset();
      return;
    }
    this._acceptNext = acceptNext;
    this._model = model;
    this._index = index;
    this._listener = this._editor.onDidChangeCursorPosition(() => {
      if (!this._ignore) {
        this.reset();
      }
    });
    this._ckOtherSuggestions.set(true);
  }
  static _moveIndex(fwd, model, index) {
    let newIndex = index;
    for (let rounds = model.items.length; rounds > 0; rounds--) {
      newIndex = (newIndex + model.items.length + (fwd ? 1 : -1)) % model.items.length;
      if (newIndex === index) {
        break;
      }
      if (!model.items[newIndex].completion.additionalTextEdits) {
        break;
      }
    }
    return newIndex;
  }
  next() {
    this._move(true);
  }
  prev() {
    this._move(false);
  }
  _move(fwd) {
    if (!this._model) {
      return;
    }
    try {
      this._ignore = true;
      this._index = SuggestAlternatives_1._moveIndex(fwd, this._model, this._index);
      this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
    } finally {
      this._ignore = false;
    }
  }
}, SuggestAlternatives_1 = _a41, _a41.OtherSuggestions = new RawContextKey("hasOtherSuggestions", false), _a41);
SuggestAlternatives = SuggestAlternatives_1 = __decorate55([
  __param55(1, IContextKeyService)
], SuggestAlternatives);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestCommitCharacters.js
init_arrays();
init_lifecycle();
init_characterClassifier();
var CommitCharacterController = class {
  constructor(editor2, widget, model, accept) {
    this._disposables = new DisposableStore();
    this._disposables.add(model.onDidSuggest((e) => {
      if (e.completionModel.items.length === 0) {
        this.reset();
      }
    }));
    this._disposables.add(model.onDidCancel((e) => {
      this.reset();
    }));
    this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));
    this._disposables.add(widget.onDidFocus(this._onItem, this));
    this._disposables.add(widget.onDidHide(this.reset, this));
    this._disposables.add(editor2.onWillType((text) => {
      if (this._active && !widget.isFrozen() && model.state !== 0) {
        const ch = text.charCodeAt(text.length - 1);
        if (this._active.acceptCharacters.has(ch) && editor2.getOption(
          0
          /* EditorOption.acceptSuggestionOnCommitCharacter */
        )) {
          accept(this._active.item);
        }
      }
    }));
  }
  _onItem(selected) {
    if (!selected || !isNonEmptyArray(selected.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === selected.item) {
      return;
    }
    const acceptCharacters = new CharacterSet();
    for (const ch of selected.item.completion.commitCharacters) {
      if (ch.length > 0) {
        acceptCharacters.add(ch.charCodeAt(0));
      }
    }
    this._active = { acceptCharacters, item: selected };
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
init_async();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
init_strings();
init_selection();
init_editorWorker();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordDistance.js
init_arrays();
init_range();

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/bracketSelections.js
init_linkedList();
init_position();
init_range();
var _BracketSelectionRangeProvider = class _BracketSelectionRangeProvider {
  async provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      const ranges = /* @__PURE__ */ new Map();
      await new Promise((resolve) => _BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
      await new Promise((resolve) => _BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
    }
    return result;
  }
  static _bracketsRightYield(resolve, round, model, pos, ranges) {
    const counts = /* @__PURE__ */ new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= _BracketSelectionRangeProvider._maxRounds) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      const bracket = model.bracketPairs.findNextBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      const d = Date.now() - t1;
      if (d > _BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => _BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));
        break;
      }
      if (bracket.bracketInfo.isOpeningBracket) {
        const key = bracket.bracketInfo.bracketText;
        const val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        const key = bracket.bracketInfo.getOpeningBrackets()[0].bracketText;
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          let list = ranges.get(key);
          if (!list) {
            list = new LinkedList();
            ranges.set(key, list);
          }
          list.push(bracket.range);
        }
      }
      pos = bracket.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {
    const counts = /* @__PURE__ */ new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= _BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      const bracket = model.bracketPairs.findPrevBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      const d = Date.now() - t1;
      if (d > _BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => _BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));
        break;
      }
      if (!bracket.bracketInfo.isOpeningBracket) {
        const key = bracket.bracketInfo.getOpeningBrackets()[0].bracketText;
        const val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        const key = bracket.bracketInfo.bracketText;
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          const list = ranges.get(key);
          if (list) {
            const closing = list.shift();
            if (list.size === 0) {
              ranges.delete(key);
            }
            const innerBracket = Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());
            const outerBracket = Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());
            bucket.push({ range: innerBracket });
            bucket.push({ range: outerBracket });
            _BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);
          }
        }
      }
      pos = bracket.range.getStartPosition();
    }
  }
  static _addBracketLeading(model, bracket, bucket) {
    if (bracket.startLineNumber === bracket.endLineNumber) {
      return;
    }
    const startLine = bracket.startLineNumber;
    const column = model.getLineFirstNonWhitespaceColumn(startLine);
    if (column !== 0 && column !== bracket.startColumn) {
      bucket.push({ range: Range.fromPositions(new Position(startLine, column), bracket.getEndPosition()) });
      bucket.push({ range: Range.fromPositions(new Position(startLine, 1), bracket.getEndPosition()) });
    }
    const aboveLine = startLine - 1;
    if (aboveLine > 0) {
      const column2 = model.getLineFirstNonWhitespaceColumn(aboveLine);
      if (column2 === bracket.startColumn && column2 !== model.getLineLastNonWhitespaceColumn(aboveLine)) {
        bucket.push({ range: Range.fromPositions(new Position(aboveLine, column2), bracket.getEndPosition()) });
        bucket.push({ range: Range.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition()) });
      }
    }
  }
};
_BracketSelectionRangeProvider._maxDuration = 30;
_BracketSelectionRangeProvider._maxRounds = 2;
var BracketSelectionRangeProvider = _BracketSelectionRangeProvider;

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordDistance.js
var _WordDistance = class _WordDistance {
  static async create(service, editor2) {
    if (!editor2.getOption(
      134
      /* EditorOption.suggest */
    ).localityBonus) {
      return _WordDistance.None;
    }
    if (!editor2.hasModel()) {
      return _WordDistance.None;
    }
    const model = editor2.getModel();
    const position = editor2.getPosition();
    if (!service.canComputeWordRanges(model.uri)) {
      return _WordDistance.None;
    }
    const [ranges] = await new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
    if (ranges.length === 0) {
      return _WordDistance.None;
    }
    const wordRanges = await service.computeWordRanges(model.uri, ranges[0].range);
    if (!wordRanges) {
      return _WordDistance.None;
    }
    const wordUntilPos = model.getWordUntilPosition(position);
    delete wordRanges[wordUntilPos.word];
    return new class extends _WordDistance {
      distance(anchor, item) {
        if (!position.equals(editor2.getPosition())) {
          return 0;
        }
        if (item.kind === 17) {
          return 2 << 20;
        }
        const word = typeof item.label === "string" ? item.label : item.label.label;
        const wordLines = wordRanges[word];
        if (isFalsyOrEmpty(wordLines)) {
          return 2 << 20;
        }
        const idx = binarySearch(wordLines, Range.fromPositions(anchor), Range.compareRangesUsingStarts);
        const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
        let blockDistance = ranges.length;
        for (const range of ranges) {
          if (!Range.containsRange(range.range, bestWordRange)) {
            break;
          }
          blockDistance -= 1;
        }
        return blockDistance;
      }
    }();
  }
};
_WordDistance.None = new class extends _WordDistance {
  distance() {
    return 0;
  }
}();
var WordDistance = _WordDistance;

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
init_configuration();
init_contextkey();
init_log();
init_telemetry();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/completionModel.js
init_arrays();
init_filters();
init_strings();
var LineContext = class {
  constructor(leadingLineContent, characterCountDelta) {
    this.leadingLineContent = leadingLineContent;
    this.characterCountDelta = characterCountDelta;
  }
};
var CompletionModel = class _CompletionModel {
  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, fuzzyScoreOptions = FuzzyScoreOptions.default, clipboardText = void 0) {
    this.clipboardText = clipboardText;
    this._snippetCompareFn = _CompletionModel._compareCompletionItems;
    this._items = items;
    this._column = column;
    this._wordDistance = wordDistance;
    this._options = options;
    this._refilterKind = 1;
    this._lineContext = lineContext;
    this._fuzzyScoreOptions = fuzzyScoreOptions;
    if (snippetSuggestions === "top") {
      this._snippetCompareFn = _CompletionModel._compareCompletionItemsSnippetsUp;
    } else if (snippetSuggestions === "bottom") {
      this._snippetCompareFn = _CompletionModel._compareCompletionItemsSnippetsDown;
    }
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(value) {
    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
      this._lineContext = value;
    }
  }
  get items() {
    this._ensureCachedState();
    return this._filteredItems;
  }
  getItemsByProvider() {
    this._ensureCachedState();
    return this._itemsByProvider;
  }
  getIncompleteProvider() {
    this._ensureCachedState();
    const result = /* @__PURE__ */ new Set();
    for (const [provider, items] of this.getItemsByProvider()) {
      if (items.length > 0 && items[0].container.incomplete) {
        result.add(provider);
      }
    }
    return result;
  }
  get stats() {
    this._ensureCachedState();
    return this._stats;
  }
  _ensureCachedState() {
    if (this._refilterKind !== 0) {
      this._createCachedState();
    }
  }
  _createCachedState() {
    this._itemsByProvider = /* @__PURE__ */ new Map();
    const labelLengths = [];
    const { leadingLineContent, characterCountDelta } = this._lineContext;
    let word = "";
    let wordLow = "";
    const source = this._refilterKind === 1 ? this._items : this._filteredItems;
    const target = [];
    const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
    for (let i2 = 0; i2 < source.length; i2++) {
      const item = source[i2];
      if (item.isInvalid) {
        continue;
      }
      const arr = this._itemsByProvider.get(item.provider);
      if (arr) {
        arr.push(item);
      } else {
        this._itemsByProvider.set(item.provider, [item]);
      }
      const overwriteBefore = item.position.column - item.editStart.column;
      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);
      if (word.length !== wordLen) {
        word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
        wordLow = word.toLowerCase();
      }
      item.word = word;
      if (wordLen === 0) {
        item.score = FuzzyScore.Default;
      } else {
        let wordPos = 0;
        while (wordPos < overwriteBefore) {
          const ch = word.charCodeAt(wordPos);
          if (ch === 32 || ch === 9) {
            wordPos += 1;
          } else {
            break;
          }
        }
        if (wordPos >= wordLen) {
          item.score = FuzzyScore.Default;
        } else if (typeof item.completion.filterText === "string") {
          const match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);
          if (!match) {
            continue;
          }
          if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {
            item.score = match;
          } else {
            item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);
            item.score[0] = match[0];
          }
        } else {
          const match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);
          if (!match) {
            continue;
          }
          item.score = match;
        }
      }
      item.idx = i2;
      item.distance = this._wordDistance.distance(item.position, item.completion);
      target.push(item);
      labelLengths.push(item.textLabel.length);
    }
    this._filteredItems = target.sort(this._snippetCompareFn);
    this._refilterKind = 0;
    this._stats = {
      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - 0.85, labelLengths, (a, b) => a - b) : 0
    };
  }
  static _compareCompletionItems(a, b) {
    if (a.score[0] > b.score[0]) {
      return -1;
    } else if (a.score[0] < b.score[0]) {
      return 1;
    } else if (a.distance < b.distance) {
      return -1;
    } else if (a.distance > b.distance) {
      return 1;
    } else if (a.idx < b.idx) {
      return -1;
    } else if (a.idx > b.idx) {
      return 1;
    } else {
      return 0;
    }
  }
  static _compareCompletionItemsSnippetsDown(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 28) {
        return 1;
      } else if (b.completion.kind === 28) {
        return -1;
      }
    }
    return _CompletionModel._compareCompletionItems(a, b);
  }
  static _compareCompletionItemsSnippetsUp(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 28) {
        return -1;
      } else if (b.completion.kind === 28) {
        return 1;
      }
    }
    return _CompletionModel._compareCompletionItems(a, b);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
init_languageFeatures();
init_filters();
init_types();
init_environment();
var __decorate56 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param56 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestModel_1;
var LineContext2 = class {
  static shouldAutoTrigger(editor2) {
    if (!editor2.hasModel()) {
      return false;
    }
    const model = editor2.getModel();
    const pos = editor2.getPosition();
    model.tokenization.tokenizeIfCheap(pos.lineNumber);
    const word = model.getWordAtPosition(pos);
    if (!word) {
      return false;
    }
    if (word.endColumn !== pos.column && word.startColumn + 1 !== pos.column) {
      return false;
    }
    if (!isNaN(Number(word.word))) {
      return false;
    }
    return true;
  }
  constructor(model, position, triggerOptions) {
    this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
    this.leadingWord = model.getWordUntilPosition(position);
    this.lineNumber = position.lineNumber;
    this.column = position.column;
    this.triggerOptions = triggerOptions;
  }
};
function canShowQuickSuggest(editor2, contextKeyService, configurationService) {
  if (!Boolean(contextKeyService.getContextKeyValue(InlineCompletionContextKeys.inlineSuggestionVisible.key))) {
    return true;
  }
  const suppressSuggestions = contextKeyService.getContextKeyValue(InlineCompletionContextKeys.suppressSuggestions.key);
  if (suppressSuggestions !== void 0) {
    return !suppressSuggestions;
  }
  return !editor2.getOption(
    71
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
function canShowSuggestOnTriggerCharacters(editor2, contextKeyService, configurationService) {
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const suppressSuggestions = contextKeyService.getContextKeyValue(InlineCompletionContextKeys.suppressSuggestions.key);
  if (suppressSuggestions !== void 0) {
    return !suppressSuggestions;
  }
  return !editor2.getOption(
    71
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
var SuggestModel = SuggestModel_1 = class SuggestModel2 {
  constructor(_editor, _editorWorkerService, _clipboardService, _telemetryService, _logService, _contextKeyService, _configurationService, _languageFeaturesService, _envService) {
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._clipboardService = _clipboardService;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._envService = _envService;
    this._toDispose = new DisposableStore();
    this._triggerCharacterListener = new DisposableStore();
    this._triggerQuickSuggest = new TimeoutTimer();
    this._triggerState = void 0;
    this._completionDisposables = new DisposableStore();
    this._onDidCancel = new Emitter();
    this._onDidTrigger = new Emitter();
    this._onDidSuggest = new Emitter();
    this.onDidCancel = this._onDidCancel.event;
    this.onDidTrigger = this._onDidTrigger.event;
    this.onDidSuggest = this._onDidSuggest.event;
    this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1);
    this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
    }));
    this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
      this._updateTriggerCharacters();
      this._updateActiveSuggestSession();
    }));
    let editorIsComposing = false;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      editorIsComposing = true;
    }));
    this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      editorIsComposing = false;
      this._onCompositionEnd();
    }));
    this._toDispose.add(this._editor.onDidChangeCursorSelection((e) => {
      if (!editorIsComposing) {
        this._onCursorChange(e);
      }
    }));
    this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!editorIsComposing && this._triggerState !== void 0) {
        this._refilterCompletionItems();
      }
    }));
    this._updateTriggerCharacters();
  }
  dispose() {
    dispose(this._triggerCharacterListener);
    dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);
    this._toDispose.dispose();
    this._completionDisposables.dispose();
    this.cancel();
  }
  _updateTriggerCharacters() {
    this._triggerCharacterListener.clear();
    if (this._editor.getOption(
      104
      /* EditorOption.readOnly */
    ) || !this._editor.hasModel() || !this._editor.getOption(
      137
      /* EditorOption.suggestOnTriggerCharacters */
    )) {
      return;
    }
    const supportsByTriggerCharacter = /* @__PURE__ */ new Map();
    for (const support of this._languageFeaturesService.completionProvider.all(this._editor.getModel())) {
      for (const ch of support.triggerCharacters || []) {
        let set = supportsByTriggerCharacter.get(ch);
        if (!set) {
          set = /* @__PURE__ */ new Set();
          const suggestSupport = getSnippetSuggestSupport();
          if (suggestSupport) {
            set.add(suggestSupport);
          }
          supportsByTriggerCharacter.set(ch, set);
        }
        set.add(support);
      }
    }
    const checkTriggerCharacter = (text) => {
      if (!canShowSuggestOnTriggerCharacters(this._editor, this._contextKeyService, this._configurationService)) {
        return;
      }
      if (LineContext2.shouldAutoTrigger(this._editor)) {
        return;
      }
      if (!text) {
        const position = this._editor.getPosition();
        const model = this._editor.getModel();
        text = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
      }
      let lastChar = "";
      if (isLowSurrogate(text.charCodeAt(text.length - 1))) {
        if (isHighSurrogate(text.charCodeAt(text.length - 2))) {
          lastChar = text.substr(text.length - 2);
        }
      } else {
        lastChar = text.charAt(text.length - 1);
      }
      const supports = supportsByTriggerCharacter.get(lastChar);
      if (supports) {
        const providerItemsToReuse = /* @__PURE__ */ new Map();
        if (this._completionModel) {
          for (const [provider, items] of this._completionModel.getItemsByProvider()) {
            if (!supports.has(provider)) {
              providerItemsToReuse.set(provider, items);
            }
          }
        }
        this.trigger({
          auto: true,
          triggerKind: 1,
          triggerCharacter: lastChar,
          retrigger: Boolean(this._completionModel),
          clipboardText: this._completionModel?.clipboardText,
          completionOptions: { providerFilter: supports, providerItemsToReuse }
        });
      }
    };
    this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));
    this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => checkTriggerCharacter()));
  }
  // --- trigger/retrigger/cancel suggest
  get state() {
    if (!this._triggerState) {
      return 0;
    } else if (!this._triggerState.auto) {
      return 1;
    } else {
      return 2;
    }
  }
  cancel(retrigger = false) {
    if (this._triggerState !== void 0) {
      this._triggerQuickSuggest.cancel();
      this._requestToken?.cancel();
      this._requestToken = void 0;
      this._triggerState = void 0;
      this._completionModel = void 0;
      this._context = void 0;
      this._onDidCancel.fire({ retrigger });
    }
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    if (this._triggerState !== void 0) {
      if (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel())) {
        this.cancel();
      } else {
        this.trigger({ auto: this._triggerState.auto, retrigger: true });
      }
    }
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    const prevSelection = this._currentSelection;
    this._currentSelection = this._editor.getSelection();
    if (!e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    if (this._triggerState === void 0 && e.reason === 0) {
      if (prevSelection.containsRange(this._currentSelection) || prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {
        this._doTriggerQuickSuggest();
      }
    } else if (this._triggerState !== void 0 && e.reason === 3) {
      this._refilterCompletionItems();
    }
  }
  _onCompositionEnd() {
    if (this._triggerState === void 0) {
      this._doTriggerQuickSuggest();
    } else {
      this._refilterCompletionItems();
    }
  }
  _doTriggerQuickSuggest() {
    if (QuickSuggestionsOptions.isAllOff(this._editor.getOption(
      102
      /* EditorOption.quickSuggestions */
    ))) {
      return;
    }
    if (this._editor.getOption(
      134
      /* EditorOption.suggest */
    ).snippetsPreventQuickSuggestions && SnippetController2.get(this._editor)?.isInSnippet()) {
      return;
    }
    this.cancel();
    this._triggerQuickSuggest.cancelAndSet(() => {
      if (this._triggerState !== void 0) {
        return;
      }
      if (!LineContext2.shouldAutoTrigger(this._editor)) {
        return;
      }
      if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
        return;
      }
      const model = this._editor.getModel();
      const pos = this._editor.getPosition();
      const config = this._editor.getOption(
        102
        /* EditorOption.quickSuggestions */
      );
      if (QuickSuggestionsOptions.isAllOff(config)) {
        return;
      }
      if (!QuickSuggestionsOptions.isAllOn(config)) {
        model.tokenization.tokenizeIfCheap(pos.lineNumber);
        const lineTokens = model.tokenization.getLineTokens(pos.lineNumber);
        const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
        if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "on") {
          return;
        }
      }
      if (!canShowQuickSuggest(this._editor, this._contextKeyService, this._configurationService)) {
        return;
      }
      if (!this._languageFeaturesService.completionProvider.has(model)) {
        return;
      }
      this.trigger({ auto: true });
    }, this._editor.getOption(
      103
      /* EditorOption.quickSuggestionsDelay */
    ));
  }
  _refilterCompletionItems() {
    assertType(this._editor.hasModel());
    assertType(this._triggerState !== void 0);
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    const ctx = new LineContext2(model, position, { ...this._triggerState, refilter: true });
    this._onNewContext(ctx);
  }
  trigger(options) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const ctx = new LineContext2(model, this._editor.getPosition(), options);
    this.cancel(options.retrigger);
    this._triggerState = options;
    this._onDidTrigger.fire({ auto: options.auto, shy: options.shy ?? false, position: this._editor.getPosition() });
    this._context = ctx;
    let suggestCtx = {
      triggerKind: options.triggerKind ?? 0
      /* CompletionTriggerKind.Invoke */
    };
    if (options.triggerCharacter) {
      suggestCtx = {
        triggerKind: 1,
        triggerCharacter: options.triggerCharacter
      };
    }
    this._requestToken = new CancellationTokenSource();
    const snippetSuggestions = this._editor.getOption(
      128
      /* EditorOption.snippetSuggestions */
    );
    let snippetSortOrder = 1;
    switch (snippetSuggestions) {
      case "top":
        snippetSortOrder = 0;
        break;
      // 	↓ that's the default anyways...
      // case 'inline':
      // 	snippetSortOrder = SnippetSortOrder.Inline;
      // 	break;
      case "bottom":
        snippetSortOrder = 2;
        break;
    }
    const { itemKind: itemKindFilter, showDeprecated } = SuggestModel_1.createSuggestFilter(this._editor);
    const completionOptions = new CompletionOptions(snippetSortOrder, options.completionOptions?.kindFilter ?? itemKindFilter, options.completionOptions?.providerFilter, options.completionOptions?.providerItemsToReuse, showDeprecated);
    const wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
    const completions = provideSuggestionItems(this._languageFeaturesService.completionProvider, model, this._editor.getPosition(), completionOptions, suggestCtx, this._requestToken.token);
    Promise.all([completions, wordDistance]).then(async ([completions2, wordDistance2]) => {
      this._requestToken?.dispose();
      if (!this._editor.hasModel()) {
        completions2.disposable.dispose();
        return;
      }
      let clipboardText = options?.clipboardText;
      if (!clipboardText && completions2.needsClipboard) {
        clipboardText = await this._clipboardService.readText();
      }
      if (this._triggerState === void 0) {
        completions2.disposable.dispose();
        return;
      }
      const model2 = this._editor.getModel();
      const ctx2 = new LineContext2(model2, this._editor.getPosition(), options);
      const fuzzySearchOptions = {
        ...FuzzyScoreOptions.default,
        firstMatchCanBeWeak: !this._editor.getOption(
          134
          /* EditorOption.suggest */
        ).matchOnWordStartOnly
      };
      this._completionModel = new CompletionModel(completions2.items, this._context.column, {
        leadingLineContent: ctx2.leadingLineContent,
        characterCountDelta: ctx2.column - this._context.column
      }, wordDistance2, this._editor.getOption(
        134
        /* EditorOption.suggest */
      ), this._editor.getOption(
        128
        /* EditorOption.snippetSuggestions */
      ), fuzzySearchOptions, clipboardText);
      this._completionDisposables.add(completions2.disposable);
      this._onNewContext(ctx2);
      this._reportDurationsTelemetry(completions2.durations);
      if (!this._envService.isBuilt || this._envService.isExtensionDevelopment) {
        for (const item of completions2.items) {
          if (item.isInvalid) {
            this._logService.warn(`[suggest] did IGNORE invalid completion item from ${item.provider._debugDisplayName}`, item.completion);
          }
        }
      }
    }).catch(onUnexpectedError);
  }
  /**
   * Report durations telemetry with a 1% sampling rate.
   * The telemetry is reported only if a random number between 0 and 100 is less than or equal to 1.
   */
  _reportDurationsTelemetry(durations) {
    if (Math.random() > 1e-4) {
      return;
    }
    setTimeout(() => {
      this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(durations) });
      this._logService.debug("suggest.durations.json", durations);
    });
  }
  static createSuggestFilter(editor2) {
    const result = /* @__PURE__ */ new Set();
    const snippetSuggestions = editor2.getOption(
      128
      /* EditorOption.snippetSuggestions */
    );
    if (snippetSuggestions === "none") {
      result.add(
        28
        /* CompletionItemKind.Snippet */
      );
    }
    const suggestOptions = editor2.getOption(
      134
      /* EditorOption.suggest */
    );
    if (!suggestOptions.showMethods) {
      result.add(
        0
        /* CompletionItemKind.Method */
      );
    }
    if (!suggestOptions.showFunctions) {
      result.add(
        1
        /* CompletionItemKind.Function */
      );
    }
    if (!suggestOptions.showConstructors) {
      result.add(
        2
        /* CompletionItemKind.Constructor */
      );
    }
    if (!suggestOptions.showFields) {
      result.add(
        3
        /* CompletionItemKind.Field */
      );
    }
    if (!suggestOptions.showVariables) {
      result.add(
        4
        /* CompletionItemKind.Variable */
      );
    }
    if (!suggestOptions.showClasses) {
      result.add(
        5
        /* CompletionItemKind.Class */
      );
    }
    if (!suggestOptions.showStructs) {
      result.add(
        6
        /* CompletionItemKind.Struct */
      );
    }
    if (!suggestOptions.showInterfaces) {
      result.add(
        7
        /* CompletionItemKind.Interface */
      );
    }
    if (!suggestOptions.showModules) {
      result.add(
        8
        /* CompletionItemKind.Module */
      );
    }
    if (!suggestOptions.showProperties) {
      result.add(
        9
        /* CompletionItemKind.Property */
      );
    }
    if (!suggestOptions.showEvents) {
      result.add(
        10
        /* CompletionItemKind.Event */
      );
    }
    if (!suggestOptions.showOperators) {
      result.add(
        11
        /* CompletionItemKind.Operator */
      );
    }
    if (!suggestOptions.showUnits) {
      result.add(
        12
        /* CompletionItemKind.Unit */
      );
    }
    if (!suggestOptions.showValues) {
      result.add(
        13
        /* CompletionItemKind.Value */
      );
    }
    if (!suggestOptions.showConstants) {
      result.add(
        14
        /* CompletionItemKind.Constant */
      );
    }
    if (!suggestOptions.showEnums) {
      result.add(
        15
        /* CompletionItemKind.Enum */
      );
    }
    if (!suggestOptions.showEnumMembers) {
      result.add(
        16
        /* CompletionItemKind.EnumMember */
      );
    }
    if (!suggestOptions.showKeywords) {
      result.add(
        17
        /* CompletionItemKind.Keyword */
      );
    }
    if (!suggestOptions.showWords) {
      result.add(
        18
        /* CompletionItemKind.Text */
      );
    }
    if (!suggestOptions.showColors) {
      result.add(
        19
        /* CompletionItemKind.Color */
      );
    }
    if (!suggestOptions.showFiles) {
      result.add(
        20
        /* CompletionItemKind.File */
      );
    }
    if (!suggestOptions.showReferences) {
      result.add(
        21
        /* CompletionItemKind.Reference */
      );
    }
    if (!suggestOptions.showColors) {
      result.add(
        22
        /* CompletionItemKind.Customcolor */
      );
    }
    if (!suggestOptions.showFolders) {
      result.add(
        23
        /* CompletionItemKind.Folder */
      );
    }
    if (!suggestOptions.showTypeParameters) {
      result.add(
        24
        /* CompletionItemKind.TypeParameter */
      );
    }
    if (!suggestOptions.showSnippets) {
      result.add(
        28
        /* CompletionItemKind.Snippet */
      );
    }
    if (!suggestOptions.showUsers) {
      result.add(
        25
        /* CompletionItemKind.User */
      );
    }
    if (!suggestOptions.showIssues) {
      result.add(
        26
        /* CompletionItemKind.Issue */
      );
    }
    return { itemKind: result, showDeprecated: suggestOptions.showDeprecated };
  }
  _onNewContext(ctx) {
    if (!this._context) {
      return;
    }
    if (ctx.lineNumber !== this._context.lineNumber) {
      this.cancel();
      return;
    }
    if (getLeadingWhitespace(ctx.leadingLineContent) !== getLeadingWhitespace(this._context.leadingLineContent)) {
      this.cancel();
      return;
    }
    if (ctx.column < this._context.column) {
      if (ctx.leadingWord.word) {
        this.trigger({ auto: this._context.triggerOptions.auto, retrigger: true });
      } else {
        this.cancel();
      }
      return;
    }
    if (!this._completionModel) {
      return;
    }
    if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {
      const shouldAutoTrigger = LineContext2.shouldAutoTrigger(this._editor);
      if (shouldAutoTrigger && this._context) {
        const map = this._completionModel.getItemsByProvider();
        this.trigger({
          auto: this._context.triggerOptions.auto,
          retrigger: true,
          clipboardText: this._completionModel.clipboardText,
          completionOptions: { providerItemsToReuse: map }
        });
      }
      return;
    }
    if (ctx.column > this._context.column && this._completionModel.getIncompleteProvider().size > 0 && ctx.leadingWord.word.length !== 0) {
      const providerItemsToReuse = /* @__PURE__ */ new Map();
      const providerFilter = /* @__PURE__ */ new Set();
      for (const [provider, items] of this._completionModel.getItemsByProvider()) {
        if (items.length > 0 && items[0].container.incomplete) {
          providerFilter.add(provider);
        } else {
          providerItemsToReuse.set(provider, items);
        }
      }
      this.trigger({
        auto: this._context.triggerOptions.auto,
        triggerKind: 2,
        retrigger: true,
        clipboardText: this._completionModel.clipboardText,
        completionOptions: { providerFilter, providerItemsToReuse }
      });
    } else {
      const oldLineContext = this._completionModel.lineContext;
      let isFrozen = false;
      this._completionModel.lineContext = {
        leadingLineContent: ctx.leadingLineContent,
        characterCountDelta: ctx.column - this._context.column
      };
      if (this._completionModel.items.length === 0) {
        const shouldAutoTrigger = LineContext2.shouldAutoTrigger(this._editor);
        if (!this._context) {
          this.cancel();
          return;
        }
        if (shouldAutoTrigger && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
          this.trigger({ auto: this._context.triggerOptions.auto, retrigger: true });
          return;
        }
        if (!this._context.triggerOptions.auto) {
          this._completionModel.lineContext = oldLineContext;
          isFrozen = this._completionModel.items.length > 0;
          if (isFrozen && ctx.leadingWord.word.length === 0) {
            this.cancel();
            return;
          }
        } else {
          this.cancel();
          return;
        }
      }
      this._onDidSuggest.fire({
        completionModel: this._completionModel,
        triggerOptions: ctx.triggerOptions,
        isFrozen
      });
    }
  }
};
SuggestModel = SuggestModel_1 = __decorate56([
  __param56(1, IEditorWorkerService),
  __param56(2, IClipboardService),
  __param56(3, ITelemetryService),
  __param56(4, ILogService),
  __param56(5, IContextKeyService),
  __param56(6, IConfigurationService),
  __param56(7, ILanguageFeaturesService),
  __param56(8, IEnvironmentService)
], SuggestModel);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestOvertypingCapturer.js
init_lifecycle();
var _OvertypingCapturer = class _OvertypingCapturer {
  constructor(editor2, suggestModel) {
    this._disposables = new DisposableStore();
    this._lastOvertyped = [];
    this._locked = false;
    this._disposables.add(editor2.onWillType(() => {
      if (this._locked || !editor2.hasModel()) {
        return;
      }
      const selections = editor2.getSelections();
      const selectionsLength = selections.length;
      let willOvertype = false;
      for (let i2 = 0; i2 < selectionsLength; i2++) {
        if (!selections[i2].isEmpty()) {
          willOvertype = true;
          break;
        }
      }
      if (!willOvertype) {
        if (this._lastOvertyped.length !== 0) {
          this._lastOvertyped.length = 0;
        }
        return;
      }
      this._lastOvertyped = [];
      const model = editor2.getModel();
      for (let i2 = 0; i2 < selectionsLength; i2++) {
        const selection = selections[i2];
        if (model.getValueLengthInRange(selection) > _OvertypingCapturer._maxSelectionLength) {
          return;
        }
        this._lastOvertyped[i2] = { value: model.getValueInRange(selection), multiline: selection.startLineNumber !== selection.endLineNumber };
      }
    }));
    this._disposables.add(suggestModel.onDidTrigger((e) => {
      this._locked = true;
    }));
    this._disposables.add(suggestModel.onDidCancel((e) => {
      this._locked = false;
    }));
  }
  getLastOvertypedInfo(idx) {
    if (idx >= 0 && idx < this._lastOvertyped.length) {
      return this._lastOvertyped[idx];
    }
    return void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};
_OvertypingCapturer._maxSelectionLength = 51200;
var OvertypingCapturer = _OvertypingCapturer;

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
init_dom();
init_async();
init_errors();
init_event();
init_lifecycle();
init_numbers();
init_strings();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/media/suggest.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js
init_dom();
init_lifecycle();
init_actions2();
init_contextkey();
init_instantiation();
var __decorate57 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param57 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestWidgetStatus = class SuggestWidgetStatus2 {
  constructor(container, _menuId, instantiationService, _menuService, _contextKeyService) {
    this._menuId = _menuId;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._menuDisposables = new DisposableStore();
    this.element = append(container, $(".suggest-status-bar"));
    const actionViewItemProvider = ((action) => {
      return action instanceof MenuItemAction ? instantiationService.createInstance(TextOnlyMenuEntryActionViewItem, action, { useComma: false }) : void 0;
    });
    this._leftActions = new ActionBar(this.element, { actionViewItemProvider });
    this._rightActions = new ActionBar(this.element, { actionViewItemProvider });
    this._leftActions.domNode.classList.add("left");
    this._rightActions.domNode.classList.add("right");
  }
  dispose() {
    this._menuDisposables.dispose();
    this._leftActions.dispose();
    this._rightActions.dispose();
    this.element.remove();
  }
  show() {
    const menu = this._menuService.createMenu(this._menuId, this._contextKeyService);
    const renderMenu = () => {
      const left = [];
      const right = [];
      for (const [group, actions] of menu.getActions()) {
        if (group === "left") {
          left.push(...actions);
        } else {
          right.push(...actions);
        }
      }
      this._leftActions.clear();
      this._leftActions.push(left);
      this._rightActions.clear();
      this._rightActions.push(right);
    };
    this._menuDisposables.add(menu.onDidChange(() => renderMenu()));
    this._menuDisposables.add(menu);
  }
  hide() {
    this._menuDisposables.clear();
  }
};
SuggestWidgetStatus = __decorate57([
  __param57(2, IInstantiationService),
  __param57(3, IMenuService),
  __param57(4, IContextKeyService)
], SuggestWidgetStatus);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
init_nls();
init_contextkey();
init_instantiation();
init_colorRegistry();
init_theme();
init_themeService();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js
init_dom();
init_codicons();
init_themables();
init_event();
init_htmlContent();
init_lifecycle();
init_nls();
init_instantiation();
var __decorate58 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param58 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function canExpandCompletionItem(item) {
  return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);
}
var SuggestDetailsWidget = class SuggestDetailsWidget2 {
  constructor(_editor, instaService) {
    this._editor = _editor;
    this._onDidClose = new Emitter();
    this.onDidClose = this._onDidClose.event;
    this._onDidChangeContents = new Emitter();
    this.onDidChangeContents = this._onDidChangeContents.event;
    this._disposables = new DisposableStore();
    this._renderDisposeable = new DisposableStore();
    this._borderWidth = 1;
    this._size = new Dimension(330, 0);
    this.domNode = $(".suggest-details");
    this.domNode.classList.add("no-docs");
    this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor });
    this._body = $(".body");
    this._scrollbar = new DomScrollableElement(this._body, {
      alwaysConsumeMouseWheel: true
    });
    append(this.domNode, this._scrollbar.getDomNode());
    this._disposables.add(this._scrollbar);
    this._header = append(this._body, $(".header"));
    this._close = append(this._header, $("span" + ThemeIcon.asCSSSelector(Codicon.close)));
    this._close.title = localize(1475, "Close");
    this._close.role = "button";
    this._close.tabIndex = -1;
    this._type = append(this._header, $("p.type"));
    this._docs = append(this._body, $("p.docs"));
    this._configureFont();
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.fontInfo */
      )) {
        this._configureFont();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._renderDisposeable.dispose();
  }
  _configureFont() {
    const options = this._editor.getOptions();
    const fontInfo = options.get(
      59
      /* EditorOption.fontInfo */
    );
    const fontFamily = fontInfo.getMassagedFontFamily();
    const fontSize = options.get(
      135
      /* EditorOption.suggestFontSize */
    ) || fontInfo.fontSize;
    const lineHeight = options.get(
      136
      /* EditorOption.suggestLineHeight */
    ) || fontInfo.lineHeight;
    const fontWeight = fontInfo.fontWeight;
    const fontSizePx = `${fontSize}px`;
    const lineHeightPx = `${lineHeight}px`;
    this.domNode.style.fontSize = fontSizePx;
    this.domNode.style.lineHeight = `${lineHeight / fontSize}`;
    this.domNode.style.fontWeight = fontWeight;
    this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
    this._type.style.fontFamily = fontFamily;
    this._close.style.height = lineHeightPx;
    this._close.style.width = lineHeightPx;
  }
  getLayoutInfo() {
    const lineHeight = this._editor.getOption(
      136
      /* EditorOption.suggestLineHeight */
    ) || this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    ).lineHeight;
    const borderWidth = this._borderWidth;
    const borderHeight = borderWidth * 2;
    return {
      lineHeight,
      borderWidth,
      borderHeight,
      verticalPadding: 22,
      horizontalPadding: 14
    };
  }
  renderLoading() {
    this._type.textContent = localize(1476, "Loading...");
    this._docs.textContent = "";
    this.domNode.classList.remove("no-docs", "no-type");
    this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);
    this._onDidChangeContents.fire(this);
  }
  renderItem(item, explainMode) {
    this._renderDisposeable.clear();
    let { detail, documentation } = item.completion;
    if (explainMode) {
      let md = "";
      md += `score: ${item.score[0]}
`;
      md += `prefix: ${item.word ?? "(no prefix)"}
`;
      md += `word: ${item.completion.filterText ? item.completion.filterText + " (filterText)" : item.textLabel}
`;
      md += `distance: ${item.distance} (localityBonus-setting)
`;
      md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || "label"}
`;
      md += `commit_chars: ${item.completion.commitCharacters?.join("")}
`;
      documentation = new MarkdownString().appendCodeblock("empty", md);
      detail = `Provider: ${item.provider._debugDisplayName}`;
    }
    if (!explainMode && !canExpandCompletionItem(item)) {
      this.clearContents();
      return;
    }
    this.domNode.classList.remove("no-docs", "no-type");
    if (detail) {
      const cappedDetail = detail.length > 1e5 ? `${detail.substr(0, 1e5)}…` : detail;
      this._type.textContent = cappedDetail;
      this._type.title = cappedDetail;
      show(this._type);
      this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(cappedDetail));
    } else {
      clearNode(this._type);
      this._type.title = "";
      hide(this._type);
      this.domNode.classList.add("no-type");
    }
    clearNode(this._docs);
    if (typeof documentation === "string") {
      this._docs.classList.remove("markdown-docs");
      this._docs.textContent = documentation;
    } else if (documentation) {
      this._docs.classList.add("markdown-docs");
      clearNode(this._docs);
      const renderedContents = this._markdownRenderer.render(documentation, {
        asyncRenderCallback: () => {
          this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
          this._onDidChangeContents.fire(this);
        }
      });
      this._docs.appendChild(renderedContents.element);
      this._renderDisposeable.add(renderedContents);
    }
    this.domNode.classList.toggle("detail-and-doc", !!detail && !!documentation);
    this.domNode.style.userSelect = "text";
    this.domNode.tabIndex = -1;
    this._close.onmousedown = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };
    this._close.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this._onDidClose.fire();
    };
    this._body.scrollTop = 0;
    this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
    this._onDidChangeContents.fire(this);
  }
  clearContents() {
    this.domNode.classList.add("no-docs");
    this._type.textContent = "";
    this._docs.textContent = "";
  }
  get isEmpty() {
    return this.domNode.classList.contains("no-docs");
  }
  get size() {
    return this._size;
  }
  layout(width, height) {
    const newSize = new Dimension(width, height);
    if (!Dimension.equals(newSize, this._size)) {
      this._size = newSize;
      size(this.domNode, width, height);
    }
    this._scrollbar.scanDomNode();
  }
  scrollDown(much = 8) {
    this._body.scrollTop += much;
  }
  scrollUp(much = 8) {
    this._body.scrollTop -= much;
  }
  scrollTop() {
    this._body.scrollTop = 0;
  }
  scrollBottom() {
    this._body.scrollTop = this._body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  set borderWidth(width) {
    this._borderWidth = width;
  }
  get borderWidth() {
    return this._borderWidth;
  }
  focus() {
    this.domNode.focus();
  }
};
SuggestDetailsWidget = __decorate58([
  __param58(1, IInstantiationService)
], SuggestDetailsWidget);
var SuggestDetailsOverlay = class {
  constructor(widget, _editor) {
    this.widget = widget;
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this._disposables = new DisposableStore();
    this._added = false;
    this._preferAlignAtTop = true;
    this._resizable = new ResizableHTMLElement();
    this._resizable.domNode.classList.add("suggest-details-container");
    this._resizable.domNode.appendChild(widget.domNode);
    this._resizable.enableSashes(false, true, true, false);
    let topLeftNow;
    let sizeNow;
    let deltaTop = 0;
    let deltaLeft = 0;
    this._disposables.add(this._resizable.onDidWillResize(() => {
      topLeftNow = this._topLeft;
      sizeNow = this._resizable.size;
    }));
    this._disposables.add(this._resizable.onDidResize((e) => {
      if (topLeftNow && sizeNow) {
        this.widget.layout(e.dimension.width, e.dimension.height);
        let updateTopLeft = false;
        if (e.west) {
          deltaLeft = sizeNow.width - e.dimension.width;
          updateTopLeft = true;
        }
        if (e.north) {
          deltaTop = sizeNow.height - e.dimension.height;
          updateTopLeft = true;
        }
        if (updateTopLeft) {
          this._applyTopLeft({
            top: topLeftNow.top + deltaTop,
            left: topLeftNow.left + deltaLeft
          });
        }
      }
      if (e.done) {
        topLeftNow = void 0;
        sizeNow = void 0;
        deltaTop = 0;
        deltaLeft = 0;
        this._userSize = e.dimension;
      }
    }));
    this._disposables.add(this.widget.onDidChangeContents(() => {
      if (this._anchorBox) {
        this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, this._preferAlignAtTop);
      }
    }));
  }
  dispose() {
    this._resizable.dispose();
    this._disposables.dispose();
    this.hide();
  }
  getId() {
    return "suggest.details";
  }
  getDomNode() {
    return this._resizable.domNode;
  }
  getPosition() {
    return this._topLeft ? { preference: this._topLeft } : null;
  }
  show() {
    if (!this._added) {
      this._editor.addOverlayWidget(this);
      this._added = true;
    }
  }
  hide(sessionEnded = false) {
    this._resizable.clearSashHoverState();
    if (this._added) {
      this._editor.removeOverlayWidget(this);
      this._added = false;
      this._anchorBox = void 0;
      this._topLeft = void 0;
    }
    if (sessionEnded) {
      this._userSize = void 0;
      this.widget.clearContents();
    }
  }
  placeAtAnchor(anchor, preferAlignAtTop) {
    const anchorBox = anchor.getBoundingClientRect();
    this._anchorBox = anchorBox;
    this._preferAlignAtTop = preferAlignAtTop;
    this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, preferAlignAtTop);
  }
  _placeAtAnchor(anchorBox, size2, preferAlignAtTop) {
    const bodyBox = getClientArea(this.getDomNode().ownerDocument.body);
    const info = this.widget.getLayoutInfo();
    const defaultMinSize = new Dimension(220, 2 * info.lineHeight);
    const defaultTop = anchorBox.top;
    const eastPlacement = (function() {
      const width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);
      const left2 = -info.borderWidth + anchorBox.left + anchorBox.width;
      const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
      const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
      return { top: defaultTop, left: left2, fit: width - size2.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };
    })();
    const westPlacement = (function() {
      const width = anchorBox.left - info.borderWidth - info.horizontalPadding;
      const left2 = Math.max(info.horizontalPadding, anchorBox.left - size2.width - info.borderWidth);
      const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
      const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
      return { top: defaultTop, left: left2, fit: width - size2.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };
    })();
    const southPacement = (function() {
      const left2 = anchorBox.left;
      const top2 = -info.borderWidth + anchorBox.top + anchorBox.height;
      const maxSizeBottom = new Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);
      return { top: top2, left: left2, fit: maxSizeBottom.height - size2.height, maxSizeBottom, maxSizeTop: maxSizeBottom, minSize: defaultMinSize.with(maxSizeBottom.width) };
    })();
    const placements = [eastPlacement, westPlacement, southPacement];
    const placement = placements.find((p) => p.fit >= 0) ?? placements.sort((a, b) => b.fit - a.fit)[0];
    const bottom = anchorBox.top + anchorBox.height - info.borderHeight;
    let alignAtTop;
    let height = size2.height;
    const maxHeight = Math.max(placement.maxSizeTop.height, placement.maxSizeBottom.height);
    if (height > maxHeight) {
      height = maxHeight;
    }
    let maxSize;
    if (preferAlignAtTop) {
      if (height <= placement.maxSizeTop.height) {
        alignAtTop = true;
        maxSize = placement.maxSizeTop;
      } else {
        alignAtTop = false;
        maxSize = placement.maxSizeBottom;
      }
    } else {
      if (height <= placement.maxSizeBottom.height) {
        alignAtTop = false;
        maxSize = placement.maxSizeBottom;
      } else {
        alignAtTop = true;
        maxSize = placement.maxSizeTop;
      }
    }
    let { top, left } = placement;
    if (!alignAtTop && height > anchorBox.height) {
      top = bottom - height;
    }
    const editorDomNode = this._editor.getDomNode();
    if (editorDomNode) {
      const editorBoundingBox = editorDomNode.getBoundingClientRect();
      top -= editorBoundingBox.top;
      left -= editorBoundingBox.left;
    }
    this._applyTopLeft({ left, top });
    this._resizable.enableSashes(!alignAtTop, placement === eastPlacement, alignAtTop, placement !== eastPlacement);
    this._resizable.minSize = placement.minSize;
    this._resizable.maxSize = maxSize;
    this._resizable.layout(height, Math.min(maxSize.width, size2.width));
    this.widget.layout(this._resizable.size.width, this._resizable.size.height);
  }
  _applyTopLeft(topLeft) {
    this._topLeft = topLeft;
    this._editor.layoutOverlayWidget(this);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js
init_dom();
init_codicons();
init_themables();
init_event();
init_filters();
init_lifecycle();
init_uri();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
init_network();
init_resources();
init_uri();
init_modesRegistry();

// node_modules/monaco-editor/esm/vs/platform/files/common/files.js
init_instantiation();
var IFileService = createDecorator("fileService");
var FileKind;
(function(FileKind2) {
  FileKind2[FileKind2["FILE"] = 0] = "FILE";
  FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
  FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));

// node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
init_themables();
var fileIconDirectoryRegex = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
function getIconClasses(modelService, languageService, resource, fileKind, icon) {
  if (ThemeIcon.isThemeIcon(icon)) {
    return [`codicon-${icon.id}`, "predefined-file-icon"];
  }
  if (URI.isUri(icon)) {
    return [];
  }
  const classes = fileKind === FileKind.ROOT_FOLDER ? ["rootfolder-icon"] : fileKind === FileKind.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (resource) {
    let name;
    if (resource.scheme === Schemas.data) {
      const metadata = DataUri.parseMetaData(resource);
      name = metadata.get(DataUri.META_DATA_LABEL);
    } else {
      const match = resource.path.match(fileIconDirectoryRegex);
      if (match) {
        name = fileIconSelectorEscape(match[2].toLowerCase());
        if (match[1]) {
          classes.push(`${fileIconSelectorEscape(match[1].toLowerCase())}-name-dir-icon`);
        }
      } else {
        name = fileIconSelectorEscape(resource.authority.toLowerCase());
      }
    }
    if (fileKind === FileKind.ROOT_FOLDER) {
      classes.push(`${name}-root-name-folder-icon`);
    } else if (fileKind === FileKind.FOLDER) {
      classes.push(`${name}-name-folder-icon`);
    } else {
      if (name) {
        classes.push(`${name}-name-file-icon`);
        classes.push(`name-file-icon`);
        if (name.length <= 255) {
          const dotSegments = name.split(".");
          for (let i2 = 1; i2 < dotSegments.length; i2++) {
            classes.push(`${dotSegments.slice(i2).join(".")}-ext-file-icon`);
          }
        }
        classes.push(`ext-file-icon`);
      }
      const detectedLanguageId = detectLanguageId(modelService, languageService, resource);
      if (detectedLanguageId) {
        classes.push(`${fileIconSelectorEscape(detectedLanguageId)}-lang-file-icon`);
      }
    }
  }
  return classes;
}
function detectLanguageId(modelService, languageService, resource) {
  if (!resource) {
    return null;
  }
  let languageId = null;
  if (resource.scheme === Schemas.data) {
    const metadata = DataUri.parseMetaData(resource);
    const mime = metadata.get(DataUri.META_DATA_MIME);
    if (mime) {
      languageId = languageService.getLanguageIdByMimeType(mime);
    }
  } else {
    const model = modelService.getModel(resource);
    if (model) {
      languageId = model.getLanguageId();
    }
  }
  if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) {
    return languageId;
  }
  return languageService.guessLanguageIdByFilepathOrFirstLine(resource);
}
function fileIconSelectorEscape(str) {
  return str.replace(/[\s]/g, "/");
}

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js
init_model();
init_language();
init_nls();
init_themeService();
var __decorate59 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param59 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var suggestMoreInfoIcon = registerIcon("suggest-more-info", Codicon.chevronRight, localize(1477, "Icon for more information in the suggest widget."));
var _a42;
var _completionItemColor = new (_a42 = class {
  extract(item, out) {
    if (item.textLabel.match(_a42._regexStrict)) {
      out[0] = item.textLabel;
      return true;
    }
    if (item.completion.detail && item.completion.detail.match(_a42._regexStrict)) {
      out[0] = item.completion.detail;
      return true;
    }
    if (item.completion.documentation) {
      const value = typeof item.completion.documentation === "string" ? item.completion.documentation : item.completion.documentation.value;
      const match = _a42._regexRelaxed.exec(value);
      if (match && (match.index === 0 || match.index + match[0].length === value.length)) {
        out[0] = match[0];
        return true;
      }
    }
    return false;
  }
}, _a42._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, _a42._regexStrict = new RegExp(`^${_a42._regexRelaxed.source}$`, "i"), _a42)();
var ItemRenderer = class ItemRenderer2 {
  constructor(_editor, _modelService, _languageService, _themeService) {
    this._editor = _editor;
    this._modelService = _modelService;
    this._languageService = _languageService;
    this._themeService = _themeService;
    this._onDidToggleDetails = new Emitter();
    this.onDidToggleDetails = this._onDidToggleDetails.event;
    this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(container) {
    const disposables = new DisposableStore();
    const root = container;
    root.classList.add("show-file-icons");
    const icon = append(container, $(".icon"));
    const colorspan = append(icon, $("span.colorspan"));
    const text = append(container, $(".contents"));
    const main = append(text, $(".main"));
    const iconContainer = append(main, $(".icon-label.codicon"));
    const left = append(main, $("span.left"));
    const right = append(main, $("span.right"));
    const iconLabel = new IconLabel(left, { supportHighlights: true, supportIcons: true });
    disposables.add(iconLabel);
    const parametersLabel = append(left, $("span.signature-label"));
    const qualifierLabel = append(left, $("span.qualifier-label"));
    const detailsLabel = append(right, $("span.details-label"));
    const readMore = append(right, $("span.readMore" + ThemeIcon.asCSSSelector(suggestMoreInfoIcon)));
    readMore.title = localize(1478, "Read More");
    const configureFont = () => {
      const options = this._editor.getOptions();
      const fontInfo = options.get(
        59
        /* EditorOption.fontInfo */
      );
      const fontFamily = fontInfo.getMassagedFontFamily();
      const fontFeatureSettings = fontInfo.fontFeatureSettings;
      const fontVariationSettings = fontInfo.fontVariationSettings;
      const fontSize = options.get(
        135
        /* EditorOption.suggestFontSize */
      ) || fontInfo.fontSize;
      const lineHeight = options.get(
        136
        /* EditorOption.suggestLineHeight */
      ) || fontInfo.lineHeight;
      const fontWeight = fontInfo.fontWeight;
      const letterSpacing = fontInfo.letterSpacing;
      const fontSizePx = `${fontSize}px`;
      const lineHeightPx = `${lineHeight}px`;
      const letterSpacingPx = `${letterSpacing}px`;
      root.style.fontSize = fontSizePx;
      root.style.fontWeight = fontWeight;
      root.style.letterSpacing = letterSpacingPx;
      main.style.fontFamily = fontFamily;
      main.style.fontFeatureSettings = fontFeatureSettings;
      main.style.fontVariationSettings = fontVariationSettings;
      main.style.lineHeight = lineHeightPx;
      icon.style.height = lineHeightPx;
      icon.style.width = lineHeightPx;
      readMore.style.height = lineHeightPx;
      readMore.style.width = lineHeightPx;
    };
    return { root, left, right, icon, colorspan, iconLabel, iconContainer, parametersLabel, qualifierLabel, detailsLabel, readMore, disposables, configureFont };
  }
  renderElement(element, index, data) {
    data.configureFont();
    const { completion } = element;
    data.colorspan.style.backgroundColor = "";
    const labelOptions = {
      labelEscapeNewLines: true,
      matches: createMatches(element.score)
    };
    const color = [];
    if (completion.kind === 19 && _completionItemColor.extract(element, color)) {
      data.icon.className = "icon customcolor";
      data.iconContainer.className = "icon hide";
      data.colorspan.style.backgroundColor = color[0];
    } else if (completion.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      const labelClasses = getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FILE);
      const detailClasses = getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FILE);
      labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;
    } else if (completion.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      labelOptions.extraClasses = [
        getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FOLDER),
        getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FOLDER)
      ].flat();
    } else {
      data.icon.className = "icon hide";
      data.iconContainer.className = "";
      data.iconContainer.classList.add("suggest-icon", ...ThemeIcon.asClassNameArray(CompletionItemKinds.toIcon(completion.kind)));
    }
    if (completion.tags && completion.tags.indexOf(
      1
      /* CompletionItemTag.Deprecated */
    ) >= 0) {
      labelOptions.extraClasses = (labelOptions.extraClasses || []).concat(["deprecated"]);
      labelOptions.matches = [];
    }
    data.iconLabel.setLabel(element.textLabel, void 0, labelOptions);
    if (typeof completion.label === "string") {
      data.parametersLabel.textContent = "";
      data.detailsLabel.textContent = stripNewLines(completion.detail || "");
      data.root.classList.add("string-label");
    } else {
      data.parametersLabel.textContent = stripNewLines(completion.label.detail || "");
      data.detailsLabel.textContent = stripNewLines(completion.label.description || "");
      data.root.classList.remove("string-label");
    }
    if (this._editor.getOption(
      134
      /* EditorOption.suggest */
    ).showInlineDetails) {
      show(data.detailsLabel);
    } else {
      hide(data.detailsLabel);
    }
    if (canExpandCompletionItem(element)) {
      data.right.classList.add("can-expand-details");
      show(data.readMore);
      data.readMore.onmousedown = (e) => {
        e.stopPropagation();
        e.preventDefault();
      };
      data.readMore.onclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        this._onDidToggleDetails.fire();
      };
    } else {
      data.right.classList.remove("can-expand-details");
      hide(data.readMore);
      data.readMore.onmousedown = null;
      data.readMore.onclick = null;
    }
  }
  disposeTemplate(templateData) {
    templateData.disposables.dispose();
  }
};
ItemRenderer = __decorate59([
  __param59(1, IModelService),
  __param59(2, ILanguageService),
  __param59(3, IThemeService)
], ItemRenderer);
function stripNewLines(str) {
  return str.replace(/\r\n|\r|\n/g, "");
}

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
init_languages();
init_platform();
var __decorate60 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param60 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestWidget_1;
registerColor("editorSuggestWidget.background", editorWidgetBackground, localize(1458, "Background color of the suggest widget."));
registerColor("editorSuggestWidget.border", editorWidgetBorder, localize(1459, "Border color of the suggest widget."));
var editorSuggestWidgetForeground = registerColor("editorSuggestWidget.foreground", editorForeground, localize(1460, "Foreground color of the suggest widget."));
registerColor("editorSuggestWidget.selectedForeground", quickInputListFocusForeground, localize(1461, "Foreground color of the selected entry in the suggest widget."));
registerColor("editorSuggestWidget.selectedIconForeground", quickInputListFocusIconForeground, localize(1462, "Icon foreground color of the selected entry in the suggest widget."));
var editorSuggestWidgetSelectedBackground = registerColor("editorSuggestWidget.selectedBackground", quickInputListFocusBackground, localize(1463, "Background color of the selected entry in the suggest widget."));
registerColor("editorSuggestWidget.highlightForeground", listHighlightForeground, localize(1464, "Color of the match highlights in the suggest widget."));
registerColor("editorSuggestWidget.focusHighlightForeground", listFocusHighlightForeground, localize(1465, "Color of the match highlights in the suggest widget when an item is focused."));
registerColor("editorSuggestWidgetStatus.foreground", transparent(editorSuggestWidgetForeground, 0.5), localize(1466, "Foreground color of the suggest widget status."));
var PersistedWidgetSize = class {
  constructor(_service, editor2) {
    this._service = _service;
    this._key = `suggestWidget.size/${editor2.getEditorType()}/${editor2 instanceof EmbeddedCodeEditorWidget}`;
  }
  restore() {
    const raw = this._service.get(
      this._key,
      0
      /* StorageScope.PROFILE */
    ) ?? "";
    try {
      const obj = JSON.parse(raw);
      if (Dimension.is(obj)) {
        return Dimension.lift(obj);
      }
    } catch {
    }
    return void 0;
  }
  store(size2) {
    this._service.store(
      this._key,
      JSON.stringify(size2),
      0,
      1
      /* StorageTarget.MACHINE */
    );
  }
  reset() {
    this._service.remove(
      this._key,
      0
      /* StorageScope.PROFILE */
    );
  }
};
var _a43;
var SuggestWidget = (_a43 = class {
  constructor(editor2, _storageService, _contextKeyService, _themeService, instantiationService) {
    this.editor = editor2;
    this._storageService = _storageService;
    this._state = 0;
    this._isAuto = false;
    this._pendingLayout = new MutableDisposable();
    this._pendingShowDetails = new MutableDisposable();
    this._ignoreFocusEvents = false;
    this._forceRenderingAbove = false;
    this._explainMode = false;
    this._showTimeout = new TimeoutTimer();
    this._disposables = new DisposableStore();
    this._onDidSelect = new PauseableEmitter();
    this._onDidFocus = new PauseableEmitter();
    this._onDidHide = new Emitter();
    this._onDidShow = new Emitter();
    this.onDidSelect = this._onDidSelect.event;
    this.onDidFocus = this._onDidFocus.event;
    this.onDidHide = this._onDidHide.event;
    this.onDidShow = this._onDidShow.event;
    this._onDetailsKeydown = new Emitter();
    this.onDetailsKeyDown = this._onDetailsKeydown.event;
    this.element = new ResizableHTMLElement();
    this.element.domNode.classList.add("editor-widget", "suggest-widget");
    this._contentWidget = new SuggestContentWidget(this, editor2);
    this._persistedSize = new PersistedWidgetSize(_storageService, editor2);
    class ResizeState {
      constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {
        this.persistedSize = persistedSize;
        this.currentSize = currentSize;
        this.persistHeight = persistHeight;
        this.persistWidth = persistWidth;
      }
    }
    let state;
    this._disposables.add(this.element.onDidWillResize(() => {
      this._contentWidget.lockPreference();
      state = new ResizeState(this._persistedSize.restore(), this.element.size);
    }));
    this._disposables.add(this.element.onDidResize((e) => {
      this._resize(e.dimension.width, e.dimension.height);
      if (state) {
        state.persistHeight = state.persistHeight || !!e.north || !!e.south;
        state.persistWidth = state.persistWidth || !!e.east || !!e.west;
      }
      if (!e.done) {
        return;
      }
      if (state) {
        const { itemHeight, defaultSize } = this.getLayoutInfo();
        const threshold = Math.round(itemHeight / 2);
        let { width, height } = this.element.size;
        if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {
          height = state.persistedSize?.height ?? defaultSize.height;
        }
        if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {
          width = state.persistedSize?.width ?? defaultSize.width;
        }
        this._persistedSize.store(new Dimension(width, height));
      }
      this._contentWidget.unlockPreference();
      state = void 0;
    }));
    this._messageElement = append(this.element.domNode, $(".message"));
    this._listElement = append(this.element.domNode, $(".tree"));
    const details = this._disposables.add(instantiationService.createInstance(SuggestDetailsWidget, this.editor));
    details.onDidClose(() => this.toggleDetails(), this, this._disposables);
    this._details = new SuggestDetailsOverlay(details, this.editor);
    const applyIconStyle = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(
      134
      /* EditorOption.suggest */
    ).showIcons);
    applyIconStyle();
    const renderer = instantiationService.createInstance(ItemRenderer, this.editor);
    this._disposables.add(renderer);
    this._disposables.add(renderer.onDidToggleDetails(() => this.toggleDetails()));
    this._list = new List("SuggestWidget", this._listElement, {
      getHeight: (_element) => this.getLayoutInfo().itemHeight,
      getTemplateId: (_element) => "suggestion"
    }, [renderer], {
      alwaysConsumeMouseWheel: true,
      useShadows: false,
      mouseSupport: false,
      multipleSelectionSupport: false,
      accessibilityProvider: {
        getRole: () => isWindows ? "listitem" : "option",
        getWidgetAriaLabel: () => localize(1469, "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (item) => {
          let label = item.textLabel;
          const kindLabel = CompletionItemKinds.toLabel(item.completion.kind);
          if (typeof item.completion.label !== "string") {
            const { detail: detail2, description } = item.completion.label;
            if (detail2 && description) {
              label = localize(1470, "{0} {1}, {2}, {3}", label, detail2, description, kindLabel);
            } else if (detail2) {
              label = localize(1471, "{0} {1}, {2}", label, detail2, kindLabel);
            } else if (description) {
              label = localize(1472, "{0}, {1}, {2}", label, description, kindLabel);
            }
          } else {
            label = localize(1473, "{0}, {1}", label, kindLabel);
          }
          if (!item.isResolved || !this._isDetailsVisible()) {
            return label;
          }
          const { documentation, detail } = item.completion;
          const docs = format("{0}{1}", detail || "", documentation ? typeof documentation === "string" ? documentation : documentation.value : "");
          return localize(1474, "{0}, docs: {1}", label, docs);
        }
      }
    });
    this._list.style(getListStyles({
      listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
      listInactiveFocusOutline: activeContrastBorder
    }));
    this._status = instantiationService.createInstance(SuggestWidgetStatus, this.element.domNode, suggestWidgetStatusbarMenu);
    const applyStatusBarStyle = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(
      134
      /* EditorOption.suggest */
    ).showStatusBar);
    applyStatusBarStyle();
    this._disposables.add(_themeService.onDidColorThemeChange((t) => this._onThemeChange(t)));
    this._onThemeChange(_themeService.getColorTheme());
    this._disposables.add(this._list.onMouseDown((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onTap((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onDidChangeSelection((e) => this._onListSelection(e)));
    this._disposables.add(this._list.onDidChangeFocus((e) => this._onListFocus(e)));
    this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged()));
    this._disposables.add(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        134
        /* EditorOption.suggest */
      )) {
        applyStatusBarStyle();
        applyIconStyle();
      }
      if (this._completionModel && (e.hasChanged(
        59
        /* EditorOption.fontInfo */
      ) || e.hasChanged(
        135
        /* EditorOption.suggestFontSize */
      ) || e.hasChanged(
        136
        /* EditorOption.suggestLineHeight */
      ))) {
        this._list.splice(0, this._list.length, this._completionModel.items);
      }
    }));
    this._ctxSuggestWidgetVisible = Context.Visible.bindTo(_contextKeyService);
    this._ctxSuggestWidgetDetailsVisible = Context.DetailsVisible.bindTo(_contextKeyService);
    this._ctxSuggestWidgetMultipleSuggestions = Context.MultipleSuggestions.bindTo(_contextKeyService);
    this._ctxSuggestWidgetHasFocusedSuggestion = Context.HasFocusedSuggestion.bindTo(_contextKeyService);
    this._disposables.add(addStandardDisposableListener(this._details.widget.domNode, "keydown", (e) => {
      this._onDetailsKeydown.fire(e);
    }));
    this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));
  }
  dispose() {
    this._details.widget.dispose();
    this._details.dispose();
    this._list.dispose();
    this._status.dispose();
    this._disposables.dispose();
    this._loadingTimeout?.dispose();
    this._pendingLayout.dispose();
    this._pendingShowDetails.dispose();
    this._showTimeout.dispose();
    this._contentWidget.dispose();
    this.element.dispose();
  }
  _onEditorMouseDown(mouseEvent) {
    if (this._details.widget.domNode.contains(mouseEvent.target.element)) {
      this._details.widget.domNode.focus();
    } else {
      if (this.element.domNode.contains(mouseEvent.target.element)) {
        this.editor.focus();
      }
    }
  }
  _onCursorSelectionChanged() {
    if (this._state !== 0) {
      this._contentWidget.layout();
    }
  }
  _onListMouseDownOrTap(e) {
    if (typeof e.element === "undefined" || typeof e.index === "undefined") {
      return;
    }
    e.browserEvent.preventDefault();
    e.browserEvent.stopPropagation();
    this._select(e.element, e.index);
  }
  _onListSelection(e) {
    if (e.elements.length) {
      this._select(e.elements[0], e.indexes[0]);
    }
  }
  _select(item, index) {
    const completionModel = this._completionModel;
    if (completionModel) {
      this._onDidSelect.fire({ item, index, model: completionModel });
      this.editor.focus();
    }
  }
  _onThemeChange(theme) {
    this._details.widget.borderWidth = isHighContrast(theme.type) ? 2 : 1;
  }
  _onListFocus(e) {
    if (this._ignoreFocusEvents) {
      return;
    }
    if (this._state === 5) {
      this._setState(
        3
        /* State.Open */
      );
    }
    if (!e.elements.length) {
      if (this._currentSuggestionDetails) {
        this._currentSuggestionDetails.cancel();
        this._currentSuggestionDetails = void 0;
        this._focusedItem = void 0;
      }
      this.editor.setAriaOptions({ activeDescendant: void 0 });
      this._ctxSuggestWidgetHasFocusedSuggestion.set(false);
      return;
    }
    if (!this._completionModel) {
      return;
    }
    this._ctxSuggestWidgetHasFocusedSuggestion.set(true);
    const item = e.elements[0];
    const index = e.indexes[0];
    if (item !== this._focusedItem) {
      this._currentSuggestionDetails?.cancel();
      this._currentSuggestionDetails = void 0;
      this._focusedItem = item;
      this._list.reveal(index);
      this._currentSuggestionDetails = createCancelablePromise(async (token) => {
        const loading = disposableTimeout(() => {
          if (this._isDetailsVisible()) {
            this._showDetails(true, false);
          }
        }, 250);
        const sub = token.onCancellationRequested(() => loading.dispose());
        try {
          return await item.resolve(token);
        } finally {
          loading.dispose();
          sub.dispose();
        }
      });
      this._currentSuggestionDetails.then(() => {
        if (index >= this._list.length || item !== this._list.element(index)) {
          return;
        }
        this._ignoreFocusEvents = true;
        this._list.splice(index, 1, [item]);
        this._list.setFocus([index]);
        this._ignoreFocusEvents = false;
        if (this._isDetailsVisible()) {
          this._showDetails(false, false);
        } else {
          this.element.domNode.classList.remove("docs-side");
        }
        this.editor.setAriaOptions({ activeDescendant: this._list.getElementID(index) });
      }).catch(onUnexpectedError);
    }
    this._onDidFocus.fire({ item, index, model: this._completionModel });
  }
  _setState(state) {
    if (this._state === state) {
      return;
    }
    this._state = state;
    this.element.domNode.classList.toggle(
      "frozen",
      state === 4
      /* State.Frozen */
    );
    this.element.domNode.classList.remove("message");
    switch (state) {
      case 0:
        hide(this._messageElement, this._listElement, this._status.element);
        this._details.hide(true);
        this._status.hide();
        this._contentWidget.hide();
        this._ctxSuggestWidgetVisible.reset();
        this._ctxSuggestWidgetMultipleSuggestions.reset();
        this._ctxSuggestWidgetHasFocusedSuggestion.reset();
        this._showTimeout.cancel();
        this.element.domNode.classList.remove("visible");
        this._list.splice(0, this._list.length);
        this._focusedItem = void 0;
        this._cappedHeight = void 0;
        this._explainMode = false;
        break;
      case 1:
        this.element.domNode.classList.add("message");
        this._messageElement.textContent = SuggestWidget_1.LOADING_MESSAGE;
        hide(this._listElement, this._status.element);
        show(this._messageElement);
        this._details.hide();
        this._show();
        this._focusedItem = void 0;
        status(SuggestWidget_1.LOADING_MESSAGE);
        break;
      case 2:
        this.element.domNode.classList.add("message");
        this._messageElement.textContent = SuggestWidget_1.NO_SUGGESTIONS_MESSAGE;
        hide(this._listElement, this._status.element);
        show(this._messageElement);
        this._details.hide();
        this._show();
        this._focusedItem = void 0;
        status(SuggestWidget_1.NO_SUGGESTIONS_MESSAGE);
        break;
      case 3:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._show();
        break;
      case 4:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._show();
        break;
      case 5:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._details.show();
        this._show();
        this._details.widget.focus();
        break;
    }
  }
  _show() {
    this._status.show();
    this._contentWidget.show();
    this._layout(this._persistedSize.restore());
    this._ctxSuggestWidgetVisible.set(true);
    this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible");
      this._onDidShow.fire(this);
    }, 100);
  }
  showTriggered(auto, delay) {
    if (this._state !== 0) {
      return;
    }
    this._contentWidget.setPosition(this.editor.getPosition());
    this._isAuto = !!auto;
    if (!this._isAuto) {
      this._loadingTimeout = disposableTimeout(() => this._setState(
        1
        /* State.Loading */
      ), delay);
    }
  }
  showSuggestions(completionModel, selectionIndex, isFrozen, isAuto, noFocus) {
    this._contentWidget.setPosition(this.editor.getPosition());
    this._loadingTimeout?.dispose();
    this._currentSuggestionDetails?.cancel();
    this._currentSuggestionDetails = void 0;
    if (this._completionModel !== completionModel) {
      this._completionModel = completionModel;
    }
    if (isFrozen && this._state !== 2 && this._state !== 0) {
      this._setState(
        4
        /* State.Frozen */
      );
      return;
    }
    const visibleCount = this._completionModel.items.length;
    const isEmpty = visibleCount === 0;
    this._ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);
    if (isEmpty) {
      this._setState(
        isAuto ? 0 : 2
        /* State.Empty */
      );
      this._completionModel = void 0;
      return;
    }
    this._focusedItem = void 0;
    this._onDidFocus.pause();
    this._onDidSelect.pause();
    try {
      this._list.splice(0, this._list.length, this._completionModel.items);
      this._setState(
        isFrozen ? 4 : 3
        /* State.Open */
      );
      this._list.reveal(selectionIndex, 0, selectionIndex === 0 ? 0 : this.getLayoutInfo().itemHeight * 0.33);
      this._list.setFocus(noFocus ? [] : [selectionIndex]);
    } finally {
      this._onDidFocus.resume();
      this._onDidSelect.resume();
    }
    this._pendingLayout.value = runAtThisOrScheduleAtNextAnimationFrame(getWindow(this.element.domNode), () => {
      this._pendingLayout.clear();
      this._layout(this.element.size);
      this._details.widget.domNode.classList.remove("focused");
    });
  }
  focusSelected() {
    if (this._list.length > 0) {
      this._list.setFocus([0]);
    }
  }
  selectNextPage() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.pageDown();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusNextPage();
        return true;
    }
  }
  selectNext() {
    switch (this._state) {
      case 0:
        return false;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusNext(1, true);
        return true;
    }
  }
  selectLast() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.scrollBottom();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusLast();
        return true;
    }
  }
  selectPreviousPage() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.pageUp();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusPreviousPage();
        return true;
    }
  }
  selectPrevious() {
    switch (this._state) {
      case 0:
        return false;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusPrevious(1, true);
        return false;
    }
  }
  selectFirst() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.scrollTop();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusFirst();
        return true;
    }
  }
  getFocusedItem() {
    if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel && this._list.getFocus().length > 0) {
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
    }
    return void 0;
  }
  toggleDetailsFocus() {
    if (this._state === 5) {
      this._list.setFocus(this._list.getFocus());
      this._setState(
        3
        /* State.Open */
      );
    } else if (this._state === 3) {
      this._setState(
        5
        /* State.Details */
      );
      if (!this._isDetailsVisible()) {
        this.toggleDetails(true);
      } else {
        this._details.widget.focus();
      }
    }
  }
  toggleDetails(focused = false) {
    if (this._isDetailsVisible()) {
      this._pendingShowDetails.clear();
      this._ctxSuggestWidgetDetailsVisible.set(false);
      this._setDetailsVisible(false);
      this._details.hide();
      this.element.domNode.classList.remove("shows-details");
    } else if ((canExpandCompletionItem(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4)) {
      this._ctxSuggestWidgetDetailsVisible.set(true);
      this._setDetailsVisible(true);
      this._showDetails(false, focused);
    }
  }
  _showDetails(loading, focused) {
    this._pendingShowDetails.value = runAtThisOrScheduleAtNextAnimationFrame(getWindow(this.element.domNode), () => {
      this._pendingShowDetails.clear();
      this._details.show();
      let didFocusDetails = false;
      if (loading) {
        this._details.widget.renderLoading();
      } else {
        this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode);
      }
      if (!this._details.widget.isEmpty) {
        this._positionDetails();
        this.element.domNode.classList.add("shows-details");
        if (focused) {
          this._details.widget.focus();
          didFocusDetails = true;
        }
      } else {
        this._details.hide();
      }
      if (!didFocusDetails) {
        this.editor.focus();
      }
    });
  }
  toggleExplainMode() {
    if (this._list.getFocusedElements()[0]) {
      this._explainMode = !this._explainMode;
      if (!this._isDetailsVisible()) {
        this.toggleDetails();
      } else {
        this._showDetails(false, false);
      }
    }
  }
  resetPersistedSize() {
    this._persistedSize.reset();
  }
  hideWidget() {
    this._pendingLayout.clear();
    this._pendingShowDetails.clear();
    this._loadingTimeout?.dispose();
    this._setState(
      0
      /* State.Hidden */
    );
    this._onDidHide.fire(this);
    this.element.clearSashHoverState();
    const dim = this._persistedSize.restore();
    const minPersistedHeight = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
    if (dim && dim.height < minPersistedHeight) {
      this._persistedSize.store(dim.with(void 0, minPersistedHeight));
    }
  }
  isFrozen() {
    return this._state === 4;
  }
  _afterRender(position) {
    if (position === null) {
      if (this._isDetailsVisible()) {
        this._details.hide();
      }
      return;
    }
    if (this._state === 2 || this._state === 1) {
      return;
    }
    if (this._isDetailsVisible() && !this._details.widget.isEmpty) {
      this._details.show();
    }
    this._positionDetails();
  }
  _layout(size2) {
    if (!this.editor.hasModel()) {
      return;
    }
    if (!this.editor.getDomNode()) {
      return;
    }
    const bodyBox = getClientArea(this.element.domNode.ownerDocument.body);
    const info = this.getLayoutInfo();
    if (!size2) {
      size2 = info.defaultSize;
    }
    let height = size2.height;
    let width = size2.width;
    this._status.element.style.height = `${info.itemHeight}px`;
    if (this._state === 2 || this._state === 1) {
      height = info.itemHeight + info.borderHeight;
      width = info.defaultSize.width / 2;
      this.element.enableSashes(false, false, false, false);
      this.element.minSize = this.element.maxSize = new Dimension(width, height);
      this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      );
    } else {
      const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;
      if (width > maxWidth) {
        width = maxWidth;
      }
      const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;
      const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;
      const minHeight = info.itemHeight + info.statusBarHeight;
      const editorBox = getDomNodePagePosition(this.editor.getDomNode());
      const cursorBox = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
      const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;
      const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);
      const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
      const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
      let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
      if (height === this._cappedHeight?.capped) {
        height = this._cappedHeight.wanted;
      }
      if (height < minHeight) {
        height = minHeight;
      }
      if (height > maxHeight) {
        height = maxHeight;
      }
      const forceRenderingAboveRequiredSpace = 150;
      if (height > maxHeightBelow && maxHeightAbove > maxHeightBelow || this._forceRenderingAbove && availableSpaceAbove > forceRenderingAboveRequiredSpace) {
        this._contentWidget.setPreference(
          1
          /* ContentWidgetPositionPreference.ABOVE */
        );
        this.element.enableSashes(true, true, false, false);
        maxHeight = maxHeightAbove;
      } else {
        this._contentWidget.setPreference(
          2
          /* ContentWidgetPositionPreference.BELOW */
        );
        this.element.enableSashes(false, true, true, false);
        maxHeight = maxHeightBelow;
      }
      this.element.preferredSize = new Dimension(preferredWidth, info.defaultSize.height);
      this.element.maxSize = new Dimension(maxWidth, maxHeight);
      this.element.minSize = new Dimension(220, minHeight);
      this._cappedHeight = height === fullHeight ? { wanted: this._cappedHeight?.wanted ?? size2.height, capped: height } : void 0;
    }
    this._resize(width, height);
  }
  _resize(width, height) {
    const { width: maxWidth, height: maxHeight } = this.element.maxSize;
    width = Math.min(maxWidth, width);
    height = Math.min(maxHeight, height);
    const { statusBarHeight } = this.getLayoutInfo();
    this._list.layout(height - statusBarHeight, width);
    this._listElement.style.height = `${height - statusBarHeight}px`;
    this.element.layout(height, width);
    this._contentWidget.layout();
    this._positionDetails();
  }
  _positionDetails() {
    if (this._isDetailsVisible()) {
      this._details.placeAtAnchor(
        this.element.domNode,
        this._contentWidget.getPosition()?.preference[0] === 2
        /* ContentWidgetPositionPreference.BELOW */
      );
    }
  }
  getLayoutInfo() {
    const fontInfo = this.editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    const itemHeight = clamp(this.editor.getOption(
      136
      /* EditorOption.suggestLineHeight */
    ) || fontInfo.lineHeight, 8, 1e3);
    const statusBarHeight = !this.editor.getOption(
      134
      /* EditorOption.suggest */
    ).showStatusBar || this._state === 2 || this._state === 1 ? 0 : itemHeight;
    const borderWidth = this._details.widget.borderWidth;
    const borderHeight = 2 * borderWidth;
    return {
      itemHeight,
      statusBarHeight,
      borderWidth,
      borderHeight,
      typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new Dimension(430, statusBarHeight + 12 * itemHeight)
    };
  }
  _isDetailsVisible() {
    return this._storageService.getBoolean("expandSuggestionDocs", 0, false);
  }
  _setDetailsVisible(value) {
    this._storageService.store(
      "expandSuggestionDocs",
      value,
      0,
      0
      /* StorageTarget.USER */
    );
  }
  forceRenderingAbove() {
    if (!this._forceRenderingAbove) {
      this._forceRenderingAbove = true;
      this._layout(this._persistedSize.restore());
    }
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = false;
  }
}, SuggestWidget_1 = _a43, _a43.LOADING_MESSAGE = localize(1467, "Loading..."), _a43.NO_SUGGESTIONS_MESSAGE = localize(1468, "No suggestions."), _a43);
SuggestWidget = SuggestWidget_1 = __decorate60([
  __param60(1, IStorageService),
  __param60(2, IContextKeyService),
  __param60(3, IThemeService),
  __param60(4, IInstantiationService)
], SuggestWidget);
var SuggestContentWidget = class {
  constructor(_widget, _editor) {
    this._widget = _widget;
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._preferenceLocked = false;
    this._added = false;
    this._hidden = false;
  }
  dispose() {
    if (this._added) {
      this._added = false;
      this._editor.removeContentWidget(this);
    }
  }
  getId() {
    return "editor.widget.suggestWidget";
  }
  getDomNode() {
    return this._widget.element.domNode;
  }
  show() {
    this._hidden = false;
    if (!this._added) {
      this._added = true;
      this._editor.addContentWidget(this);
    }
  }
  hide() {
    if (!this._hidden) {
      this._hidden = true;
      this.layout();
    }
  }
  layout() {
    this._editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this._hidden || !this._position || !this._preference) {
      return null;
    }
    return {
      position: this._position,
      preference: [this._preference]
    };
  }
  beforeRender() {
    const { height, width } = this._widget.element.size;
    const { borderWidth, horizontalPadding } = this._widget.getLayoutInfo();
    return new Dimension(width + 2 * borderWidth + horizontalPadding, height + 2 * borderWidth);
  }
  afterRender(position) {
    this._widget._afterRender(position);
  }
  setPreference(preference) {
    if (!this._preferenceLocked) {
      this._preference = preference;
    }
  }
  lockPreference() {
    this._preferenceLocked = true;
  }
  unlockPreference() {
    this._preferenceLocked = false;
  }
  setPosition(position) {
    this._position = position;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
init_telemetry();
init_resources();
init_hash();
init_dom();
init_textModel();
init_textModelEditSource();
var __decorate61 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param61 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestController_1;
var _sticky2 = false;
var LineSuffix = class {
  constructor(_model, _position) {
    this._model = _model;
    this._position = _position;
    this._decorationOptions = ModelDecorationOptions.register({
      description: "suggest-line-suffix",
      stickiness: 1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    });
    const maxColumn = _model.getLineMaxColumn(_position.lineNumber);
    if (maxColumn !== _position.column) {
      const offset = _model.getOffsetAt(_position);
      const end = _model.getPositionAt(offset + 1);
      _model.changeDecorations((accessor) => {
        if (this._marker) {
          accessor.removeDecoration(this._marker);
        }
        this._marker = accessor.addDecoration(Range.fromPositions(_position, end), this._decorationOptions);
      });
    }
  }
  dispose() {
    if (this._marker && !this._model.isDisposed()) {
      this._model.changeDecorations((accessor) => {
        accessor.removeDecoration(this._marker);
        this._marker = void 0;
      });
    }
  }
  delta(position) {
    if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {
      return 0;
    }
    if (this._marker) {
      const range = this._model.getDecorationRange(this._marker);
      const end = this._model.getOffsetAt(range.getStartPosition());
      return end - this._model.getOffsetAt(position);
    } else {
      return this._model.getLineMaxColumn(position.lineNumber) - position.column;
    }
  }
};
var _a44;
var SuggestController = (_a44 = class {
  static get(editor2) {
    return editor2.getContribution(SuggestController_1.ID);
  }
  get onWillInsertSuggestItem() {
    return this._onWillInsertSuggestItem.event;
  }
  constructor(editor2, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService, _telemetryService) {
    this._memoryService = _memoryService;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._telemetryService = _telemetryService;
    this._lineSuffix = new MutableDisposable();
    this._toDispose = new DisposableStore();
    this._selectors = new PriorityRegistry((s) => s.priority);
    this._onWillInsertSuggestItem = new Emitter();
    this._wantsForceRenderingAbove = false;
    this.editor = editor2;
    this.model = _instantiationService.createInstance(SuggestModel, this.editor);
    this._selectors.register({
      priority: 0,
      select: (model, pos, items) => this._memoryService.select(model, pos, items)
    });
    const ctxInsertMode = Context.InsertMode.bindTo(_contextKeyService);
    ctxInsertMode.set(editor2.getOption(
      134
      /* EditorOption.suggest */
    ).insertMode);
    this._toDispose.add(this.model.onDidTrigger(() => ctxInsertMode.set(editor2.getOption(
      134
      /* EditorOption.suggest */
    ).insertMode)));
    this.widget = this._toDispose.add(new WindowIdleValue(getWindow(editor2.getDomNode()), () => {
      const widget = this._instantiationService.createInstance(SuggestWidget, this.editor);
      this._toDispose.add(widget);
      this._toDispose.add(widget.onDidSelect((item) => this._insertSuggestion(
        item,
        0
        /* InsertFlags.None */
      ), this));
      const commitCharacterController = new CommitCharacterController(this.editor, widget, this.model, (item) => this._insertSuggestion(
        item,
        2
        /* InsertFlags.NoAfterUndoStop */
      ));
      this._toDispose.add(commitCharacterController);
      const ctxMakesTextEdit = Context.MakesTextEdit.bindTo(this._contextKeyService);
      const ctxHasInsertAndReplace = Context.HasInsertAndReplaceRange.bindTo(this._contextKeyService);
      const ctxCanResolve = Context.CanResolve.bindTo(this._contextKeyService);
      this._toDispose.add(toDisposable(() => {
        ctxMakesTextEdit.reset();
        ctxHasInsertAndReplace.reset();
        ctxCanResolve.reset();
      }));
      this._toDispose.add(widget.onDidFocus(({ item }) => {
        const position = this.editor.getPosition();
        const startColumn = item.editStart.column;
        const endColumn = position.column;
        let value = true;
        if (this.editor.getOption(
          1
          /* EditorOption.acceptSuggestionOnEnter */
        ) === "smart" && this.model.state === 2 && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4) && endColumn - startColumn === item.completion.insertText.length) {
          const oldText = this.editor.getModel().getValueInRange({
            startLineNumber: position.lineNumber,
            startColumn,
            endLineNumber: position.lineNumber,
            endColumn
          });
          value = oldText !== item.completion.insertText;
        }
        ctxMakesTextEdit.set(value);
        ctxHasInsertAndReplace.set(!Position.equals(item.editInsertEnd, item.editReplaceEnd));
        ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);
      }));
      this._toDispose.add(widget.onDetailsKeyDown((e) => {
        if (e.toKeyCodeChord().equals(new KeyCodeChord(
          true,
          false,
          false,
          false,
          33
          /* KeyCode.KeyC */
        )) || isMacintosh && e.toKeyCodeChord().equals(new KeyCodeChord(
          false,
          false,
          false,
          true,
          33
          /* KeyCode.KeyC */
        ))) {
          e.stopPropagation();
          return;
        }
        if (!e.toKeyCodeChord().isModifierKey()) {
          this.editor.focus();
        }
      }));
      if (this._wantsForceRenderingAbove) {
        widget.forceRenderingAbove();
      }
      return widget;
    }));
    this._overtypingCapturer = this._toDispose.add(new WindowIdleValue(getWindow(editor2.getDomNode()), () => {
      return this._toDispose.add(new OvertypingCapturer(this.editor, this.model));
    }));
    this._alternatives = this._toDispose.add(new WindowIdleValue(getWindow(editor2.getDomNode()), () => {
      return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));
    }));
    this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor2));
    this._toDispose.add(this.model.onDidTrigger((e) => {
      this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);
      this._lineSuffix.value = new LineSuffix(this.editor.getModel(), e.position);
    }));
    this._toDispose.add(this.model.onDidSuggest((e) => {
      if (e.triggerOptions.shy) {
        return;
      }
      let index = -1;
      for (const selector of this._selectors.itemsOrderedByPriorityDesc) {
        index = selector.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
        if (index !== -1) {
          break;
        }
      }
      if (index === -1) {
        index = 0;
      }
      if (this.model.state === 0) {
        return;
      }
      let noFocus = false;
      if (e.triggerOptions.auto) {
        const options = this.editor.getOption(
          134
          /* EditorOption.suggest */
        );
        if (options.selectionMode === "never" || options.selectionMode === "always") {
          noFocus = options.selectionMode === "never";
        } else if (options.selectionMode === "whenTriggerCharacter") {
          noFocus = e.triggerOptions.triggerKind !== 1;
        } else if (options.selectionMode === "whenQuickSuggestion") {
          noFocus = e.triggerOptions.triggerKind === 1 && !e.triggerOptions.refilter;
        }
      }
      this.widget.value.showSuggestions(e.completionModel, index, e.isFrozen, e.triggerOptions.auto, noFocus);
    }));
    this._toDispose.add(this.model.onDidCancel((e) => {
      if (!e.retrigger) {
        this.widget.value.hideWidget();
      }
    }));
    this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      if (!_sticky2) {
        this.model.cancel();
        this.model.clear();
      }
    }));
    const acceptSuggestionsOnEnter = Context.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
    const updateFromConfig = () => {
      const acceptSuggestionOnEnter = this.editor.getOption(
        1
        /* EditorOption.acceptSuggestionOnEnter */
      );
      acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === "on" || acceptSuggestionOnEnter === "smart");
    };
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));
    updateFromConfig();
  }
  dispose() {
    this._alternatives.dispose();
    this._toDispose.dispose();
    this.widget.dispose();
    this.model.dispose();
    this._lineSuffix.dispose();
    this._onWillInsertSuggestItem.dispose();
  }
  _insertSuggestion(event, flags) {
    if (!event || !event.item) {
      this._alternatives.value.reset();
      this.model.cancel();
      this.model.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const snippetController = SnippetController2.get(this.editor);
    if (!snippetController) {
      return;
    }
    this._onWillInsertSuggestItem.fire({ item: event.item });
    const model = this.editor.getModel();
    const modelVersionNow = model.getAlternativeVersionId();
    const { item } = event;
    const tasks = [];
    const cts = new CancellationTokenSource();
    if (!(flags & 1)) {
      this.editor.pushUndoStop();
    }
    const info = this.getOverwriteInfo(item, Boolean(
      flags & 8
      /* InsertFlags.AlternativeOverwriteConfig */
    ));
    this._memoryService.memorize(model, this.editor.getPosition(), item);
    const isResolved = item.isResolved;
    let _commandExectionDuration = -1;
    let _additionalEditsAppliedAsync = -1;
    if (Array.isArray(item.completion.additionalTextEdits)) {
      this.model.cancel();
      const scrollState = StableEditorScrollState.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", item.completion.additionalTextEdits.map((edit) => {
        let range = Range.lift(edit.range);
        if (range.startLineNumber === item.position.lineNumber && range.startColumn > item.position.column) {
          const columnDelta = this.editor.getPosition().column - item.position.column;
          const startColumnDelta = columnDelta;
          const endColumnDelta = Range.spansMultipleLines(range) ? 0 : columnDelta;
          range = new Range(range.startLineNumber, range.startColumn + startColumnDelta, range.endLineNumber, range.endColumn + endColumnDelta);
        }
        return EditOperation.replaceMove(range, edit.text);
      }));
      scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!isResolved) {
      const sw = new StopWatch();
      let position;
      const docListener = model.onDidChangeContent((e) => {
        if (e.isFlush) {
          cts.cancel();
          docListener.dispose();
          return;
        }
        for (const change of e.changes) {
          const thisPosition = Range.getEndPosition(change.range);
          if (!position || Position.isBefore(thisPosition, position)) {
            position = thisPosition;
          }
        }
      });
      const oldFlags = flags;
      flags |= 2;
      let didType = false;
      const typeListener = this.editor.onWillType(() => {
        typeListener.dispose();
        didType = true;
        if (!(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
      });
      tasks.push(item.resolve(cts.token).then(() => {
        if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) {
          return void 0;
        }
        if (position && item.completion.additionalTextEdits.some((edit) => Position.isBefore(position, Range.getStartPosition(edit.range)))) {
          return false;
        }
        if (didType) {
          this.editor.pushUndoStop();
        }
        const scrollState = StableEditorScrollState.capture(this.editor);
        this.editor.executeEdits("suggestController.additionalTextEdits.async", item.completion.additionalTextEdits.map((edit) => EditOperation.replaceMove(Range.lift(edit.range), edit.text)));
        scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
        if (didType || !(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
        return true;
      }).then((applied) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", sw.elapsed(), applied);
        _additionalEditsAppliedAsync = applied === true ? 1 : applied === false ? 0 : -2;
      }).finally(() => {
        docListener.dispose();
        typeListener.dispose();
      }));
    }
    let { insertText } = item.completion;
    if (!(item.completion.insertTextRules & 4)) {
      insertText = SnippetParser.escape(insertText);
    }
    this.model.cancel();
    snippetController.insert(insertText, {
      overwriteBefore: info.overwriteBefore,
      overwriteAfter: info.overwriteAfter,
      undoStopBefore: false,
      undoStopAfter: false,
      adjustWhitespace: !(item.completion.insertTextRules & 1),
      clipboardText: event.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value,
      reason: EditSources.suggest({ providerId: ProviderId.fromExtensionId(item.extensionId?.value) })
    });
    if (!(flags & 2)) {
      this.editor.pushUndoStop();
    }
    if (item.completion.command) {
      if (item.completion.command.id === TriggerSuggestAction.id) {
        this.model.trigger({ auto: true, retrigger: true });
      } else {
        const sw = new StopWatch();
        tasks.push(this._commandService.executeCommand(item.completion.command.id, ...item.completion.command.arguments ? [...item.completion.command.arguments] : []).catch((e) => {
          if (item.completion.extensionId) {
            onUnexpectedExternalError(e);
          } else {
            onUnexpectedError(e);
          }
        }).finally(() => {
          _commandExectionDuration = sw.elapsed();
        }));
      }
    }
    if (flags & 4) {
      this._alternatives.value.set(event, (next) => {
        cts.cancel();
        while (model.canUndo()) {
          if (modelVersionNow !== model.getAlternativeVersionId()) {
            model.undo();
          }
          this._insertSuggestion(next, 1 | 2 | (flags & 8 ? 8 : 0));
          break;
        }
      });
    }
    this._alertCompletionItem(item);
    Promise.all(tasks).finally(() => {
      this._reportSuggestionAcceptedTelemetry(item, model, isResolved, _commandExectionDuration, _additionalEditsAppliedAsync, event.index, event.model.items);
      this.model.clear();
      cts.dispose();
    });
  }
  _reportSuggestionAcceptedTelemetry(item, model, itemResolved, commandExectionDuration, additionalEditsAppliedAsync, index, completionItems) {
    if (Math.random() > 1e-4) {
      return;
    }
    const labelMap = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < Math.min(30, completionItems.length); i2++) {
      const label = completionItems[i2].textLabel;
      if (labelMap.has(label)) {
        labelMap.get(label).push(i2);
      } else {
        labelMap.set(label, [i2]);
      }
    }
    const firstIndexArray = labelMap.get(item.textLabel);
    const hasDuplicates = firstIndexArray && firstIndexArray.length > 1;
    const firstIndex = hasDuplicates ? firstIndexArray[0] : -1;
    this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
      extensionId: item.extensionId?.value ?? "unknown",
      providerId: item.provider._debugDisplayName ?? "unknown",
      kind: item.completion.kind,
      basenameHash: hash(basename2(model.uri)).toString(16),
      languageId: model.getLanguageId(),
      fileExtension: extname(model.uri),
      resolveInfo: !item.provider.resolveCompletionItem ? -1 : itemResolved ? 1 : 0,
      resolveDuration: item.resolveDuration,
      commandDuration: commandExectionDuration,
      additionalEditsAsync: additionalEditsAppliedAsync,
      index,
      firstIndex
    });
  }
  getOverwriteInfo(item, toggleMode) {
    assertType(this.editor.hasModel());
    let replace = this.editor.getOption(
      134
      /* EditorOption.suggest */
    ).insertMode === "replace";
    if (toggleMode) {
      replace = !replace;
    }
    const overwriteBefore = item.position.column - item.editStart.column;
    const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;
    const columnDelta = this.editor.getPosition().column - item.position.column;
    const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: overwriteBefore + columnDelta,
      overwriteAfter: overwriteAfter + suffixDelta
    };
  }
  _alertCompletionItem(item) {
    if (isNonEmptyArray(item.completion.additionalTextEdits)) {
      const msg = localize(1448, "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);
      alert(msg);
    }
  }
  triggerSuggest(onlyFrom, auto, noFilter) {
    if (this.editor.hasModel()) {
      this.model.trigger({
        auto: auto ?? false,
        completionOptions: { providerFilter: onlyFrom, kindFilter: noFilter ? /* @__PURE__ */ new Set() : void 0 }
      });
      this.editor.revealPosition(
        this.editor.getPosition(),
        0
        /* ScrollType.Smooth */
      );
      this.editor.focus();
    }
  }
  triggerSuggestAndAcceptBest(arg) {
    if (!this.editor.hasModel()) {
      return;
    }
    const positionNow = this.editor.getPosition();
    const fallback = () => {
      if (positionNow.equals(this.editor.getPosition())) {
        this._commandService.executeCommand(arg.fallback);
      }
    };
    const makesTextEdit = (item) => {
      if (item.completion.insertTextRules & 4 || item.completion.additionalTextEdits) {
        return true;
      }
      const position = this.editor.getPosition();
      const startColumn = item.editStart.column;
      const endColumn = position.column;
      if (endColumn - startColumn !== item.completion.insertText.length) {
        return true;
      }
      const textNow = this.editor.getModel().getValueInRange({
        startLineNumber: position.lineNumber,
        startColumn,
        endLineNumber: position.lineNumber,
        endColumn
      });
      return textNow !== item.completion.insertText;
    };
    Event.once(this.model.onDidTrigger)((_) => {
      const listener = [];
      Event.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        dispose(listener);
        fallback();
      }, void 0, listener);
      this.model.onDidSuggest(({ completionModel }) => {
        dispose(listener);
        if (completionModel.items.length === 0) {
          fallback();
          return;
        }
        const index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);
        const item = completionModel.items[index];
        if (!makesTextEdit(item)) {
          fallback();
          return;
        }
        this.editor.pushUndoStop();
        this._insertSuggestion(
          { index, item, model: completionModel },
          4 | 1 | 2
          /* InsertFlags.NoAfterUndoStop */
        );
      }, void 0, listener);
    });
    this.model.trigger({ auto: false, shy: true });
    this.editor.revealPosition(
      positionNow,
      0
      /* ScrollType.Smooth */
    );
    this.editor.focus();
  }
  acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {
    const item = this.widget.value.getFocusedItem();
    let flags = 0;
    if (keepAlternativeSuggestions) {
      flags |= 4;
    }
    if (alternativeOverwriteConfig) {
      flags |= 8;
    }
    this._insertSuggestion(item, flags);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel();
    this.model.clear();
    this.widget.value.hideWidget();
  }
  focusSuggestion() {
    this.widget.value.focusSelected();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
  resetWidgetSize() {
    this.widget.value.resetPersistedSize();
  }
  forceRenderingAbove() {
    if (this.widget.isInitialized) {
      this.widget.value.forceRenderingAbove();
    } else {
      this._wantsForceRenderingAbove = true;
    }
  }
  stopForceRenderingAbove() {
    if (this.widget.isInitialized) {
      this.widget.value.stopForceRenderingAbove();
    } else {
      this._wantsForceRenderingAbove = false;
    }
  }
  registerSelector(selector) {
    return this._selectors.register(selector);
  }
}, SuggestController_1 = _a44, _a44.ID = "editor.contrib.suggestController", _a44);
SuggestController = SuggestController_1 = __decorate61([
  __param61(1, ISuggestMemoryService),
  __param61(2, ICommandService),
  __param61(3, IContextKeyService),
  __param61(4, IInstantiationService),
  __param61(5, ILogService),
  __param61(6, ITelemetryService)
], SuggestController);
var PriorityRegistry = class {
  constructor(prioritySelector) {
    this.prioritySelector = prioritySelector;
    this._items = new Array();
  }
  register(value) {
    if (this._items.indexOf(value) !== -1) {
      throw new Error("Value is already registered");
    }
    this._items.push(value);
    this._items.sort((s1, s2) => this.prioritySelector(s2) - this.prioritySelector(s1));
    return {
      dispose: () => {
        const idx = this._items.indexOf(value);
        if (idx >= 0) {
          this._items.splice(idx, 1);
        }
      }
    };
  }
  get itemsOrderedByPriorityDesc() {
    return this._items;
  }
};
var _TriggerSuggestAction = class _TriggerSuggestAction extends EditorAction {
  constructor() {
    super({
      id: _TriggerSuggestAction.id,
      label: localize2(1456, "Trigger Suggest"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider, Context.Visible.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 10,
        secondary: [
          2048 | 39
          /* KeyCode.KeyI */
        ],
        mac: { primary: 256 | 10, secondary: [
          512 | 9,
          2048 | 39
          /* KeyCode.KeyI */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2, args) {
    const controller = SuggestController.get(editor2);
    if (!controller) {
      return;
    }
    let auto;
    if (args && typeof args === "object") {
      if (args.auto === true) {
        auto = true;
      }
    }
    controller.triggerSuggest(void 0, auto, void 0);
  }
};
_TriggerSuggestAction.id = "editor.action.triggerSuggest";
var TriggerSuggestAction = _TriggerSuggestAction;
registerEditorContribution(
  SuggestController.ID,
  SuggestController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(TriggerSuggestAction);
var weight2 = 100 + 90;
var SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
registerEditorCommand(new SuggestCommand({
  id: "acceptSelectedSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion),
  handler(x) {
    x.acceptSelectedSuggestion(true, false);
  },
  kbOpts: [{
    // normal tab
    primary: 2,
    kbExpr: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus),
    weight: weight2
  }, {
    // accept on enter has special rules
    primary: 3,
    kbExpr: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus, Context.AcceptSuggestionsOnEnter, Context.MakesTextEdit),
    weight: weight2
  }],
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    title: localize(1449, "Insert"),
    group: "left",
    order: 1,
    when: Context.HasInsertAndReplaceRange.toNegated()
  }, {
    menuId: suggestWidgetStatusbarMenu,
    title: localize(1450, "Insert"),
    group: "left",
    order: 1,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert"))
  }, {
    menuId: suggestWidgetStatusbarMenu,
    title: localize(1451, "Replace"),
    group: "left",
    order: 1,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace"))
  }]
}));
registerEditorCommand(new SuggestCommand({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus, Context.HasFocusedSuggestion),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 3,
    secondary: [
      1024 | 2
      /* KeyCode.Tab */
    ]
  },
  handler(x) {
    x.acceptSelectedSuggestion(false, true);
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert")),
    title: localize(1452, "Replace")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace")),
    title: localize(1453, "Insert")
  }]
}));
CommandsRegistry.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
registerEditorCommand(new SuggestCommand({
  id: "hideSuggestWidget",
  precondition: Context.Visible,
  handler: (x) => x.cancelSuggestWidget(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, ContextKeyExpr.or(Context.MultipleSuggestions, Context.HasFocusedSuggestion.negate())),
  handler: (c) => c.selectNextSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 18,
    secondary: [
      2048 | 18
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      2048 | 18,
      256 | 44
      /* KeyCode.KeyN */
    ] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextPageSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, ContextKeyExpr.or(Context.MultipleSuggestions, Context.HasFocusedSuggestion.negate())),
  handler: (c) => c.selectNextPageSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 12,
    secondary: [
      2048 | 12
      /* KeyCode.PageDown */
    ]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectLastSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, ContextKeyExpr.or(Context.MultipleSuggestions, Context.HasFocusedSuggestion.negate())),
  handler: (c) => c.selectLastSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, ContextKeyExpr.or(Context.MultipleSuggestions, Context.HasFocusedSuggestion.negate())),
  handler: (c) => c.selectPrevSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 16,
    secondary: [
      2048 | 16
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      2048 | 16,
      256 | 46
      /* KeyCode.KeyP */
    ] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevPageSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, ContextKeyExpr.or(Context.MultipleSuggestions, Context.HasFocusedSuggestion.negate())),
  handler: (c) => c.selectPrevPageSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 11,
    secondary: [
      2048 | 11
      /* KeyCode.PageUp */
    ]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectFirstSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, ContextKeyExpr.or(Context.MultipleSuggestions, Context.HasFocusedSuggestion.negate())),
  handler: (c) => c.selectFirstSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "focusSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion.negate()),
  handler: (x) => x.focusSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 10,
    secondary: [
      2048 | 39
      /* KeyCode.KeyI */
    ],
    mac: { primary: 256 | 10, secondary: [
      2048 | 39
      /* KeyCode.KeyI */
    ] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "focusAndAcceptSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion.negate()),
  handler: (c) => {
    c.focusSuggestion();
    c.acceptSelectedSuggestion(true, false);
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionDetails",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion),
  handler: (x) => x.toggleSuggestionDetails(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 10,
    secondary: [
      2048 | 39
      /* KeyCode.KeyI */
    ],
    mac: { primary: 256 | 10, secondary: [
      2048 | 39
      /* KeyCode.KeyI */
    ] }
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context.DetailsVisible, Context.CanResolve),
    title: localize(1454, "Show Less")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context.DetailsVisible.toNegated(), Context.CanResolve),
    title: localize(1455, "Show More")
  }]
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleExplainMode",
  precondition: Context.Visible,
  handler: (x) => x.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2048 | 90
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionFocus",
  precondition: Context.Visible,
  handler: (x) => x.toggleSuggestionFocus(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 512 | 10,
    mac: {
      primary: 256 | 512 | 10
      /* KeyCode.Space */
    }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertBestCompletion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), WordContextKey.AtEnd, Context.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x, arg) => {
    x.triggerSuggestAndAcceptBest(isObject(arg) ? { fallback: "tab", ...arg } : { fallback: "tab" });
  },
  kbOpts: {
    weight: weight2,
    primary: 2
    /* KeyCode.Tab */
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertNextSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptNextSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertPrevSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptPrevSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 2
    /* KeyCode.Tab */
  }
}));
registerEditorAction(class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.resetSuggestSize",
      label: localize2(1457, "Reset Suggest Widget Size"),
      precondition: void 0
    });
  }
  run(_accessor, editor2) {
    SuggestController.get(editor2)?.resetWidgetSize();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/model/suggestWidgetAdapter.js
init_observable();
var SuggestWidgetAdaptor = class extends Disposable {
  get selectedItem() {
    return this._currentSuggestItemInfo;
  }
  constructor(editor2, suggestControllerPreselector, onWillAccept) {
    super();
    this.editor = editor2;
    this.suggestControllerPreselector = suggestControllerPreselector;
    this.onWillAccept = onWillAccept;
    this.isSuggestWidgetVisible = false;
    this.isShiftKeyPressed = false;
    this._isActive = false;
    this._currentSuggestItemInfo = void 0;
    this._onDidSelectedItemChange = this._register(new Emitter());
    this.onDidSelectedItemChange = this._onDidSelectedItemChange.event;
    this._register(editor2.onKeyDown((e) => {
      if (e.shiftKey && !this.isShiftKeyPressed) {
        this.isShiftKeyPressed = true;
        this.update(this._isActive);
      }
    }));
    this._register(editor2.onKeyUp((e) => {
      if (e.shiftKey && this.isShiftKeyPressed) {
        this.isShiftKeyPressed = false;
        this.update(this._isActive);
      }
    }));
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      this._register(suggestController.registerSelector({
        priority: 100,
        select: (model, pos, suggestItems) => {
          const textModel = this.editor.getModel();
          if (!textModel) {
            return -1;
          }
          const i2 = this.suggestControllerPreselector();
          const itemToPreselect = i2 ? singleTextRemoveCommonPrefix(i2, textModel) : void 0;
          if (!itemToPreselect) {
            return -1;
          }
          const position = Position.lift(pos);
          const candidates = suggestItems.map((suggestItem, index) => {
            const suggestItemInfo = SuggestItemInfo.fromSuggestion(suggestController, textModel, position, suggestItem, this.isShiftKeyPressed);
            const suggestItemTextEdit = singleTextRemoveCommonPrefix(suggestItemInfo.getSingleTextEdit(), textModel);
            const valid = singleTextEditAugments(itemToPreselect, suggestItemTextEdit);
            return { index, valid, prefixLength: suggestItemTextEdit.text.length, suggestItem };
          }).filter((item) => item && item.valid && item.prefixLength > 0);
          const result = findFirstMax(candidates, compareBy((s) => s.prefixLength, numberComparator));
          return result ? result.index : -1;
        }
      }));
      let isBoundToSuggestWidget = false;
      const bindToSuggestWidget = () => {
        if (isBoundToSuggestWidget) {
          return;
        }
        isBoundToSuggestWidget = true;
        this._register(suggestController.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
        this._register(suggestController.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = false;
          this.update(false);
        }));
        this._register(suggestController.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
      };
      this._register(Event.once(suggestController.model.onDidTrigger)((e) => {
        bindToSuggestWidget();
      }));
      this._register(suggestController.onWillInsertSuggestItem((e) => {
        const position = this.editor.getPosition();
        const model = this.editor.getModel();
        if (!position || !model) {
          return void 0;
        }
        const suggestItemInfo = SuggestItemInfo.fromSuggestion(suggestController, model, position, e.item, this.isShiftKeyPressed);
        this.onWillAccept(suggestItemInfo);
      }));
    }
    this.update(this._isActive);
  }
  update(newActive) {
    const newInlineCompletion = this.getSuggestItemInfo();
    if (this._isActive !== newActive || !suggestItemInfoEquals(this._currentSuggestItemInfo, newInlineCompletion)) {
      this._isActive = newActive;
      this._currentSuggestItemInfo = newInlineCompletion;
      this._onDidSelectedItemChange.fire();
    }
  }
  getSuggestItemInfo() {
    const suggestController = SuggestController.get(this.editor);
    if (!suggestController || !this.isSuggestWidgetVisible) {
      return void 0;
    }
    const focusedItem = suggestController.widget.value.getFocusedItem();
    const position = this.editor.getPosition();
    const model = this.editor.getModel();
    if (!focusedItem || !position || !model) {
      return void 0;
    }
    return SuggestItemInfo.fromSuggestion(suggestController, model, position, focusedItem.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController?.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController?.forceRenderingAbove();
  }
};
var SuggestItemInfo = class _SuggestItemInfo {
  static fromSuggestion(suggestController, model, position, item, toggleMode) {
    let { insertText } = item.completion;
    let isSnippetText = false;
    if (item.completion.insertTextRules & 4) {
      const snippet = new SnippetParser().parse(insertText);
      if (snippet.children.length < 100) {
        SnippetSession.adjustWhitespace(model, position, true, snippet);
      }
      insertText = snippet.toString();
      isSnippetText = true;
    }
    const info = suggestController.getOverwriteInfo(item, toggleMode);
    return new _SuggestItemInfo(Range.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0))), insertText, item.completion.kind, isSnippetText, item.container.incomplete ?? false);
  }
  constructor(range, insertText, completionItemKind, isSnippetText, listIncomplete) {
    this.range = range;
    this.insertText = insertText;
    this.completionItemKind = completionItemKind;
    this.isSnippetText = isSnippetText;
    this.listIncomplete = listIncomplete;
  }
  equals(other) {
    return this.range.equalsRange(other.range) && this.insertText === other.insertText && this.completionItemKind === other.completionItemKind && this.isSnippetText === other.isSnippetText;
  }
  toSelectedSuggestionInfo() {
    return new SelectedSuggestionInfo(this.range, this.insertText, this.completionItemKind, this.isSnippetText);
  }
  getSingleTextEdit() {
    return new TextReplacement(this.range, this.insertText);
  }
};
function suggestItemInfoEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.equals(b);
}
var ObservableSuggestWidgetAdapter = class extends Disposable {
  constructor(_editorObs, _handleSuggestAccepted, _suggestControllerPreselector) {
    super();
    this._editorObs = _editorObs;
    this._handleSuggestAccepted = _handleSuggestAccepted;
    this._suggestControllerPreselector = _suggestControllerPreselector;
    this._suggestWidgetAdaptor = this._register(new SuggestWidgetAdaptor(this._editorObs.editor, () => {
      this._editorObs.forceUpdate();
      return this._suggestControllerPreselector();
    }, (item) => this._editorObs.forceUpdate((_tx) => {
      this._handleSuggestAccepted(item);
    })));
    this.selectedItem = observableFromEvent(this, (cb) => this._suggestWidgetAdaptor.onDidSelectedItemChange(() => {
      this._editorObs.forceUpdate((_tx) => cb(void 0));
    }), () => this._suggestWidgetAdaptor.selectedItem);
  }
  stopForceRenderingAbove() {
    this._suggestWidgetAdaptor.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    this._suggestWidgetAdaptor.forceRenderingAbove();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineCompletionsView.js
init_lifecycle();
init_observable();
init_instantiation();
init_observableCodeEditor();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/ghostText/ghostTextView.js
init_iconLabels2();
init_codicons();
init_event();
init_lifecycle();
init_observable();
init_strings();
init_observableCodeEditor();
init_position();
init_range();
init_stringBuilder();
init_language();
init_model2();
init_lineTokens();

// node_modules/monaco-editor/esm/vs/editor/common/core/ranges/rangeSingleLine.js
var RangeSingleLine = class {
  constructor(lineNumber, columnRange) {
    this.lineNumber = lineNumber;
    this.columnRange = columnRange;
  }
};

// node_modules/monaco-editor/esm/vs/editor/common/core/ranges/columnRange.js
init_errors();
init_offsetRange();
init_range();
var ColumnRange = class {
  constructor(startColumn, endColumnExclusive) {
    this.startColumn = startColumn;
    this.endColumnExclusive = endColumnExclusive;
    if (startColumn > endColumnExclusive) {
      throw new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);
    }
  }
  toRange(lineNumber) {
    return new Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);
  }
  equals(other) {
    return this.startColumn === other.startColumn && this.endColumnExclusive === other.endColumnExclusive;
  }
  toZeroBasedOffsetRange() {
    return new OffsetRange(this.startColumn - 1, this.endColumnExclusive - 1);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/ghostText/ghostTextView.js
init_dom();
init_mouseEvent();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/ghostText/ghostTextView.css";

// node_modules/monaco-editor/esm/vs/editor/common/tokens/tokenWithTextArray.js
init_offsetRange();
init_lineTokens();
var TokenWithTextArray = class _TokenWithTextArray {
  static fromLineTokens(lineTokens) {
    const tokenInfo = [];
    for (let i2 = 0; i2 < lineTokens.getCount(); i2++) {
      tokenInfo.push(new TokenWithTextInfo(lineTokens.getTokenText(i2), lineTokens.getMetadata(i2)));
    }
    return _TokenWithTextArray.create(tokenInfo);
  }
  static create(tokenInfo) {
    return new _TokenWithTextArray(tokenInfo);
  }
  constructor(_tokenInfo) {
    this._tokenInfo = _tokenInfo;
  }
  toLineTokens(decoder) {
    return LineTokens.createFromTextAndMetadata(this.map((_r, t) => ({ text: t.text, metadata: t.metadata })), decoder);
  }
  map(cb) {
    const result = [];
    let lengthSum = 0;
    for (const tokenInfo of this._tokenInfo) {
      const range = new OffsetRange(lengthSum, lengthSum + tokenInfo.text.length);
      result.push(cb(range, tokenInfo));
      lengthSum += tokenInfo.text.length;
    }
    return result;
  }
  slice(range) {
    const result = [];
    let lengthSum = 0;
    for (const tokenInfo of this._tokenInfo) {
      const tokenStart = lengthSum;
      const tokenEndEx = tokenStart + tokenInfo.text.length;
      if (tokenEndEx > range.start) {
        if (tokenStart >= range.endExclusive) {
          break;
        }
        const deltaBefore = Math.max(0, range.start - tokenStart);
        const deltaAfter = Math.max(0, tokenEndEx - range.endExclusive);
        result.push(new TokenWithTextInfo(tokenInfo.text.slice(deltaBefore, tokenInfo.text.length - deltaAfter), tokenInfo.metadata));
      }
      lengthSum += tokenInfo.text.length;
    }
    return _TokenWithTextArray.create(result);
  }
  append(other) {
    const result = this._tokenInfo.concat(other._tokenInfo);
    return _TokenWithTextArray.create(result);
  }
};
var TokenWithTextInfo = class {
  constructor(text, metadata) {
    this.text = text;
    this.metadata = metadata;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/ghostText/ghostTextView.js
init_arrays();
var __decorate62 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param62 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GhostTextView_1;
var USE_SQUIGGLES_FOR_WARNING = true;
var GHOST_TEXT_CLASS_NAME = "ghost-text";
var _a45;
var GhostTextView = (_a45 = class extends Disposable {
  constructor(_editor, _model, _options, _shouldKeepCursorStable, _isClickable, _languageService) {
    super();
    this._editor = _editor;
    this._model = _model;
    this._options = _options;
    this._shouldKeepCursorStable = _shouldKeepCursorStable;
    this._isClickable = _isClickable;
    this._languageService = _languageService;
    this._isDisposed = observableValue(this, false);
    this._editorObs = observableCodeEditor(this._editor);
    this._warningState = derived((reader) => {
      const gt = this._model.ghostText.read(reader);
      if (!gt) {
        return void 0;
      }
      const warning = this._model.warning.read(reader);
      if (!warning) {
        return void 0;
      }
      return { lineNumber: gt.lineNumber, position: new Position(gt.lineNumber, gt.parts[0].column), icon: warning.icon };
    });
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._useSyntaxHighlighting = this._options.map((o) => o.syntaxHighlightingEnabled);
    this._extraClassNames = derived(this, (reader) => {
      const extraClasses = [...this._options.read(reader).extraClasses ?? []];
      if (this._useSyntaxHighlighting.read(reader)) {
        extraClasses.push("syntax-highlighted");
      }
      if (USE_SQUIGGLES_FOR_WARNING && this._warningState.read(reader)) {
        extraClasses.push("warning");
      }
      const extraClassNames = extraClasses.map((c) => ` ${c}`).join("");
      return extraClassNames;
    });
    this.uiState = derived(this, (reader) => {
      if (this._isDisposed.read(reader)) {
        return void 0;
      }
      const textModel = this._editorObs.model.read(reader);
      if (textModel !== this._model.targetTextModel.read(reader)) {
        return void 0;
      }
      const ghostText = this._model.ghostText.read(reader);
      if (!ghostText) {
        return void 0;
      }
      const replacedRange = ghostText instanceof GhostTextReplacement ? ghostText.columnRange : void 0;
      const syntaxHighlightingEnabled = this._useSyntaxHighlighting.read(reader);
      const extraClassNames = this._extraClassNames.read(reader);
      const { inlineTexts, additionalLines, hiddenRange, additionalLinesOriginalSuffix } = computeGhostTextViewData(ghostText, textModel, GHOST_TEXT_CLASS_NAME + extraClassNames);
      const currentLine = textModel.getLineContent(ghostText.lineNumber);
      const edit = new StringEdit(inlineTexts.map((t) => StringReplacement.insert(t.column - 1, t.text)));
      const tokens = syntaxHighlightingEnabled ? textModel.tokenization.tokenizeLinesAt(ghostText.lineNumber, [edit.apply(currentLine), ...additionalLines.map((l) => l.content)]) : void 0;
      const newRanges = edit.getNewRanges();
      const inlineTextsWithTokens = inlineTexts.map((t, idx) => ({ ...t, tokens: tokens?.[0]?.getTokensInRange(newRanges[idx]) }));
      const tokenizedAdditionalLines = additionalLines.map((l, idx) => {
        let content = tokens?.[idx + 1] ?? LineTokens.createEmpty(l.content, this._languageService.languageIdCodec);
        if (idx === additionalLines.length - 1 && additionalLinesOriginalSuffix) {
          const t = TokenWithTextArray.fromLineTokens(textModel.tokenization.getLineTokens(additionalLinesOriginalSuffix.lineNumber));
          const existingContent = t.slice(additionalLinesOriginalSuffix.columnRange.toZeroBasedOffsetRange());
          content = TokenWithTextArray.fromLineTokens(content).append(existingContent).toLineTokens(content.languageIdCodec);
        }
        return {
          content,
          decorations: l.decorations
        };
      });
      const cursorColumn = this._editor.getSelection()?.getStartPosition().column;
      const disjointInlineTexts = inlineTextsWithTokens.filter((inline) => inline.text !== "");
      const hasInsertionOnCurrentLine = disjointInlineTexts.length !== 0;
      const renderData = {
        cursorColumnDistance: (hasInsertionOnCurrentLine ? disjointInlineTexts[0].column : 1) - cursorColumn,
        cursorLineDistance: hasInsertionOnCurrentLine ? 0 : additionalLines.findIndex((line) => line.content !== "") + 1,
        lineCountOriginal: hasInsertionOnCurrentLine ? 1 : 0,
        lineCountModified: additionalLines.length + (hasInsertionOnCurrentLine ? 1 : 0),
        characterCountOriginal: 0,
        characterCountModified: sum(disjointInlineTexts.map((inline) => inline.text.length)) + sum(tokenizedAdditionalLines.map((line) => line.content.getTextLength())),
        disjointReplacements: disjointInlineTexts.length + (additionalLines.length > 0 ? 1 : 0),
        sameShapeReplacements: disjointInlineTexts.length > 1 && tokenizedAdditionalLines.length === 0 ? disjointInlineTexts.every((inline) => inline.text === disjointInlineTexts[0].text) : void 0
      };
      this._model.handleInlineCompletionShown.read(reader)?.(renderData);
      return {
        replacedRange,
        inlineTexts: inlineTextsWithTokens,
        additionalLines: tokenizedAdditionalLines,
        hiddenRange,
        lineNumber: ghostText.lineNumber,
        additionalReservedLineCount: this._model.minReservedLineCount.read(reader),
        targetTextModel: textModel,
        syntaxHighlightingEnabled
      };
    });
    this.decorations = derived(this, (reader) => {
      const uiState = this.uiState.read(reader);
      if (!uiState) {
        return [];
      }
      const decorations = [];
      const extraClassNames = this._extraClassNames.read(reader);
      if (uiState.replacedRange) {
        decorations.push({
          range: uiState.replacedRange.toRange(uiState.lineNumber),
          options: { inlineClassName: "inline-completion-text-to-replace" + extraClassNames, description: "GhostTextReplacement" }
        });
      }
      if (uiState.hiddenRange) {
        decorations.push({
          range: uiState.hiddenRange.toRange(uiState.lineNumber),
          options: { inlineClassName: "ghost-text-hidden", description: "ghost-text-hidden" }
        });
      }
      for (const p of uiState.inlineTexts) {
        decorations.push({
          range: Range.fromPositions(new Position(uiState.lineNumber, p.column)),
          options: {
            description: "ghost-text-decoration",
            after: {
              content: p.text,
              tokens: p.tokens,
              inlineClassName: (p.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration") + (this._isClickable ? " clickable" : "") + extraClassNames + p.lineDecorations.map((d) => " " + d.className).join(" "),
              // TODO: take the ranges into account for line decorations
              cursorStops: InjectedTextCursorStops.Left,
              attachedData: new GhostTextAttachedData(this)
            },
            showIfCollapsed: true
          }
        });
      }
      return decorations;
    });
    this._additionalLinesWidget = this._register(new AdditionalLinesWidget(this._editor, derived((reader) => {
      const uiState = this.uiState.read(reader);
      return uiState ? {
        lineNumber: uiState.lineNumber,
        additionalLines: uiState.additionalLines,
        minReservedLineCount: uiState.additionalReservedLineCount,
        targetTextModel: uiState.targetTextModel
      } : void 0;
    }), this._shouldKeepCursorStable, this._isClickable));
    this._isInlineTextHovered = this._editorObs.isTargetHovered((p) => p.target.type === 6 && p.target.detail.injectedText?.options.attachedData instanceof GhostTextAttachedData && p.target.detail.injectedText.options.attachedData.owner === this, this._store);
    this.isHovered = derived(this, (reader) => {
      if (this._isDisposed.read(reader)) {
        return false;
      }
      return this._isInlineTextHovered.read(reader) || this._additionalLinesWidget.isHovered.read(reader);
    });
    this.height = derived(this, (reader) => {
      const lineHeight = this._editorObs.getOption(
        75
        /* EditorOption.lineHeight */
      ).read(reader);
      return lineHeight + (this._additionalLinesWidget.viewZoneHeight.read(reader) ?? 0);
    });
    this._register(toDisposable(() => {
      this._isDisposed.set(true, void 0);
    }));
    this._register(this._editorObs.setDecorations(this.decorations));
    if (this._isClickable) {
      this._register(this._additionalLinesWidget.onDidClick((e) => this._onDidClick.fire(e)));
      this._register(this._editor.onMouseUp((e) => {
        if (e.target.type !== 6) {
          return;
        }
        const a = e.target.detail.injectedText?.options.attachedData;
        if (a instanceof GhostTextAttachedData && a.owner === this) {
          this._onDidClick.fire(e.event);
        }
      }));
    }
    this._register(autorunWithStore((reader, store) => {
      if (USE_SQUIGGLES_FOR_WARNING) {
        return;
      }
      const state = this._warningState.read(reader);
      if (!state) {
        return;
      }
      const lineHeight = this._editorObs.getOption(
        75
        /* EditorOption.lineHeight */
      );
      store.add(this._editorObs.createContentWidget({
        position: constObservable({
          position: new Position(state.lineNumber, Number.MAX_SAFE_INTEGER),
          preference: [
            0
            /* ContentWidgetPositionPreference.EXACT */
          ],
          positionAffinity: 1
        }),
        allowEditorOverflow: false,
        domNode: n.div({
          class: "ghost-text-view-warning-widget",
          style: {
            width: lineHeight,
            height: lineHeight,
            marginLeft: 4,
            color: "orange"
          },
          ref: (dom) => {
            dom.ghostTextViewWarningWidgetData = { range: Range.fromPositions(state.position) };
          }
        }, [
          n.div({
            class: "ghost-text-view-warning-widget-icon",
            style: {
              width: "100%",
              height: "100%",
              display: "flex",
              alignContent: "center",
              alignItems: "center"
            }
          }, [
            renderIcon(state.icon && "id" in state.icon ? state.icon : Codicon.warning)
          ])
        ]).keepUpdated(store).element
      }));
    }));
  }
  static getWarningWidgetContext(domNode) {
    const data = domNode.ghostTextViewWarningWidgetData;
    if (data) {
      return data;
    } else if (domNode.parentElement) {
      return this.getWarningWidgetContext(domNode.parentElement);
    }
    return void 0;
  }
  ownsViewZone(viewZoneId) {
    return this._additionalLinesWidget.viewZoneId === viewZoneId;
  }
}, GhostTextView_1 = _a45, _a45.hot = createHotClass(GhostTextView_1), _a45);
GhostTextView = GhostTextView_1 = __decorate62([
  __param62(5, ILanguageService)
], GhostTextView);
var GhostTextAttachedData = class {
  constructor(owner) {
    this.owner = owner;
  }
};
function computeGhostTextViewData(ghostText, textModel, ghostTextClassName) {
  const inlineTexts = [];
  const additionalLines = [];
  function addToAdditionalLines(ghLines, className) {
    if (additionalLines.length > 0) {
      const lastLine = additionalLines[additionalLines.length - 1];
      if (className) {
        lastLine.decorations.push(new LineDecoration(
          lastLine.content.length + 1,
          lastLine.content.length + 1 + ghLines[0].line.length,
          className,
          0
          /* InlineDecorationType.Regular */
        ));
      }
      lastLine.content += ghLines[0].line;
      ghLines = ghLines.slice(1);
    }
    for (const ghLine of ghLines) {
      additionalLines.push({
        content: ghLine.line,
        decorations: className ? [new LineDecoration(
          1,
          ghLine.line.length + 1,
          className,
          0
          /* InlineDecorationType.Regular */
        ), ...ghLine.lineDecorations] : [...ghLine.lineDecorations]
      });
    }
  }
  const textBufferLine = textModel.getLineContent(ghostText.lineNumber);
  let hiddenTextStartColumn = void 0;
  let lastIdx = 0;
  for (const part of ghostText.parts) {
    let ghLines = part.lines;
    if (hiddenTextStartColumn === void 0) {
      inlineTexts.push({ column: part.column, text: ghLines[0].line, preview: part.preview, lineDecorations: ghLines[0].lineDecorations });
      ghLines = ghLines.slice(1);
    } else {
      addToAdditionalLines([{ line: textBufferLine.substring(lastIdx, part.column - 1), lineDecorations: [] }], void 0);
    }
    if (ghLines.length > 0) {
      addToAdditionalLines(ghLines, ghostTextClassName);
      if (hiddenTextStartColumn === void 0 && part.column <= textBufferLine.length) {
        hiddenTextStartColumn = part.column;
      }
    }
    lastIdx = part.column - 1;
  }
  let additionalLinesOriginalSuffix = void 0;
  if (hiddenTextStartColumn !== void 0) {
    additionalLinesOriginalSuffix = new RangeSingleLine(ghostText.lineNumber, new ColumnRange(lastIdx + 1, textBufferLine.length + 1));
  }
  const hiddenRange = hiddenTextStartColumn !== void 0 ? new ColumnRange(hiddenTextStartColumn, textBufferLine.length + 1) : void 0;
  return {
    inlineTexts,
    additionalLines,
    hiddenRange,
    additionalLinesOriginalSuffix
  };
}
var AdditionalLinesWidget = class extends Disposable {
  get viewZoneId() {
    return this._viewZoneInfo?.viewZoneId;
  }
  get viewZoneHeight() {
    return this._viewZoneHeight;
  }
  constructor(_editor, _lines, _shouldKeepCursorStable, _isClickable) {
    super();
    this._editor = _editor;
    this._lines = _lines;
    this._shouldKeepCursorStable = _shouldKeepCursorStable;
    this._isClickable = _isClickable;
    this._viewZoneHeight = observableValue("viewZoneHeight", void 0);
    this.editorOptionsChanged = observableSignalFromEvent("editorOptionChanged", Event.filter(this._editor.onDidChangeConfiguration, (e) => e.hasChanged(
      40
      /* EditorOption.disableMonospaceOptimizations */
    ) || e.hasChanged(
      133
      /* EditorOption.stopRenderingLineAfter */
    ) || e.hasChanged(
      113
      /* EditorOption.renderWhitespace */
    ) || e.hasChanged(
      108
      /* EditorOption.renderControlCharacters */
    ) || e.hasChanged(
      60
      /* EditorOption.fontLigatures */
    ) || e.hasChanged(
      59
      /* EditorOption.fontInfo */
    ) || e.hasChanged(
      75
      /* EditorOption.lineHeight */
    )));
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._viewZoneListener = this._register(new MutableDisposable());
    this.isHovered = observableCodeEditor(this._editor).isTargetHovered((p) => isTargetGhostText(p.target.element), this._store);
    this.hasBeenAccepted = false;
    if (this._editor instanceof CodeEditorWidget && this._shouldKeepCursorStable) {
      this._register(this._editor.onBeforeExecuteEdit((e) => this.hasBeenAccepted = e.source === "inlineSuggestion.accept"));
    }
    this._register(autorun((reader) => {
      const lines = this._lines.read(reader);
      this.editorOptionsChanged.read(reader);
      if (lines) {
        this.hasBeenAccepted = false;
        this.updateLines(lines.lineNumber, lines.additionalLines, lines.minReservedLineCount);
      } else {
        this.clear();
      }
    }));
  }
  dispose() {
    super.dispose();
    this.clear();
  }
  clear() {
    this._viewZoneListener.clear();
    this._editor.changeViewZones((changeAccessor) => {
      this.removeActiveViewZone(changeAccessor);
    });
  }
  updateLines(lineNumber, additionalLines, minReservedLineCount) {
    const textModel = this._editor.getModel();
    if (!textModel) {
      return;
    }
    const { tabSize } = textModel.getOptions();
    this._editor.changeViewZones((changeAccessor) => {
      const store = new DisposableStore();
      this.removeActiveViewZone(changeAccessor);
      const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
      if (heightInLines > 0) {
        const domNode = document.createElement("div");
        renderLines2(domNode, tabSize, additionalLines, this._editor.getOptions(), this._isClickable);
        if (this._isClickable) {
          store.add(addDisposableListener(domNode, "mousedown", (e) => {
            e.preventDefault();
          }));
          store.add(addDisposableListener(domNode, "click", (e) => {
            if (isTargetGhostText(e.target)) {
              this._onDidClick.fire(new StandardMouseEvent(getWindow(e), e));
            }
          }));
        }
        this.addViewZone(changeAccessor, lineNumber, heightInLines, domNode);
      }
      this._viewZoneListener.value = store;
    });
  }
  addViewZone(changeAccessor, afterLineNumber, heightInLines, domNode) {
    const id = changeAccessor.addZone({
      afterLineNumber,
      heightInLines,
      domNode,
      afterColumnAffinity: 1,
      onComputedHeight: (height) => {
        this._viewZoneHeight.set(height, void 0);
      }
    });
    this.keepCursorStable(afterLineNumber, heightInLines);
    this._viewZoneInfo = { viewZoneId: id, heightInLines, lineNumber: afterLineNumber };
  }
  removeActiveViewZone(changeAccessor) {
    if (this._viewZoneInfo) {
      changeAccessor.removeZone(this._viewZoneInfo.viewZoneId);
      if (!this.hasBeenAccepted) {
        this.keepCursorStable(this._viewZoneInfo.lineNumber, -this._viewZoneInfo.heightInLines);
      }
      this._viewZoneInfo = void 0;
      this._viewZoneHeight.set(void 0, void 0);
    }
  }
  keepCursorStable(lineNumber, heightInLines) {
    if (!this._shouldKeepCursorStable) {
      return;
    }
    const cursorLineNumber = this._editor.getSelection()?.getStartPosition()?.lineNumber;
    if (cursorLineNumber !== void 0 && lineNumber < cursorLineNumber) {
      this._editor.setScrollTop(this._editor.getScrollTop() + heightInLines * this._editor.getOption(
        75
        /* EditorOption.lineHeight */
      ));
    }
  }
};
function isTargetGhostText(target) {
  return isHTMLElement(target) && target.classList.contains(GHOST_TEXT_CLASS_NAME);
}
function renderLines2(domNode, tabSize, lines, opts, isClickable) {
  const disableMonospaceOptimizations = opts.get(
    40
    /* EditorOption.disableMonospaceOptimizations */
  );
  const stopRenderingLineAfter = opts.get(
    133
    /* EditorOption.stopRenderingLineAfter */
  );
  const renderWhitespace = "none";
  const renderControlCharacters = opts.get(
    108
    /* EditorOption.renderControlCharacters */
  );
  const fontLigatures = opts.get(
    60
    /* EditorOption.fontLigatures */
  );
  const fontInfo = opts.get(
    59
    /* EditorOption.fontInfo */
  );
  const lineHeight = opts.get(
    75
    /* EditorOption.lineHeight */
  );
  let classNames2 = "suggest-preview-text";
  if (isClickable) {
    classNames2 += " clickable";
  }
  const sb = new StringBuilder(1e4);
  sb.appendString(`<div class="${classNames2}">`);
  for (let i2 = 0, len = lines.length; i2 < len; i2++) {
    const lineData = lines[i2];
    const lineTokens = lineData.content;
    sb.appendString('<div class="view-line');
    sb.appendString('" style="top:');
    sb.appendString(String(i2 * lineHeight));
    sb.appendString('px;width:1000000px;">');
    const line = lineTokens.getLineContent();
    const isBasicASCII2 = isBasicASCII(line);
    const containsRTL2 = containsRTL(line);
    renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII2, containsRTL2, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null, null, 0), sb);
    sb.appendString("</div>");
  }
  sb.appendString("</div>");
  applyFontInfo(domNode, fontInfo);
  const html = sb.build();
  const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;
  domNode.innerHTML = trustedhtml;
}
var ttPolicy = createTrustedTypesPolicy("editorGhostText", { createHTML: (value) => value });

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViewProducer.js
init_lifecycle();
init_observable();
init_instantiation();
init_observableCodeEditor();
init_lineRange();
init_range();

// node_modules/monaco-editor/esm/vs/editor/common/core/edits/lineEdit.js
init_assert();
init_strings();
init_lineRange();
init_position();
init_range();
var _LineEdit = class _LineEdit {
  constructor(replacements) {
    this.replacements = replacements;
    assert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));
  }
  toString() {
    return this.replacements.map((e) => e.toString()).join(",");
  }
  getNewLineRanges() {
    const ranges = [];
    let offset = 0;
    for (const e of this.replacements) {
      ranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length));
      offset += e.newLines.length - e.lineRange.length;
    }
    return ranges;
  }
};
_LineEdit.empty = new _LineEdit([]);
var LineEdit = _LineEdit;
var LineReplacement = class _LineReplacement {
  static fromSingleTextEdit(edit, initialValue) {
    const newLines = splitLines(edit.text);
    let startLineNumber = edit.range.startLineNumber;
    const survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(new Position(edit.range.startLineNumber, 1), edit.range.getStartPosition()));
    newLines[0] = survivingFirstLineText + newLines[0];
    let endLineNumberEx = edit.range.endLineNumber + 1;
    const editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;
    const survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(edit.range.getEndPosition(), new Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)));
    newLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;
    const startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;
    const endAfterNewLine = edit.range.endColumn === 1;
    if (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {
      startLineNumber++;
      newLines.shift();
    }
    if (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {
      endLineNumberEx--;
      newLines.pop();
    }
    return new _LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);
  }
  constructor(lineRange, newLines) {
    this.lineRange = lineRange;
    this.newLines = newLines;
  }
  toString() {
    return `${this.lineRange}->${JSON.stringify(this.newLines)}`;
  }
  toLineEdit() {
    return new LineEdit([this]);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditWithChanges.js
init_lineRange();
var InlineEditWithChanges = class {
  get lineEdit() {
    return LineReplacement.fromSingleTextEdit(this.edit.toReplacement(this.originalText), this.originalText);
  }
  get originalLineRange() {
    return this.lineEdit.lineRange;
  }
  get modifiedLineRange() {
    return this.lineEdit.toLineEdit().getNewLineRanges()[0];
  }
  get displayRange() {
    return this.originalText.lineRange.intersect(this.originalLineRange.join(LineRange.ofLength(this.originalLineRange.startLineNumber, this.lineEdit.newLines.length)));
  }
  constructor(originalText, edit, cursorPosition, commands, inlineCompletion) {
    this.originalText = originalText;
    this.edit = edit;
    this.cursorPosition = cursorPosition;
    this.commands = commands;
    this.inlineCompletion = inlineCompletion;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsModel.js
init_observable();
init_nls();
init_observableCodeEditor();
var InlineEditModel = class {
  constructor(_model, inlineEdit, tabAction) {
    this._model = _model;
    this.inlineEdit = inlineEdit;
    this.tabAction = tabAction;
    this.action = this.inlineEdit.inlineCompletion.action;
    this.displayName = this.inlineEdit.inlineCompletion.source.provider.displayName ?? localize(1209, "Inline Edit");
    this.extensionCommands = this.inlineEdit.inlineCompletion.source.inlineSuggestions.commands ?? [];
    this.isInDiffEditor = this._model.isInDiffEditor;
    this.displayLocation = this.inlineEdit.inlineCompletion.displayLocation;
    this.showCollapsed = this._model.showCollapsed;
  }
  accept() {
    this._model.accept();
  }
  jump() {
    this._model.jump();
  }
  abort(reason) {
    console.error(reason);
    this.inlineEdit.inlineCompletion.reportInlineEditError(reason);
    this._model.stop();
  }
  handleInlineEditShown(viewKind, viewData) {
    this._model.handleInlineSuggestionShown(this.inlineEdit.inlineCompletion, viewKind, viewData);
  }
};
var InlineEditHost = class {
  constructor(_model) {
    this._model = _model;
    this.onDidAccept = this._model.onDidAccept;
    this.inAcceptFlow = this._model.inAcceptFlow;
  }
};
var GhostTextIndicator = class {
  constructor(editor2, model, lineRange, inlineCompletion) {
    this.lineRange = lineRange;
    const editorObs = observableCodeEditor(editor2);
    const tabAction = derived(this, (reader) => {
      if (editorObs.isFocused.read(reader)) {
        if (inlineCompletion.showInlineEditMenu) {
          return InlineEditTabAction.Accept;
        }
      }
      return InlineEditTabAction.Inactive;
    });
    this.model = new InlineEditModel(model, new InlineEditWithChanges(new StringText(""), new TextEdit([inlineCompletion.getSingleTextEdit()]), model.primaryPosition.get(), inlineCompletion.source.inlineSuggestions.commands ?? [], inlineCompletion), tabAction);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsView.js
init_equals();
init_errors();
init_event();
init_lifecycle();
init_observable();
init_instantiation();
init_observableCodeEditor();
init_lineRange();
init_range();
init_textLength();
init_textModel();

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/components/gutterIndicatorView.js
init_dom();
init_iconLabels2();
init_codicons();
init_errors();
init_lifecycle();
init_observable();
init_instantiation();
init_colorUtils();
init_themeService();
init_point();

// node_modules/monaco-editor/esm/vs/editor/common/core/2d/rect.js
init_errors();
init_point();
var Rect = class _Rect {
  static fromPoints(topLeft, bottomRight) {
    return new _Rect(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
  }
  static fromPointSize(point, size2) {
    return new _Rect(point.x, point.y, point.x + size2.x, point.y + size2.y);
  }
  static fromLeftTopRightBottom(left, top, right, bottom) {
    return new _Rect(left, top, right, bottom);
  }
  static fromLeftTopWidthHeight(left, top, width, height) {
    return new _Rect(left, top, left + width, top + height);
  }
  static fromRanges(leftRight, topBottom) {
    return new _Rect(leftRight.start, topBottom.start, leftRight.endExclusive, topBottom.endExclusive);
  }
  static hull(rects) {
    let left = Number.MAX_SAFE_INTEGER;
    let top = Number.MAX_SAFE_INTEGER;
    let right = Number.MIN_SAFE_INTEGER;
    let bottom = Number.MIN_SAFE_INTEGER;
    for (const rect of rects) {
      left = Math.min(left, rect.left);
      top = Math.min(top, rect.top);
      right = Math.max(right, rect.right);
      bottom = Math.max(bottom, rect.bottom);
    }
    return new _Rect(left, top, right, bottom);
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  constructor(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    if (left > right) {
      throw new BugIndicatingError("Invalid arguments: Horizontally offset by " + (left - right));
    }
    if (top > bottom) {
      throw new BugIndicatingError("Invalid arguments: Vertically offset by " + (top - bottom));
    }
  }
  withMargin(marginOrVerticalOrTop, rightOrHorizontal, bottom, left) {
    let marginLeft, marginRight, marginTop, marginBottom;
    if (rightOrHorizontal === void 0 && bottom === void 0 && left === void 0) {
      marginLeft = marginRight = marginTop = marginBottom = marginOrVerticalOrTop;
    } else if (bottom === void 0 && left === void 0) {
      marginLeft = marginRight = rightOrHorizontal;
      marginTop = marginBottom = marginOrVerticalOrTop;
    } else {
      marginLeft = left;
      marginRight = rightOrHorizontal;
      marginTop = marginOrVerticalOrTop;
      marginBottom = bottom;
    }
    return new _Rect(this.left - marginLeft, this.top - marginTop, this.right + marginRight, this.bottom + marginBottom);
  }
  intersectVertical(range) {
    const newTop = Math.max(this.top, range.start);
    const newBottom = Math.min(this.bottom, range.endExclusive);
    return new _Rect(this.left, newTop, this.right, Math.max(newTop, newBottom));
  }
  intersectHorizontal(range) {
    const newLeft = Math.max(this.left, range.start);
    const newRight = Math.min(this.right, range.endExclusive);
    return new _Rect(newLeft, this.top, Math.max(newLeft, newRight), this.bottom);
  }
  toString() {
    return `Rect{(${this.left},${this.top}), (${this.right},${this.bottom})}`;
  }
  intersect(parent) {
    const left = Math.max(this.left, parent.left);
    const right = Math.min(this.right, parent.right);
    const top = Math.max(this.top, parent.top);
    const bottom = Math.min(this.bottom, parent.bottom);
    if (left > right || top > bottom) {
      return void 0;
    }
    return new _Rect(left, top, right, bottom);
  }
  containsRect(other) {
    return this.left <= other.left && this.top <= other.top && this.right >= other.right && this.bottom >= other.bottom;
  }
  containsPoint(point) {
    return this.left <= point.x && this.top <= point.y && this.right >= point.x && this.bottom >= point.y;
  }
  moveToBeContainedIn(parent) {
    const width = this.width;
    const height = this.height;
    let left = this.left;
    let top = this.top;
    if (left < parent.left) {
      left = parent.left;
    } else if (left + width > parent.right) {
      left = parent.right - width;
    }
    if (top < parent.top) {
      top = parent.top;
    } else if (top + height > parent.bottom) {
      top = parent.bottom - height;
    }
    return new _Rect(left, top, left + width, top + height);
  }
  withWidth(width) {
    return new _Rect(this.left, this.top, this.left + width, this.bottom);
  }
  withHeight(height) {
    return new _Rect(this.left, this.top, this.right, this.top + height);
  }
  withTop(top) {
    return new _Rect(this.left, top, this.right, this.bottom);
  }
  withLeft(left) {
    return new _Rect(left, this.top, this.right, this.bottom);
  }
  translateX(delta) {
    return new _Rect(this.left + delta, this.top, this.right + delta, this.bottom);
  }
  translateY(delta) {
    return new _Rect(this.left, this.top + delta, this.right, this.bottom + delta);
  }
  getLeftBottom() {
    return new Point(this.left, this.bottom);
  }
  getRightBottom() {
    return new Point(this.right, this.bottom);
  }
  getRightTop() {
    return new Point(this.right, this.top);
  }
  toStyles() {
    return {
      position: "absolute",
      left: `${this.left}px`,
      top: `${this.top}px`,
      width: `${this.width}px`,
      height: `${this.height}px`
    };
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/components/gutterIndicatorView.js
init_offsetRange();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
init_lifecycle();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js
init_dom();
init_arrays();
init_lifecycle();
init_themables();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScroll.css";
init_position();
init_stringBuilder();
init_event();
var StickyScrollWidgetState = class _StickyScrollWidgetState {
  constructor(startLineNumbers, endLineNumbers, lastLineRelativePosition, showEndForLine = null) {
    this.startLineNumbers = startLineNumbers;
    this.endLineNumbers = endLineNumbers;
    this.lastLineRelativePosition = lastLineRelativePosition;
    this.showEndForLine = showEndForLine;
  }
  equals(other) {
    return !!other && this.lastLineRelativePosition === other.lastLineRelativePosition && this.showEndForLine === other.showEndForLine && equals(this.startLineNumbers, other.startLineNumbers) && equals(this.endLineNumbers, other.endLineNumbers);
  }
  static get Empty() {
    return new _StickyScrollWidgetState([], [], 0);
  }
};
var _ttPolicy = createTrustedTypesPolicy("stickyScrollViewLayer", { createHTML: (value) => value });
var STICKY_INDEX_ATTR = "data-sticky-line-index";
var STICKY_IS_LINE_ATTR = "data-sticky-is-line";
var STICKY_IS_LINE_NUMBER_ATTR = "data-sticky-is-line-number";
var STICKY_IS_FOLDING_ICON_ATTR = "data-sticky-is-folding-icon";
var StickyScrollWidget = class extends Disposable {
  get height() {
    return this._height;
  }
  constructor(editor2) {
    super();
    this._foldingIconStore = new DisposableStore();
    this._rootDomNode = document.createElement("div");
    this._lineNumbersDomNode = document.createElement("div");
    this._linesDomNodeScrollable = document.createElement("div");
    this._linesDomNode = document.createElement("div");
    this._renderedStickyLines = [];
    this._lineNumbers = [];
    this._lastLineRelativePosition = 0;
    this._minContentWidthInPx = 0;
    this._isOnGlyphMargin = false;
    this._height = -1;
    this._onDidChangeStickyScrollHeight = this._register(new Emitter());
    this.onDidChangeStickyScrollHeight = this._onDidChangeStickyScrollHeight.event;
    this._editor = editor2;
    this._lineHeight = editor2.getOption(
      75
      /* EditorOption.lineHeight */
    );
    this._lineNumbersDomNode.className = "sticky-widget-line-numbers";
    this._lineNumbersDomNode.setAttribute("role", "none");
    this._linesDomNode.className = "sticky-widget-lines";
    this._linesDomNode.setAttribute("role", "list");
    this._linesDomNodeScrollable.className = "sticky-widget-lines-scrollable";
    this._linesDomNodeScrollable.appendChild(this._linesDomNode);
    this._rootDomNode.className = "sticky-widget";
    this._rootDomNode.classList.toggle("peek", editor2 instanceof EmbeddedCodeEditorWidget);
    this._rootDomNode.appendChild(this._lineNumbersDomNode);
    this._rootDomNode.appendChild(this._linesDomNodeScrollable);
    this._setHeight(0);
    const updateScrollLeftPosition = () => {
      this._linesDomNode.style.left = this._editor.getOption(
        131
        /* EditorOption.stickyScroll */
      ).scrollWithEditor ? `-${this._editor.getScrollLeft()}px` : "0px";
    };
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        131
        /* EditorOption.stickyScroll */
      )) {
        updateScrollLeftPosition();
      }
      if (e.hasChanged(
        75
        /* EditorOption.lineHeight */
      )) {
        this._lineHeight = this._editor.getOption(
          75
          /* EditorOption.lineHeight */
        );
      }
    }));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollLeftChanged) {
        updateScrollLeftPosition();
      }
      if (e.scrollWidthChanged) {
        this._updateWidgetWidth();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      updateScrollLeftPosition();
      this._updateWidgetWidth();
    }));
    this._register(this._foldingIconStore);
    updateScrollLeftPosition();
    this._register(this._editor.onDidLayoutChange((e) => {
      this._updateWidgetWidth();
    }));
    this._updateWidgetWidth();
  }
  get lineNumbers() {
    return this._lineNumbers;
  }
  get lineNumberCount() {
    return this._lineNumbers.length;
  }
  getRenderedStickyLine(lineNumber) {
    return this._renderedStickyLines.find((stickyLine) => stickyLine.lineNumber === lineNumber);
  }
  getCurrentLines() {
    return this._lineNumbers;
  }
  setState(state, foldingModel, rebuildFromIndexCandidate) {
    const currentStateAndPreviousStateUndefined = !this._state && !state;
    const currentStateDefinedAndEqualsPreviousState = this._state && this._state.equals(state);
    if (rebuildFromIndexCandidate === void 0 && (currentStateAndPreviousStateUndefined || currentStateDefinedAndEqualsPreviousState)) {
      return;
    }
    const data = this._findRenderingData(state);
    const previousLineNumbers = this._lineNumbers;
    this._lineNumbers = data.lineNumbers;
    this._lastLineRelativePosition = data.lastLineRelativePosition;
    const rebuildFromIndex = this._findIndexToRebuildFrom(previousLineNumbers, this._lineNumbers, rebuildFromIndexCandidate);
    this._renderRootNode(this._lineNumbers, this._lastLineRelativePosition, foldingModel, rebuildFromIndex);
    this._state = state;
  }
  _findRenderingData(state) {
    if (!state) {
      return { lineNumbers: [], lastLineRelativePosition: 0 };
    }
    const candidateLineNumbers = [...state.startLineNumbers];
    if (state.showEndForLine !== null) {
      candidateLineNumbers[state.showEndForLine] = state.endLineNumbers[state.showEndForLine];
    }
    let totalHeight = 0;
    for (let i2 = 0; i2 < candidateLineNumbers.length; i2++) {
      totalHeight += this._editor.getLineHeightForPosition(new Position(candidateLineNumbers[i2], 1));
    }
    if (totalHeight === 0) {
      return { lineNumbers: [], lastLineRelativePosition: 0 };
    }
    return { lineNumbers: candidateLineNumbers, lastLineRelativePosition: state.lastLineRelativePosition };
  }
  _findIndexToRebuildFrom(previousLineNumbers, newLineNumbers, rebuildFromIndexCandidate) {
    if (newLineNumbers.length === 0) {
      return 0;
    }
    if (rebuildFromIndexCandidate !== void 0) {
      return rebuildFromIndexCandidate;
    }
    const validIndex = newLineNumbers.findIndex((startLineNumber) => !previousLineNumbers.includes(startLineNumber));
    return validIndex === -1 ? 0 : validIndex;
  }
  _updateWidgetWidth() {
    const layoutInfo = this._editor.getLayoutInfo();
    const lineNumbersWidth = layoutInfo.contentLeft;
    this._lineNumbersDomNode.style.width = `${lineNumbersWidth}px`;
    this._linesDomNodeScrollable.style.setProperty("--vscode-editorStickyScroll-scrollableWidth", `${this._editor.getScrollWidth() - layoutInfo.verticalScrollbarWidth}px`);
    this._rootDomNode.style.width = `${layoutInfo.width - layoutInfo.verticalScrollbarWidth}px`;
  }
  _useFoldingOpacityTransition(requireTransitions) {
    this._lineNumbersDomNode.style.setProperty("--vscode-editorStickyScroll-foldingOpacityTransition", `opacity ${requireTransitions ? 0.5 : 0}s`);
  }
  _setFoldingIconsVisibility(allVisible) {
    for (const line of this._renderedStickyLines) {
      const foldingIcon = line.foldingIcon;
      if (!foldingIcon) {
        continue;
      }
      foldingIcon.setVisible(allVisible ? true : foldingIcon.isCollapsed);
    }
  }
  async _renderRootNode(lineNumbers, lastLineRelativePosition, foldingModel, rebuildFromIndex) {
    const viewModel = this._editor._getViewModel();
    if (!viewModel) {
      this._clearWidget();
      return;
    }
    if (lineNumbers.length === 0) {
      this._clearWidget();
      return;
    }
    const renderedStickyLines = [];
    const lastLineNumber = lineNumbers[lineNumbers.length - 1];
    let top = 0;
    for (let i2 = 0; i2 < this._renderedStickyLines.length; i2++) {
      if (i2 < rebuildFromIndex) {
        const renderedLine = this._renderedStickyLines[i2];
        renderedStickyLines.push(this._updatePosition(renderedLine, top, renderedLine.lineNumber === lastLineNumber));
        top += renderedLine.height;
      } else {
        const renderedLine = this._renderedStickyLines[i2];
        renderedLine.lineNumberDomNode.remove();
        renderedLine.lineDomNode.remove();
      }
    }
    const layoutInfo = this._editor.getLayoutInfo();
    for (let i2 = rebuildFromIndex; i2 < lineNumbers.length; i2++) {
      const stickyLine = this._renderChildNode(viewModel, i2, lineNumbers[i2], top, lastLineNumber === lineNumbers[i2], foldingModel, layoutInfo);
      top += stickyLine.height;
      this._linesDomNode.appendChild(stickyLine.lineDomNode);
      this._lineNumbersDomNode.appendChild(stickyLine.lineNumberDomNode);
      renderedStickyLines.push(stickyLine);
    }
    if (foldingModel) {
      this._setFoldingHoverListeners();
      this._useFoldingOpacityTransition(!this._isOnGlyphMargin);
    }
    this._minContentWidthInPx = Math.max(...this._renderedStickyLines.map((l) => l.scrollWidth)) + layoutInfo.verticalScrollbarWidth;
    this._renderedStickyLines = renderedStickyLines;
    this._setHeight(top + lastLineRelativePosition);
    this._editor.layoutOverlayWidget(this);
  }
  _clearWidget() {
    for (let i2 = 0; i2 < this._renderedStickyLines.length; i2++) {
      const stickyLine = this._renderedStickyLines[i2];
      stickyLine.lineNumberDomNode.remove();
      stickyLine.lineDomNode.remove();
    }
    this._setHeight(0);
  }
  _setHeight(height) {
    if (this._height === height) {
      return;
    }
    this._height = height;
    if (this._height === 0) {
      this._rootDomNode.style.display = "none";
    } else {
      this._rootDomNode.style.display = "block";
      this._lineNumbersDomNode.style.height = `${this._height}px`;
      this._linesDomNodeScrollable.style.height = `${this._height}px`;
      this._rootDomNode.style.height = `${this._height}px`;
    }
    this._onDidChangeStickyScrollHeight.fire({ height: this._height });
  }
  _setFoldingHoverListeners() {
    const showFoldingControls = this._editor.getOption(
      126
      /* EditorOption.showFoldingControls */
    );
    if (showFoldingControls !== "mouseover") {
      return;
    }
    this._foldingIconStore.add(addDisposableListener(this._lineNumbersDomNode, EventType.MOUSE_ENTER, () => {
      this._isOnGlyphMargin = true;
      this._setFoldingIconsVisibility(true);
    }));
    this._foldingIconStore.add(addDisposableListener(this._lineNumbersDomNode, EventType.MOUSE_LEAVE, () => {
      this._isOnGlyphMargin = false;
      this._useFoldingOpacityTransition(true);
      this._setFoldingIconsVisibility(false);
    }));
  }
  _renderChildNode(viewModel, index, line, top, isLastLine, foldingModel, layoutInfo) {
    const viewLineNumber = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position(line, 1)).lineNumber;
    const lineRenderingData = viewModel.getViewLineRenderingData(viewLineNumber);
    const lineNumberOption = this._editor.getOption(
      76
      /* EditorOption.lineNumbers */
    );
    const verticalScrollbarSize = this._editor.getOption(
      117
      /* EditorOption.scrollbar */
    ).verticalScrollbarSize;
    let actualInlineDecorations;
    try {
      actualInlineDecorations = LineDecoration.filter(lineRenderingData.inlineDecorations, viewLineNumber, lineRenderingData.minColumn, lineRenderingData.maxColumn);
    } catch (err) {
      actualInlineDecorations = [];
    }
    const lineHeight = this._editor.getLineHeightForPosition(new Position(line, 1));
    const textDirection = viewModel.getTextDirection(line);
    const renderLineInput = new RenderLineInput(true, true, lineRenderingData.content, lineRenderingData.continuesWithWrappedLine, lineRenderingData.isBasicASCII, lineRenderingData.containsRTL, 0, lineRenderingData.tokens, actualInlineDecorations, lineRenderingData.tabSize, lineRenderingData.startVisibleColumn, 1, 1, 1, 500, "none", true, true, null, textDirection, verticalScrollbarSize);
    const sb = new StringBuilder(2e3);
    const renderOutput = renderViewLine(renderLineInput, sb);
    let newLine;
    if (_ttPolicy) {
      newLine = _ttPolicy.createHTML(sb.build());
    } else {
      newLine = sb.build();
    }
    const lineHTMLNode = document.createElement("span");
    lineHTMLNode.setAttribute(STICKY_INDEX_ATTR, String(index));
    lineHTMLNode.setAttribute(STICKY_IS_LINE_ATTR, "");
    lineHTMLNode.setAttribute("role", "listitem");
    lineHTMLNode.tabIndex = 0;
    lineHTMLNode.className = "sticky-line-content";
    lineHTMLNode.classList.add(`stickyLine${line}`);
    lineHTMLNode.style.lineHeight = `${lineHeight}px`;
    lineHTMLNode.innerHTML = newLine;
    const lineNumberHTMLNode = document.createElement("span");
    lineNumberHTMLNode.setAttribute(STICKY_INDEX_ATTR, String(index));
    lineNumberHTMLNode.setAttribute(STICKY_IS_LINE_NUMBER_ATTR, "");
    lineNumberHTMLNode.className = "sticky-line-number";
    lineNumberHTMLNode.style.lineHeight = `${lineHeight}px`;
    const lineNumbersWidth = layoutInfo.contentLeft;
    lineNumberHTMLNode.style.width = `${lineNumbersWidth}px`;
    const innerLineNumberHTML = document.createElement("span");
    if (lineNumberOption.renderType === 1 || lineNumberOption.renderType === 3 && line % 10 === 0) {
      innerLineNumberHTML.innerText = line.toString();
    } else if (lineNumberOption.renderType === 2) {
      innerLineNumberHTML.innerText = Math.abs(line - this._editor.getPosition().lineNumber).toString();
    }
    innerLineNumberHTML.className = "sticky-line-number-inner";
    innerLineNumberHTML.style.width = `${layoutInfo.lineNumbersWidth}px`;
    innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft}px`;
    lineNumberHTMLNode.appendChild(innerLineNumberHTML);
    const foldingIcon = this._renderFoldingIconForLine(foldingModel, line);
    if (foldingIcon) {
      lineNumberHTMLNode.appendChild(foldingIcon.domNode);
      foldingIcon.domNode.style.left = `${layoutInfo.lineNumbersWidth + layoutInfo.lineNumbersLeft}px`;
      foldingIcon.domNode.style.lineHeight = `${lineHeight}px`;
    }
    this._editor.applyFontInfo(lineHTMLNode);
    this._editor.applyFontInfo(lineNumberHTMLNode);
    lineNumberHTMLNode.style.lineHeight = `${lineHeight}px`;
    lineHTMLNode.style.lineHeight = `${lineHeight}px`;
    lineNumberHTMLNode.style.height = `${lineHeight}px`;
    lineHTMLNode.style.height = `${lineHeight}px`;
    const renderedLine = new RenderedStickyLine(index, line, lineHTMLNode, lineNumberHTMLNode, foldingIcon, renderOutput.characterMapping, lineHTMLNode.scrollWidth, lineHeight);
    return this._updatePosition(renderedLine, top, isLastLine);
  }
  _updatePosition(stickyLine, top, isLastLine) {
    const lineHTMLNode = stickyLine.lineDomNode;
    const lineNumberHTMLNode = stickyLine.lineNumberDomNode;
    if (isLastLine) {
      const zIndex = "0";
      lineHTMLNode.style.zIndex = zIndex;
      lineNumberHTMLNode.style.zIndex = zIndex;
      const updatedTop = `${top + this._lastLineRelativePosition + (stickyLine.foldingIcon?.isCollapsed ? 1 : 0)}px`;
      lineHTMLNode.style.top = updatedTop;
      lineNumberHTMLNode.style.top = updatedTop;
    } else {
      const zIndex = "1";
      lineHTMLNode.style.zIndex = zIndex;
      lineNumberHTMLNode.style.zIndex = zIndex;
      lineHTMLNode.style.top = `${top}px`;
      lineNumberHTMLNode.style.top = `${top}px`;
    }
    return stickyLine;
  }
  _renderFoldingIconForLine(foldingModel, line) {
    const showFoldingControls = this._editor.getOption(
      126
      /* EditorOption.showFoldingControls */
    );
    if (!foldingModel || showFoldingControls === "never") {
      return;
    }
    const foldingRegions = foldingModel.regions;
    const indexOfFoldingRegion = foldingRegions.findRange(line);
    const startLineNumber = foldingRegions.getStartLineNumber(indexOfFoldingRegion);
    const isFoldingScope = line === startLineNumber;
    if (!isFoldingScope) {
      return;
    }
    const isCollapsed = foldingRegions.isCollapsed(indexOfFoldingRegion);
    const foldingIcon = new StickyFoldingIcon(isCollapsed, startLineNumber, foldingRegions.getEndLineNumber(indexOfFoldingRegion), this._lineHeight);
    foldingIcon.setVisible(this._isOnGlyphMargin ? true : isCollapsed || showFoldingControls === "always");
    foldingIcon.domNode.setAttribute(STICKY_IS_FOLDING_ICON_ATTR, "");
    return foldingIcon;
  }
  getId() {
    return "editor.contrib.stickyScrollWidget";
  }
  getDomNode() {
    return this._rootDomNode;
  }
  getPosition() {
    return {
      preference: 2,
      stackOridinal: 10
    };
  }
  getMinContentWidthInPx() {
    return this._minContentWidthInPx;
  }
  focusLineWithIndex(index) {
    if (0 <= index && index < this._renderedStickyLines.length) {
      this._renderedStickyLines[index].lineDomNode.focus();
    }
  }
  /**
   * Given a leaf dom node, tries to find the editor position.
   */
  getEditorPositionFromNode(spanDomNode) {
    if (!spanDomNode || spanDomNode.children.length > 0) {
      return null;
    }
    const renderedStickyLine = this._getRenderedStickyLineFromChildDomNode(spanDomNode);
    if (!renderedStickyLine) {
      return null;
    }
    const column = getColumnOfNodeOffset(renderedStickyLine.characterMapping, spanDomNode, 0);
    return new Position(renderedStickyLine.lineNumber, column);
  }
  getLineNumberFromChildDomNode(domNode) {
    return this._getRenderedStickyLineFromChildDomNode(domNode)?.lineNumber ?? null;
  }
  _getRenderedStickyLineFromChildDomNode(domNode) {
    const index = this.getLineIndexFromChildDomNode(domNode);
    if (index === null || index < 0 || index >= this._renderedStickyLines.length) {
      return null;
    }
    return this._renderedStickyLines[index];
  }
  /**
   * Given a child dom node, tries to find the line number attribute that was stored in the node.
   * @returns the attribute value or null if none is found.
   */
  getLineIndexFromChildDomNode(domNode) {
    const lineIndex = this._getAttributeValue(domNode, STICKY_INDEX_ATTR);
    return lineIndex ? parseInt(lineIndex, 10) : null;
  }
  /**
   * Given a child dom node, tries to find if it is (contained in) a sticky line.
   * @returns a boolean.
   */
  isInStickyLine(domNode) {
    const isInLine = this._getAttributeValue(domNode, STICKY_IS_LINE_ATTR);
    return isInLine !== void 0;
  }
  /**
   * Given a child dom node, tries to find if this dom node is (contained in) a sticky folding icon.
   * @returns a boolean.
   */
  isInFoldingIconDomNode(domNode) {
    const isInFoldingIcon = this._getAttributeValue(domNode, STICKY_IS_FOLDING_ICON_ATTR);
    return isInFoldingIcon !== void 0;
  }
  /**
   * Given the dom node, finds if it or its parent sequence contains the given attribute.
   * @returns the attribute value or undefined.
   */
  _getAttributeValue(domNode, attribute) {
    while (domNode && domNode !== this._rootDomNode) {
      const line = domNode.getAttribute(attribute);
      if (line !== null) {
        return line;
      }
      domNode = domNode.parentElement;
    }
    return;
  }
};
var RenderedStickyLine = class {
  constructor(index, lineNumber, lineDomNode, lineNumberDomNode, foldingIcon, characterMapping, scrollWidth, height) {
    this.index = index;
    this.lineNumber = lineNumber;
    this.lineDomNode = lineDomNode;
    this.lineNumberDomNode = lineNumberDomNode;
    this.foldingIcon = foldingIcon;
    this.characterMapping = characterMapping;
    this.scrollWidth = scrollWidth;
    this.height = height;
  }
};
var StickyFoldingIcon = class {
  constructor(isCollapsed, foldingStartLine, foldingEndLine, dimension) {
    this.isCollapsed = isCollapsed;
    this.foldingStartLine = foldingStartLine;
    this.foldingEndLine = foldingEndLine;
    this.dimension = dimension;
    this.domNode = document.createElement("div");
    this.domNode.style.width = `26px`;
    this.domNode.style.height = `${dimension}px`;
    this.domNode.style.lineHeight = `${dimension}px`;
    this.domNode.className = ThemeIcon.asClassName(isCollapsed ? foldingCollapsedIcon : foldingExpandedIcon);
  }
  setVisible(visible) {
    this.domNode.style.cursor = visible ? "pointer" : "default";
    this.domNode.style.opacity = visible ? "1" : "0";
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
init_lifecycle();
init_languageFeatures();
init_cancellation();
init_async();
init_arrays();
init_event();
init_languageConfigurationRegistry();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js
init_lifecycle();
init_languageFeatures();
init_outlineModel();
init_async();
init_languageConfigurationRegistry();
init_errors();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollElement.js
var StickyRange = class {
  constructor(startLineNumber, endLineNumber) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
  }
};
var StickyElement = class {
  constructor(range, children, parent) {
    this.range = range;
    this.children = children;
    this.parent = parent;
  }
};
var StickyModel = class {
  constructor(uri, version, element, outlineProviderId) {
    this.uri = uri;
    this.version = version;
    this.element = element;
    this.outlineProviderId = outlineProviderId;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollModelProvider.js
init_iterator();
init_instantiation();
var __decorate63 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param63 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModelProvider;
(function(ModelProvider2) {
  ModelProvider2["OUTLINE_MODEL"] = "outlineModel";
  ModelProvider2["FOLDING_PROVIDER_MODEL"] = "foldingProviderModel";
  ModelProvider2["INDENTATION_MODEL"] = "indentationModel";
})(ModelProvider || (ModelProvider = {}));
var Status;
(function(Status2) {
  Status2[Status2["VALID"] = 0] = "VALID";
  Status2[Status2["INVALID"] = 1] = "INVALID";
  Status2[Status2["CANCELED"] = 2] = "CANCELED";
})(Status || (Status = {}));
var StickyModelProvider = class StickyModelProvider2 extends Disposable {
  constructor(_editor, onProviderUpdate, _languageConfigurationService, _languageFeaturesService) {
    super();
    this._editor = _editor;
    this._modelProviders = [];
    this._modelPromise = null;
    this._updateScheduler = this._register(new Delayer(300));
    this._updateOperation = this._register(new DisposableStore());
    switch (this._editor.getOption(
      131
      /* EditorOption.stickyScroll */
    ).defaultModel) {
      case ModelProvider.OUTLINE_MODEL:
        this._modelProviders.push(new StickyModelFromCandidateOutlineProvider(this._editor, _languageFeaturesService));
      // fall through
      case ModelProvider.FOLDING_PROVIDER_MODEL:
        this._modelProviders.push(new StickyModelFromCandidateSyntaxFoldingProvider(this._editor, onProviderUpdate, _languageFeaturesService));
      // fall through
      case ModelProvider.INDENTATION_MODEL:
        this._modelProviders.push(new StickyModelFromCandidateIndentationFoldingProvider(this._editor, _languageConfigurationService));
        break;
    }
  }
  dispose() {
    this._modelProviders.forEach((provider) => provider.dispose());
    this._updateOperation.clear();
    this._cancelModelPromise();
    super.dispose();
  }
  _cancelModelPromise() {
    if (this._modelPromise) {
      this._modelPromise.cancel();
      this._modelPromise = null;
    }
  }
  async update(token) {
    this._updateOperation.clear();
    this._updateOperation.add({
      dispose: () => {
        this._cancelModelPromise();
        this._updateScheduler.cancel();
      }
    });
    this._cancelModelPromise();
    return await this._updateScheduler.trigger(async () => {
      for (const modelProvider of this._modelProviders) {
        const { statusPromise, modelPromise } = modelProvider.computeStickyModel(token);
        this._modelPromise = modelPromise;
        const status2 = await statusPromise;
        if (this._modelPromise !== modelPromise) {
          return null;
        }
        switch (status2) {
          case Status.CANCELED:
            this._updateOperation.clear();
            return null;
          case Status.VALID:
            return modelProvider.stickyModel;
        }
      }
      return null;
    }).catch((error) => {
      onUnexpectedError(error);
      return null;
    });
  }
};
StickyModelProvider = __decorate63([
  __param63(2, IInstantiationService),
  __param63(3, ILanguageFeaturesService)
], StickyModelProvider);
var StickyModelCandidateProvider = class extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._stickyModel = null;
  }
  get stickyModel() {
    return this._stickyModel;
  }
  _invalid() {
    this._stickyModel = null;
    return Status.INVALID;
  }
  computeStickyModel(token) {
    if (token.isCancellationRequested || !this.isProviderValid()) {
      return { statusPromise: this._invalid(), modelPromise: null };
    }
    const providerModelPromise = createCancelablePromise((token2) => this.createModelFromProvider(token2));
    return {
      statusPromise: providerModelPromise.then((providerModel) => {
        if (!this.isModelValid(providerModel)) {
          return this._invalid();
        }
        if (token.isCancellationRequested) {
          return Status.CANCELED;
        }
        this._stickyModel = this.createStickyModel(token, providerModel);
        return Status.VALID;
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return Status.CANCELED;
      }),
      modelPromise: providerModelPromise
    };
  }
  /**
   * Method which checks whether the model returned by the provider is valid and can be used to compute a sticky model.
   * This method by default returns true.
   * @param model model returned by the provider
   * @returns boolean indicating whether the model is valid
   */
  isModelValid(model) {
    return true;
  }
  /**
   * Method which checks whether the provider is valid before applying it to find the provider model.
   * This method by default returns true.
   * @returns boolean indicating whether the provider is valid
   */
  isProviderValid() {
    return true;
  }
};
var StickyModelFromCandidateOutlineProvider = class StickyModelFromCandidateOutlineProvider2 extends StickyModelCandidateProvider {
  constructor(_editor, _languageFeaturesService) {
    super(_editor);
    this._languageFeaturesService = _languageFeaturesService;
  }
  createModelFromProvider(token) {
    return OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, this._editor.getModel(), token);
  }
  createStickyModel(token, model) {
    const { stickyOutlineElement, providerID } = this._stickyModelFromOutlineModel(model, this._stickyModel?.outlineProviderId);
    const textModel = this._editor.getModel();
    return new StickyModel(textModel.uri, textModel.getVersionId(), stickyOutlineElement, providerID);
  }
  isModelValid(model) {
    return model && model.children.size > 0;
  }
  _stickyModelFromOutlineModel(outlineModel, preferredProvider) {
    let outlineElements;
    if (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {
      const provider = Iterable.find(outlineModel.children.values(), (outlineGroupOfModel) => outlineGroupOfModel.id === preferredProvider);
      if (provider) {
        outlineElements = provider.children;
      } else {
        let tempID = "";
        let maxTotalSumOfRanges = -1;
        let optimalOutlineGroup = void 0;
        for (const [_key, outlineGroup] of outlineModel.children.entries()) {
          const totalSumRanges = this._findSumOfRangesOfGroup(outlineGroup);
          if (totalSumRanges > maxTotalSumOfRanges) {
            optimalOutlineGroup = outlineGroup;
            maxTotalSumOfRanges = totalSumRanges;
            tempID = outlineGroup.id;
          }
        }
        preferredProvider = tempID;
        outlineElements = optimalOutlineGroup.children;
      }
    } else {
      outlineElements = outlineModel.children;
    }
    const stickyChildren = [];
    const outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {
      const range1 = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);
      const range2 = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);
      return this._comparator(range1, range2);
    });
    for (const outlineElement of outlineElementsArray) {
      stickyChildren.push(this._stickyModelFromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));
    }
    const stickyOutlineElement = new StickyElement(void 0, stickyChildren, void 0);
    return {
      stickyOutlineElement,
      providerID: preferredProvider
    };
  }
  _stickyModelFromOutlineElement(outlineElement, previousStartLine) {
    const children = [];
    for (const child of outlineElement.children.values()) {
      if (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {
        if (child.symbol.selectionRange.startLineNumber !== previousStartLine) {
          children.push(this._stickyModelFromOutlineElement(child, child.symbol.selectionRange.startLineNumber));
        } else {
          for (const subchild of child.children.values()) {
            children.push(this._stickyModelFromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));
          }
        }
      }
    }
    children.sort((child1, child2) => this._comparator(child1.range, child2.range));
    const range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);
    return new StickyElement(range, children, void 0);
  }
  _comparator(range1, range2) {
    if (range1.startLineNumber !== range2.startLineNumber) {
      return range1.startLineNumber - range2.startLineNumber;
    } else {
      return range2.endLineNumber - range1.endLineNumber;
    }
  }
  _findSumOfRangesOfGroup(outline) {
    let res = 0;
    for (const child of outline.children.values()) {
      res += this._findSumOfRangesOfGroup(child);
    }
    if (outline instanceof OutlineElement) {
      return res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;
    } else {
      return res;
    }
  }
};
StickyModelFromCandidateOutlineProvider = __decorate63([
  __param63(1, ILanguageFeaturesService)
], StickyModelFromCandidateOutlineProvider);
var StickyModelFromCandidateFoldingProvider = class extends StickyModelCandidateProvider {
  constructor(editor2) {
    super(editor2);
    this._foldingLimitReporter = this._register(new RangesLimitReporter(editor2));
  }
  createStickyModel(token, model) {
    const foldingElement = this._fromFoldingRegions(model);
    const textModel = this._editor.getModel();
    return new StickyModel(textModel.uri, textModel.getVersionId(), foldingElement, void 0);
  }
  isModelValid(model) {
    return model !== null;
  }
  _fromFoldingRegions(foldingRegions) {
    const length = foldingRegions.length;
    const orderedStickyElements = [];
    const stickyOutlineElement = new StickyElement(void 0, [], void 0);
    for (let i2 = 0; i2 < length; i2++) {
      const parentIndex = foldingRegions.getParentIndex(i2);
      let parentNode;
      if (parentIndex !== -1) {
        parentNode = orderedStickyElements[parentIndex];
      } else {
        parentNode = stickyOutlineElement;
      }
      const child = new StickyElement(new StickyRange(foldingRegions.getStartLineNumber(i2), foldingRegions.getEndLineNumber(i2) + 1), [], parentNode);
      parentNode.children.push(child);
      orderedStickyElements.push(child);
    }
    return stickyOutlineElement;
  }
};
var StickyModelFromCandidateIndentationFoldingProvider = class StickyModelFromCandidateIndentationFoldingProvider2 extends StickyModelFromCandidateFoldingProvider {
  constructor(editor2, _languageConfigurationService) {
    super(editor2);
    this._languageConfigurationService = _languageConfigurationService;
    this.provider = this._register(new IndentRangeProvider(editor2.getModel(), this._languageConfigurationService, this._foldingLimitReporter));
  }
  async createModelFromProvider(token) {
    return this.provider.compute(token);
  }
};
StickyModelFromCandidateIndentationFoldingProvider = __decorate63([
  __param63(1, ILanguageConfigurationService)
], StickyModelFromCandidateIndentationFoldingProvider);
var StickyModelFromCandidateSyntaxFoldingProvider = class StickyModelFromCandidateSyntaxFoldingProvider2 extends StickyModelFromCandidateFoldingProvider {
  constructor(editor2, onProviderUpdate, _languageFeaturesService) {
    super(editor2);
    this._languageFeaturesService = _languageFeaturesService;
    this.provider = this._register(new MutableDisposable());
    this._register(this._languageFeaturesService.foldingRangeProvider.onDidChange(() => {
      this._updateProvider(editor2, onProviderUpdate);
    }));
    this._updateProvider(editor2, onProviderUpdate);
  }
  _updateProvider(editor2, onProviderUpdate) {
    const selectedProviders = FoldingController.getFoldingRangeProviders(this._languageFeaturesService, editor2.getModel());
    if (selectedProviders.length === 0) {
      return;
    }
    this.provider.value = new SyntaxRangeProvider(editor2.getModel(), selectedProviders, onProviderUpdate, this._foldingLimitReporter, void 0);
  }
  isProviderValid() {
    return this.provider !== void 0;
  }
  async createModelFromProvider(token) {
    return this.provider.value?.compute(token) ?? null;
  }
};
StickyModelFromCandidateSyntaxFoldingProvider = __decorate63([
  __param63(2, ILanguageFeaturesService)
], StickyModelFromCandidateSyntaxFoldingProvider);

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
init_position();
init_range();
var __decorate64 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param64 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StickyLineCandidate = class {
  constructor(startLineNumber, endLineNumber, top, height) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
    this.top = top;
    this.height = height;
  }
};
var StickyLineCandidateProvider = class StickyLineCandidateProvider2 extends Disposable {
  constructor(editor2, _languageFeaturesService, _languageConfigurationService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this._onDidChangeStickyScroll = this._register(new Emitter());
    this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event;
    this._model = null;
    this._cts = null;
    this._stickyModelProvider = null;
    this._editor = editor2;
    this._sessionStore = this._register(new DisposableStore());
    this._updateSoon = this._register(new RunOnceScheduler(() => this.update(), 50));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        131
        /* EditorOption.stickyScroll */
      )) {
        this.readConfiguration();
      }
    }));
    this.readConfiguration();
  }
  /**
   * Read and apply the sticky scroll configuration.
   */
  readConfiguration() {
    this._sessionStore.clear();
    const options = this._editor.getOption(
      131
      /* EditorOption.stickyScroll */
    );
    if (!options.enabled) {
      return;
    }
    this._sessionStore.add(this._editor.onDidChangeModel(() => {
      this._model = null;
      this.updateStickyModelProvider();
      this._onDidChangeStickyScroll.fire();
      this.update();
    }));
    this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update()));
    this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));
    this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => this.update()));
    this._sessionStore.add(toDisposable(() => {
      this._stickyModelProvider?.dispose();
      this._stickyModelProvider = null;
    }));
    this.updateStickyModelProvider();
    this.update();
  }
  /**
   * Get the version ID of the sticky model.
   */
  getVersionId() {
    return this._model?.version;
  }
  /**
   * Update the sticky model provider.
   */
  updateStickyModelProvider() {
    this._stickyModelProvider?.dispose();
    this._stickyModelProvider = null;
    if (this._editor.hasModel()) {
      this._stickyModelProvider = new StickyModelProvider(this._editor, () => this._updateSoon.schedule(), this._languageConfigurationService, this._languageFeaturesService);
    }
  }
  /**
   * Update the sticky line candidates.
   */
  async update() {
    this._cts?.dispose(true);
    this._cts = new CancellationTokenSource();
    await this.updateStickyModel(this._cts.token);
    this._onDidChangeStickyScroll.fire();
  }
  /**
   * Update the sticky model based on the current editor state.
   */
  async updateStickyModel(token) {
    if (!this._editor.hasModel() || !this._stickyModelProvider || this._editor.getModel().isTooLargeForTokenization()) {
      this._model = null;
      return;
    }
    const model = await this._stickyModelProvider.update(token);
    if (!token.isCancellationRequested) {
      this._model = model;
    }
  }
  /**
   * Get sticky line candidates intersecting a given range.
   */
  getCandidateStickyLinesIntersecting(range) {
    if (!this._model?.element) {
      return [];
    }
    const stickyLineCandidates = [];
    this.getCandidateStickyLinesIntersectingFromStickyModel(range, this._model.element, stickyLineCandidates, 0, 0, -1);
    return this.filterHiddenRanges(stickyLineCandidates);
  }
  /**
   * Get sticky line candidates intersecting a given range from the sticky model.
   */
  getCandidateStickyLinesIntersectingFromStickyModel(range, outlineModel, result, depth, top, lastStartLineNumber) {
    const textModel = this._editor.getModel();
    if (!textModel) {
      return;
    }
    if (outlineModel.children.length === 0) {
      return;
    }
    let lastLine = lastStartLineNumber;
    const childrenStartLines = [];
    for (let i2 = 0; i2 < outlineModel.children.length; i2++) {
      const child = outlineModel.children[i2];
      if (child.range) {
        childrenStartLines.push(child.range.startLineNumber);
      }
    }
    const lowerBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber, (a, b) => {
      return a - b;
    }));
    const upperBound = this.updateIndex(binarySearch(childrenStartLines, range.endLineNumber, (a, b) => {
      return a - b;
    }));
    for (let i2 = lowerBound; i2 <= upperBound; i2++) {
      const child = outlineModel.children[i2];
      if (!child || !child.range) {
        continue;
      }
      const { startLineNumber, endLineNumber } = child.range;
      if (endLineNumber > startLineNumber + 1 && range.startLineNumber <= endLineNumber + 1 && startLineNumber - 1 <= range.endLineNumber && startLineNumber !== lastLine && textModel.isValidRange(new Range(startLineNumber, 1, endLineNumber, 1))) {
        lastLine = startLineNumber;
        const lineHeight = this._editor.getLineHeightForPosition(new Position(startLineNumber, 1));
        result.push(new StickyLineCandidate(startLineNumber, endLineNumber - 1, top, lineHeight));
        this.getCandidateStickyLinesIntersectingFromStickyModel(range, child, result, depth + 1, top + lineHeight, startLineNumber);
      }
    }
  }
  /**
   * Filter out sticky line candidates that are within hidden ranges.
   */
  filterHiddenRanges(stickyLineCandidates) {
    const hiddenRanges = this._editor._getViewModel()?.getHiddenAreas();
    if (!hiddenRanges) {
      return stickyLineCandidates;
    }
    return stickyLineCandidates.filter((candidate) => {
      return !hiddenRanges.some((hiddenRange) => candidate.startLineNumber >= hiddenRange.startLineNumber && candidate.endLineNumber <= hiddenRange.endLineNumber + 1);
    });
  }
  /**
   * Update the binary search index.
   */
  updateIndex(index) {
    if (index === -1) {
      return 0;
    } else if (index < 0) {
      return -index - 2;
    }
    return index;
  }
};
StickyLineCandidateProvider = __decorate64([
  __param64(1, ILanguageFeaturesService),
  __param64(2, ILanguageConfigurationService)
], StickyLineCandidateProvider);

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
init_instantiation();
init_actions2();
init_contextkey();
init_editorContextKeys();
init_range();
init_position();
init_cancellation();
init_languageConfigurationRegistry();
init_languageFeatureDebounce();
init_dom();
init_mouseEvent();
init_event();
init_window();
var __decorate65 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param65 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StickyScrollController_1;
var _a46;
var StickyScrollController = (_a46 = class extends Disposable {
  constructor(_editor, _contextMenuService, _languageFeaturesService, _instaService, _languageConfigurationService, _languageFeatureDebounceService, _contextKeyService) {
    super();
    this._editor = _editor;
    this._contextMenuService = _contextMenuService;
    this._languageFeaturesService = _languageFeaturesService;
    this._instaService = _instaService;
    this._contextKeyService = _contextKeyService;
    this._sessionStore = new DisposableStore();
    this._maxStickyLines = Number.MAX_SAFE_INTEGER;
    this._candidateDefinitionsLength = -1;
    this._focusedStickyElementIndex = -1;
    this._enabled = false;
    this._focused = false;
    this._positionRevealed = false;
    this._onMouseDown = false;
    this._endLineNumbers = [];
    this._mouseTarget = null;
    this._onDidChangeStickyScrollHeight = this._register(new Emitter());
    this.onDidChangeStickyScrollHeight = this._onDidChangeStickyScrollHeight.event;
    this._stickyScrollWidget = new StickyScrollWidget(this._editor);
    this._stickyLineCandidateProvider = new StickyLineCandidateProvider(this._editor, _languageFeaturesService, _languageConfigurationService);
    this._register(this._stickyScrollWidget);
    this._register(this._stickyLineCandidateProvider);
    this._widgetState = StickyScrollWidgetState.Empty;
    const stickyScrollDomNode = this._stickyScrollWidget.getDomNode();
    this._register(this._editor.onDidChangeLineHeight((e) => {
      e.changes.forEach((change) => {
        const lineNumber = change.lineNumber;
        if (this._widgetState.startLineNumbers.includes(lineNumber)) {
          this._renderStickyScroll(lineNumber);
        }
      });
    }));
    this._register(this._editor.onDidChangeFont((e) => {
      e.changes.forEach((change) => {
        const lineNumber = change.lineNumber;
        if (this._widgetState.startLineNumbers.includes(lineNumber)) {
          this._renderStickyScroll(lineNumber);
        }
      });
    }));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      this._readConfigurationChange(e);
    }));
    this._register(addDisposableListener(stickyScrollDomNode, EventType.CONTEXT_MENU, async (event) => {
      this._onContextMenu(getWindow(stickyScrollDomNode), event);
    }));
    this._stickyScrollFocusedContextKey = EditorContextKeys.stickyScrollFocused.bindTo(this._contextKeyService);
    this._stickyScrollVisibleContextKey = EditorContextKeys.stickyScrollVisible.bindTo(this._contextKeyService);
    const focusTracker = this._register(trackFocus(stickyScrollDomNode));
    this._register(focusTracker.onDidBlur((_) => {
      if (this._positionRevealed === false && stickyScrollDomNode.clientHeight === 0) {
        this._focusedStickyElementIndex = -1;
        this.focus();
      } else {
        this._disposeFocusStickyScrollStore();
      }
    }));
    this._register(focusTracker.onDidFocus((_) => {
      this.focus();
    }));
    this._registerMouseListeners();
    this._register(addDisposableListener(stickyScrollDomNode, EventType.MOUSE_DOWN, (e) => {
      this._onMouseDown = true;
    }));
    this._register(this._stickyScrollWidget.onDidChangeStickyScrollHeight((e) => {
      this._onDidChangeStickyScrollHeight.fire(e);
    }));
    this._onDidResize();
    this._readConfiguration();
  }
  get stickyScrollWidgetHeight() {
    return this._stickyScrollWidget.height;
  }
  static get(editor2) {
    return editor2.getContribution(StickyScrollController_1.ID);
  }
  _disposeFocusStickyScrollStore() {
    this._stickyScrollFocusedContextKey.set(false);
    this._focusDisposableStore?.dispose();
    this._focused = false;
    this._positionRevealed = false;
    this._onMouseDown = false;
  }
  isFocused() {
    return this._focused;
  }
  focus() {
    if (this._onMouseDown) {
      this._onMouseDown = false;
      this._editor.focus();
      return;
    }
    const focusState = this._stickyScrollFocusedContextKey.get();
    if (focusState === true) {
      return;
    }
    this._focused = true;
    this._focusDisposableStore = new DisposableStore();
    this._stickyScrollFocusedContextKey.set(true);
    this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumbers.length - 1;
    this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
  }
  focusNext() {
    if (this._focusedStickyElementIndex < this._stickyScrollWidget.lineNumberCount - 1) {
      this._focusNav(true);
    }
  }
  focusPrevious() {
    if (this._focusedStickyElementIndex > 0) {
      this._focusNav(false);
    }
  }
  selectEditor() {
    this._editor.focus();
  }
  // True is next, false is previous
  _focusNav(direction) {
    this._focusedStickyElementIndex = direction ? this._focusedStickyElementIndex + 1 : this._focusedStickyElementIndex - 1;
    this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
  }
  goToFocused() {
    const lineNumbers = this._stickyScrollWidget.lineNumbers;
    this._disposeFocusStickyScrollStore();
    this._revealPosition({ lineNumber: lineNumbers[this._focusedStickyElementIndex], column: 1 });
  }
  _revealPosition(position) {
    this._reveaInEditor(position, () => this._editor.revealPosition(position));
  }
  _revealLineInCenterIfOutsideViewport(position) {
    this._reveaInEditor(position, () => this._editor.revealLineInCenterIfOutsideViewport(
      position.lineNumber,
      0
      /* ScrollType.Smooth */
    ));
  }
  _reveaInEditor(position, revealFunction) {
    if (this._focused) {
      this._disposeFocusStickyScrollStore();
    }
    this._positionRevealed = true;
    revealFunction();
    this._editor.setSelection(Range.fromPositions(position));
    this._editor.focus();
  }
  _registerMouseListeners() {
    const sessionStore = this._register(new DisposableStore());
    const gesture = this._register(new ClickLinkGesture(this._editor, {
      extractLineNumberFromMouseEvent: (e) => {
        const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);
        return position ? position.lineNumber : 0;
      }
    }));
    const getMouseEventTarget = (mouseEvent) => {
      if (!this._editor.hasModel()) {
        return null;
      }
      if (mouseEvent.target.type !== 12 || mouseEvent.target.detail !== this._stickyScrollWidget.getId()) {
        return null;
      }
      const mouseTargetElement = mouseEvent.target.element;
      if (!mouseTargetElement || mouseTargetElement.innerText !== mouseTargetElement.innerHTML) {
        return null;
      }
      const position = this._stickyScrollWidget.getEditorPositionFromNode(mouseTargetElement);
      if (!position) {
        return null;
      }
      return {
        range: new Range(position.lineNumber, position.column, position.lineNumber, position.column + mouseTargetElement.innerText.length),
        textElement: mouseTargetElement
      };
    };
    const stickyScrollWidgetDomNode = this._stickyScrollWidget.getDomNode();
    this._register(addStandardDisposableListener(stickyScrollWidgetDomNode, EventType.CLICK, (mouseEvent) => {
      if (mouseEvent.ctrlKey || mouseEvent.altKey || mouseEvent.metaKey) {
        return;
      }
      if (!mouseEvent.leftButton) {
        return;
      }
      if (mouseEvent.shiftKey) {
        const lineIndex = this._stickyScrollWidget.getLineIndexFromChildDomNode(mouseEvent.target);
        if (lineIndex === null) {
          return;
        }
        const position2 = new Position(this._endLineNumbers[lineIndex], 1);
        this._revealLineInCenterIfOutsideViewport(position2);
        return;
      }
      const isInFoldingIconDomNode = this._stickyScrollWidget.isInFoldingIconDomNode(mouseEvent.target);
      if (isInFoldingIconDomNode) {
        const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);
        this._toggleFoldingRegionForLine(lineNumber);
        return;
      }
      const isInStickyLine = this._stickyScrollWidget.isInStickyLine(mouseEvent.target);
      if (!isInStickyLine) {
        return;
      }
      let position = this._stickyScrollWidget.getEditorPositionFromNode(mouseEvent.target);
      if (!position) {
        const lineNumber = this._stickyScrollWidget.getLineNumberFromChildDomNode(mouseEvent.target);
        if (lineNumber === null) {
          return;
        }
        position = new Position(lineNumber, 1);
      }
      this._revealPosition(position);
    }));
    this._register(addDisposableListener(mainWindow, EventType.MOUSE_MOVE, (mouseEvent) => {
      this._mouseTarget = mouseEvent.target;
      this._onMouseMoveOrKeyDown(mouseEvent);
    }));
    this._register(addDisposableListener(mainWindow, EventType.KEY_DOWN, (mouseEvent) => {
      this._onMouseMoveOrKeyDown(mouseEvent);
    }));
    this._register(addDisposableListener(mainWindow, EventType.KEY_UP, () => {
      if (this._showEndForLine !== void 0) {
        this._showEndForLine = void 0;
        this._renderStickyScroll();
      }
    }));
    this._register(gesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, _keyboardEvent]) => {
      const mouseTarget = getMouseEventTarget(mouseEvent);
      if (!mouseTarget || !mouseEvent.hasTriggerModifier || !this._editor.hasModel()) {
        sessionStore.clear();
        return;
      }
      const { range, textElement } = mouseTarget;
      if (!range.equalsRange(this._stickyRangeProjectedOnEditor)) {
        this._stickyRangeProjectedOnEditor = range;
        sessionStore.clear();
      } else if (textElement.style.textDecoration === "underline") {
        return;
      }
      const cancellationToken = new CancellationTokenSource();
      sessionStore.add(toDisposable(() => cancellationToken.dispose(true)));
      let currentHTMLChild;
      getDefinitionsAtPosition(this._languageFeaturesService.definitionProvider, this._editor.getModel(), new Position(range.startLineNumber, range.startColumn + 1), false, cancellationToken.token).then(((candidateDefinitions) => {
        if (cancellationToken.token.isCancellationRequested) {
          return;
        }
        if (candidateDefinitions.length !== 0) {
          this._candidateDefinitionsLength = candidateDefinitions.length;
          const childHTML = textElement;
          if (currentHTMLChild !== childHTML) {
            sessionStore.clear();
            currentHTMLChild = childHTML;
            currentHTMLChild.style.textDecoration = "underline";
            sessionStore.add(toDisposable(() => {
              currentHTMLChild.style.textDecoration = "none";
            }));
          } else if (!currentHTMLChild) {
            currentHTMLChild = childHTML;
            currentHTMLChild.style.textDecoration = "underline";
            sessionStore.add(toDisposable(() => {
              currentHTMLChild.style.textDecoration = "none";
            }));
          }
        } else {
          sessionStore.clear();
        }
      }));
    }));
    this._register(gesture.onCancel(() => {
      sessionStore.clear();
    }));
    this._register(gesture.onExecute(async (e) => {
      if (e.target.type !== 12 || e.target.detail !== this._stickyScrollWidget.getId()) {
        return;
      }
      const position = this._stickyScrollWidget.getEditorPositionFromNode(e.target.element);
      if (!position) {
        return;
      }
      if (!this._editor.hasModel() || !this._stickyRangeProjectedOnEditor) {
        return;
      }
      if (this._candidateDefinitionsLength > 1) {
        if (this._focused) {
          this._disposeFocusStickyScrollStore();
        }
        this._revealPosition({ lineNumber: position.lineNumber, column: 1 });
      }
      this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor });
    }));
  }
  _onContextMenu(targetWindow, e) {
    const event = new StandardMouseEvent(targetWindow, e);
    this._contextMenuService.showContextMenu({
      menuId: MenuId.StickyScrollContext,
      getAnchor: () => event
    });
  }
  _onMouseMoveOrKeyDown(mouseEvent) {
    if (!mouseEvent.shiftKey) {
      return;
    }
    if (!this._mouseTarget || !isHTMLElement(this._mouseTarget)) {
      return;
    }
    const currentEndForLineIndex = this._stickyScrollWidget.getLineIndexFromChildDomNode(this._mouseTarget);
    if (currentEndForLineIndex === null || this._showEndForLine === currentEndForLineIndex) {
      return;
    }
    this._showEndForLine = currentEndForLineIndex;
    this._renderStickyScroll();
  }
  _toggleFoldingRegionForLine(line) {
    if (!this._foldingModel || line === null) {
      return;
    }
    const stickyLine = this._stickyScrollWidget.getRenderedStickyLine(line);
    const foldingIcon = stickyLine?.foldingIcon;
    if (!foldingIcon) {
      return;
    }
    toggleCollapseState(this._foldingModel, 1, [line]);
    foldingIcon.isCollapsed = !foldingIcon.isCollapsed;
    const scrollTop = (foldingIcon.isCollapsed ? this._editor.getTopForLineNumber(foldingIcon.foldingEndLine) : this._editor.getTopForLineNumber(foldingIcon.foldingStartLine)) - this._editor.getOption(
      75
      /* EditorOption.lineHeight */
    ) * stickyLine.index + 1;
    this._editor.setScrollTop(scrollTop);
    this._renderStickyScroll(line);
  }
  _readConfiguration() {
    const options = this._editor.getOption(
      131
      /* EditorOption.stickyScroll */
    );
    if (options.enabled === false) {
      this._editor.removeOverlayWidget(this._stickyScrollWidget);
      this._resetState();
      this._sessionStore.clear();
      this._enabled = false;
      return;
    } else if (options.enabled && !this._enabled) {
      this._editor.addOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.add(this._editor.onDidScrollChange((e) => {
        if (e.scrollTopChanged) {
          this._showEndForLine = void 0;
          this._renderStickyScroll();
        }
      }));
      this._sessionStore.add(this._editor.onDidLayoutChange(() => this._onDidResize()));
      this._sessionStore.add(this._editor.onDidChangeModelTokens((e) => this._onTokensChange(e)));
      this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => {
        this._showEndForLine = void 0;
        this._renderStickyScroll();
      }));
      this._enabled = true;
    }
    const lineNumberOption = this._editor.getOption(
      76
      /* EditorOption.lineNumbers */
    );
    if (lineNumberOption.renderType === 2) {
      this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => {
        this._showEndForLine = void 0;
        this._renderStickyScroll(0);
      }));
    }
  }
  _readConfigurationChange(event) {
    if (event.hasChanged(
      131
      /* EditorOption.stickyScroll */
    ) || event.hasChanged(
      81
      /* EditorOption.minimap */
    ) || event.hasChanged(
      75
      /* EditorOption.lineHeight */
    ) || event.hasChanged(
      126
      /* EditorOption.showFoldingControls */
    ) || event.hasChanged(
      76
      /* EditorOption.lineNumbers */
    )) {
      this._readConfiguration();
    }
    if (event.hasChanged(
      76
      /* EditorOption.lineNumbers */
    ) || event.hasChanged(
      52
      /* EditorOption.folding */
    ) || event.hasChanged(
      126
      /* EditorOption.showFoldingControls */
    )) {
      this._renderStickyScroll(0);
    }
  }
  _needsUpdate(event) {
    const stickyLineNumbers = this._stickyScrollWidget.getCurrentLines();
    for (const stickyLineNumber of stickyLineNumbers) {
      for (const range of event.ranges) {
        if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) {
          return true;
        }
      }
    }
    return false;
  }
  _onTokensChange(event) {
    if (this._needsUpdate(event)) {
      this._renderStickyScroll(0);
    }
  }
  _onDidResize() {
    const layoutInfo = this._editor.getLayoutInfo();
    const theoreticalLines = layoutInfo.height / this._editor.getOption(
      75
      /* EditorOption.lineHeight */
    );
    this._maxStickyLines = Math.round(theoreticalLines * 0.25);
    this._renderStickyScroll(0);
  }
  async _renderStickyScroll(rebuildFromLine) {
    const model = this._editor.getModel();
    if (!model || model.isTooLargeForTokenization()) {
      this._resetState();
      return;
    }
    const nextRebuildFromLine = this._updateAndGetMinRebuildFromLine(rebuildFromLine);
    const stickyWidgetVersion = this._stickyLineCandidateProvider.getVersionId();
    const shouldUpdateState = stickyWidgetVersion === void 0 || stickyWidgetVersion === model.getVersionId();
    if (shouldUpdateState) {
      if (!this._focused) {
        await this._updateState(nextRebuildFromLine);
      } else {
        if (this._focusedStickyElementIndex === -1) {
          await this._updateState(nextRebuildFromLine);
          this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
          if (this._focusedStickyElementIndex !== -1) {
            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
          }
        } else {
          const focusedStickyElementLineNumber = this._stickyScrollWidget.lineNumbers[this._focusedStickyElementIndex];
          await this._updateState(nextRebuildFromLine);
          if (this._stickyScrollWidget.lineNumberCount === 0) {
            this._focusedStickyElementIndex = -1;
          } else {
            const previousFocusedLineNumberExists = this._stickyScrollWidget.lineNumbers.includes(focusedStickyElementLineNumber);
            if (!previousFocusedLineNumberExists) {
              this._focusedStickyElementIndex = this._stickyScrollWidget.lineNumberCount - 1;
            }
            this._stickyScrollWidget.focusLineWithIndex(this._focusedStickyElementIndex);
          }
        }
      }
    }
  }
  _updateAndGetMinRebuildFromLine(rebuildFromLine) {
    if (rebuildFromLine !== void 0) {
      const minRebuildFromLineOrInfinity = this._minRebuildFromLine !== void 0 ? this._minRebuildFromLine : Infinity;
      this._minRebuildFromLine = Math.min(rebuildFromLine, minRebuildFromLineOrInfinity);
    }
    return this._minRebuildFromLine;
  }
  async _updateState(rebuildFromLine) {
    this._minRebuildFromLine = void 0;
    this._foldingModel = await FoldingController.get(this._editor)?.getFoldingModel() ?? void 0;
    this._widgetState = this.findScrollWidgetState();
    const stickyWidgetHasLines = this._widgetState.startLineNumbers.length > 0;
    this._stickyScrollVisibleContextKey.set(stickyWidgetHasLines);
    this._stickyScrollWidget.setState(this._widgetState, this._foldingModel, rebuildFromLine);
  }
  async _resetState() {
    this._minRebuildFromLine = void 0;
    this._foldingModel = void 0;
    this._widgetState = StickyScrollWidgetState.Empty;
    this._stickyScrollVisibleContextKey.set(false);
    this._stickyScrollWidget.setState(void 0, void 0);
  }
  findScrollWidgetState() {
    const maxNumberStickyLines = Math.min(this._maxStickyLines, this._editor.getOption(
      131
      /* EditorOption.stickyScroll */
    ).maxLineCount);
    const scrollTop = this._editor.getScrollTop();
    let lastLineRelativePosition = 0;
    const startLineNumbers = [];
    const endLineNumbers = [];
    const arrayVisibleRanges = this._editor.getVisibleRanges();
    if (arrayVisibleRanges.length !== 0) {
      const fullVisibleRange = new StickyRange(arrayVisibleRanges[0].startLineNumber, arrayVisibleRanges[arrayVisibleRanges.length - 1].endLineNumber);
      const candidateRanges = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(fullVisibleRange);
      for (const range of candidateRanges) {
        const start = range.startLineNumber;
        const end = range.endLineNumber;
        const topOfElement = range.top;
        const bottomOfElement = topOfElement + range.height;
        const topOfBeginningLine = this._editor.getTopForLineNumber(start) - scrollTop;
        const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;
        if (topOfElement > topOfBeginningLine && topOfElement <= bottomOfEndLine) {
          startLineNumbers.push(start);
          endLineNumbers.push(end + 1);
          if (bottomOfElement > bottomOfEndLine) {
            lastLineRelativePosition = bottomOfEndLine - bottomOfElement;
          }
        }
        if (startLineNumbers.length === maxNumberStickyLines) {
          break;
        }
      }
    }
    this._endLineNumbers = endLineNumbers;
    return new StickyScrollWidgetState(startLineNumbers, endLineNumbers, lastLineRelativePosition, this._showEndForLine);
  }
  dispose() {
    super.dispose();
    this._sessionStore.dispose();
  }
}, StickyScrollController_1 = _a46, _a46.ID = "store.contrib.stickyScrollController", _a46);
StickyScrollController = StickyScrollController_1 = __decorate65([
  __param65(1, IContextMenuService),
  __param65(2, ILanguageFeaturesService),
  __param65(3, IInstantiationService),
  __param65(4, ILanguageConfigurationService),
  __param65(5, ILanguageFeatureDebounceService),
  __param65(6, IContextKeyService)
], StickyScrollController);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/theme.js
init_errors();
init_observable();
init_nls();
init_colorRegistry();
init_colorUtils();
var originalBackgroundColor = registerColor("inlineEdit.originalBackground", transparent(diffRemoved, 0.2), localize(1210, "Background color for the original text in inline edits."), true);
var modifiedBackgroundColor = registerColor("inlineEdit.modifiedBackground", transparent(diffInserted, 0.3), localize(1211, "Background color for the modified text in inline edits."), true);
var originalChangedLineBackgroundColor = registerColor("inlineEdit.originalChangedLineBackground", transparent(diffRemoved, 0.8), localize(1212, "Background color for the changed lines in the original text of inline edits."), true);
var originalChangedTextOverlayColor = registerColor("inlineEdit.originalChangedTextBackground", transparent(diffRemoved, 0.8), localize(1213, "Overlay color for the changed text in the original text of inline edits."), true);
var modifiedChangedLineBackgroundColor = registerColor("inlineEdit.modifiedChangedLineBackground", {
  light: transparent(diffInsertedLine, 0.7),
  dark: transparent(diffInsertedLine, 0.7),
  hcDark: diffInsertedLine,
  hcLight: diffInsertedLine
}, localize(1214, "Background color for the changed lines in the modified text of inline edits."), true);
var modifiedChangedTextOverlayColor = registerColor("inlineEdit.modifiedChangedTextBackground", transparent(diffInserted, 0.7), localize(1215, "Overlay color for the changed text in the modified text of inline edits."), true);
var inlineEditIndicatorPrimaryForeground = registerColor("inlineEdit.gutterIndicator.primaryForeground", buttonForeground, localize(1216, "Foreground color for the primary inline edit gutter indicator."));
var inlineEditIndicatorPrimaryBorder = registerColor("inlineEdit.gutterIndicator.primaryBorder", buttonBackground, localize(1217, "Border color for the primary inline edit gutter indicator."));
var inlineEditIndicatorPrimaryBackground = registerColor("inlineEdit.gutterIndicator.primaryBackground", {
  light: transparent(inlineEditIndicatorPrimaryBorder, 0.5),
  dark: transparent(inlineEditIndicatorPrimaryBorder, 0.4),
  hcDark: transparent(inlineEditIndicatorPrimaryBorder, 0.4),
  hcLight: transparent(inlineEditIndicatorPrimaryBorder, 0.5)
}, localize(1218, "Background color for the primary inline edit gutter indicator."));
var inlineEditIndicatorSecondaryForeground = registerColor("inlineEdit.gutterIndicator.secondaryForeground", buttonSecondaryForeground, localize(1219, "Foreground color for the secondary inline edit gutter indicator."));
var inlineEditIndicatorSecondaryBorder = registerColor("inlineEdit.gutterIndicator.secondaryBorder", buttonSecondaryBackground, localize(1220, "Border color for the secondary inline edit gutter indicator."));
var inlineEditIndicatorSecondaryBackground = registerColor("inlineEdit.gutterIndicator.secondaryBackground", inlineEditIndicatorSecondaryBorder, localize(1221, "Background color for the secondary inline edit gutter indicator."));
var inlineEditIndicatorsuccessfulForeground = registerColor("inlineEdit.gutterIndicator.successfulForeground", buttonForeground, localize(1222, "Foreground color for the successful inline edit gutter indicator."));
var inlineEditIndicatorsuccessfulBorder = registerColor("inlineEdit.gutterIndicator.successfulBorder", buttonBackground, localize(1223, "Border color for the successful inline edit gutter indicator."));
var inlineEditIndicatorsuccessfulBackground = registerColor("inlineEdit.gutterIndicator.successfulBackground", inlineEditIndicatorsuccessfulBorder, localize(1224, "Background color for the successful inline edit gutter indicator."));
var inlineEditIndicatorBackground = registerColor("inlineEdit.gutterIndicator.background", {
  hcDark: transparent("tab.inactiveBackground", 0.5),
  hcLight: transparent("tab.inactiveBackground", 0.5),
  dark: transparent("tab.inactiveBackground", 0.5),
  light: "#5f5f5f18"
}, localize(1225, "Background color for the inline edit gutter indicator."));
var originalBorder = registerColor("inlineEdit.originalBorder", {
  light: diffRemoved,
  dark: diffRemoved,
  hcDark: diffRemoved,
  hcLight: diffRemoved
}, localize(1226, "Border color for the original text in inline edits."));
var modifiedBorder = registerColor("inlineEdit.modifiedBorder", {
  light: darken(diffInserted, 0.6),
  dark: diffInserted,
  hcDark: diffInserted,
  hcLight: diffInserted
}, localize(1227, "Border color for the modified text in inline edits."));
var tabWillAcceptModifiedBorder = registerColor("inlineEdit.tabWillAcceptModifiedBorder", {
  light: darken(modifiedBorder, 0),
  dark: darken(modifiedBorder, 0),
  hcDark: darken(modifiedBorder, 0),
  hcLight: darken(modifiedBorder, 0)
}, localize(1228, "Modified border color for the inline edits widget when tab will accept it."));
var tabWillAcceptOriginalBorder = registerColor("inlineEdit.tabWillAcceptOriginalBorder", {
  light: darken(originalBorder, 0),
  dark: darken(originalBorder, 0),
  hcDark: darken(originalBorder, 0),
  hcLight: darken(originalBorder, 0)
}, localize(1229, "Original border color for the inline edits widget over the original text when tab will accept it."));
function getModifiedBorderColor(tabAction) {
  return tabAction.map((a) => a === InlineEditTabAction.Accept ? tabWillAcceptModifiedBorder : modifiedBorder);
}
function getOriginalBorderColor(tabAction) {
  return tabAction.map((a) => a === InlineEditTabAction.Accept ? tabWillAcceptOriginalBorder : originalBorder);
}
function getEditorBlendedColor(colorIdentifier, themeService) {
  let color;
  if (typeof colorIdentifier === "string") {
    color = observeColor(colorIdentifier, themeService);
  } else {
    color = colorIdentifier.map((identifier, reader) => observeColor(identifier, themeService).read(reader));
  }
  const backgroundColor = observeColor(editorBackground, themeService);
  return color.map((c, reader) => (
    /** @description makeOpaque */
    c.makeOpaque(backgroundColor.read(reader))
  ));
}
function observeColor(colorIdentifier, themeService) {
  return observableFromEventOpts({
    owner: { observeColor: colorIdentifier },
    equalsFn: (a, b) => a.equals(b),
    debugName: () => `observeColor(${colorIdentifier})`
  }, themeService.onDidColorThemeChange, () => {
    const color = themeService.getColorTheme().getColor(colorIdentifier);
    if (!color) {
      throw new BugIndicatingError(`Missing color: ${colorIdentifier}`);
    }
    return color;
  });
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/utils/utils.js
init_arrays();
init_arraysFind();
init_observable();
init_strings();
init_offsetRange();
init_position();
init_range();
init_textModel();
init_errors();
function maxContentWidthInRange(editor2, range, reader) {
  editor2.layoutInfo.read(reader);
  editor2.value.read(reader);
  const model = editor2.model.read(reader);
  if (!model) {
    return 0;
  }
  let maxContentWidth = 0;
  editor2.scrollTop.read(reader);
  for (let i2 = range.startLineNumber; i2 < range.endLineNumberExclusive; i2++) {
    const column = model.getLineMaxColumn(i2);
    let lineContentWidth = editor2.editor.getOffsetForColumn(i2, column);
    if (lineContentWidth === -1) {
      const typicalHalfwidthCharacterWidth = editor2.editor.getOption(
        59
        /* EditorOption.fontInfo */
      ).typicalHalfwidthCharacterWidth;
      const approximation = column * typicalHalfwidthCharacterWidth;
      lineContentWidth = approximation;
    }
    maxContentWidth = Math.max(maxContentWidth, lineContentWidth);
  }
  const lines = range.mapToLineArray((l) => model.getLineContent(l));
  if (maxContentWidth < 5 && lines.some((l) => l.length > 0) && model.uri.scheme !== "file") {
    console.error("unexpected width");
  }
  return maxContentWidth;
}
function getOffsetForPos(editor2, pos, reader) {
  editor2.layoutInfo.read(reader);
  editor2.value.read(reader);
  const model = editor2.model.read(reader);
  if (!model) {
    return 0;
  }
  editor2.scrollTop.read(reader);
  const lineContentWidth = editor2.editor.getOffsetForColumn(pos.lineNumber, pos.column);
  return lineContentWidth;
}
function getPrefixTrim(diffRanges, originalLinesRange, modifiedLines, editor2) {
  const textModel = editor2.getModel();
  if (!textModel) {
    return { prefixTrim: 0, prefixLeftOffset: 0 };
  }
  const replacementStart = diffRanges.map((r) => r.isSingleLine() ? r.startColumn - 1 : 0);
  const originalIndents = originalLinesRange.mapToLineArray((line) => indentOfLine(textModel.getLineContent(line)));
  const modifiedIndents = modifiedLines.filter((line) => line !== "").map((line) => indentOfLine(line));
  const prefixTrim = Math.min(...replacementStart, ...originalIndents, ...modifiedIndents);
  let prefixLeftOffset;
  const startLineIndent = textModel.getLineIndentColumn(originalLinesRange.startLineNumber);
  if (startLineIndent >= prefixTrim + 1) {
    prefixLeftOffset = editor2.getOffsetForColumn(originalLinesRange.startLineNumber, prefixTrim + 1);
  } else if (modifiedLines.length > 0) {
    prefixLeftOffset = getContentRenderWidth(modifiedLines[0].slice(0, prefixTrim), editor2, textModel);
  } else {
    return { prefixTrim: 0, prefixLeftOffset: 0 };
  }
  return { prefixTrim, prefixLeftOffset };
}
function getContentRenderWidth(content, editor2, textModel) {
  const w = editor2.getOption(
    59
    /* EditorOption.fontInfo */
  ).typicalHalfwidthCharacterWidth;
  const tabSize = textModel.getOptions().tabSize * w;
  const numTabs = content.split("	").length - 1;
  const numNoneTabs = content.length - numTabs;
  return numNoneTabs * w + numTabs * tabSize;
}
function getEditorValidOverlayRect(editor2) {
  const contentLeft = editor2.layoutInfoContentLeft;
  const width = derived({ name: "editor.validOverlay.width" }, (r) => {
    const hasMinimapOnTheRight = editor2.layoutInfoMinimap.read(r).minimapLeft !== 0;
    const editorWidth = editor2.layoutInfoWidth.read(r) - contentLeft.read(r);
    if (hasMinimapOnTheRight) {
      const minimapAndScrollbarWidth = editor2.layoutInfoMinimap.read(r).minimapWidth + editor2.layoutInfoVerticalScrollbarWidth.read(r);
      return editorWidth - minimapAndScrollbarWidth;
    }
    return editorWidth;
  });
  const height = derived({ name: "editor.validOverlay.height" }, (r) => editor2.layoutInfoHeight.read(r) + editor2.contentHeight.read(r));
  return derived({ name: "editor.validOverlay" }, (r) => Rect.fromLeftTopWidthHeight(contentLeft.read(r), 0, width.read(r), height.read(r)));
}
function applyEditToModifiedRangeMappings(rangeMapping, edit) {
  const updatedMappings = [];
  for (const m of rangeMapping) {
    const updatedRange = edit.mapRange(m.modifiedRange);
    updatedMappings.push(new RangeMapping(m.originalRange, updatedRange));
  }
  return updatedMappings;
}
function classNames(...classes) {
  return classes.filter((c) => typeof c === "string").join(" ");
}
function offsetRangeToRange(columnOffsetRange, startPos) {
  return new Range(startPos.lineNumber, startPos.column + columnOffsetRange.start, startPos.lineNumber, startPos.column + columnOffsetRange.endExclusive);
}
function getIndentationSize(line, tabSize) {
  let currentSize = 0;
  loop: for (let i2 = 0, len = line.length; i2 < len; i2++) {
    switch (line.charCodeAt(i2)) {
      case 9:
        currentSize += tabSize;
        break;
      case 32:
        currentSize++;
        break;
      default:
        break loop;
    }
  }
  return currentSize - currentSize % tabSize;
}
function indentSizeToIndentLength(line, indentSize, tabSize) {
  let remainingSize = indentSize - indentSize % tabSize;
  let i2 = 0;
  for (; i2 < line.length; i2++) {
    if (remainingSize === 0) {
      break;
    }
    switch (line.charCodeAt(i2)) {
      case 9:
        remainingSize -= tabSize;
        break;
      case 32:
        remainingSize--;
        break;
      default:
        throw new BugIndicatingError("Unexpected character found while calculating indent length");
    }
  }
  return i2;
}
function createReindentEdit(text, range, tabSize) {
  const newLines = splitLines(text);
  const edits = [];
  const minIndentSize = findFirstMin(range.mapToLineArray((l) => getIndentationSize(newLines[l - 1], tabSize)), numberComparator);
  range.forEach((lineNumber) => {
    const indentLength = indentSizeToIndentLength(newLines[lineNumber - 1], minIndentSize, tabSize);
    edits.push(new TextReplacement(offsetRangeToRange(new OffsetRange(0, indentLength), new Position(lineNumber, 1)), ""));
  });
  return new TextEdit(edits);
}
var PathBuilder = class {
  constructor() {
    this._data = "";
  }
  moveTo(point) {
    this._data += `M ${point.x} ${point.y} `;
    return this;
  }
  lineTo(point) {
    this._data += `L ${point.x} ${point.y} `;
    return this;
  }
  build() {
    return this._data;
  }
};
function mapOutFalsy(obs) {
  const nonUndefinedObs = derivedObservableWithCache(void 0, (reader, lastValue) => obs.read(reader) || lastValue);
  return derivedOpts({
    debugName: () => `${obs.debugName}.mapOutFalsy`
  }, (reader) => {
    nonUndefinedObs.read(reader);
    const val = obs.read(reader);
    if (!val) {
      return void 0;
    }
    return nonUndefinedObs;
  });
}
function rectToProps(fn) {
  return {
    left: derived({ name: "editor.validOverlay.left" }, (reader) => (
      /** @description left */
      fn(reader).left
    )),
    top: derived({ name: "editor.validOverlay.top" }, (reader) => (
      /** @description top */
      fn(reader).top
    )),
    width: derived({ name: "editor.validOverlay.width" }, (reader) => (
      /** @description width */
      fn(reader).right - fn(reader).left
    )),
    height: derived({ name: "editor.validOverlay.height" }, (reader) => (
      /** @description height */
      fn(reader).bottom - fn(reader).top
    ))
  };
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/components/gutterIndicatorMenu.js
init_dom();
init_iconLabels2();
init_codicons();
init_observable();
init_platform();
init_themables();
init_nls();
init_commands();
init_contextkey();
init_colorRegistry();
var __decorate66 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param66 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GutterIndicatorMenuContent = class GutterIndicatorMenuContent2 {
  constructor(_model, _close, _editorObs, _contextKeyService, _keybindingService, _commandService) {
    this._model = _model;
    this._close = _close;
    this._editorObs = _editorObs;
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._commandService = _commandService;
    this._inlineEditsShowCollapsed = this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).map((s) => s.edits.showCollapsed);
  }
  toDisposableLiveElement() {
    return this._createHoverContent().toDisposableLiveElement();
  }
  _createHoverContent() {
    const activeElement = observableValue("active", void 0);
    const createOptionArgs = (options) => {
      return {
        title: options.title,
        icon: options.icon,
        keybinding: typeof options.commandId === "string" ? this._getKeybinding(options.commandArgs ? void 0 : options.commandId) : derived(this, (reader) => typeof options.commandId === "string" ? void 0 : this._getKeybinding(options.commandArgs ? void 0 : options.commandId.read(reader)).read(reader)),
        isActive: activeElement.map((v) => v === options.id),
        onHoverChange: (v) => activeElement.set(v ? options.id : void 0, void 0),
        onAction: () => {
          this._close(true);
          return this._commandService.executeCommand(typeof options.commandId === "string" ? options.commandId : options.commandId.get(), ...options.commandArgs ?? []);
        }
      };
    };
    const title = header(this._model.displayName);
    const gotoAndAccept = option(createOptionArgs({
      id: "gotoAndAccept",
      title: `${localize(1203, "Go To")} / ${localize(1204, "Accept")}`,
      icon: Codicon.check,
      commandId: inlineSuggestCommitId
    }));
    const reject = option(createOptionArgs({
      id: "reject",
      title: localize(1205, "Reject"),
      icon: Codicon.close,
      commandId: hideInlineCompletionId
    }));
    const extensionCommands = this._model.extensionCommands.map((c, idx) => option(createOptionArgs({
      id: c.command.id + "_" + idx,
      title: c.command.title,
      icon: c.icon ?? Codicon.symbolEvent,
      commandId: c.command.id,
      commandArgs: c.command.arguments
    })));
    const toggleCollapsedMode = this._inlineEditsShowCollapsed.map((showCollapsed) => showCollapsed ? option(createOptionArgs({
      id: "showExpanded",
      title: localize(1206, "Show Expanded"),
      icon: Codicon.expandAll,
      commandId: toggleShowCollapsedId
    })) : option(createOptionArgs({
      id: "showCollapsed",
      title: localize(1207, "Show Collapsed"),
      icon: Codicon.collapseAll,
      commandId: toggleShowCollapsedId
    })));
    const settings = option(createOptionArgs({
      id: "settings",
      title: localize(1208, "Settings"),
      icon: Codicon.gear,
      commandId: "workbench.action.openSettings",
      commandArgs: ["@tag:nextEditSuggestions"]
    }));
    const actions = this._model.action ? [this._model.action] : [];
    const actionBarFooter = actions.length > 0 ? actionBar(actions.map((action) => ({
      id: action.id,
      label: action.title + "...",
      enabled: true,
      run: () => this._commandService.executeCommand(action.id, ...action.arguments ?? []),
      class: void 0,
      tooltip: action.tooltip ?? action.title
    })), {
      hoverDelegate: nativeHoverDelegate
      /* unable to show hover inside another hover */
    }) : void 0;
    return hoverContent([
      title,
      gotoAndAccept,
      reject,
      toggleCollapsedMode,
      extensionCommands.length ? separator() : void 0,
      settings,
      ...extensionCommands,
      actionBarFooter ? separator() : void 0,
      actionBarFooter
    ]);
  }
  _getKeybinding(commandId) {
    if (!commandId) {
      return constObservable(void 0);
    }
    return observableFromEvent(this._contextKeyService.onDidChangeContext, () => this._keybindingService.lookupKeybinding(commandId));
  }
};
GutterIndicatorMenuContent = __decorate66([
  __param66(3, IContextKeyService),
  __param66(4, IKeybindingService),
  __param66(5, ICommandService)
], GutterIndicatorMenuContent);
function hoverContent(content) {
  return n.div({
    class: "content",
    style: {
      margin: 4,
      minWidth: 180
    }
  }, content);
}
function header(title) {
  return n.div({
    class: "header",
    style: {
      color: asCssVariable(descriptionForeground),
      fontSize: "13px",
      fontWeight: "600",
      padding: "0 4px",
      lineHeight: 28
    }
  }, [title]);
}
function option(props) {
  return derived({ name: "inlineEdits.option" }, (_reader) => n.div({
    class: ["monaco-menu-option", props.isActive?.map((v) => v && "active")],
    onmouseenter: () => props.onHoverChange?.(true),
    onmouseleave: () => props.onHoverChange?.(false),
    onclick: props.onAction,
    onkeydown: (e) => {
      if (e.key === "Enter") {
        props.onAction?.();
      }
    },
    tabIndex: 0,
    style: {
      borderRadius: 3
      // same as hover widget border radius
    }
  }, [
    n.elem("span", {
      style: {
        fontSize: 16,
        display: "flex"
      }
    }, [ThemeIcon.isThemeIcon(props.icon) ? renderIcon(props.icon) : props.icon.map((icon) => renderIcon(icon))]),
    n.elem("span", {}, [props.title]),
    n.div({
      style: { marginLeft: "auto" },
      ref: (elem) => {
        const keybindingLabel = _reader.store.add(new KeybindingLabel(elem, OS, {
          disableTitle: true,
          ...defaultKeybindingLabelStyles,
          keybindingLabelShadow: void 0,
          keybindingLabelForeground: asCssVariable(descriptionForeground),
          keybindingLabelBackground: "transparent",
          keybindingLabelBorder: "transparent",
          keybindingLabelBottomBorder: void 0
        }));
        _reader.store.add(autorun((reader) => {
          keybindingLabel.set(props.keybinding.read(reader));
        }));
      }
    })
  ]));
}
function actionBar(actions, options) {
  return derived({ name: "inlineEdits.actionBar" }, (_reader) => n.div({
    class: ["action-widget-action-bar"],
    style: {
      padding: "3px 24px"
    }
  }, [
    n.div({
      ref: (elem) => {
        const actionBar2 = _reader.store.add(new ActionBar(elem, options));
        actionBar2.push(actions, { icon: false, label: true });
      }
    })
  ]));
}
function separator() {
  return n.div({
    id: "inline-edit-gutter-indicator-menu-separator",
    class: "menu-separator",
    style: {
      color: asCssVariable(editorActionListForeground),
      padding: "2px 0"
    }
  }, n.div({
    style: {
      borderBottom: `1px solid ${asCssVariable(editorHoverBorder)}`
    }
  }));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/components/gutterIndicatorView.js
init_assert();
var __decorate67 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param67 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineEditsGutterIndicator = class InlineEditsGutterIndicator2 extends Disposable {
  get model() {
    const model = this._model.get();
    if (!model) {
      throw new BugIndicatingError("Inline Edit Model not available");
    }
    return model;
  }
  constructor(_editorObs, _originalRange, _verticalOffset, _model, _isHoveringOverInlineEdit, _focusIsInMenu, _hoverService, _instantiationService, _accessibilityService, themeService) {
    super();
    this._editorObs = _editorObs;
    this._originalRange = _originalRange;
    this._verticalOffset = _verticalOffset;
    this._model = _model;
    this._isHoveringOverInlineEdit = _isHoveringOverInlineEdit;
    this._focusIsInMenu = _focusIsInMenu;
    this._hoverService = _hoverService;
    this._instantiationService = _instantiationService;
    this._accessibilityService = _accessibilityService;
    this._tabAction = derived(this, (reader) => {
      const model = this._model.read(reader);
      if (!model) {
        return InlineEditTabAction.Inactive;
      }
      return model.tabAction.read(reader);
    });
    this._hoverVisible = observableValue(this, false);
    this.isHoverVisible = this._hoverVisible;
    this._isHoveredOverIcon = observableValue(this, false);
    this._isHoveredOverIconDebounced = debouncedObservable(this._isHoveredOverIcon, 100);
    this.isHoveredOverIcon = this._isHoveredOverIconDebounced;
    this._isHoveredOverInlineEditDebounced = debouncedObservable(this._isHoveringOverInlineEdit, 100);
    this._gutterIndicatorStyles = this._tabAction.map(this, (v, reader) => {
      switch (v) {
        case InlineEditTabAction.Inactive:
          return {
            background: getEditorBlendedColor(inlineEditIndicatorSecondaryBackground, themeService).read(reader).toString(),
            foreground: getEditorBlendedColor(inlineEditIndicatorSecondaryForeground, themeService).read(reader).toString(),
            border: getEditorBlendedColor(inlineEditIndicatorSecondaryBorder, themeService).read(reader).toString()
          };
        case InlineEditTabAction.Jump:
          return {
            background: getEditorBlendedColor(inlineEditIndicatorPrimaryBackground, themeService).read(reader).toString(),
            foreground: getEditorBlendedColor(inlineEditIndicatorPrimaryForeground, themeService).read(reader).toString(),
            border: getEditorBlendedColor(inlineEditIndicatorPrimaryBorder, themeService).read(reader).toString()
          };
        case InlineEditTabAction.Accept:
          return {
            background: getEditorBlendedColor(inlineEditIndicatorsuccessfulBackground, themeService).read(reader).toString(),
            foreground: getEditorBlendedColor(inlineEditIndicatorsuccessfulForeground, themeService).read(reader).toString(),
            border: getEditorBlendedColor(inlineEditIndicatorsuccessfulBorder, themeService).read(reader).toString()
          };
        default:
          assertNever(v);
      }
    });
    this._originalRangeObs = mapOutFalsy(this._originalRange);
    this._state = derived(this, (reader) => {
      const range = this._originalRangeObs.read(reader);
      if (!range) {
        return void 0;
      }
      return {
        range,
        lineOffsetRange: this._editorObs.observeLineOffsetRange(range, this._store)
      };
    });
    this._stickyScrollController = StickyScrollController.get(this._editorObs.editor);
    this._stickyScrollHeight = this._stickyScrollController ? observableFromEvent(this._stickyScrollController.onDidChangeStickyScrollHeight, () => this._stickyScrollController.stickyScrollWidgetHeight) : constObservable(0);
    this._lineNumberToRender = derived(this, (reader) => {
      if (this._verticalOffset.read(reader) !== 0) {
        return "";
      }
      const lineNumber = this._originalRange.read(reader)?.startLineNumber;
      const lineNumberOptions = this._editorObs.getOption(
        76
        /* EditorOption.lineNumbers */
      ).read(reader);
      if (lineNumber === void 0 || lineNumberOptions.renderType === 0) {
        return "";
      }
      if (lineNumberOptions.renderType === 3) {
        const cursorPosition = this._editorObs.cursorPosition.read(reader);
        if (lineNumber % 10 === 0 || cursorPosition && cursorPosition.lineNumber === lineNumber) {
          return lineNumber.toString();
        }
        return "";
      }
      if (lineNumberOptions.renderType === 2) {
        const cursorPosition = this._editorObs.cursorPosition.read(reader);
        if (!cursorPosition) {
          return "";
        }
        const relativeLineNumber = Math.abs(lineNumber - cursorPosition.lineNumber);
        if (relativeLineNumber === 0) {
          return lineNumber.toString();
        }
        return relativeLineNumber.toString();
      }
      if (lineNumberOptions.renderType === 4) {
        if (lineNumberOptions.renderFn) {
          return lineNumberOptions.renderFn(lineNumber);
        }
        return "";
      }
      return lineNumber.toString();
    });
    this._availableWidthForIcon = derived(this, (reader) => {
      const textModel = this._editorObs.editor.getModel();
      const editor2 = this._editorObs.editor;
      const layout = this._editorObs.layoutInfo.read(reader);
      const gutterWidth = layout.decorationsLeft + layout.decorationsWidth - layout.glyphMarginLeft;
      if (!textModel || gutterWidth <= 0) {
        return () => 0;
      }
      if (layout.lineNumbersLeft === 0) {
        return () => gutterWidth;
      }
      const lineNumberOptions = this._editorObs.getOption(
        76
        /* EditorOption.lineNumbers */
      ).read(reader);
      if (lineNumberOptions.renderType === 2 || /* likely to flicker */
      lineNumberOptions.renderType === 0) {
        return () => gutterWidth;
      }
      const w = editor2.getOption(
        59
        /* EditorOption.fontInfo */
      ).typicalHalfwidthCharacterWidth;
      const rightOfLineNumber = layout.lineNumbersLeft + layout.lineNumbersWidth;
      const totalLines = textModel.getLineCount();
      const totalLinesDigits = (totalLines + 1).toString().length;
      const offsetDigits = [];
      for (let digits = 1; digits <= totalLinesDigits; digits++) {
        const firstLineNumberWithDigitCount = 10 ** (digits - 1);
        const topOfLineNumber = editor2.getTopForLineNumber(firstLineNumberWithDigitCount);
        const digitsWidth = digits * w;
        const usableWidthLeftOfLineNumber = Math.min(gutterWidth, Math.max(0, rightOfLineNumber - digitsWidth - layout.glyphMarginLeft));
        offsetDigits.push({ firstLineNumberWithDigitCount, topOfLineNumber, usableWidthLeftOfLineNumber });
      }
      return (topOffset) => {
        for (let i2 = offsetDigits.length - 1; i2 >= 0; i2--) {
          if (topOffset >= offsetDigits[i2].topOfLineNumber) {
            return offsetDigits[i2].usableWidthLeftOfLineNumber;
          }
        }
        throw new BugIndicatingError("Could not find avilable width for icon");
      };
    });
    this._layout = derived(this, (reader) => {
      const s = this._state.read(reader);
      if (!s) {
        return void 0;
      }
      const layout = this._editorObs.layoutInfo.read(reader);
      const lineHeight = this._editorObs.observeLineHeightForLine(s.range.map((r) => r.startLineNumber)).read(reader);
      const gutterViewPortPadding = 2;
      const gutterWidthWithoutPadding = layout.decorationsLeft + layout.decorationsWidth - layout.glyphMarginLeft - 2 * gutterViewPortPadding;
      const gutterHeightWithoutPadding = layout.height - 2 * gutterViewPortPadding;
      const gutterViewPortWithStickyScroll = Rect.fromLeftTopWidthHeight(gutterViewPortPadding, gutterViewPortPadding, gutterWidthWithoutPadding, gutterHeightWithoutPadding);
      const gutterViewPortWithoutStickyScrollWithoutPaddingTop = gutterViewPortWithStickyScroll.withTop(this._stickyScrollHeight.read(reader));
      const gutterViewPortWithoutStickyScroll = gutterViewPortWithStickyScroll.withTop(gutterViewPortWithoutStickyScrollWithoutPaddingTop.top + gutterViewPortPadding);
      const verticalEditRange = s.lineOffsetRange.read(reader);
      const gutterEditArea = Rect.fromRanges(OffsetRange.fromTo(gutterViewPortWithoutStickyScroll.left, gutterViewPortWithoutStickyScroll.right), verticalEditRange);
      const pillHeight = lineHeight;
      const pillOffset = this._verticalOffset.read(reader);
      const pillFullyDockedRect = gutterEditArea.withHeight(pillHeight).translateY(pillOffset);
      const pillIsFullyDocked = gutterViewPortWithoutStickyScrollWithoutPaddingTop.containsRect(pillFullyDockedRect);
      const iconNoneDocked = this._tabAction.map((action) => action === InlineEditTabAction.Accept ? Codicon.keyboardTab : Codicon.arrowRight);
      const iconDocked = derived(this, (reader2) => {
        if (this._isHoveredOverIconDebounced.read(reader2) || this._isHoveredOverInlineEditDebounced.read(reader2)) {
          return Codicon.check;
        }
        if (this._tabAction.read(reader2) === InlineEditTabAction.Accept) {
          return Codicon.keyboardTab;
        }
        const cursorLineNumber = this._editorObs.cursorLineNumber.read(reader2) ?? 0;
        const editStartLineNumber = s.range.read(reader2).startLineNumber;
        return cursorLineNumber <= editStartLineNumber ? Codicon.keyboardTabAbove : Codicon.keyboardTabBelow;
      });
      const idealIconWidth = 22;
      const minimalIconWidth = 16;
      const iconWidth = (pillRect2) => {
        const availableWidth = this._availableWidthForIcon.read(void 0)(pillRect2.bottom + this._editorObs.editor.getScrollTop()) - gutterViewPortPadding;
        return Math.max(Math.min(availableWidth, idealIconWidth), minimalIconWidth);
      };
      if (pillIsFullyDocked) {
        const pillRect2 = pillFullyDockedRect;
        let lineNumberWidth;
        if (layout.lineNumbersWidth === 0) {
          lineNumberWidth = Math.min(Math.max(layout.lineNumbersLeft - gutterViewPortWithStickyScroll.left, 0), pillRect2.width - idealIconWidth);
        } else {
          lineNumberWidth = Math.max(layout.lineNumbersLeft + layout.lineNumbersWidth - gutterViewPortWithStickyScroll.left, 0);
        }
        const lineNumberRect = pillRect2.withWidth(lineNumberWidth);
        const iconWidth2 = Math.max(Math.min(layout.decorationsWidth, idealIconWidth), minimalIconWidth);
        const iconRect2 = pillRect2.withWidth(iconWidth2).translateX(lineNumberWidth);
        return {
          gutterEditArea,
          icon: iconDocked,
          iconDirection: "right",
          iconRect: iconRect2,
          pillRect: pillRect2,
          lineNumberRect
        };
      }
      const pillPartiallyDockedPossibleArea = gutterViewPortWithStickyScroll.intersect(gutterEditArea);
      const pillIsPartiallyDocked = pillPartiallyDockedPossibleArea && pillPartiallyDockedPossibleArea.height >= pillHeight;
      if (pillIsPartiallyDocked) {
        const pillRectMoved2 = pillFullyDockedRect.moveToBeContainedIn(gutterViewPortWithoutStickyScroll).moveToBeContainedIn(pillPartiallyDockedPossibleArea);
        const pillRect2 = pillRectMoved2.withWidth(iconWidth(pillRectMoved2));
        const iconRect2 = pillRect2;
        return {
          gutterEditArea,
          icon: iconDocked,
          iconDirection: "right",
          iconRect: iconRect2,
          pillRect: pillRect2
        };
      }
      const pillRectMoved = pillFullyDockedRect.moveToBeContainedIn(gutterViewPortWithStickyScroll);
      const pillRect = pillRectMoved.withWidth(iconWidth(pillRectMoved));
      const iconRect = pillRect;
      const iconDirection = pillRect.top < pillFullyDockedRect.top ? "top" : "bottom";
      return {
        gutterEditArea,
        icon: iconNoneDocked,
        iconDirection,
        iconRect,
        pillRect
      };
    });
    this._iconRef = n.ref();
    this.isVisible = this._layout.map((l) => !!l);
    this._indicator = n.div({
      class: "inline-edits-view-gutter-indicator",
      onclick: () => {
        const layout = this._layout.get();
        const acceptOnClick = layout?.icon.get() === Codicon.check;
        this._editorObs.editor.focus();
        if (acceptOnClick) {
          this.model.accept();
        } else {
          this.model.jump();
        }
      },
      tabIndex: 0,
      style: {
        position: "absolute",
        overflow: "visible"
      }
    }, mapOutFalsy(this._layout).map((layout) => !layout ? [] : [
      n.div({
        style: {
          position: "absolute",
          background: asCssVariable(inlineEditIndicatorBackground),
          borderRadius: "4px",
          ...rectToProps((reader) => layout.read(reader).gutterEditArea)
        }
      }),
      n.div({
        class: "icon",
        ref: this._iconRef,
        onmouseenter: () => {
          this._showHover();
        },
        style: {
          cursor: "pointer",
          zIndex: "20",
          position: "absolute",
          backgroundColor: this._gutterIndicatorStyles.map((v) => v.background),
          ["--vscodeIconForeground"]: this._gutterIndicatorStyles.map((v) => v.foreground),
          border: this._gutterIndicatorStyles.map((v) => `1px solid ${v.border}`),
          boxSizing: "border-box",
          borderRadius: "4px",
          display: "flex",
          justifyContent: "flex-end",
          transition: "background-color 0.2s ease-in-out, width 0.2s ease-in-out",
          ...rectToProps((reader) => layout.read(reader).pillRect)
        }
      }, [
        n.div({
          className: "line-number",
          style: {
            lineHeight: layout.map((l) => l.lineNumberRect ? l.lineNumberRect.height : 0),
            display: layout.map((l) => l.lineNumberRect ? "flex" : "none"),
            alignItems: "center",
            justifyContent: "flex-end",
            width: layout.map((l) => l.lineNumberRect ? l.lineNumberRect.width : 0),
            height: "100%",
            color: this._gutterIndicatorStyles.map((v) => v.foreground)
          }
        }, this._lineNumberToRender),
        n.div({
          style: {
            rotate: layout.map((l) => `${getRotationFromDirection(l.iconDirection)}deg`),
            transition: "rotate 0.2s ease-in-out",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            marginRight: layout.map((l) => l.pillRect.width - l.iconRect.width - (l.lineNumberRect?.width ?? 0)),
            width: layout.map((l) => l.iconRect.width)
          }
        }, [
          layout.map((l, reader) => renderIcon(l.icon.read(reader)))
        ])
      ])
    ])).keepUpdated(this._store);
    this._register(this._editorObs.createOverlayWidget({
      domNode: this._indicator.element,
      position: constObservable(null),
      allowEditorOverflow: false,
      minContentWidthInPx: constObservable(0)
    }));
    this._register(this._editorObs.editor.onMouseMove((e) => {
      const state = this._state.get();
      if (state === void 0) {
        return;
      }
      const el = this._iconRef.element;
      const rect = el.getBoundingClientRect();
      const rectangularArea = Rect.fromLeftTopWidthHeight(rect.left, rect.top, rect.width, rect.height);
      const point = new Point(e.event.posx, e.event.posy);
      this._isHoveredOverIcon.set(rectangularArea.containsPoint(point), void 0);
    }));
    this._register(this._editorObs.editor.onDidScrollChange(() => {
      this._isHoveredOverIcon.set(false, void 0);
    }));
    this._register(runOnChange(this._isHoveredOverInlineEditDebounced, (isHovering) => {
      if (isHovering) {
        this.triggerAnimation();
      }
    }));
    this._register(autorun((reader) => {
      this._indicator.readEffect(reader);
      if (this._indicator.element) {
        this._editorObs.editor.applyFontInfo(this._indicator.element);
      }
    }));
  }
  triggerAnimation() {
    if (this._accessibilityService.isMotionReduced()) {
      return new Animation(null, null).finished;
    }
    const animation = this._iconRef.element.animate([
      {
        outline: `2px solid ${this._gutterIndicatorStyles.map((v) => v.border).get()}`,
        outlineOffset: "-1px",
        offset: 0
      },
      {
        outline: `2px solid transparent`,
        outlineOffset: "10px",
        offset: 1
      }
    ], { duration: 500 });
    return animation.finished;
  }
  _showHover() {
    if (this._hoverVisible.get()) {
      return;
    }
    const disposableStore = new DisposableStore();
    const content = disposableStore.add(this._instantiationService.createInstance(GutterIndicatorMenuContent, this.model, (focusEditor) => {
      if (focusEditor) {
        this._editorObs.editor.focus();
      }
      h2?.dispose();
    }, this._editorObs).toDisposableLiveElement());
    const focusTracker = disposableStore.add(trackFocus(content.element));
    disposableStore.add(focusTracker.onDidBlur(() => this._focusIsInMenu.set(false, void 0)));
    disposableStore.add(focusTracker.onDidFocus(() => this._focusIsInMenu.set(true, void 0)));
    disposableStore.add(toDisposable(() => this._focusIsInMenu.set(false, void 0)));
    const h2 = this._hoverService.showInstantHover({
      target: this._iconRef.element,
      content: content.element
    });
    if (h2) {
      this._hoverVisible.set(true, void 0);
      disposableStore.add(this._editorObs.editor.onDidScrollChange(() => h2.dispose()));
      disposableStore.add(h2.onDispose(() => {
        this._hoverVisible.set(false, void 0);
        disposableStore.dispose();
      }));
    } else {
      disposableStore.dispose();
    }
  }
};
InlineEditsGutterIndicator = __decorate67([
  __param67(6, IHoverService),
  __param67(7, IInstantiationService),
  __param67(8, IAccessibilityService),
  __param67(9, IThemeService)
], InlineEditsGutterIndicator);
function getRotationFromDirection(direction) {
  switch (direction) {
    case "top":
      return 90;
    case "bottom":
      return -90;
    case "right":
      return 0;
  }
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsNewUsers.js
init_async();
init_errors();
init_lifecycle();
init_observable();
init_configuration();
var __decorate68 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param68 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var UserKind;
(function(UserKind2) {
  UserKind2["FirstTime"] = "firstTime";
  UserKind2["SecondTime"] = "secondTime";
  UserKind2["Active"] = "active";
})(UserKind || (UserKind = {}));
var InlineEditsOnboardingExperience = class InlineEditsOnboardingExperience2 extends Disposable {
  constructor(_host, _model, _indicator, _collapsedView, _storageService, _configurationService) {
    super();
    this._host = _host;
    this._model = _model;
    this._indicator = _indicator;
    this._collapsedView = _collapsedView;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._disposables = this._register(new MutableDisposable());
    this._setupDone = observableValue({ name: "setupDone" }, false);
    this._activeCompletionId = derived((reader) => {
      const model = this._model.read(reader);
      if (!model) {
        return void 0;
      }
      if (!this._setupDone.read(reader)) {
        return void 0;
      }
      const indicator = this._indicator.read(reader);
      if (!indicator || !indicator.isVisible.read(reader)) {
        return void 0;
      }
      return model.inlineEdit.inlineCompletion.identity.id;
    });
    this._register(this._initializeDebugSetting());
    this._disposables.value = this.setupNewUserExperience();
    this._setupDone.set(true, void 0);
  }
  setupNewUserExperience() {
    if (this.getNewUserType() === UserKind.Active) {
      return void 0;
    }
    const disposableStore = new DisposableStore();
    let userHasHoveredOverIcon = false;
    let inlineEditHasBeenAccepted = false;
    let firstTimeUserAnimationCount = 0;
    let secondTimeUserAnimationCount = 0;
    disposableStore.add(runOnChangeWithCancellationToken(this._activeCompletionId, async (id, _, __, token) => {
      if (id === void 0) {
        return;
      }
      let userType = this.getNewUserType();
      switch (userType) {
        case UserKind.FirstTime: {
          if (firstTimeUserAnimationCount++ >= 5 || userHasHoveredOverIcon) {
            userType = UserKind.SecondTime;
            this.setNewUserType(userType);
          }
          break;
        }
        case UserKind.SecondTime: {
          if (secondTimeUserAnimationCount++ >= 3 && inlineEditHasBeenAccepted) {
            userType = UserKind.Active;
            this.setNewUserType(userType);
          }
          break;
        }
      }
      switch (userType) {
        case UserKind.FirstTime: {
          for (let i2 = 0; i2 < 3 && !token.isCancellationRequested; i2++) {
            await this._indicator.get()?.triggerAnimation();
            await timeout(500);
          }
          break;
        }
        case UserKind.SecondTime: {
          this._indicator.get()?.triggerAnimation();
          break;
        }
      }
    }));
    disposableStore.add(autorun((reader) => {
      if (this._collapsedView.isVisible.read(reader)) {
        if (this.getNewUserType() !== UserKind.Active) {
          this._collapsedView.triggerAnimation();
        }
      }
    }));
    disposableStore.add(autorunWithStore((reader, store) => {
      const indicator = this._indicator.read(reader);
      if (!indicator) {
        return;
      }
      store.add(runOnChange(indicator.isHoveredOverIcon, async (isHovered) => {
        if (isHovered) {
          userHasHoveredOverIcon = true;
        }
      }));
    }));
    disposableStore.add(autorunWithStore((reader, store) => {
      const host = this._host.read(reader);
      if (!host) {
        return;
      }
      store.add(host.onDidAccept(() => {
        inlineEditHasBeenAccepted = true;
      }));
    }));
    return disposableStore;
  }
  getNewUserType() {
    return this._storageService.get("inlineEditsGutterIndicatorUserKind", -1, UserKind.FirstTime);
  }
  setNewUserType(value) {
    switch (value) {
      case UserKind.FirstTime:
        throw new BugIndicatingError("UserKind should not be set to first time");
      case UserKind.SecondTime:
        break;
      case UserKind.Active:
        this._disposables.clear();
        break;
    }
    this._storageService.store(
      "inlineEditsGutterIndicatorUserKind",
      value,
      -1,
      0
      /* StorageTarget.USER */
    );
  }
  _initializeDebugSetting() {
    const hiddenDebugSetting = "editor.inlineSuggest.edits.resetNewUserExperience";
    if (this._configurationService.getValue(hiddenDebugSetting)) {
      this._storageService.remove(
        "inlineEditsGutterIndicatorUserKind",
        -1
        /* StorageScope.APPLICATION */
      );
    }
    const disposable = this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(hiddenDebugSetting) && this._configurationService.getValue(hiddenDebugSetting)) {
        this._storageService.remove(
          "inlineEditsGutterIndicatorUserKind",
          -1
          /* StorageScope.APPLICATION */
        );
        this._disposables.value = this.setupNewUserExperience();
      }
    });
    return disposable;
  }
};
InlineEditsOnboardingExperience = __decorate68([
  __param68(4, IStorageService),
  __param68(5, IConfigurationService)
], InlineEditsOnboardingExperience);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsCollapsedView.js
init_dom();
init_event();
init_lifecycle();
init_observable();
init_colorUtils();
init_observableCodeEditor();
init_point();
var __decorate69 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param69 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineEditsCollapsedView = class InlineEditsCollapsedView2 extends Disposable {
  constructor(_editor, _edit, _accessibilityService) {
    super();
    this._editor = _editor;
    this._edit = _edit;
    this._accessibilityService = _accessibilityService;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._iconRef = n.ref();
    this.isHovered = constObservable(false);
    this._editorObs = observableCodeEditor(this._editor);
    const firstEdit = this._edit.map((inlineEdit) => inlineEdit?.edit.replacements[0] ?? null);
    const startPosition = firstEdit.map((edit) => edit ? singleTextRemoveCommonPrefix(edit, this._editor.getModel()).range.getStartPosition() : null);
    const observedStartPoint = this._editorObs.observePosition(startPosition, this._store);
    const startPoint = derived((reader) => {
      const point = observedStartPoint.read(reader);
      if (!point) {
        return null;
      }
      const contentLeft = this._editorObs.layoutInfoContentLeft.read(reader);
      const scrollLeft = this._editorObs.scrollLeft.read(reader);
      return new Point(contentLeft + point.x - scrollLeft, point.y);
    });
    const overlayElement = n.div({
      class: "inline-edits-collapsed-view",
      style: {
        position: "absolute",
        overflow: "visible",
        top: "0px",
        left: "0px",
        display: "block"
      }
    }, [
      [this.getCollapsedIndicator(startPoint)]
    ]).keepUpdated(this._store).element;
    this._register(this._editorObs.createOverlayWidget({
      domNode: overlayElement,
      position: constObservable(null),
      allowEditorOverflow: false,
      minContentWidthInPx: constObservable(0)
    }));
    this.isVisible = this._edit.map((inlineEdit, reader) => !!inlineEdit && startPoint.read(reader) !== null);
  }
  triggerAnimation() {
    if (this._accessibilityService.isMotionReduced()) {
      return new Animation(null, null).finished;
    }
    const animation = this._iconRef.element.animate([
      { offset: 0, transform: "translateY(-3px)" },
      { offset: 0.2, transform: "translateY(1px)" },
      { offset: 0.36, transform: "translateY(-1px)" },
      { offset: 0.52, transform: "translateY(1px)" },
      { offset: 0.68, transform: "translateY(-1px)" },
      { offset: 0.84, transform: "translateY(1px)" },
      { offset: 1, transform: "translateY(0px)" }
    ], { duration: 2e3 });
    return animation.finished;
  }
  getCollapsedIndicator(startPoint) {
    const contentLeft = this._editorObs.layoutInfoContentLeft;
    const startPointTranslated = startPoint.map((p, reader) => p ? p.deltaX(-contentLeft.read(reader)) : null);
    const iconPath = this.createIconPath(startPointTranslated);
    return n.svg({
      class: "collapsedView",
      ref: this._iconRef,
      style: {
        position: "absolute",
        ...rectToProps((r) => getEditorValidOverlayRect(this._editorObs).read(r)),
        overflow: "hidden",
        pointerEvents: "none"
      }
    }, [
      n.svgElem("path", {
        class: "collapsedViewPath",
        d: iconPath,
        fill: asCssVariable(inlineEditIndicatorPrimaryBorder)
      })
    ]);
  }
  createIconPath(indicatorPoint) {
    const width = 6;
    const triangleHeight = 3;
    const baseHeight = 1;
    return indicatorPoint.map((point) => {
      if (!point) {
        return new PathBuilder().build();
      }
      const baseTopLeft = point.deltaX(-width / 2).deltaY(-baseHeight);
      const baseTopRight = baseTopLeft.deltaX(width);
      const baseBottomLeft = baseTopLeft.deltaY(baseHeight);
      const baseBottomRight = baseTopRight.deltaY(baseHeight);
      const triangleBottomCenter = baseBottomLeft.deltaX(width / 2).deltaY(triangleHeight);
      return new PathBuilder().moveTo(baseTopLeft).lineTo(baseTopRight).lineTo(baseBottomRight).lineTo(triangleBottomCenter).lineTo(baseBottomLeft).lineTo(baseTopLeft).build();
    });
  }
};
InlineEditsCollapsedView = __decorate69([
  __param69(2, IAccessibilityService)
], InlineEditsCollapsedView);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsCustomView.js
init_dom();
init_mouseEvent();
init_event();
init_lifecycle();
init_observable();
init_colorRegistry();
init_colorUtils();
init_themeService();
init_observableCodeEditor();
init_lineRange();
init_languages();
init_language();
init_lineTokens();
var __decorate70 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param70 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MIN_END_OF_LINE_PADDING = 14;
var PADDING_VERTICALLY = 0;
var PADDING_HORIZONTALLY = 4;
var HORIZONTAL_OFFSET_WHEN_ABOVE_BELOW = 4;
var VERTICAL_OFFSET_WHEN_ABOVE_BELOW = 2;
var InlineEditsCustomView = class InlineEditsCustomView2 extends Disposable {
  constructor(_editor, displayLocation, tabAction, themeService, _languageService) {
    super();
    this._editor = _editor;
    this._languageService = _languageService;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._isHovered = observableValue(this, false);
    this.isHovered = this._isHovered;
    this._viewRef = n.ref();
    this._editorObs = observableCodeEditor(this._editor);
    const styles = tabAction.map((v, reader) => {
      let border;
      switch (v) {
        case InlineEditTabAction.Inactive:
          border = inlineEditIndicatorSecondaryBackground;
          break;
        case InlineEditTabAction.Jump:
          border = inlineEditIndicatorPrimaryBackground;
          break;
        case InlineEditTabAction.Accept:
          border = inlineEditIndicatorsuccessfulBackground;
          break;
      }
      return {
        border: getEditorBlendedColor(border, themeService).read(reader).toString(),
        background: asCssVariable(editorBackground)
      };
    });
    const state = displayLocation.map((dl) => dl ? this.getState(dl) : void 0);
    const view = state.map((s) => s ? this.getRendering(s, styles) : void 0);
    this.minEditorScrollHeight = derived(this, (reader) => {
      const s = state.read(reader);
      if (!s) {
        return 0;
      }
      return s.rect.read(reader).bottom + this._editor.getScrollTop();
    });
    const overlay = n.div({
      class: "inline-edits-custom-view",
      style: {
        position: "absolute",
        overflow: "visible",
        top: "0px",
        left: "0px",
        display: "block"
      }
    }, [view]).keepUpdated(this._store);
    this._register(this._editorObs.createOverlayWidget({
      domNode: overlay.element,
      position: constObservable(null),
      allowEditorOverflow: false,
      minContentWidthInPx: derivedObservableWithCache(this, (reader, prev) => {
        const s = state.read(reader);
        if (!s) {
          return prev ?? 0;
        }
        const current = s.rect.map((rect) => rect.right).read(reader) + this._editorObs.layoutInfoVerticalScrollbarWidth.read(reader) + PADDING_HORIZONTALLY - this._editorObs.layoutInfoContentLeft.read(reader);
        return Math.max(prev ?? 0, current);
      }).recomputeInitiallyAndOnChange(this._store)
    }));
    this._register(autorun((reader) => {
      const v = view.read(reader);
      if (!v) {
        this._isHovered.set(false, void 0);
        return;
      }
      this._isHovered.set(overlay.isHovered.read(reader), void 0);
    }));
  }
  // TODO: this is very similar to side by side `fitsInsideViewport`, try to use the same function
  fitsInsideViewport(range, displayLabel, reader) {
    const editorWidth = this._editorObs.layoutInfoWidth.read(reader);
    const editorContentLeft = this._editorObs.layoutInfoContentLeft.read(reader);
    const editorVerticalScrollbar = this._editor.getLayoutInfo().verticalScrollbarWidth;
    const minimapWidth = this._editorObs.layoutInfoMinimap.read(reader).minimapLeft !== 0 ? this._editorObs.layoutInfoMinimap.read(reader).minimapWidth : 0;
    const maxOriginalContent = maxContentWidthInRange(this._editorObs, range, void 0);
    const maxModifiedContent = getContentRenderWidth(displayLabel, this._editor, this._editor.getModel());
    const padding = PADDING_HORIZONTALLY + MIN_END_OF_LINE_PADDING;
    return maxOriginalContent + maxModifiedContent + padding < editorWidth - editorContentLeft - editorVerticalScrollbar - minimapWidth;
  }
  getState(displayLocation) {
    const contentState = derived(this, (reader) => {
      const startLineNumber2 = displayLocation.range.startLineNumber;
      const endLineNumber2 = displayLocation.range.endLineNumber;
      const startColumn = displayLocation.range.startColumn;
      const endColumn = displayLocation.range.endColumn;
      const lineCount = this._editor.getModel()?.getLineCount() ?? 0;
      const lineWidth = maxContentWidthInRange(this._editorObs, new LineRange(startLineNumber2, startLineNumber2 + 1), reader);
      const lineWidthBelow = startLineNumber2 + 1 <= lineCount ? maxContentWidthInRange(this._editorObs, new LineRange(startLineNumber2 + 1, startLineNumber2 + 2), reader) : void 0;
      const lineWidthAbove = startLineNumber2 - 1 >= 1 ? maxContentWidthInRange(this._editorObs, new LineRange(startLineNumber2 - 1, startLineNumber2), reader) : void 0;
      const startContentLeftOffset = this._editor.getOffsetForColumn(startLineNumber2, startColumn);
      const endContentLeftOffset = this._editor.getOffsetForColumn(endLineNumber2, endColumn);
      return {
        lineWidth,
        lineWidthBelow,
        lineWidthAbove,
        startContentLeftOffset,
        endContentLeftOffset
      };
    });
    const startLineNumber = displayLocation.range.startLineNumber;
    const endLineNumber = displayLocation.range.endLineNumber;
    const fitsInsideViewport = this.fitsInsideViewport(new LineRange(startLineNumber, endLineNumber + 1), displayLocation.label, void 0);
    const rect = derived(this, (reader) => {
      const w = this._editorObs.getOption(
        59
        /* EditorOption.fontInfo */
      ).read(reader).typicalHalfwidthCharacterWidth;
      const { lineWidth, lineWidthBelow, lineWidthAbove, startContentLeftOffset, endContentLeftOffset } = contentState.read(reader);
      const contentLeft = this._editorObs.layoutInfoContentLeft.read(reader);
      const lineHeight = this._editorObs.observeLineHeightForLine(startLineNumber).recomputeInitiallyAndOnChange(reader.store).read(reader);
      const scrollTop = this._editorObs.scrollTop.read(reader);
      const scrollLeft = this._editorObs.scrollLeft.read(reader);
      let position;
      if (startLineNumber === endLineNumber && endContentLeftOffset + 5 * w >= lineWidth && fitsInsideViewport) {
        position = "end";
      } else if (lineWidthBelow !== void 0 && lineWidthBelow + MIN_END_OF_LINE_PADDING - HORIZONTAL_OFFSET_WHEN_ABOVE_BELOW - PADDING_HORIZONTALLY < startContentLeftOffset) {
        position = "below";
      } else if (lineWidthAbove !== void 0 && lineWidthAbove + MIN_END_OF_LINE_PADDING - HORIZONTAL_OFFSET_WHEN_ABOVE_BELOW - PADDING_HORIZONTALLY < startContentLeftOffset) {
        position = "above";
      } else {
        position = "end";
      }
      let topOfLine;
      let contentStartOffset;
      let deltaX = 0;
      let deltaY = 0;
      switch (position) {
        case "end": {
          topOfLine = this._editorObs.editor.getTopForLineNumber(startLineNumber);
          contentStartOffset = lineWidth;
          deltaX = PADDING_HORIZONTALLY + MIN_END_OF_LINE_PADDING;
          break;
        }
        case "below": {
          topOfLine = this._editorObs.editor.getTopForLineNumber(startLineNumber + 1);
          contentStartOffset = startContentLeftOffset;
          deltaX = PADDING_HORIZONTALLY + HORIZONTAL_OFFSET_WHEN_ABOVE_BELOW;
          deltaY = PADDING_VERTICALLY + VERTICAL_OFFSET_WHEN_ABOVE_BELOW;
          break;
        }
        case "above": {
          topOfLine = this._editorObs.editor.getTopForLineNumber(startLineNumber - 1);
          contentStartOffset = startContentLeftOffset;
          deltaX = PADDING_HORIZONTALLY + HORIZONTAL_OFFSET_WHEN_ABOVE_BELOW;
          deltaY = -PADDING_VERTICALLY + VERTICAL_OFFSET_WHEN_ABOVE_BELOW;
          break;
        }
      }
      const textRect = Rect.fromLeftTopWidthHeight(contentLeft + contentStartOffset - scrollLeft, topOfLine - scrollTop, w * displayLocation.label.length, lineHeight);
      return textRect.withMargin(PADDING_VERTICALLY, PADDING_HORIZONTALLY).translateX(deltaX).translateY(deltaY);
    });
    return {
      rect,
      label: displayLocation.label,
      kind: displayLocation.kind
    };
  }
  getRendering(state, styles) {
    const line = document.createElement("div");
    const t = this._editor.getModel().tokenization.tokenizeLinesAt(1, [state.label])?.[0];
    let tokens;
    if (t && state.kind === InlineCompletionDisplayLocationKind.Code) {
      tokens = TokenArray.fromLineTokens(t).toLineTokens(state.label, this._languageService.languageIdCodec);
    } else {
      tokens = LineTokens.createEmpty(state.label, this._languageService.languageIdCodec);
    }
    const result = renderLines(new LineSource([tokens]), RenderOptions.fromEditor(this._editor).withSetWidth(false).withScrollBeyondLastColumn(0), [], line, true);
    line.style.width = `${result.minWidthInPx}px`;
    const rect = state.rect.map((r) => r.withMargin(0, PADDING_HORIZONTALLY));
    return n.div({
      class: "collapsedView",
      ref: this._viewRef,
      style: {
        position: "absolute",
        ...rectToProps((reader) => rect.read(reader)),
        overflow: "hidden",
        boxSizing: "border-box",
        cursor: "pointer",
        border: styles.map((s) => `1px solid ${s.border}`),
        borderRadius: "4px",
        backgroundColor: styles.map((s) => s.background),
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        whiteSpace: "nowrap"
      },
      onmousedown: (e) => {
        e.preventDefault();
      },
      onclick: (e) => {
        this._onDidClick.fire(new StandardMouseEvent(getWindow(e), e));
      }
    }, [
      line
    ]);
  }
};
InlineEditsCustomView = __decorate70([
  __param70(3, IThemeService),
  __param70(4, ILanguageService)
], InlineEditsCustomView);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsDeletionView.js
init_dom();
init_event();
init_lifecycle();
init_observable();
init_colorRegistry();
init_colorUtils();
init_observableCodeEditor();
init_offsetRange();
init_position();
var HORIZONTAL_PADDING = 0;
var VERTICAL_PADDING = 0;
var BORDER_WIDTH = 1;
var WIDGET_SEPARATOR_WIDTH = 1;
var WIDGET_SEPARATOR_DIFF_EDITOR_WIDTH = 3;
var BORDER_RADIUS = 4;
var InlineEditsDeletionView = class extends Disposable {
  constructor(_editor, _edit, _uiState, _tabAction) {
    super();
    this._editor = _editor;
    this._edit = _edit;
    this._uiState = _uiState;
    this._tabAction = _tabAction;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._display = derived(this, (reader) => !!this._uiState.read(reader) ? "block" : "none");
    this._editorMaxContentWidthInRange = derived(this, (reader) => {
      const originalDisplayRange = this._originalDisplayRange.read(reader);
      if (!originalDisplayRange) {
        return constObservable(0);
      }
      this._editorObs.versionId.read(reader);
      return derivedObservableWithCache(this, (reader2, lastValue) => {
        const maxWidth = maxContentWidthInRange(this._editorObs, originalDisplayRange, reader2);
        return Math.max(maxWidth, lastValue ?? 0);
      });
    }).map((v, r) => v.read(r));
    this._maxPrefixTrim = derived(this, (reader) => {
      const state = this._uiState.read(reader);
      if (!state) {
        return { prefixTrim: 0, prefixLeftOffset: 0 };
      }
      return getPrefixTrim(state.deletions, state.originalRange, [], this._editor);
    });
    this._editorLayoutInfo = derived(this, (reader) => {
      const inlineEdit = this._edit.read(reader);
      if (!inlineEdit) {
        return null;
      }
      const state = this._uiState.read(reader);
      if (!state) {
        return null;
      }
      const editorLayout = this._editorObs.layoutInfo.read(reader);
      const horizontalScrollOffset = this._editorObs.scrollLeft.read(reader);
      const w = this._editorObs.getOption(
        59
        /* EditorOption.fontInfo */
      ).map((f) => f.typicalHalfwidthCharacterWidth).read(reader);
      const right = editorLayout.contentLeft + Math.max(this._editorMaxContentWidthInRange.read(reader), w) - horizontalScrollOffset;
      const range = inlineEdit.originalLineRange;
      const selectionTop = this._originalVerticalStartPosition.read(reader) ?? this._editor.getTopForLineNumber(range.startLineNumber) - this._editorObs.scrollTop.read(reader);
      const selectionBottom = this._originalVerticalEndPosition.read(reader) ?? this._editor.getTopForLineNumber(range.endLineNumberExclusive) - this._editorObs.scrollTop.read(reader);
      const left = editorLayout.contentLeft + this._maxPrefixTrim.read(reader).prefixLeftOffset - horizontalScrollOffset;
      if (right <= left) {
        return null;
      }
      const codeRect = Rect.fromLeftTopRightBottom(left, selectionTop, right, selectionBottom).withMargin(VERTICAL_PADDING, HORIZONTAL_PADDING);
      return {
        codeRect,
        contentLeft: editorLayout.contentLeft
      };
    }).recomputeInitiallyAndOnChange(this._store);
    this._originalOverlay = n.div({
      style: { pointerEvents: "none" }
    }, derived(this, (reader) => {
      const layoutInfoObs = mapOutFalsy(this._editorLayoutInfo).read(reader);
      if (!layoutInfoObs) {
        return void 0;
      }
      const overlayhider = layoutInfoObs.map((layoutInfo) => Rect.fromLeftTopRightBottom(layoutInfo.contentLeft - BORDER_RADIUS - BORDER_WIDTH, layoutInfo.codeRect.top, layoutInfo.contentLeft, layoutInfo.codeRect.bottom));
      const overlayRect = derived(this, (reader2) => {
        const rect = layoutInfoObs.read(reader2).codeRect;
        const overlayHider = overlayhider.read(reader2);
        return rect.intersectHorizontal(new OffsetRange(overlayHider.left, Number.MAX_SAFE_INTEGER));
      });
      const separatorWidth = this._uiState.map((s) => s?.inDiffEditor ? WIDGET_SEPARATOR_DIFF_EDITOR_WIDTH : WIDGET_SEPARATOR_WIDTH).read(reader);
      const separatorRect = overlayRect.map((rect) => rect.withMargin(separatorWidth, separatorWidth));
      return [
        n.div({
          class: "originalSeparatorDeletion",
          style: {
            ...separatorRect.read(reader).toStyles(),
            borderRadius: `${BORDER_RADIUS}px`,
            border: `${BORDER_WIDTH + separatorWidth}px solid ${asCssVariable(editorBackground)}`,
            boxSizing: "border-box"
          }
        }),
        n.div({
          class: "originalOverlayDeletion",
          style: {
            ...overlayRect.read(reader).toStyles(),
            borderRadius: `${BORDER_RADIUS}px`,
            border: getOriginalBorderColor(this._tabAction).map((bc) => `${BORDER_WIDTH}px solid ${asCssVariable(bc)}`),
            boxSizing: "border-box",
            backgroundColor: asCssVariable(originalBackgroundColor)
          }
        }),
        n.div({
          class: "originalOverlayHiderDeletion",
          style: {
            ...overlayhider.read(reader).toStyles(),
            backgroundColor: asCssVariable(editorBackground)
          }
        })
      ];
    })).keepUpdated(this._store);
    this._nonOverflowView = n.div({
      class: "inline-edits-view",
      style: {
        position: "absolute",
        overflow: "visible",
        top: "0px",
        left: "0px",
        display: this._display
      }
    }, [
      [this._originalOverlay]
    ]).keepUpdated(this._store);
    this.isHovered = constObservable(false);
    this._editorObs = observableCodeEditor(this._editor);
    const originalStartPosition = derived(this, (reader) => {
      const inlineEdit = this._edit.read(reader);
      return inlineEdit ? new Position(inlineEdit.originalLineRange.startLineNumber, 1) : null;
    });
    const originalEndPosition = derived(this, (reader) => {
      const inlineEdit = this._edit.read(reader);
      return inlineEdit ? new Position(inlineEdit.originalLineRange.endLineNumberExclusive, 1) : null;
    });
    this._originalDisplayRange = this._uiState.map((s) => s?.originalRange);
    this._originalVerticalStartPosition = this._editorObs.observePosition(originalStartPosition, this._store).map((p) => p?.y);
    this._originalVerticalEndPosition = this._editorObs.observePosition(originalEndPosition, this._store).map((p) => p?.y);
    this._register(this._editorObs.createOverlayWidget({
      domNode: this._nonOverflowView.element,
      position: constObservable(null),
      allowEditorOverflow: false,
      minContentWidthInPx: derived(this, (reader) => {
        const info = this._editorLayoutInfo.read(reader);
        if (info === null) {
          return 0;
        }
        return info.codeRect.width;
      })
    }));
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsInsertionView.js
init_dom();
init_event();
init_lifecycle();
init_observable();
init_instantiation();
init_colorRegistry();
init_colorUtils();
init_observableCodeEditor();
init_position();
init_range();
init_lineRange();
init_offsetRange();
init_language();
init_lineTokens();
var __decorate71 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param71 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BORDER_WIDTH2 = 1;
var WIDGET_SEPARATOR_WIDTH2 = 1;
var WIDGET_SEPARATOR_DIFF_EDITOR_WIDTH2 = 3;
var BORDER_RADIUS2 = 4;
var InlineEditsInsertionView = class InlineEditsInsertionView2 extends Disposable {
  constructor(_editor, _input, _tabAction, instantiationService, _languageService) {
    super();
    this._editor = _editor;
    this._input = _input;
    this._tabAction = _tabAction;
    this._languageService = _languageService;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._state = derived(this, (reader) => {
      const state = this._input.read(reader);
      if (!state) {
        return void 0;
      }
      const textModel = this._editor.getModel();
      const eol = textModel.getEOL();
      if (state.startColumn === 1 && state.lineNumber > 1 && textModel.getLineLength(state.lineNumber) !== 0 && state.text.endsWith(eol) && !state.text.startsWith(eol)) {
        const endOfLineColumn = textModel.getLineLength(state.lineNumber - 1) + 1;
        return { lineNumber: state.lineNumber - 1, column: endOfLineColumn, text: eol + state.text.slice(0, -eol.length) };
      }
      return { lineNumber: state.lineNumber, column: state.startColumn, text: state.text };
    });
    this._trimVertically = derived(this, (reader) => {
      const state = this._state.read(reader);
      const text = state?.text;
      if (!text || text.trim() === "") {
        return { topOffset: 0, bottomOffset: 0, linesTop: 0, linesBottom: 0 };
      }
      const lineHeight = this._editor.getLineHeightForPosition(new Position(state.lineNumber, 1));
      const eol = this._editor.getModel().getEOL();
      let linesTop = 0;
      let linesBottom = 0;
      let i2 = 0;
      for (; i2 < text.length && text.startsWith(eol, i2); i2 += eol.length) {
        linesTop += 1;
      }
      for (let j = text.length; j > i2 && text.endsWith(eol, j); j -= eol.length) {
        linesBottom += 1;
      }
      return { topOffset: linesTop * lineHeight, bottomOffset: linesBottom * lineHeight, linesTop, linesBottom };
    });
    this._maxPrefixTrim = derived(this, (reader) => {
      const state = this._state.read(reader);
      if (!state) {
        return { prefixLeftOffset: 0, prefixTrim: 0 };
      }
      const textModel = this._editor.getModel();
      const eol = textModel.getEOL();
      const trimVertically = this._trimVertically.read(reader);
      const lines = state.text.split(eol);
      const modifiedLines = lines.slice(trimVertically.linesTop, lines.length - trimVertically.linesBottom);
      if (trimVertically.linesTop === 0) {
        modifiedLines[0] = textModel.getLineContent(state.lineNumber) + modifiedLines[0];
      }
      const originalRange = new LineRange(state.lineNumber, state.lineNumber + (trimVertically.linesTop > 0 ? 0 : 1));
      return getPrefixTrim([], originalRange, modifiedLines, this._editor);
    });
    this._ghostText = derived((reader) => {
      const state = this._state.read(reader);
      const prefixTrim = this._maxPrefixTrim.read(reader);
      if (!state) {
        return void 0;
      }
      const textModel = this._editor.getModel();
      const eol = textModel.getEOL();
      const modifiedLines = state.text.split(eol);
      const inlineDecorations = modifiedLines.map((line, i2) => new InlineDecoration(
        new Range(i2 + 1, i2 === 0 ? 1 : prefixTrim.prefixTrim + 1, i2 + 1, line.length + 1),
        "modified-background",
        0
        /* InlineDecorationType.Regular */
      ));
      return new GhostText(state.lineNumber, [new GhostTextPart(state.column, state.text, false, inlineDecorations)]);
    });
    this._display = derived(this, (reader) => !!this._state.read(reader) ? "block" : "none");
    this._editorMaxContentWidthInRange = derived(this, (reader) => {
      const state = this._state.read(reader);
      if (!state) {
        return 0;
      }
      this._editorObs.versionId.read(reader);
      const textModel = this._editor.getModel();
      const eol = textModel.getEOL();
      const textBeforeInsertion = state.text.startsWith(eol) ? "" : textModel.getValueInRange(new Range(state.lineNumber, 1, state.lineNumber, state.column));
      const textAfterInsertion = textModel.getValueInRange(new Range(state.lineNumber, state.column, state.lineNumber, textModel.getLineLength(state.lineNumber) + 1));
      const text = textBeforeInsertion + state.text + textAfterInsertion;
      const lines = text.split(eol);
      const renderOptions = RenderOptions.fromEditor(this._editor).withSetWidth(false).withScrollBeyondLastColumn(0);
      const lineWidths = lines.map((line) => {
        const t = textModel.tokenization.tokenizeLinesAt(state.lineNumber, [line])?.[0];
        let tokens;
        if (t) {
          tokens = TokenArray.fromLineTokens(t).toLineTokens(line, this._languageService.languageIdCodec);
        } else {
          tokens = LineTokens.createEmpty(line, this._languageService.languageIdCodec);
        }
        return renderLines(new LineSource([tokens]), renderOptions, [], $("div"), true).minWidthInPx;
      });
      return Math.max(...lineWidths);
    });
    this.startLineOffset = this._trimVertically.map((v) => v.topOffset);
    this.originalLines = this._state.map((s) => s ? new LineRange(s.lineNumber, Math.min(s.lineNumber + 2, this._editor.getModel().getLineCount() + 1)) : void 0);
    this._overlayLayout = derived(this, (reader) => {
      this._ghostText.read(reader);
      const state = this._state.read(reader);
      if (!state) {
        return null;
      }
      this._editorObs.observePosition(observableValue(this, new Position(state.lineNumber, state.column)), reader.store).read(reader);
      const editorLayout = this._editorObs.layoutInfo.read(reader);
      const horizontalScrollOffset = this._editorObs.scrollLeft.read(reader);
      const verticalScrollbarWidth = this._editorObs.layoutInfoVerticalScrollbarWidth.read(reader);
      const right = editorLayout.contentLeft + this._editorMaxContentWidthInRange.read(reader) - horizontalScrollOffset;
      const prefixLeftOffset = this._maxPrefixTrim.read(reader).prefixLeftOffset ?? 0;
      const left = editorLayout.contentLeft + prefixLeftOffset - horizontalScrollOffset;
      if (right <= left) {
        return null;
      }
      const { topOffset: topTrim, bottomOffset: bottomTrim } = this._trimVertically.read(reader);
      const scrollTop = this._editorObs.scrollTop.read(reader);
      const height = this._ghostTextView.height.read(reader) - topTrim - bottomTrim;
      const top = this._editor.getTopForLineNumber(state.lineNumber) - scrollTop + topTrim;
      const bottom = top + height;
      const overlay = new Rect(left, top, right, bottom);
      return {
        overlay,
        startsAtContentLeft: prefixLeftOffset === 0,
        contentLeft: editorLayout.contentLeft,
        minContentWidthRequired: prefixLeftOffset + overlay.width + verticalScrollbarWidth
      };
    }).recomputeInitiallyAndOnChange(this._store);
    this._modifiedOverlay = n.div({
      style: { pointerEvents: "none" }
    }, derived(this, (reader) => {
      const overlayLayoutObs = mapOutFalsy(this._overlayLayout).read(reader);
      if (!overlayLayoutObs) {
        return void 0;
      }
      const overlayHider = overlayLayoutObs.map((layoutInfo) => Rect.fromLeftTopRightBottom(layoutInfo.contentLeft - BORDER_RADIUS2 - BORDER_WIDTH2, layoutInfo.overlay.top, layoutInfo.contentLeft, layoutInfo.overlay.bottom)).read(reader);
      const separatorWidth = this._input.map((i2) => i2?.inDiffEditor ? WIDGET_SEPARATOR_DIFF_EDITOR_WIDTH2 : WIDGET_SEPARATOR_WIDTH2).read(reader);
      const overlayRect = overlayLayoutObs.map((l) => l.overlay.withMargin(0, BORDER_WIDTH2, 0, l.startsAtContentLeft ? 0 : BORDER_WIDTH2).intersectHorizontal(new OffsetRange(overlayHider.left, Number.MAX_SAFE_INTEGER)));
      const underlayRect = overlayRect.map((rect) => rect.withMargin(separatorWidth, separatorWidth));
      return [
        n.div({
          class: "originalUnderlayInsertion",
          style: {
            ...underlayRect.read(reader).toStyles(),
            borderRadius: BORDER_RADIUS2,
            border: `${BORDER_WIDTH2 + separatorWidth}px solid ${asCssVariable(editorBackground)}`,
            boxSizing: "border-box"
          }
        }),
        n.div({
          class: "originalOverlayInsertion",
          style: {
            ...overlayRect.read(reader).toStyles(),
            borderRadius: BORDER_RADIUS2,
            border: getModifiedBorderColor(this._tabAction).map((bc) => `${BORDER_WIDTH2}px solid ${asCssVariable(bc)}`),
            boxSizing: "border-box",
            backgroundColor: asCssVariable(modifiedBackgroundColor)
          }
        }),
        n.div({
          class: "originalOverlayHiderInsertion",
          style: {
            ...overlayHider.toStyles(),
            backgroundColor: asCssVariable(editorBackground)
          }
        })
      ];
    })).keepUpdated(this._store);
    this._view = n.div({
      class: "inline-edits-view",
      style: {
        position: "absolute",
        overflow: "visible",
        top: "0px",
        left: "0px",
        display: this._display
      }
    }, [
      [this._modifiedOverlay]
    ]).keepUpdated(this._store);
    this._editorObs = observableCodeEditor(this._editor);
    this._ghostTextView = this._register(instantiationService.createInstance(GhostTextView, this._editor, {
      ghostText: this._ghostText,
      minReservedLineCount: constObservable(0),
      targetTextModel: this._editorObs.model.map((model) => model ?? void 0),
      warning: constObservable(void 0),
      handleInlineCompletionShown: constObservable(() => {
      })
    }, observableValue(this, { syntaxHighlightingEnabled: true, extraClasses: ["inline-edit"] }), true, true));
    this.isHovered = this._ghostTextView.isHovered;
    this._register(this._ghostTextView.onDidClick((e) => {
      this._onDidClick.fire(e);
    }));
    this._register(this._editorObs.createOverlayWidget({
      domNode: this._view.element,
      position: constObservable(null),
      allowEditorOverflow: false,
      minContentWidthInPx: derived(this, (reader) => {
        const info = this._overlayLayout.read(reader);
        if (info === null) {
          return 0;
        }
        return info.minContentWidthRequired;
      })
    }));
  }
};
InlineEditsInsertionView = __decorate71([
  __param71(3, IInstantiationService),
  __param71(4, ILanguageService)
], InlineEditsInsertionView);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsLineReplacementView.js
init_dom();
init_mouseEvent();
init_event();
init_lifecycle();
init_observable();
init_colorRegistry();
init_colorUtils();
init_themeService();
init_point();
init_range();
init_offsetRange();
init_language();
init_lineTokens();
var __decorate72 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param72 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineEditsLineReplacementView = class InlineEditsLineReplacementView2 extends Disposable {
  constructor(_editor, _edit, _isInDiffEditor, _tabAction, _languageService, _themeService) {
    super();
    this._editor = _editor;
    this._edit = _edit;
    this._isInDiffEditor = _isInDiffEditor;
    this._tabAction = _tabAction;
    this._languageService = _languageService;
    this._themeService = _themeService;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._maxPrefixTrim = this._edit.map((e) => e ? getPrefixTrim(e.replacements.flatMap((r) => [r.originalRange, r.modifiedRange]), e.originalRange, e.modifiedLines, this._editor.editor) : void 0);
    this._modifiedLineElements = derived(this, (reader) => {
      const lines = [];
      let requiredWidth = 0;
      const prefixTrim = this._maxPrefixTrim.read(reader);
      const edit = this._edit.read(reader);
      if (!edit || !prefixTrim) {
        return void 0;
      }
      const maxPrefixTrim = prefixTrim.prefixTrim;
      const modifiedBubbles = rangesToBubbleRanges(edit.replacements.map((r) => r.modifiedRange)).map((r) => new Range(r.startLineNumber, r.startColumn - maxPrefixTrim, r.endLineNumber, r.endColumn - maxPrefixTrim));
      const textModel = this._editor.model.get();
      const startLineNumber = edit.modifiedRange.startLineNumber;
      for (let i2 = 0; i2 < edit.modifiedRange.length; i2++) {
        const line = document.createElement("div");
        const lineNumber = startLineNumber + i2;
        const modLine = edit.modifiedLines[i2].slice(maxPrefixTrim);
        const t = textModel.tokenization.tokenizeLinesAt(lineNumber, [modLine])?.[0];
        let tokens;
        if (t) {
          tokens = TokenArray.fromLineTokens(t).toLineTokens(modLine, this._languageService.languageIdCodec);
        } else {
          tokens = LineTokens.createEmpty(modLine, this._languageService.languageIdCodec);
        }
        const decorations = [];
        for (const modified of modifiedBubbles.filter((b) => b.startLineNumber === lineNumber)) {
          const validatedEndColumn = Math.min(modified.endColumn, modLine.length + 1);
          decorations.push(new InlineDecoration(
            new Range(1, modified.startColumn, 1, validatedEndColumn),
            "inlineCompletions-modified-bubble",
            0
            /* InlineDecorationType.Regular */
          ));
        }
        const result = renderLines(new LineSource([tokens]), RenderOptions.fromEditor(this._editor.editor).withSetWidth(false).withScrollBeyondLastColumn(0), decorations, line, true);
        this._editor.getOption(
          59
          /* EditorOption.fontInfo */
        ).read(reader);
        requiredWidth = Math.max(requiredWidth, result.minWidthInPx);
        lines.push(line);
      }
      return { lines, requiredWidth };
    });
    this._layout = derived(this, (reader) => {
      const modifiedLines = this._modifiedLineElements.read(reader);
      const maxPrefixTrim = this._maxPrefixTrim.read(reader);
      const edit = this._edit.read(reader);
      if (!modifiedLines || !maxPrefixTrim || !edit) {
        return void 0;
      }
      const { prefixLeftOffset } = maxPrefixTrim;
      const { requiredWidth } = modifiedLines;
      const originalLineHeights = this._editor.observeLineHeightsForLineRange(edit.originalRange).read(reader);
      const modifiedLineHeights = (() => {
        const lineHeights = originalLineHeights.slice(0, edit.modifiedRange.length);
        while (lineHeights.length < edit.modifiedRange.length) {
          lineHeights.push(originalLineHeights[originalLineHeights.length - 1]);
        }
        return lineHeights;
      })();
      const contentLeft = this._editor.layoutInfoContentLeft.read(reader);
      const verticalScrollbarWidth = this._editor.layoutInfoVerticalScrollbarWidth.read(reader);
      const scrollLeft = this._editor.scrollLeft.read(reader);
      const scrollTop = this._editor.scrollTop.read(reader);
      const editorLeftOffset = contentLeft - scrollLeft;
      const textModel = this._editor.editor.getModel();
      const originalLineWidths = edit.originalRange.mapToLineArray((line) => this._editor.editor.getOffsetForColumn(line, textModel.getLineMaxColumn(line)) - prefixLeftOffset);
      const maxLineWidth = Math.max(...originalLineWidths, requiredWidth);
      const startLineNumber = edit.originalRange.startLineNumber;
      const endLineNumber = edit.originalRange.endLineNumberExclusive - 1;
      const topOfOriginalLines = this._editor.editor.getTopForLineNumber(startLineNumber) - scrollTop;
      const bottomOfOriginalLines = this._editor.editor.getBottomForLineNumber(endLineNumber) - scrollTop;
      const originalLinesOverlay = Rect.fromLeftTopWidthHeight(editorLeftOffset + prefixLeftOffset, topOfOriginalLines, maxLineWidth, bottomOfOriginalLines - topOfOriginalLines);
      const modifiedLinesOverlay = Rect.fromLeftTopWidthHeight(originalLinesOverlay.left, originalLinesOverlay.bottom, originalLinesOverlay.width, modifiedLineHeights.reduce((sum2, h2) => sum2 + h2, 0));
      const background = Rect.hull([originalLinesOverlay, modifiedLinesOverlay]);
      const lowerBackground = background.intersectVertical(new OffsetRange(originalLinesOverlay.bottom, Number.MAX_SAFE_INTEGER));
      const lowerText = new Rect(lowerBackground.left, lowerBackground.top, lowerBackground.right, lowerBackground.bottom);
      return {
        originalLinesOverlay,
        modifiedLinesOverlay,
        background,
        lowerBackground,
        lowerText,
        modifiedLineHeights,
        minContentWidthRequired: prefixLeftOffset + maxLineWidth + verticalScrollbarWidth
      };
    });
    this._viewZoneInfo = derived((reader) => {
      const shouldShowViewZone = this._editor.getOption(
        71
        /* EditorOption.inlineSuggest */
      ).map((o) => o.edits.allowCodeShifting === "always").read(reader);
      if (!shouldShowViewZone) {
        return void 0;
      }
      const layout = this._layout.read(reader);
      const edit = this._edit.read(reader);
      if (!layout || !edit) {
        return void 0;
      }
      const viewZoneHeight = layout.lowerBackground.height;
      const viewZoneLineNumber = edit.originalRange.endLineNumberExclusive;
      return { height: viewZoneHeight, lineNumber: viewZoneLineNumber };
    });
    this.minEditorScrollHeight = derived(this, (reader) => {
      const layout = mapOutFalsy(this._layout).read(reader);
      if (!layout || this._viewZoneInfo.read(reader) !== void 0) {
        return 0;
      }
      return layout.read(reader).lowerText.bottom + this._editor.editor.getScrollTop();
    });
    this._div = n.div({
      class: "line-replacement"
    }, [
      derived(this, (reader) => {
        const layout = mapOutFalsy(this._layout).read(reader);
        const modifiedLineElements = this._modifiedLineElements.read(reader);
        if (!layout || !modifiedLineElements) {
          return [];
        }
        const layoutProps = layout.read(reader);
        const contentLeft = this._editor.layoutInfoContentLeft.read(reader);
        const separatorWidth = this._isInDiffEditor.read(reader) ? 3 : 1;
        modifiedLineElements.lines.forEach((l, i2) => {
          l.style.width = `${layoutProps.lowerText.width}px`;
          l.style.height = `${layoutProps.modifiedLineHeights[i2]}px`;
          l.style.position = "relative";
        });
        const modifiedBorderColor = getModifiedBorderColor(this._tabAction).read(reader);
        const originalBorderColor = getOriginalBorderColor(this._tabAction).read(reader);
        return [
          n.div({
            style: {
              position: "absolute",
              ...rectToProps((r) => getEditorValidOverlayRect(this._editor).read(r)),
              overflow: "hidden",
              pointerEvents: "none"
            }
          }, [
            n.div({
              class: "borderAroundLineReplacement",
              style: {
                position: "absolute",
                ...rectToProps((reader2) => layout.read(reader2).background.translateX(-contentLeft).withMargin(separatorWidth)),
                borderRadius: "4px",
                border: `${separatorWidth + 1}px solid ${asCssVariable(editorBackground)}`,
                boxSizing: "border-box",
                pointerEvents: "none"
              }
            }),
            n.div({
              class: "originalOverlayLineReplacement",
              style: {
                position: "absolute",
                ...rectToProps((reader2) => layout.read(reader2).background.translateX(-contentLeft)),
                borderRadius: "4px",
                border: getEditorBlendedColor(originalBorderColor, this._themeService).map((c) => `1px solid ${c.toString()}`),
                pointerEvents: "none",
                boxSizing: "border-box",
                background: asCssVariable(originalBackgroundColor)
              }
            }),
            n.div({
              class: "modifiedOverlayLineReplacement",
              style: {
                position: "absolute",
                ...rectToProps((reader2) => layout.read(reader2).lowerBackground.translateX(-contentLeft)),
                borderRadius: "0 0 4px 4px",
                background: asCssVariable(editorBackground),
                boxShadow: `${asCssVariable(scrollbarShadow)} 0 6px 6px -6px`,
                border: `1px solid ${asCssVariable(modifiedBorderColor)}`,
                boxSizing: "border-box",
                overflow: "hidden",
                cursor: "pointer",
                pointerEvents: "auto"
              },
              onmousedown: (e) => {
                e.preventDefault();
              },
              onclick: (e) => this._onDidClick.fire(new StandardMouseEvent(getWindow(e), e))
            }, [
              n.div({
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  width: "100%",
                  height: "100%",
                  background: asCssVariable(modifiedChangedLineBackgroundColor)
                }
              })
            ]),
            n.div({
              class: "modifiedLinesLineReplacement",
              style: {
                position: "absolute",
                boxSizing: "border-box",
                ...rectToProps((reader2) => layout.read(reader2).lowerText.translateX(-contentLeft)),
                fontFamily: this._editor.getOption(
                  58
                  /* EditorOption.fontFamily */
                ),
                fontSize: this._editor.getOption(
                  61
                  /* EditorOption.fontSize */
                ),
                fontWeight: this._editor.getOption(
                  62
                  /* EditorOption.fontWeight */
                ),
                pointerEvents: "none",
                whiteSpace: "nowrap",
                borderRadius: "0 0 4px 4px",
                overflow: "hidden"
              }
            }, [...modifiedLineElements.lines])
          ])
        ];
      })
    ]).keepUpdated(this._store);
    this.isHovered = this._editor.isTargetHovered((e) => this._isMouseOverWidget(e), this._store);
    this._previousViewZoneInfo = void 0;
    this._register(toDisposable(() => this._editor.editor.changeViewZones((accessor) => this.removePreviousViewZone(accessor))));
    this._register(autorunDelta(this._viewZoneInfo, ({ lastValue, newValue }) => {
      if (lastValue === newValue || lastValue?.height === newValue?.height && lastValue?.lineNumber === newValue?.lineNumber) {
        return;
      }
      this._editor.editor.changeViewZones((changeAccessor) => {
        this.removePreviousViewZone(changeAccessor);
        if (!newValue) {
          return;
        }
        this.addViewZone(newValue, changeAccessor);
      });
    }));
    this._register(this._editor.createOverlayWidget({
      domNode: this._div.element,
      minContentWidthInPx: derived(this, (reader) => {
        return this._layout.read(reader)?.minContentWidthRequired ?? 0;
      }),
      position: constObservable({ preference: { top: 0, left: 0 } }),
      allowEditorOverflow: false
    }));
  }
  _isMouseOverWidget(e) {
    const layout = this._layout.get();
    if (!layout || !(e.event instanceof EditorMouseEvent)) {
      return false;
    }
    return layout.lowerBackground.containsPoint(new Point(e.event.relativePos.x, e.event.relativePos.y));
  }
  removePreviousViewZone(changeAccessor) {
    if (!this._previousViewZoneInfo) {
      return;
    }
    changeAccessor.removeZone(this._previousViewZoneInfo.id);
    const cursorLineNumber = this._editor.cursorLineNumber.get();
    if (cursorLineNumber !== null && cursorLineNumber >= this._previousViewZoneInfo.lineNumber) {
      this._editor.editor.setScrollTop(this._editor.scrollTop.get() - this._previousViewZoneInfo.height);
    }
    this._previousViewZoneInfo = void 0;
  }
  addViewZone(viewZoneInfo, changeAccessor) {
    const activeViewZone = changeAccessor.addZone({
      afterLineNumber: viewZoneInfo.lineNumber - 1,
      heightInPx: viewZoneInfo.height,
      // move computation to layout?
      domNode: $("div")
    });
    this._previousViewZoneInfo = { height: viewZoneInfo.height, lineNumber: viewZoneInfo.lineNumber, id: activeViewZone };
    const cursorLineNumber = this._editor.cursorLineNumber.get();
    if (cursorLineNumber !== null && cursorLineNumber >= viewZoneInfo.lineNumber) {
      this._editor.editor.setScrollTop(this._editor.scrollTop.get() + viewZoneInfo.height);
    }
  }
};
InlineEditsLineReplacementView = __decorate72([
  __param72(4, ILanguageService),
  __param72(5, IThemeService)
], InlineEditsLineReplacementView);
function rangesToBubbleRanges(ranges) {
  const result = [];
  while (ranges.length) {
    let range = ranges.shift();
    if (range.startLineNumber !== range.endLineNumber) {
      ranges.push(new Range(range.startLineNumber + 1, 1, range.endLineNumber, range.endColumn));
      range = new Range(range.startLineNumber, range.startColumn, range.startLineNumber, Number.MAX_SAFE_INTEGER);
    }
    result.push(range);
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsSideBySideView.js
init_dom();
init_mouseEvent();
init_color();
init_event();
init_lifecycle();
init_observable();
init_instantiation();
init_colorRegistry();
init_colorUtils();
init_themeService();
init_observableCodeEditor();
init_offsetRange();
init_position();
init_range();
var __decorate73 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param73 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HORIZONTAL_PADDING2 = 0;
var VERTICAL_PADDING2 = 0;
var ENABLE_OVERFLOW = false;
var BORDER_WIDTH3 = 1;
var WIDGET_SEPARATOR_WIDTH3 = 1;
var WIDGET_SEPARATOR_DIFF_EDITOR_WIDTH3 = 3;
var BORDER_RADIUS3 = 4;
var ORIGINAL_END_PADDING = 20;
var MODIFIED_END_PADDING = 12;
var InlineEditsSideBySideView = class InlineEditsSideBySideView2 extends Disposable {
  // This is an approximation and should be improved by using the real parameters used bellow
  static fitsInsideViewport(editor2, textModel, edit, reader) {
    const editorObs = observableCodeEditor(editor2);
    const editorWidth = editorObs.layoutInfoWidth.read(reader);
    const editorContentLeft = editorObs.layoutInfoContentLeft.read(reader);
    const editorVerticalScrollbar = editor2.getLayoutInfo().verticalScrollbarWidth;
    const minimapWidth = editorObs.layoutInfoMinimap.read(reader).minimapLeft !== 0 ? editorObs.layoutInfoMinimap.read(reader).minimapWidth : 0;
    const maxOriginalContent = maxContentWidthInRange(
      editorObs,
      edit.displayRange,
      void 0
      /* do not reconsider on each layout info change */
    );
    const maxModifiedContent = edit.lineEdit.newLines.reduce((max, line) => Math.max(max, getContentRenderWidth(line, editor2, textModel)), 0);
    const originalPadding = ORIGINAL_END_PADDING;
    const modifiedPadding = MODIFIED_END_PADDING + 2 * BORDER_WIDTH3;
    return maxOriginalContent + maxModifiedContent + originalPadding + modifiedPadding < editorWidth - editorContentLeft - editorVerticalScrollbar - minimapWidth;
  }
  constructor(_editor, _edit, _previewTextModel, _uiState, _tabAction, _instantiationService, _themeService) {
    super();
    this._editor = _editor;
    this._edit = _edit;
    this._previewTextModel = _previewTextModel;
    this._uiState = _uiState;
    this._tabAction = _tabAction;
    this._instantiationService = _instantiationService;
    this._themeService = _themeService;
    this._editorObs = observableCodeEditor(this._editor);
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._display = derived(this, (reader) => !!this._uiState.read(reader) ? "block" : "none");
    this.previewRef = n.ref();
    const separatorWidthObs = this._uiState.map((s) => s?.isInDiffEditor ? WIDGET_SEPARATOR_DIFF_EDITOR_WIDTH3 : WIDGET_SEPARATOR_WIDTH3);
    this._editorContainer = n.div({
      class: ["editorContainer"],
      style: { position: "absolute", overflow: "hidden", cursor: "pointer" },
      onmousedown: (e) => {
        e.preventDefault();
      },
      onclick: (e) => {
        this._onDidClick.fire(new StandardMouseEvent(getWindow(e), e));
      }
    }, [
      n.div({ class: "preview", style: { pointerEvents: "none" }, ref: this.previewRef })
    ]).keepUpdated(this._store);
    this.isHovered = this._editorContainer.didMouseMoveDuringHover;
    this.previewEditor = this._register(this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this.previewRef.element, {
      glyphMargin: false,
      lineNumbers: "off",
      minimap: { enabled: false },
      guides: {
        indentation: false,
        bracketPairs: false,
        bracketPairsHorizontal: false,
        highlightActiveIndentation: false
      },
      rulers: [],
      padding: { top: 0, bottom: 0 },
      folding: false,
      selectOnLineNumbers: false,
      selectionHighlight: false,
      columnSelection: false,
      overviewRulerBorder: false,
      overviewRulerLanes: 0,
      lineDecorationsWidth: 0,
      lineNumbersMinChars: 0,
      revealHorizontalRightPadding: 0,
      bracketPairColorization: { enabled: true, independentColorPoolPerBracketType: false },
      scrollBeyondLastLine: false,
      scrollbar: {
        vertical: "hidden",
        horizontal: "hidden",
        handleMouseWheel: false
      },
      readOnly: true,
      wordWrap: "off",
      wordWrapOverride1: "off",
      wordWrapOverride2: "off"
    }, {
      contextKeyValues: {
        [InlineCompletionContextKeys.inInlineEditsPreviewEditor.key]: true
      },
      contributions: []
    }, this._editor));
    this._previewEditorObs = observableCodeEditor(this.previewEditor);
    this._activeViewZones = [];
    this._updatePreviewEditor = derived(this, (reader) => {
      this._editorContainer.readEffect(reader);
      this._previewEditorObs.model.read(reader);
      this._display.read(reader);
      if (this._nonOverflowView) {
        this._nonOverflowView.element.style.display = this._display.read(reader);
      }
      const uiState = this._uiState.read(reader);
      const edit = this._edit.read(reader);
      if (!uiState || !edit) {
        return;
      }
      const range = edit.originalLineRange;
      const hiddenAreas = [];
      if (range.startLineNumber > 1) {
        hiddenAreas.push(new Range(1, 1, range.startLineNumber - 1, 1));
      }
      if (range.startLineNumber + uiState.newTextLineCount < this._previewTextModel.getLineCount() + 1) {
        hiddenAreas.push(new Range(range.startLineNumber + uiState.newTextLineCount, 1, this._previewTextModel.getLineCount() + 1, 1));
      }
      this.previewEditor.setHiddenAreas(hiddenAreas, void 0, true);
      const previousViewZones = [...this._activeViewZones];
      this._activeViewZones = [];
      const reducedLinesCount = range.endLineNumberExclusive - range.startLineNumber - uiState.newTextLineCount;
      this.previewEditor.changeViewZones((changeAccessor) => {
        previousViewZones.forEach((id) => changeAccessor.removeZone(id));
        if (reducedLinesCount > 0) {
          this._activeViewZones.push(changeAccessor.addZone({
            afterLineNumber: range.startLineNumber + uiState.newTextLineCount - 1,
            heightInLines: reducedLinesCount,
            showInHiddenAreas: true,
            domNode: $("div.diagonal-fill.inline-edits-view-zone")
          }));
        }
      });
    });
    this._previewEditorWidth = derived(this, (reader) => {
      const edit = this._edit.read(reader);
      if (!edit) {
        return 0;
      }
      this._updatePreviewEditor.read(reader);
      return maxContentWidthInRange(this._previewEditorObs, edit.modifiedLineRange, reader);
    });
    this._cursorPosIfTouchesEdit = derived(this, (reader) => {
      const cursorPos = this._editorObs.cursorPosition.read(reader);
      const edit = this._edit.read(reader);
      if (!edit || !cursorPos) {
        return void 0;
      }
      return edit.modifiedLineRange.contains(cursorPos.lineNumber) ? cursorPos : void 0;
    });
    this._originalStartPosition = derived(this, (reader) => {
      const inlineEdit = this._edit.read(reader);
      return inlineEdit ? new Position(inlineEdit.originalLineRange.startLineNumber, 1) : null;
    });
    this._originalEndPosition = derived(this, (reader) => {
      const inlineEdit = this._edit.read(reader);
      return inlineEdit ? new Position(inlineEdit.originalLineRange.endLineNumberExclusive, 1) : null;
    });
    this._originalVerticalStartPosition = this._editorObs.observePosition(this._originalStartPosition, this._store).map((p) => p?.y);
    this._originalVerticalEndPosition = this._editorObs.observePosition(this._originalEndPosition, this._store).map((p) => p?.y);
    this._originalDisplayRange = this._edit.map((e) => e?.displayRange);
    this._editorMaxContentWidthInRange = derived(this, (reader) => {
      const originalDisplayRange = this._originalDisplayRange.read(reader);
      if (!originalDisplayRange) {
        return constObservable(0);
      }
      this._editorObs.versionId.read(reader);
      return derivedObservableWithCache(this, (reader2, lastValue) => {
        const maxWidth = maxContentWidthInRange(this._editorObs, originalDisplayRange, reader2);
        return Math.max(maxWidth, lastValue ?? 0);
      });
    }).map((v, r) => v.read(r));
    this._previewEditorLayoutInfo = derived(this, (reader) => {
      const inlineEdit = this._edit.read(reader);
      if (!inlineEdit) {
        return null;
      }
      const state = this._uiState.read(reader);
      if (!state) {
        return null;
      }
      const range = inlineEdit.originalLineRange;
      const horizontalScrollOffset = this._editorObs.scrollLeft.read(reader);
      const editorContentMaxWidthInRange = this._editorMaxContentWidthInRange.read(reader);
      const editorLayout = this._editorObs.layoutInfo.read(reader);
      const previewContentWidth = this._previewEditorWidth.read(reader);
      const editorContentAreaWidth = editorLayout.contentWidth - editorLayout.verticalScrollbarWidth;
      const editorBoundingClientRect = this._editor.getContainerDomNode().getBoundingClientRect();
      const clientContentAreaRight = editorLayout.contentLeft + editorLayout.contentWidth + editorBoundingClientRect.left;
      const remainingWidthRightOfContent = getWindow(this._editor.getContainerDomNode()).innerWidth - clientContentAreaRight;
      const remainingWidthRightOfEditor = getWindow(this._editor.getContainerDomNode()).innerWidth - editorBoundingClientRect.right;
      const desiredMinimumWidth = Math.min(editorLayout.contentWidth * 0.3, previewContentWidth, 100);
      const IN_EDITOR_DISPLACEMENT = 0;
      const maximumAvailableWidth = IN_EDITOR_DISPLACEMENT + remainingWidthRightOfContent;
      const cursorPos = this._cursorPosIfTouchesEdit.read(reader);
      const maxPreviewEditorLeft = Math.max(
        // We're starting from the content area right and moving it left by IN_EDITOR_DISPLACEMENT and also by an amount to ensure some minimum desired width
        editorContentAreaWidth + horizontalScrollOffset - IN_EDITOR_DISPLACEMENT - Math.max(0, desiredMinimumWidth - maximumAvailableWidth),
        // But we don't want that the moving left ends up covering the cursor, so this will push it to the right again
        Math.min(cursorPos ? getOffsetForPos(this._editorObs, cursorPos, reader) + 50 : 0, editorContentAreaWidth + horizontalScrollOffset)
      );
      const previewEditorLeftInTextArea = Math.min(editorContentMaxWidthInRange + ORIGINAL_END_PADDING, maxPreviewEditorLeft);
      const maxContentWidth = editorContentMaxWidthInRange + ORIGINAL_END_PADDING + previewContentWidth + 70;
      const dist = maxPreviewEditorLeft - previewEditorLeftInTextArea;
      let desiredPreviewEditorScrollLeft;
      let codeRight;
      if (previewEditorLeftInTextArea > horizontalScrollOffset) {
        desiredPreviewEditorScrollLeft = 0;
        codeRight = editorLayout.contentLeft + previewEditorLeftInTextArea - horizontalScrollOffset;
      } else {
        desiredPreviewEditorScrollLeft = horizontalScrollOffset - previewEditorLeftInTextArea;
        codeRight = editorLayout.contentLeft;
      }
      const selectionTop = this._originalVerticalStartPosition.read(reader) ?? this._editor.getTopForLineNumber(range.startLineNumber) - this._editorObs.scrollTop.read(reader);
      const selectionBottom = this._originalVerticalEndPosition.read(reader) ?? this._editor.getBottomForLineNumber(range.endLineNumberExclusive - 1) - this._editorObs.scrollTop.read(reader);
      const codeLeft = editorLayout.contentLeft - horizontalScrollOffset;
      let codeRect = Rect.fromLeftTopRightBottom(codeLeft, selectionTop, codeRight, selectionBottom);
      const isInsertion = codeRect.height === 0;
      if (!isInsertion) {
        codeRect = codeRect.withMargin(VERTICAL_PADDING2, HORIZONTAL_PADDING2);
      }
      const previewLineHeights = this._previewEditorObs.observeLineHeightsForLineRange(inlineEdit.modifiedLineRange).read(reader);
      const editHeight = previewLineHeights.reduce((acc, h2) => acc + h2, 0);
      const codeHeight = selectionBottom - selectionTop;
      const previewEditorHeight = Math.max(codeHeight, editHeight);
      const clipped = dist === 0;
      const codeEditDist = 0;
      const previewEditorWidth = Math.min(previewContentWidth + MODIFIED_END_PADDING, remainingWidthRightOfEditor + editorLayout.width - editorLayout.contentLeft - codeEditDist);
      let editRect = Rect.fromLeftTopWidthHeight(codeRect.right + codeEditDist, selectionTop, previewEditorWidth, previewEditorHeight);
      if (!isInsertion) {
        editRect = editRect.withMargin(VERTICAL_PADDING2, HORIZONTAL_PADDING2).translateX(HORIZONTAL_PADDING2 + BORDER_WIDTH3);
      } else {
        editRect = editRect.withMargin(VERTICAL_PADDING2, HORIZONTAL_PADDING2).translateY(VERTICAL_PADDING2);
      }
      return {
        codeRect,
        editRect,
        codeScrollLeft: horizontalScrollOffset,
        contentLeft: editorLayout.contentLeft,
        isInsertion,
        maxContentWidth,
        shouldShowShadow: clipped,
        desiredPreviewEditorScrollLeft,
        previewEditorWidth
      };
    });
    this._stickyScrollController = StickyScrollController.get(this._editorObs.editor);
    this._stickyScrollHeight = this._stickyScrollController ? observableFromEvent(this._stickyScrollController.onDidChangeStickyScrollHeight, () => this._stickyScrollController.stickyScrollWidgetHeight) : constObservable(0);
    this._shouldOverflow = derived(this, (reader) => {
      if (!ENABLE_OVERFLOW) {
        return false;
      }
      const range = this._edit.read(reader)?.originalLineRange;
      if (!range) {
        return false;
      }
      const stickyScrollHeight = this._stickyScrollHeight.read(reader);
      const top = this._editor.getTopForLineNumber(range.startLineNumber) - this._editorObs.scrollTop.read(reader);
      if (top <= stickyScrollHeight) {
        return false;
      }
      const bottom = this._editor.getTopForLineNumber(range.endLineNumberExclusive) - this._editorObs.scrollTop.read(reader);
      if (bottom >= this._editorObs.layoutInfo.read(reader).height) {
        return false;
      }
      return true;
    });
    this._originalBackgroundColor = observableFromEvent(this, this._themeService.onDidColorThemeChange, () => {
      return this._themeService.getColorTheme().getColor(originalBackgroundColor) ?? Color.transparent;
    });
    this._backgroundSvg = n.svg({
      transform: "translate(-0.5 -0.5)",
      style: { overflow: "visible", pointerEvents: "none", position: "absolute" }
    }, [
      n.svgElem("path", {
        class: "rightOfModifiedBackgroundCoverUp",
        d: derived(this, (reader) => {
          const layoutInfo = this._previewEditorLayoutInfo.read(reader);
          if (!layoutInfo) {
            return void 0;
          }
          const originalBackgroundColor2 = this._originalBackgroundColor.read(reader);
          if (originalBackgroundColor2.isTransparent()) {
            return void 0;
          }
          return new PathBuilder().moveTo(layoutInfo.codeRect.getRightTop()).lineTo(layoutInfo.codeRect.getRightTop().deltaX(1e3)).lineTo(layoutInfo.codeRect.getRightBottom().deltaX(1e3)).lineTo(layoutInfo.codeRect.getRightBottom()).build();
        }),
        style: {
          fill: asCssVariableWithDefault(editorBackground, "transparent")
        }
      })
    ]).keepUpdated(this._store);
    this._originalOverlay = n.div({
      style: { pointerEvents: "none", display: this._previewEditorLayoutInfo.map((layoutInfo) => layoutInfo?.isInsertion ? "none" : "block") }
    }, derived(this, (reader) => {
      const layoutInfoObs = mapOutFalsy(this._previewEditorLayoutInfo).read(reader);
      if (!layoutInfoObs) {
        return void 0;
      }
      const separatorWidth = separatorWidthObs.read(reader);
      const borderStyling = getOriginalBorderColor(this._tabAction).map((bc) => `${BORDER_WIDTH3}px solid ${asCssVariable(bc)}`);
      const borderStylingSeparator = `${BORDER_WIDTH3 + separatorWidth}px solid ${asCssVariable(editorBackground)}`;
      const hasBorderLeft = layoutInfoObs.read(reader).codeScrollLeft !== 0;
      const isModifiedLower = layoutInfoObs.map((layoutInfo) => layoutInfo.codeRect.bottom < layoutInfo.editRect.bottom);
      const transitionRectSize = BORDER_RADIUS3 * 2 + BORDER_WIDTH3 * 2;
      const overlayHider = layoutInfoObs.map((layoutInfo) => Rect.fromLeftTopRightBottom(layoutInfo.contentLeft - BORDER_RADIUS3 - BORDER_WIDTH3, layoutInfo.codeRect.top, layoutInfo.contentLeft, layoutInfo.codeRect.bottom + transitionRectSize)).read(reader);
      const intersectionLine = new OffsetRange(overlayHider.left, Number.MAX_SAFE_INTEGER);
      const overlayRect = layoutInfoObs.map((layoutInfo) => layoutInfo.codeRect.intersectHorizontal(intersectionLine));
      const separatorRect = overlayRect.map((overlayRect2) => overlayRect2.withMargin(separatorWidth, 0, separatorWidth, separatorWidth).intersectHorizontal(intersectionLine));
      const transitionRect = overlayRect.map((overlayRect2) => Rect.fromLeftTopWidthHeight(overlayRect2.right - transitionRectSize + BORDER_WIDTH3, overlayRect2.bottom - BORDER_WIDTH3, transitionRectSize, transitionRectSize).intersectHorizontal(intersectionLine));
      return [
        n.div({
          class: "originalSeparatorSideBySide",
          style: {
            ...separatorRect.read(reader).toStyles(),
            boxSizing: "border-box",
            borderRadius: `${BORDER_RADIUS3}px 0 0 ${BORDER_RADIUS3}px`,
            borderTop: borderStylingSeparator,
            borderBottom: borderStylingSeparator,
            borderLeft: hasBorderLeft ? "none" : borderStylingSeparator
          }
        }),
        n.div({
          class: "originalOverlaySideBySide",
          style: {
            ...overlayRect.read(reader).toStyles(),
            boxSizing: "border-box",
            borderRadius: `${BORDER_RADIUS3}px 0 0 ${BORDER_RADIUS3}px`,
            borderTop: borderStyling,
            borderBottom: borderStyling,
            borderLeft: hasBorderLeft ? "none" : borderStyling,
            backgroundColor: asCssVariable(originalBackgroundColor)
          }
        }),
        n.div({
          class: "originalCornerCutoutSideBySide",
          style: {
            pointerEvents: "none",
            display: isModifiedLower.map((isLower) => isLower ? "block" : "none"),
            ...transitionRect.read(reader).toStyles()
          }
        }, [
          n.div({
            class: "originalCornerCutoutBackground",
            style: {
              position: "absolute",
              top: "0px",
              left: "0px",
              width: "100%",
              height: "100%",
              backgroundColor: getEditorBlendedColor(originalBackgroundColor, this._themeService).map((c) => c.toString())
            }
          }),
          n.div({
            class: "originalCornerCutoutBorder",
            style: {
              position: "absolute",
              top: "0px",
              left: "0px",
              width: "100%",
              height: "100%",
              boxSizing: "border-box",
              borderTop: borderStyling,
              borderRight: borderStyling,
              borderRadius: `0 100% 0 0`,
              backgroundColor: asCssVariable(editorBackground)
            }
          })
        ]),
        n.div({
          class: "originalOverlaySideBySideHider",
          style: {
            ...overlayHider.toStyles(),
            backgroundColor: asCssVariable(editorBackground)
          }
        })
      ];
    })).keepUpdated(this._store);
    this._modifiedOverlay = n.div({
      style: { pointerEvents: "none" }
    }, derived(this, (reader) => {
      const layoutInfoObs = mapOutFalsy(this._previewEditorLayoutInfo).read(reader);
      if (!layoutInfoObs) {
        return void 0;
      }
      const isModifiedLower = layoutInfoObs.map((layoutInfo) => layoutInfo.codeRect.bottom < layoutInfo.editRect.bottom);
      const separatorWidth = separatorWidthObs.read(reader);
      const borderRadius = isModifiedLower.map((isLower) => `0 ${BORDER_RADIUS3}px ${BORDER_RADIUS3}px ${isLower ? BORDER_RADIUS3 : 0}px`);
      const borderStyling = getEditorBlendedColor(getModifiedBorderColor(this._tabAction), this._themeService).map((c) => `1px solid ${c.toString()}`);
      const borderStylingSeparator = `${BORDER_WIDTH3 + separatorWidth}px solid ${asCssVariable(editorBackground)}`;
      const overlayRect = layoutInfoObs.map((layoutInfo) => layoutInfo.editRect.withMargin(0, BORDER_WIDTH3));
      const separatorRect = overlayRect.map((overlayRect2) => overlayRect2.withMargin(separatorWidth, separatorWidth, separatorWidth, 0));
      const insertionRect = derived(this, (reader2) => {
        const overlay = overlayRect.read(reader2);
        const layoutinfo = layoutInfoObs.read(reader2);
        if (!layoutinfo.isInsertion || layoutinfo.contentLeft >= overlay.left) {
          return Rect.fromLeftTopWidthHeight(overlay.left, overlay.top, 0, 0);
        }
        return new Rect(layoutinfo.contentLeft, overlay.top, overlay.left, overlay.top + BORDER_WIDTH3 * 2);
      });
      return [
        n.div({
          class: "modifiedInsertionSideBySide",
          style: {
            ...insertionRect.read(reader).toStyles(),
            backgroundColor: getModifiedBorderColor(this._tabAction).map((c) => asCssVariable(c))
          }
        }),
        n.div({
          class: "modifiedSeparatorSideBySide",
          style: {
            ...separatorRect.read(reader).toStyles(),
            borderRadius,
            borderTop: borderStylingSeparator,
            borderBottom: borderStylingSeparator,
            borderRight: borderStylingSeparator,
            boxSizing: "border-box"
          }
        }),
        n.div({
          class: "modifiedOverlaySideBySide",
          style: {
            ...overlayRect.read(reader).toStyles(),
            borderRadius,
            border: borderStyling,
            boxSizing: "border-box",
            backgroundColor: asCssVariable(modifiedBackgroundColor)
          }
        })
      ];
    })).keepUpdated(this._store);
    this._nonOverflowView = n.div({
      class: "inline-edits-view",
      style: {
        position: "absolute",
        overflow: "visible",
        top: "0px",
        left: "0px",
        display: this._display
      }
    }, [
      this._backgroundSvg,
      derived(this, (reader) => this._shouldOverflow.read(reader) ? [] : [this._editorContainer, this._originalOverlay, this._modifiedOverlay])
    ]).keepUpdated(this._store);
    this._register(this._editorObs.createOverlayWidget({
      domNode: this._nonOverflowView.element,
      position: constObservable(null),
      allowEditorOverflow: false,
      minContentWidthInPx: derived(this, (reader) => {
        const x = this._previewEditorLayoutInfo.read(reader)?.maxContentWidth;
        if (x === void 0) {
          return 0;
        }
        return x;
      })
    }));
    this.previewEditor.setModel(this._previewTextModel);
    this._register(autorun((reader) => {
      const layoutInfo = this._previewEditorLayoutInfo.read(reader);
      if (!layoutInfo) {
        return;
      }
      const editorRect = layoutInfo.editRect.withMargin(-VERTICAL_PADDING2, -HORIZONTAL_PADDING2);
      this.previewEditor.layout({
        height: editorRect.height,
        width: layoutInfo.previewEditorWidth + 15
        /* Make sure editor does not scroll horizontally */
      });
      this._editorContainer.element.style.top = `${editorRect.top}px`;
      this._editorContainer.element.style.left = `${editorRect.left}px`;
      this._editorContainer.element.style.width = `${layoutInfo.previewEditorWidth + HORIZONTAL_PADDING2}px`;
    }));
    this._register(autorun((reader) => {
      const layoutInfo = this._previewEditorLayoutInfo.read(reader);
      if (!layoutInfo) {
        return;
      }
      this._previewEditorObs.editor.setScrollLeft(layoutInfo.desiredPreviewEditorScrollLeft);
    }));
    this._updatePreviewEditor.recomputeInitiallyAndOnChange(this._store);
  }
};
InlineEditsSideBySideView = __decorate73([
  __param73(5, IInstantiationService),
  __param73(6, IThemeService)
], InlineEditsSideBySideView);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/inlineEditsWordReplacementView.js
init_dom();
init_mouseEvent();
init_event();
init_lifecycle();
init_observable();
init_colorRegistry();
init_colorUtils();
init_point();
init_offsetRange();
init_language();
init_lineTokens();
var __decorate74 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param74 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BORDER_WIDTH4 = 1;
var _a47;
var InlineEditsWordReplacementView = (_a47 = class extends Disposable {
  constructor(_editor, _edit, _tabAction, _languageService) {
    super();
    this._editor = _editor;
    this._edit = _edit;
    this._tabAction = _tabAction;
    this._languageService = _languageService;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this._start = this._editor.observePosition(constObservable(this._edit.range.getStartPosition()), this._store);
    this._end = this._editor.observePosition(constObservable(this._edit.range.getEndPosition()), this._store);
    this._line = document.createElement("div");
    this._hoverableElement = observableValue(this, null);
    this.isHovered = this._hoverableElement.map((e, reader) => e?.didMouseMoveDuringHover.read(reader) ?? false);
    this._renderTextEffect = derived(this, (_reader) => {
      const tm = this._editor.model.get();
      const origLine = tm.getLineContent(this._edit.range.startLineNumber);
      const edit = StringReplacement.replace(new OffsetRange(this._edit.range.startColumn - 1, this._edit.range.endColumn - 1), this._edit.text);
      const lineToTokenize = edit.replace(origLine);
      const t = tm.tokenization.tokenizeLinesAt(this._edit.range.startLineNumber, [lineToTokenize])?.[0];
      let tokens;
      if (t) {
        tokens = TokenArray.fromLineTokens(t).slice(edit.getRangeAfterReplace()).toLineTokens(this._edit.text, this._languageService.languageIdCodec);
      } else {
        tokens = LineTokens.createEmpty(this._edit.text, this._languageService.languageIdCodec);
      }
      const res = renderLines(new LineSource([tokens]), RenderOptions.fromEditor(this._editor.editor).withSetWidth(false).withScrollBeyondLastColumn(0), [], this._line, true);
      this._line.style.width = `${res.minWidthInPx}px`;
    });
    const modifiedLineHeight = this._editor.observeLineHeightForPosition(this._edit.range.getStartPosition());
    this._layout = derived(this, (reader) => {
      this._renderTextEffect.read(reader);
      const widgetStart = this._start.read(reader);
      const widgetEnd = this._end.read(reader);
      if (!widgetStart || !widgetEnd || widgetStart.x > widgetEnd.x || widgetStart.y > widgetEnd.y) {
        return void 0;
      }
      const lineHeight = modifiedLineHeight.read(reader);
      const scrollLeft = this._editor.scrollLeft.read(reader);
      const w = this._editor.getOption(
        59
        /* EditorOption.fontInfo */
      ).read(reader).typicalHalfwidthCharacterWidth;
      const modifiedLeftOffset = 3 * w;
      const modifiedTopOffset = 4;
      const modifiedOffset = new Point(modifiedLeftOffset, modifiedTopOffset);
      const originalLine = Rect.fromPoints(widgetStart, widgetEnd).withHeight(lineHeight).translateX(-scrollLeft);
      const modifiedLine = Rect.fromPointSize(originalLine.getLeftBottom().add(modifiedOffset), new Point(this._edit.text.length * w, originalLine.height));
      const lowerBackground = modifiedLine.withLeft(originalLine.left);
      return {
        originalLine,
        modifiedLine,
        lowerBackground,
        lineHeight
      };
    });
    this.minEditorScrollHeight = derived(this, (reader) => {
      const layout = mapOutFalsy(this._layout).read(reader);
      if (!layout) {
        return 0;
      }
      return layout.read(reader).modifiedLine.bottom + BORDER_WIDTH4 + this._editor.editor.getScrollTop();
    });
    this._root = n.div({
      class: "word-replacement"
    }, [
      derived(this, (reader) => {
        const layout = mapOutFalsy(this._layout).read(reader);
        if (!layout) {
          return [];
        }
        const originalBorderColor = getOriginalBorderColor(this._tabAction).map((c) => asCssVariable(c)).read(reader);
        const modifiedBorderColor = getModifiedBorderColor(this._tabAction).map((c) => asCssVariable(c)).read(reader);
        return [
          n.div({
            style: {
              position: "absolute",
              ...rectToProps((r) => getEditorValidOverlayRect(this._editor).read(r)),
              overflow: "hidden",
              pointerEvents: "none"
            }
          }, [
            n.div({
              style: {
                position: "absolute",
                ...rectToProps((reader2) => layout.read(reader2).lowerBackground.withMargin(BORDER_WIDTH4, 2 * BORDER_WIDTH4, BORDER_WIDTH4, 0)),
                background: asCssVariable(editorBackground),
                //boxShadow: `${asCssVariable(scrollbarShadow)} 0 6px 6px -6px`,
                cursor: "pointer",
                pointerEvents: "auto"
              },
              onmousedown: (e) => {
                e.preventDefault();
              },
              onmouseup: (e) => this._onDidClick.fire(new StandardMouseEvent(getWindow(e), e)),
              obsRef: (elem) => {
                this._hoverableElement.set(elem, void 0);
              }
            }),
            n.div({
              style: {
                position: "absolute",
                ...rectToProps((reader2) => layout.read(reader2).modifiedLine.withMargin(BORDER_WIDTH4, 2 * BORDER_WIDTH4)),
                fontFamily: this._editor.getOption(
                  58
                  /* EditorOption.fontFamily */
                ),
                fontSize: this._editor.getOption(
                  61
                  /* EditorOption.fontSize */
                ),
                fontWeight: this._editor.getOption(
                  62
                  /* EditorOption.fontWeight */
                ),
                pointerEvents: "none",
                boxSizing: "border-box",
                borderRadius: "4px",
                border: `${BORDER_WIDTH4}px solid ${modifiedBorderColor}`,
                background: asCssVariable(modifiedChangedTextOverlayColor),
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                outline: `2px solid ${asCssVariable(editorBackground)}`
              }
            }, [this._line]),
            n.div({
              style: {
                position: "absolute",
                ...rectToProps((reader2) => layout.read(reader2).originalLine.withMargin(BORDER_WIDTH4)),
                boxSizing: "border-box",
                borderRadius: "4px",
                border: `${BORDER_WIDTH4}px solid ${originalBorderColor}`,
                background: asCssVariable(originalChangedTextOverlayColor),
                pointerEvents: "none"
              }
            }, []),
            n.svg({
              width: 11,
              height: 14,
              viewBox: "0 0 11 14",
              fill: "none",
              style: {
                position: "absolute",
                left: layout.map((l) => l.modifiedLine.left - 16),
                top: layout.map((l) => l.modifiedLine.top + Math.round((l.lineHeight - 14 - 5) / 2))
              }
            }, [
              n.svgElem("path", {
                d: "M1 0C1 2.98966 1 5.92087 1 8.49952C1 9.60409 1.89543 10.5 3 10.5H10.5",
                stroke: asCssVariable(editorHoverForeground)
              }),
              n.svgElem("path", {
                d: "M6 7.5L9.99999 10.49998L6 13.5",
                stroke: asCssVariable(editorHoverForeground)
              })
            ])
          ])
        ];
      })
    ]).keepUpdated(this._store);
    this._register(this._editor.createOverlayWidget({
      domNode: this._root.element,
      minContentWidthInPx: constObservable(0),
      position: constObservable({ preference: { top: 0, left: 0 } }),
      allowEditorOverflow: false
    }));
  }
}, _a47.MAX_LENGTH = 100, _a47);
InlineEditsWordReplacementView = __decorate74([
  __param74(3, ILanguageService)
], InlineEditsWordReplacementView);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViews/originalEditorInlineDiffView.js
init_event();
init_lifecycle();
init_observable();
init_observableCodeEditor();
init_offsetRange();
init_range();
init_model2();
init_textModel();
var OriginalEditorInlineDiffView = class extends Disposable {
  constructor(_originalEditor, _state, _modifiedTextModel) {
    super();
    this._originalEditor = _originalEditor;
    this._state = _state;
    this._modifiedTextModel = _modifiedTextModel;
    this._onDidClick = this._register(new Emitter());
    this.onDidClick = this._onDidClick.event;
    this.isHovered = observableCodeEditor(this._originalEditor).isTargetHovered((p) => p.target.type === 6 && p.target.detail.injectedText?.options.attachedData instanceof InlineEditAttachedData && p.target.detail.injectedText.options.attachedData.owner === this, this._store);
    this._tokenizationFinished = modelTokenizationFinished(this._modifiedTextModel);
    this._decorations = derived(this, (reader) => {
      const diff = this._state.read(reader);
      if (!diff) {
        return void 0;
      }
      const modified = diff.modifiedText;
      const showInline = diff.mode === "insertionInline";
      const hasOneInnerChange = diff.diff.length === 1 && diff.diff[0].innerChanges?.length === 1;
      const showEmptyDecorations = true;
      const originalDecorations = [];
      const modifiedDecorations = [];
      const diffLineAddDecorationBackground = ModelDecorationOptions.register({
        className: "inlineCompletions-line-insert",
        description: "line-insert",
        isWholeLine: true,
        marginClassName: "gutter-insert"
      });
      const diffLineDeleteDecorationBackground = ModelDecorationOptions.register({
        className: "inlineCompletions-line-delete",
        description: "line-delete",
        isWholeLine: true,
        marginClassName: "gutter-delete"
      });
      const diffWholeLineDeleteDecoration = ModelDecorationOptions.register({
        className: "inlineCompletions-char-delete",
        description: "char-delete",
        isWholeLine: false,
        zIndex: 1
        // be on top of diff background decoration
      });
      const diffWholeLineAddDecoration = ModelDecorationOptions.register({
        className: "inlineCompletions-char-insert",
        description: "char-insert",
        isWholeLine: true
      });
      const diffAddDecoration = ModelDecorationOptions.register({
        className: "inlineCompletions-char-insert",
        description: "char-insert",
        shouldFillLineOnLineBreak: true
      });
      const diffAddDecorationEmpty = ModelDecorationOptions.register({
        className: "inlineCompletions-char-insert diff-range-empty",
        description: "char-insert diff-range-empty"
      });
      const NESOriginalBackground = ModelDecorationOptions.register({
        className: "inlineCompletions-original-lines",
        description: "inlineCompletions-original-lines",
        isWholeLine: false,
        shouldFillLineOnLineBreak: true
      });
      const showFullLineDecorations = diff.mode !== "sideBySide" && diff.mode !== "deletion" && diff.mode !== "insertionInline" && diff.mode !== "lineReplacement";
      const hideEmptyInnerDecorations = diff.mode === "lineReplacement";
      for (const m of diff.diff) {
        if (showFullLineDecorations) {
          if (!m.original.isEmpty) {
            originalDecorations.push({
              range: m.original.toInclusiveRange(),
              options: diffLineDeleteDecorationBackground
            });
          }
          if (!m.modified.isEmpty) {
            modifiedDecorations.push({
              range: m.modified.toInclusiveRange(),
              options: diffLineAddDecorationBackground
            });
          }
        }
        if (m.modified.isEmpty || m.original.isEmpty) {
          if (!m.original.isEmpty) {
            originalDecorations.push({ range: m.original.toInclusiveRange(), options: diffWholeLineDeleteDecoration });
          }
          if (!m.modified.isEmpty) {
            modifiedDecorations.push({ range: m.modified.toInclusiveRange(), options: diffWholeLineAddDecoration });
          }
        } else {
          const useInlineDiff = showInline && allowsTrueInlineDiffRendering(m);
          for (const i2 of m.innerChanges || []) {
            if (m.original.contains(i2.originalRange.startLineNumber) && !(hideEmptyInnerDecorations && i2.originalRange.isEmpty())) {
              const replacedText = this._originalEditor.getModel()?.getValueInRange(
                i2.originalRange,
                1
                /* EndOfLinePreference.LF */
              );
              originalDecorations.push({
                range: i2.originalRange,
                options: {
                  description: "char-delete",
                  shouldFillLineOnLineBreak: false,
                  className: classNames("inlineCompletions-char-delete", i2.originalRange.isSingleLine() && diff.mode === "insertionInline" && "single-line-inline", i2.originalRange.isEmpty() && "empty", (i2.originalRange.isEmpty() && hasOneInnerChange || diff.mode === "deletion" && replacedText === "\n") && showEmptyDecorations && !useInlineDiff && "diff-range-empty"),
                  inlineClassName: useInlineDiff ? classNames("strike-through", "inlineCompletions") : null,
                  zIndex: 1
                }
              });
            }
            if (m.modified.contains(i2.modifiedRange.startLineNumber)) {
              modifiedDecorations.push({
                range: i2.modifiedRange,
                options: i2.modifiedRange.isEmpty() && showEmptyDecorations && !useInlineDiff && hasOneInnerChange ? diffAddDecorationEmpty : diffAddDecoration
              });
            }
            if (useInlineDiff) {
              const insertedText = modified.getValueOfRange(i2.modifiedRange);
              const textSegments = insertedText.length > 3 ? [
                { text: insertedText.slice(0, 1), extraClasses: ["start"], offsetRange: new OffsetRange(i2.modifiedRange.startColumn - 1, i2.modifiedRange.startColumn) },
                { text: insertedText.slice(1, -1), extraClasses: [], offsetRange: new OffsetRange(i2.modifiedRange.startColumn, i2.modifiedRange.endColumn - 2) },
                { text: insertedText.slice(-1), extraClasses: ["end"], offsetRange: new OffsetRange(i2.modifiedRange.endColumn - 2, i2.modifiedRange.endColumn - 1) }
              ] : [
                { text: insertedText, extraClasses: ["start", "end"], offsetRange: new OffsetRange(i2.modifiedRange.startColumn - 1, i2.modifiedRange.endColumn) }
              ];
              this._tokenizationFinished.read(reader);
              const lineTokens = this._modifiedTextModel.tokenization.getLineTokens(i2.modifiedRange.startLineNumber);
              for (const { text, extraClasses, offsetRange } of textSegments) {
                originalDecorations.push({
                  range: Range.fromPositions(i2.originalRange.getEndPosition()),
                  options: {
                    description: "inserted-text",
                    before: {
                      tokens: lineTokens.getTokensInRange(offsetRange),
                      content: text,
                      inlineClassName: classNames(
                        "inlineCompletions-char-insert",
                        i2.modifiedRange.isSingleLine() && diff.mode === "insertionInline" && "single-line-inline",
                        ...extraClasses
                        // include extraClasses for additional styling if provided
                      ),
                      cursorStops: InjectedTextCursorStops.None,
                      attachedData: new InlineEditAttachedData(this)
                    },
                    zIndex: 2,
                    showIfCollapsed: true
                  }
                });
              }
            }
          }
        }
      }
      if (diff.isInDiffEditor) {
        for (const m of diff.diff) {
          if (!m.original.isEmpty) {
            originalDecorations.push({
              range: m.original.toExclusiveRange(),
              options: NESOriginalBackground
            });
          }
        }
      }
      return { originalDecorations, modifiedDecorations };
    });
    this._register(observableCodeEditor(this._originalEditor).setDecorations(this._decorations.map((d) => d?.originalDecorations ?? [])));
    const modifiedCodeEditor = this._state.map((s) => s?.modifiedCodeEditor);
    this._register(autorunWithStore((reader, store) => {
      const e = modifiedCodeEditor.read(reader);
      if (e) {
        store.add(observableCodeEditor(e).setDecorations(this._decorations.map((d) => d?.modifiedDecorations ?? [])));
      }
    }));
    this._register(this._originalEditor.onMouseUp((e) => {
      if (e.target.type !== 6) {
        return;
      }
      const a = e.target.detail.injectedText?.options.attachedData;
      if (a instanceof InlineEditAttachedData && a.owner === this) {
        this._onDidClick.fire(e.event);
      }
    }));
  }
};
var InlineEditAttachedData = class {
  constructor(owner) {
    this.owner = owner;
  }
};
function allowsTrueInlineDiffRendering(mapping) {
  if (!mapping.innerChanges) {
    return false;
  }
  return mapping.innerChanges.every((c) => rangeIsSingleLine(c.modifiedRange) && rangeIsSingleLine(c.originalRange));
}
var i = 0;
function modelTokenizationFinished(model) {
  return observableFromEvent(model.onDidChangeTokens, () => i++);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsView.js
init_dom();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/view.css";
var __decorate75 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param75 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineEditsView_1;
var InlineEditsView = InlineEditsView_1 = class InlineEditsView2 extends Disposable {
  constructor(_editor, _host, _model, _ghostTextIndicator, _focusIsInMenu, _instantiationService) {
    super();
    this._editor = _editor;
    this._host = _host;
    this._model = _model;
    this._ghostTextIndicator = _ghostTextIndicator;
    this._focusIsInMenu = _focusIsInMenu;
    this._instantiationService = _instantiationService;
    this._editorObs = observableCodeEditor(this._editor);
    this._tabAction = derived((reader) => this._model.read(reader)?.tabAction.read(reader) ?? InlineEditTabAction.Inactive);
    this._constructorDone = observableValue(this, false);
    this._uiState = derived(this, (reader) => {
      const model = this._model.read(reader);
      if (!model || !this._constructorDone.read(reader)) {
        return void 0;
      }
      const inlineEdit = model.inlineEdit;
      let mappings = RangeMapping.fromEdit(inlineEdit.edit);
      let newText = inlineEdit.edit.apply(inlineEdit.originalText);
      let diff = lineRangeMappingFromRangeMappings(mappings, inlineEdit.originalText, new StringText(newText));
      let state = this.determineRenderState(model, reader, diff, new StringText(newText));
      if (!state) {
        model.abort(`unable to determine view: tried to render ${this._previousView?.view}`);
        return void 0;
      }
      if (state.kind === InlineCompletionViewKind.SideBySide) {
        const indentationAdjustmentEdit = createReindentEdit(newText, inlineEdit.modifiedLineRange, textModel.getOptions().tabSize);
        newText = indentationAdjustmentEdit.applyToString(newText);
        mappings = applyEditToModifiedRangeMappings(mappings, indentationAdjustmentEdit);
        diff = lineRangeMappingFromRangeMappings(mappings, inlineEdit.originalText, new StringText(newText));
      }
      this._previewTextModel.setLanguage(this._editor.getModel().getLanguageId());
      const previousNewText = this._previewTextModel.getValue();
      if (previousNewText !== newText) {
        this._previewTextModel.setValue(newText);
      }
      if (model.showCollapsed.read(reader) && !this._indicator.read(reader)?.isHoverVisible.read(reader)) {
        state = { kind: InlineCompletionViewKind.Collapsed, viewData: state.viewData };
      }
      model.handleInlineEditShown(state.kind, state.viewData);
      return {
        state,
        diff,
        edit: inlineEdit,
        newText,
        newTextLineCount: inlineEdit.modifiedLineRange.length,
        isInDiffEditor: model.isInDiffEditor
      };
    });
    this._previewTextModel = this._register(this._instantiationService.createInstance(TextModel, "", this._editor.getModel().getLanguageId(), { ...TextModel.DEFAULT_CREATION_OPTIONS, bracketPairColorizationOptions: { enabled: true, independentColorPoolPerBracketType: false } }, null));
    this._indicatorCyclicDependencyCircuitBreaker = observableValue(this, false);
    this._indicator = derived(this, (reader) => {
      if (!this._indicatorCyclicDependencyCircuitBreaker.read(reader)) {
        return void 0;
      }
      const indicatorDisplayRange = derivedOpts({ owner: this, equalsFn: equalsIfDefined(itemEquals()) }, (reader2) => {
        const ghostTextIndicator = this._ghostTextIndicator.read(reader2);
        if (ghostTextIndicator) {
          return ghostTextIndicator.lineRange;
        }
        const state = this._uiState.read(reader2);
        if (!state) {
          return void 0;
        }
        if (state.state?.kind === "custom") {
          const range = state.state.displayLocation?.range;
          if (!range) {
            throw new BugIndicatingError("custom view should have a range");
          }
          return new LineRange(range.startLineNumber, range.endLineNumber);
        }
        if (state.state?.kind === "insertionMultiLine") {
          return this._insertion.originalLines.read(reader2);
        }
        return state.edit.displayRange;
      });
      const modelWithGhostTextSupport = derived(this, (reader2) => {
        const model = this._model.read(reader2);
        if (model) {
          return model;
        }
        const ghostTextIndicator = this._ghostTextIndicator.read(reader2);
        if (ghostTextIndicator) {
          return ghostTextIndicator.model;
        }
        return model;
      });
      return reader.store.add(this._instantiationService.createInstance(InlineEditsGutterIndicator, this._editorObs, indicatorDisplayRange, this._gutterIndicatorOffset, modelWithGhostTextSupport, this._inlineEditsIsHovered, this._focusIsInMenu));
    });
    this._inlineEditsIsHovered = derived(this, (reader) => {
      return this._sideBySide.isHovered.read(reader) || this._wordReplacementViews.read(reader).some((v) => v.isHovered.read(reader)) || this._deletion.isHovered.read(reader) || this._inlineDiffView.isHovered.read(reader) || this._lineReplacementView.isHovered.read(reader) || this._insertion.isHovered.read(reader) || this._customView.isHovered.read(reader);
    });
    this._gutterIndicatorOffset = derived(this, (reader) => {
      if (this._uiState.read(reader)?.state?.kind === "insertionMultiLine") {
        return this._insertion.startLineOffset.read(reader);
      }
      const ghostTextIndicator = this._ghostTextIndicator.read(reader);
      if (ghostTextIndicator) {
        return getGhostTextTopOffset(ghostTextIndicator, this._editor);
      }
      return 0;
    });
    this._sideBySide = this._register(this._instantiationService.createInstance(InlineEditsSideBySideView, this._editor, this._model.map((m) => m?.inlineEdit), this._previewTextModel, this._uiState.map((s) => s && s.state?.kind === InlineCompletionViewKind.SideBySide ? {
      newTextLineCount: s.newTextLineCount,
      isInDiffEditor: s.isInDiffEditor
    } : void 0), this._tabAction));
    this._deletion = this._register(this._instantiationService.createInstance(InlineEditsDeletionView, this._editor, this._model.map((m) => m?.inlineEdit), this._uiState.map((s) => s && s.state?.kind === InlineCompletionViewKind.Deletion ? {
      originalRange: s.state.originalRange,
      deletions: s.state.deletions,
      inDiffEditor: s.isInDiffEditor
    } : void 0), this._tabAction));
    this._insertion = this._register(this._instantiationService.createInstance(InlineEditsInsertionView, this._editor, this._uiState.map((s) => s && s.state?.kind === InlineCompletionViewKind.InsertionMultiLine ? {
      lineNumber: s.state.lineNumber,
      startColumn: s.state.column,
      text: s.state.text,
      inDiffEditor: s.isInDiffEditor
    } : void 0), this._tabAction));
    this._inlineDiffViewState = derived(this, (reader) => {
      const e = this._uiState.read(reader);
      if (!e || !e.state) {
        return void 0;
      }
      if (e.state.kind === "wordReplacements" || e.state.kind === "insertionMultiLine" || e.state.kind === "collapsed" || e.state.kind === "custom") {
        return void 0;
      }
      return {
        modifiedText: new StringText(e.newText),
        diff: e.diff,
        mode: e.state.kind,
        modifiedCodeEditor: this._sideBySide.previewEditor,
        isInDiffEditor: e.isInDiffEditor
      };
    });
    this._inlineCollapsedView = this._register(this._instantiationService.createInstance(InlineEditsCollapsedView, this._editor, this._model.map((m, reader) => this._uiState.read(reader)?.state?.kind === "collapsed" ? m?.inlineEdit : void 0)));
    this._customView = this._register(this._instantiationService.createInstance(InlineEditsCustomView, this._editor, this._model.map((m, reader) => this._uiState.read(reader)?.state?.kind === "custom" ? m?.displayLocation : void 0), this._tabAction));
    this._inlineDiffView = this._register(new OriginalEditorInlineDiffView(this._editor, this._inlineDiffViewState, this._previewTextModel));
    this._wordReplacementViews = mapObservableArrayCached(this, this._uiState.map((s) => s?.state?.kind === "wordReplacements" ? s.state.replacements : []), (e, store) => {
      return store.add(this._instantiationService.createInstance(InlineEditsWordReplacementView, this._editorObs, e, this._tabAction));
    });
    this._lineReplacementView = this._register(this._instantiationService.createInstance(InlineEditsLineReplacementView, this._editorObs, this._uiState.map((s) => s?.state?.kind === InlineCompletionViewKind.LineReplacement ? {
      originalRange: s.state.originalRange,
      modifiedRange: s.state.modifiedRange,
      modifiedLines: s.state.modifiedLines,
      replacements: s.state.replacements
    } : void 0), this._uiState.map((s) => s?.isInDiffEditor ?? false), this._tabAction));
    this._useCodeShifting = this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).map((s) => s.edits.allowCodeShifting);
    this._renderSideBySide = this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).map((s) => s.edits.renderSideBySide);
    this._register(autorunWithStore((reader, store) => {
      const model = this._model.read(reader);
      if (!model) {
        return;
      }
      store.add(Event.any(this._sideBySide.onDidClick, this._deletion.onDidClick, this._lineReplacementView.onDidClick, this._insertion.onDidClick, ...this._wordReplacementViews.read(reader).map((w) => w.onDidClick), this._inlineDiffView.onDidClick, this._customView.onDidClick)((e) => {
        if (this._viewHasBeenShownLongerThan(350)) {
          e.preventDefault();
          model.accept();
        }
      }));
    }));
    this._indicator.recomputeInitiallyAndOnChange(this._store);
    this._wordReplacementViews.recomputeInitiallyAndOnChange(this._store);
    this._indicatorCyclicDependencyCircuitBreaker.set(true, void 0);
    this._register(this._instantiationService.createInstance(InlineEditsOnboardingExperience, this._host, this._model, this._indicator, this._inlineCollapsedView));
    const minEditorScrollHeight = derived(this, (reader) => {
      return Math.max(...this._wordReplacementViews.read(reader).map((v) => v.minEditorScrollHeight.read(reader)), this._lineReplacementView.minEditorScrollHeight.read(reader), this._customView.minEditorScrollHeight.read(reader));
    }).recomputeInitiallyAndOnChange(this._store);
    const textModel = this._editor.getModel();
    let viewZoneId;
    this._register(autorun((reader) => {
      const minScrollHeight = minEditorScrollHeight.read(reader);
      this._editor.changeViewZones((accessor) => {
        const scrollHeight = this._editor.getScrollHeight();
        const viewZoneHeight = minScrollHeight - scrollHeight + 1;
        if (viewZoneHeight !== 0 && viewZoneId) {
          accessor.removeZone(viewZoneId);
          viewZoneId = void 0;
        }
        if (viewZoneHeight <= 0) {
          return;
        }
        viewZoneId = accessor.addZone({
          afterLineNumber: textModel.getLineCount(),
          heightInPx: viewZoneHeight,
          domNode: $("div.minScrollHeightViewZone")
        });
      });
    }));
    this._constructorDone.set(true, void 0);
  }
  getCacheId(model) {
    return model.inlineEdit.inlineCompletion.identity.id;
  }
  determineView(model, reader, diff, newText) {
    const inlineEdit = model.inlineEdit;
    const canUseCache = this._previousView?.id === this.getCacheId(model);
    const reconsiderViewEditorWidthChange = this._previousView?.editorWidth !== this._editorObs.layoutInfoWidth.read(reader) && (this._previousView?.view === InlineCompletionViewKind.SideBySide || this._previousView?.view === InlineCompletionViewKind.LineReplacement);
    if (canUseCache && !reconsiderViewEditorWidthChange) {
      return this._previousView.view;
    }
    if (model.displayLocation) {
      return InlineCompletionViewKind.Custom;
    }
    const numOriginalLines = inlineEdit.originalLineRange.length;
    const numModifiedLines = inlineEdit.modifiedLineRange.length;
    const inner = diff.flatMap((d) => d.innerChanges ?? []);
    const isSingleInnerEdit = inner.length === 1;
    if (!model.isInDiffEditor) {
      if (isSingleInnerEdit && this._useCodeShifting.read(reader) !== "never" && isSingleLineInsertion(diff)) {
        if (isSingleLineInsertionAfterPosition(diff, inlineEdit.cursorPosition)) {
          return InlineCompletionViewKind.InsertionInline;
        }
        return InlineCompletionViewKind.LineReplacement;
      }
      if (isDeletion(inner, inlineEdit, newText)) {
        return InlineCompletionViewKind.Deletion;
      }
      if (isSingleMultiLineInsertion(diff) && this._useCodeShifting.read(reader) === "always") {
        return InlineCompletionViewKind.InsertionMultiLine;
      }
      const allInnerChangesNotTooLong = inner.every((m) => TextLength.ofRange(m.originalRange).columnCount < InlineEditsWordReplacementView.MAX_LENGTH && TextLength.ofRange(m.modifiedRange).columnCount < InlineEditsWordReplacementView.MAX_LENGTH);
      if (allInnerChangesNotTooLong && isSingleInnerEdit && numOriginalLines === 1 && numModifiedLines === 1) {
        const modifiedText = inner.map((m) => newText.getValueOfRange(m.modifiedRange));
        const originalText = inner.map((m) => model.inlineEdit.originalText.getValueOfRange(m.originalRange));
        if (!modifiedText.some((v) => v.includes("	")) && !originalText.some((v) => v.includes("	"))) {
          if (!inner.some((m) => m.originalRange.isEmpty()) || !growEditsUntilWhitespace(inner.map((m) => new TextReplacement(m.originalRange, "")), inlineEdit.originalText).some((e) => e.range.isEmpty() && TextLength.ofRange(e.range).columnCount < InlineEditsWordReplacementView.MAX_LENGTH)) {
            return InlineCompletionViewKind.WordReplacements;
          }
        }
      }
    }
    if (numOriginalLines > 0 && numModifiedLines > 0) {
      if (numOriginalLines === 1 && numModifiedLines === 1 && !model.isInDiffEditor) {
        return InlineCompletionViewKind.LineReplacement;
      }
      if (this._renderSideBySide.read(reader) !== "never" && InlineEditsSideBySideView.fitsInsideViewport(this._editor, this._previewTextModel, inlineEdit, reader)) {
        return InlineCompletionViewKind.SideBySide;
      }
      return InlineCompletionViewKind.LineReplacement;
    }
    if (model.isInDiffEditor) {
      if (isDeletion(inner, inlineEdit, newText)) {
        return InlineCompletionViewKind.Deletion;
      }
      if (isSingleMultiLineInsertion(diff) && this._useCodeShifting.read(reader) === "always") {
        return InlineCompletionViewKind.InsertionMultiLine;
      }
    }
    return InlineCompletionViewKind.SideBySide;
  }
  determineRenderState(model, reader, diff, newText) {
    const inlineEdit = model.inlineEdit;
    const view = this.determineView(model, reader, diff, newText);
    this._previousView = { id: this.getCacheId(model), view, editorWidth: this._editor.getLayoutInfo().width, timestamp: Date.now() };
    const inner = diff.flatMap((d) => d.innerChanges ?? []);
    const textModel = this._editor.getModel();
    const stringChanges = inner.map((m) => ({
      originalRange: m.originalRange,
      modifiedRange: m.modifiedRange,
      original: textModel.getValueInRange(m.originalRange),
      modified: newText.getValueOfRange(m.modifiedRange)
    }));
    const cursorPosition = inlineEdit.cursorPosition;
    const startsWithEOL = stringChanges[0].modified.startsWith(textModel.getEOL());
    const viewData = {
      cursorColumnDistance: inlineEdit.edit.replacements[0].range.getStartPosition().column - cursorPosition.column,
      cursorLineDistance: inlineEdit.lineEdit.lineRange.startLineNumber - cursorPosition.lineNumber + (startsWithEOL && inlineEdit.lineEdit.lineRange.startLineNumber >= cursorPosition.lineNumber ? 1 : 0),
      lineCountOriginal: inlineEdit.lineEdit.lineRange.length,
      lineCountModified: inlineEdit.lineEdit.newLines.length,
      characterCountOriginal: stringChanges.reduce((acc, r) => acc + r.original.length, 0),
      characterCountModified: stringChanges.reduce((acc, r) => acc + r.modified.length, 0),
      disjointReplacements: stringChanges.length,
      sameShapeReplacements: stringChanges.every((r) => r.original === stringChanges[0].original && r.modified === stringChanges[0].modified)
    };
    switch (view) {
      case InlineCompletionViewKind.InsertionInline:
        return { kind: InlineCompletionViewKind.InsertionInline, viewData };
      case InlineCompletionViewKind.SideBySide:
        return { kind: InlineCompletionViewKind.SideBySide, viewData };
      case InlineCompletionViewKind.Collapsed:
        return { kind: InlineCompletionViewKind.Collapsed, viewData };
      case InlineCompletionViewKind.Custom:
        return { kind: InlineCompletionViewKind.Custom, displayLocation: model.displayLocation, viewData };
    }
    if (view === InlineCompletionViewKind.Deletion) {
      return {
        kind: InlineCompletionViewKind.Deletion,
        originalRange: inlineEdit.originalLineRange,
        deletions: inner.map((m) => m.originalRange),
        viewData
      };
    }
    if (view === InlineCompletionViewKind.InsertionMultiLine) {
      const change = inner[0];
      return {
        kind: InlineCompletionViewKind.InsertionMultiLine,
        lineNumber: change.originalRange.startLineNumber,
        column: change.originalRange.startColumn,
        text: newText.getValueOfRange(change.modifiedRange),
        viewData
      };
    }
    const replacements = stringChanges.map((m) => new TextReplacement(m.originalRange, m.modified));
    if (replacements.length === 0) {
      return void 0;
    }
    if (view === InlineCompletionViewKind.WordReplacements) {
      let grownEdits = growEditsToEntireWord(replacements, inlineEdit.originalText);
      if (grownEdits.some((e) => e.range.isEmpty())) {
        grownEdits = growEditsUntilWhitespace(replacements, inlineEdit.originalText);
      }
      return {
        kind: InlineCompletionViewKind.WordReplacements,
        replacements: grownEdits,
        viewData
      };
    }
    if (view === InlineCompletionViewKind.LineReplacement) {
      return {
        kind: InlineCompletionViewKind.LineReplacement,
        originalRange: inlineEdit.originalLineRange,
        modifiedRange: inlineEdit.modifiedLineRange,
        modifiedLines: inlineEdit.modifiedLineRange.mapToLineArray((line) => newText.getLineAt(line)),
        replacements: inner.map((m) => ({ originalRange: m.originalRange, modifiedRange: m.modifiedRange })),
        viewData
      };
    }
    return void 0;
  }
  _viewHasBeenShownLongerThan(durationMs) {
    const viewCreationTime = this._previousView?.timestamp;
    if (!viewCreationTime) {
      throw new BugIndicatingError("viewHasBeenShownLongThan called before a view has been shown");
    }
    const currentTime = Date.now();
    return currentTime - viewCreationTime >= durationMs;
  }
};
InlineEditsView = InlineEditsView_1 = __decorate75([
  __param75(5, IInstantiationService)
], InlineEditsView);
function isSingleLineInsertion(diff) {
  return diff.every((m) => m.innerChanges.every((r) => isWordInsertion(r)));
  function isWordInsertion(r) {
    if (!r.originalRange.isEmpty()) {
      return false;
    }
    const isInsertionWithinLine = r.modifiedRange.startLineNumber === r.modifiedRange.endLineNumber;
    if (!isInsertionWithinLine) {
      return false;
    }
    return true;
  }
}
function isSingleLineInsertionAfterPosition(diff, position) {
  if (!position) {
    return false;
  }
  if (!isSingleLineInsertion(diff)) {
    return false;
  }
  const pos = position;
  return diff.every((m) => m.innerChanges.every((r) => isStableWordInsertion(r)));
  function isStableWordInsertion(r) {
    const insertPosition = r.originalRange.getStartPosition();
    if (pos.isBeforeOrEqual(insertPosition)) {
      return true;
    }
    if (insertPosition.lineNumber < pos.lineNumber) {
      return true;
    }
    return false;
  }
}
function isSingleMultiLineInsertion(diff) {
  const inner = diff.flatMap((d) => d.innerChanges ?? []);
  if (inner.length !== 1) {
    return false;
  }
  const change = inner[0];
  if (!change.originalRange.isEmpty()) {
    return false;
  }
  if (change.modifiedRange.startLineNumber === change.modifiedRange.endLineNumber) {
    return false;
  }
  return true;
}
function isDeletion(inner, inlineEdit, newText) {
  const innerValues = inner.map((m) => ({ original: inlineEdit.originalText.getValueOfRange(m.originalRange), modified: newText.getValueOfRange(m.modifiedRange) }));
  return innerValues.every(({ original, modified }) => modified.trim() === "" && original.length > 0 && (original.length > modified.length || original.trim() !== ""));
}
function growEditsToEntireWord(replacements, originalText) {
  return _growEdits(replacements, originalText, (char) => /^[a-zA-Z]$/.test(char));
}
function growEditsUntilWhitespace(replacements, originalText) {
  return _growEdits(replacements, originalText, (char) => !/^\s$/.test(char));
}
function _growEdits(replacements, originalText, fn) {
  const result = [];
  replacements.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
  for (const edit of replacements) {
    let startIndex = edit.range.startColumn - 1;
    let endIndex = edit.range.endColumn - 2;
    let prefix = "";
    let suffix = "";
    const startLineContent = originalText.getLineAt(edit.range.startLineNumber);
    const endLineContent = originalText.getLineAt(edit.range.endLineNumber);
    if (isIncluded(startLineContent[startIndex])) {
      while (isIncluded(startLineContent[startIndex - 1])) {
        prefix = startLineContent[startIndex - 1] + prefix;
        startIndex--;
      }
    }
    if (isIncluded(endLineContent[endIndex]) || endIndex < startIndex) {
      while (isIncluded(endLineContent[endIndex + 1])) {
        suffix += endLineContent[endIndex + 1];
        endIndex++;
      }
    }
    let newEdit = new TextReplacement(new Range(edit.range.startLineNumber, startIndex + 1, edit.range.endLineNumber, endIndex + 2), prefix + edit.text + suffix);
    if (result.length > 0 && Range.areIntersectingOrTouching(result[result.length - 1].range, newEdit.range)) {
      newEdit = TextReplacement.joinReplacements([result.pop(), newEdit], originalText);
    }
    result.push(newEdit);
  }
  function isIncluded(c) {
    if (c === void 0) {
      return false;
    }
    return fn(c);
  }
  return result;
}
function getGhostTextTopOffset(ghostTextIndicator, editor2) {
  const replacements = ghostTextIndicator.model.inlineEdit.edit.replacements;
  if (replacements.length !== 1) {
    return 0;
  }
  const textModel = editor2.getModel();
  if (!textModel) {
    return 0;
  }
  const EOL = textModel.getEOL();
  const replacement = replacements[0];
  if (replacement.range.isEmpty() && replacement.text.startsWith(EOL)) {
    const lineHeight = editor2.getLineHeightForPosition(replacement.range.getStartPosition());
    return countPrefixRepeats(replacement.text, EOL) * lineHeight;
  }
  return 0;
}
function countPrefixRepeats(str, prefix) {
  if (!prefix.length) {
    return 0;
  }
  let count = 0;
  let i2 = 0;
  while (str.startsWith(prefix, i2)) {
    count++;
    i2 += prefix.length;
  }
  return count;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineEdits/inlineEditsViewProducer.js
var __decorate76 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param76 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineEditsViewAndDiffProducer_1;
var _a48;
var InlineEditsViewAndDiffProducer = (_a48 = class extends Disposable {
  constructor(_editor, _edit, _model, _focusIsInMenu, instantiationService) {
    super();
    this._editor = _editor;
    this._edit = _edit;
    this._model = _model;
    this._focusIsInMenu = _focusIsInMenu;
    this._inlineEdit = derived(this, (reader) => {
      const model = this._model.read(reader);
      if (!model) {
        return void 0;
      }
      const inlineEdit = this._edit.read(reader);
      if (!inlineEdit) {
        return void 0;
      }
      const textModel = this._editor.getModel();
      if (!textModel) {
        return void 0;
      }
      const editOffset = model.inlineEditState.read(void 0)?.inlineCompletion.updatedEdit;
      if (!editOffset) {
        return void 0;
      }
      const edits = editOffset.replacements.map((e) => {
        const innerEditRange = Range.fromPositions(textModel.getPositionAt(e.replaceRange.start), textModel.getPositionAt(e.replaceRange.endExclusive));
        return new TextReplacement(innerEditRange, e.newText);
      });
      const diffEdits = new TextEdit(edits);
      const text = new TextModelText(textModel);
      return new InlineEditWithChanges(text, diffEdits, model.primaryPosition.read(void 0), inlineEdit.commands, inlineEdit.inlineCompletion);
    });
    this._inlineEditModel = derived(this, (reader) => {
      const model = this._model.read(reader);
      if (!model) {
        return void 0;
      }
      const edit = this._inlineEdit.read(reader);
      if (!edit) {
        return void 0;
      }
      const tabAction = derived(this, (reader2) => {
        if (this._editorObs.isFocused.read(reader2)) {
          if (model.tabShouldJumpToInlineEdit.read(reader2)) {
            return InlineEditTabAction.Jump;
          }
          if (model.tabShouldAcceptInlineEdit.read(reader2)) {
            return InlineEditTabAction.Accept;
          }
        }
        return InlineEditTabAction.Inactive;
      });
      return new InlineEditModel(model, edit, tabAction);
    });
    this._inlineEditHost = derived(this, (reader) => {
      const model = this._model.read(reader);
      if (!model) {
        return void 0;
      }
      return new InlineEditHost(model);
    });
    this._ghostTextIndicator = derived(this, (reader) => {
      const model = this._model.read(reader);
      if (!model) {
        return void 0;
      }
      const state = model.inlineCompletionState.read(reader);
      if (!state) {
        return void 0;
      }
      const inlineCompletion = state.inlineCompletion;
      if (!inlineCompletion) {
        return void 0;
      }
      if (!inlineCompletion.showInlineEditMenu) {
        return void 0;
      }
      const lineRange = LineRange.ofLength(state.primaryGhostText.lineNumber, 1);
      return new GhostTextIndicator(this._editor, model, lineRange, inlineCompletion);
    });
    this._editorObs = observableCodeEditor(this._editor);
    this._register(instantiationService.createInstance(InlineEditsView, this._editor, this._inlineEditHost, this._inlineEditModel, this._ghostTextIndicator, this._focusIsInMenu));
  }
}, InlineEditsViewAndDiffProducer_1 = _a48, _a48.hot = createHotClass(InlineEditsViewAndDiffProducer_1), _a48);
InlineEditsViewAndDiffProducer = InlineEditsViewAndDiffProducer_1 = __decorate76([
  __param76(4, IInstantiationService)
], InlineEditsViewAndDiffProducer);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/view/inlineCompletionsView.js
var __decorate77 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param77 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsView = class InlineCompletionsView2 extends Disposable {
  constructor(_editor, _model, _focusIsInMenu, _instantiationService) {
    super();
    this._editor = _editor;
    this._model = _model;
    this._focusIsInMenu = _focusIsInMenu;
    this._instantiationService = _instantiationService;
    this._ghostTexts = derived(this, (reader) => {
      const model = this._model.read(reader);
      return model?.ghostTexts.read(reader) ?? [];
    });
    this._stablizedGhostTexts = convertItemsToStableObservables(this._ghostTexts, this._store);
    this._editorObs = observableCodeEditor(this._editor);
    this._ghostTextWidgets = mapObservableArrayCached(this, this._stablizedGhostTexts, (ghostText, store) => derivedDisposable((reader) => this._instantiationService.createInstance(GhostTextView.hot.read(reader), this._editor, {
      ghostText,
      warning: this._model.map((m, reader2) => {
        const warning = m?.warning?.read(reader2);
        return warning ? { icon: warning.icon } : void 0;
      }),
      minReservedLineCount: constObservable(0),
      targetTextModel: this._model.map((v) => v?.textModel),
      handleInlineCompletionShown: this._model.map((model, reader2) => {
        const inlineCompletion = model?.inlineCompletionState.read(reader2)?.inlineCompletion;
        if (inlineCompletion) {
          return (viewData) => model.handleInlineSuggestionShown(inlineCompletion, InlineCompletionViewKind.GhostText, viewData);
        }
        return () => {
        };
      })
    }, this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).map((v) => ({ syntaxHighlightingEnabled: v.syntaxHighlightingEnabled })), false, false)).recomputeInitiallyAndOnChange(store)).recomputeInitiallyAndOnChange(this._store);
    this._inlineEdit = derived(this, (reader) => this._model.read(reader)?.inlineEditState.read(reader)?.inlineEdit);
    this._everHadInlineEdit = derivedObservableWithCache(this, (reader, last) => last || !!this._inlineEdit.read(reader) || !!this._model.read(reader)?.inlineCompletionState.read(reader)?.inlineCompletion?.showInlineEditMenu);
    this._inlineEditWidget = derivedDisposable((reader) => {
      if (!this._everHadInlineEdit.read(reader)) {
        return void 0;
      }
      return this._instantiationService.createInstance(InlineEditsViewAndDiffProducer.hot.read(reader), this._editor, this._inlineEdit, this._model, this._focusIsInMenu);
    }).recomputeInitiallyAndOnChange(this._store);
    this._fontFamily = this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).map((val) => val.fontFamily);
    this._register(createStyleSheetFromObservable(derived((reader) => {
      const fontFamily = this._fontFamily.read(reader);
      return `
.monaco-editor .ghost-text-decoration,
.monaco-editor .ghost-text-decoration-preview,
.monaco-editor .ghost-text {
	font-family: ${fontFamily};
}`;
    })));
    this._register(new InlineCompletionsHintsWidget(this._editor, this._model, this._instantiationService));
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    return this._ghostTextWidgets.get()[0]?.get().ownsViewZone(viewZoneId) ?? false;
  }
};
InlineCompletionsView = __decorate77([
  __param77(3, IInstantiationService)
], InlineCompletionsView);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/inlineCompletionsController.js
var __decorate78 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param78 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsController_1;
var _a49;
var InlineCompletionsController = (_a49 = class extends Disposable {
  /**
   * Find the controller in the focused editor or in the outer editor (if applicable)
   */
  static getInFocusedEditorOrParent(accessor) {
    const outerEditor = getOuterEditor(accessor);
    if (!outerEditor) {
      return null;
    }
    return InlineCompletionsController_1.get(outerEditor);
  }
  static get(editor2) {
    return hotClassGetOriginalInstance(editor2.getContribution(InlineCompletionsController_1.ID));
  }
  constructor(editor2, _instantiationService, _contextKeyService, _configurationService, _commandService, _debounceService, _languageFeaturesService, _accessibilitySignalService, _keybindingService, _accessibilityService) {
    super();
    this.editor = editor2;
    this._instantiationService = _instantiationService;
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._commandService = _commandService;
    this._debounceService = _debounceService;
    this._languageFeaturesService = _languageFeaturesService;
    this._accessibilitySignalService = _accessibilitySignalService;
    this._keybindingService = _keybindingService;
    this._accessibilityService = _accessibilityService;
    this._editorObs = observableCodeEditor(this.editor);
    this._positions = derived(this, (reader) => this._editorObs.selections.read(reader)?.map((s) => s.getEndPosition()) ?? [new Position(1, 1)]);
    this._suggestWidgetAdapter = this._register(new ObservableSuggestWidgetAdapter(this._editorObs, (item) => this.model.get()?.handleSuggestAccepted(item), () => this.model.get()?.selectedInlineCompletion.get()?.getSingleTextEdit()));
    this._enabledInConfig = observableFromEvent(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).enabled);
    this._isScreenReaderEnabled = observableFromEvent(this, this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized());
    this._editorDictationInProgress = observableFromEvent(this, this._contextKeyService.onDidChangeContext, () => this._contextKeyService.getContext(this.editor.getDomNode()).getValue("editorDictation.inProgress") === true);
    this._enabled = derived(this, (reader) => this._enabledInConfig.read(reader) && (!this._isScreenReaderEnabled.read(reader) || !this._editorDictationInProgress.read(reader)));
    this._debounceValue = this._debounceService.for(this._languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", { min: 50, max: 50 });
    this._focusIsInMenu = observableValue(this, false);
    this._focusIsInEditorOrMenu = derived(this, (reader) => {
      const editorHasFocus = this._editorObs.isFocused.read(reader);
      const menuHasFocus = this._focusIsInMenu.read(reader);
      return editorHasFocus || menuHasFocus;
    });
    this._cursorIsInIndentation = derived(this, (reader) => {
      const cursorPos = this._editorObs.cursorPosition.read(reader);
      if (cursorPos === null) {
        return false;
      }
      const model = this._editorObs.model.read(reader);
      if (!model) {
        return false;
      }
      this._editorObs.versionId.read(reader);
      const indentMaxColumn = model.getLineIndentColumn(cursorPos.lineNumber);
      return cursorPos.column <= indentMaxColumn;
    });
    this.model = derivedDisposable(this, (reader) => {
      if (this._editorObs.isReadonly.read(reader)) {
        return void 0;
      }
      const textModel = this._editorObs.model.read(reader);
      if (!textModel) {
        return void 0;
      }
      const model = this._instantiationService.createInstance(InlineCompletionsModel, textModel, this._suggestWidgetAdapter.selectedItem, this._editorObs.versionId, this._positions, this._debounceValue, this._enabled, this.editor);
      return model;
    }).recomputeInitiallyAndOnChange(this._store);
    this._playAccessibilitySignal = observableSignal(this);
    this._hideInlineEditOnSelectionChange = this._editorObs.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).map((val) => true);
    this._view = this._register(this._instantiationService.createInstance(InlineCompletionsView, this.editor, this.model, this._focusIsInMenu));
    InlineCompletionsController_1._instances.add(this);
    this._register(toDisposable(() => InlineCompletionsController_1._instances.delete(this)));
    this._register(autorun((reader) => {
      const model = this.model.read(reader);
      if (!model) {
        return;
      }
      const state = model.state.read(reader);
      if (!state) {
        return;
      }
      if (!this._focusIsInEditorOrMenu.read(void 0)) {
        return;
      }
      const nextEditUri = state.kind === "inlineEdit" ? state.nextEditUri : void 0;
      for (const ctrl of InlineCompletionsController_1._instances) {
        if (ctrl === this) {
          continue;
        } else if (nextEditUri && isEqual(nextEditUri, ctrl.editor.getModel()?.uri)) {
          ctrl.model.read(void 0)?.trigger();
        } else {
          ctrl.reject();
        }
      }
    }));
    this._register(autorun((reader) => {
      const model = this.model.read(reader);
      const uri = this.editor.getModel()?.uri;
      if (!model || !uri) {
        return;
      }
      reader.store.add(model.onDidAccept(() => {
        for (const ctrl of InlineCompletionsController_1._instances) {
          if (ctrl === this) {
            continue;
          }
          const state = ctrl.model.read(void 0)?.state.read(void 0);
          if (state?.kind === "inlineEdit" && isEqual(state.nextEditUri, uri)) {
            ctrl.model.read(void 0)?.stop("automatic");
          }
        }
      }));
    }));
    this._register(runOnChange(this._editorObs.onDidType, (_value, _changes) => {
      if (this._enabled.get()) {
        this.model.get()?.trigger();
      }
    }));
    this._register(runOnChange(this._editorObs.onDidPaste, (_value, _changes) => {
      if (this._enabled.get()) {
        this.model.get()?.trigger();
      }
    }));
    this._register(this._commandService.onDidExecuteCommand((e) => {
      const commands = /* @__PURE__ */ new Set([
        CoreEditingCommands.Tab.id,
        CoreEditingCommands.DeleteLeft.id,
        CoreEditingCommands.DeleteRight.id,
        inlineSuggestCommitId,
        "acceptSelectedSuggestion"
      ]);
      if (commands.has(e.commandId) && editor2.hasTextFocus() && this._enabled.get()) {
        let noDelay = false;
        if (e.commandId === inlineSuggestCommitId) {
          noDelay = true;
        }
        this._editorObs.forceUpdate((tx) => {
          this.model.get()?.trigger(tx, { noDelay });
        });
      }
    }));
    this._register(runOnChange(this._editorObs.selections, (_value, _, changes) => {
      if (changes.some((e) => e.reason === 3 || e.source === "api")) {
        if (!this._hideInlineEditOnSelectionChange.get() && this.model.get()?.state.get()?.kind === "inlineEdit") {
          return;
        }
        const m = this.model.get();
        if (!m) {
          return;
        }
        if (m.state.get()?.kind === "ghostText") {
          this.model.get()?.stop();
        }
      }
    }));
    this._register(autorun((reader) => {
      const isFocused = this._focusIsInEditorOrMenu.read(reader);
      const model = this.model.read(void 0);
      if (isFocused) {
        const state = model?.state.read(void 0);
        if (!state || state.kind !== "inlineEdit" || !state.nextEditUri) {
          transaction((tx) => {
            for (const ctrl of InlineCompletionsController_1._instances) {
              if (ctrl !== this) {
                ctrl.model.read(void 0)?.stop("automatic", tx);
              }
            }
          });
        }
        return;
      }
      if (this._contextKeyService.getContextKeyValue("accessibleViewIsShown") || this._configurationService.getValue("editor.inlineSuggest.keepOnBlur") || editor2.getOption(
        71
        /* EditorOption.inlineSuggest */
      ).keepOnBlur || InlineSuggestionHintsContentWidget.dropDownVisible) {
        return;
      }
      if (!model) {
        return;
      }
      if (model.state.read(void 0)?.inlineCompletion?.isFromExplicitRequest && model.inlineEditAvailable.read(void 0)) {
        return;
      }
      transaction((tx) => {
        model.stop("automatic", tx);
      });
    }));
    this._register(autorun((reader) => {
      const state = this.model.read(reader)?.inlineCompletionState.read(reader);
      if (state?.suggestItem) {
        if (state.primaryGhostText.lineCount >= 2) {
          this._suggestWidgetAdapter.forceRenderingAbove();
        }
      } else {
        this._suggestWidgetAdapter.stopForceRenderingAbove();
      }
    }));
    this._register(toDisposable(() => {
      this._suggestWidgetAdapter.stopForceRenderingAbove();
    }));
    const currentInlineCompletionBySemanticId = derivedObservableWithCache(this, (reader, last) => {
      const model = this.model.read(reader);
      const state = model?.state.read(reader);
      if (this._suggestWidgetAdapter.selectedItem.get()) {
        return last;
      }
      return state?.inlineCompletion?.semanticId;
    });
    this._register(runOnChangeWithStore(derived((reader) => {
      this._playAccessibilitySignal.read(reader);
      currentInlineCompletionBySemanticId.read(reader);
      return {};
    }), async (_value, _, _deltas, store) => {
      let model = this.model.get();
      let state = model?.state.get();
      if (!state || !model) {
        return;
      }
      await timeout(50, cancelOnDispose(store));
      await waitForState(this._suggestWidgetAdapter.selectedItem, isUndefined, () => false, cancelOnDispose(store));
      model = this.model.get();
      state = model?.state.get();
      if (!state || !model) {
        return;
      }
      const lineText = state.kind === "ghostText" ? model.textModel.getLineContent(state.primaryGhostText.lineNumber) : "";
      this._accessibilitySignalService.playSignal(state.kind === "ghostText" ? AccessibilitySignal.inlineSuggestion : AccessibilitySignal.nextEditSuggestion);
      if (this.editor.getOption(
        12
        /* EditorOption.screenReaderAnnounceInlineSuggestion */
      )) {
        if (state.kind === "ghostText") {
          this._provideScreenReaderUpdate(state.primaryGhostText.renderForScreenReader(lineText));
        } else {
          this._provideScreenReaderUpdate("");
        }
      }
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("accessibility.verbosity.inlineCompletions")) {
        this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue("accessibility.verbosity.inlineCompletions") });
      }
    }));
    this.editor.updateOptions({ inlineCompletionsAccessibilityVerbose: this._configurationService.getValue("accessibility.verbosity.inlineCompletions") });
    const contextKeySvcObs = new ObservableContextKeyService(this._contextKeyService);
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.cursorInIndentation, this._cursorIsInIndentation));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.hasSelection, (reader) => !this._editorObs.cursorSelection.read(reader)?.isEmpty()));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.cursorAtInlineEdit, this.model.map((m, reader) => m?.inlineEditState?.read(reader)?.cursorAtInlineEdit.read(reader))));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.tabShouldAcceptInlineEdit, this.model.map((m, r) => !!m?.tabShouldAcceptInlineEdit.read(r))));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.tabShouldJumpToInlineEdit, this.model.map((m, r) => !!m?.tabShouldJumpToInlineEdit.read(r))));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.inlineEditVisible, (reader) => this.model.read(reader)?.inlineEditState.read(reader) !== void 0));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.inlineSuggestionHasIndentation, (reader) => this.model.read(reader)?.getIndentationInfo(reader)?.startsWithIndentation));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize, (reader) => this.model.read(reader)?.getIndentationInfo(reader)?.startsWithIndentationLessThanTabSize));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.suppressSuggestions, (reader) => {
      const model = this.model.read(reader);
      const state = model?.inlineCompletionState.read(reader);
      return state?.primaryGhostText && state?.inlineCompletion ? state.inlineCompletion.source.inlineSuggestions.suppressSuggestions : void 0;
    }));
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.inlineSuggestionVisible, (reader) => {
      const model = this.model.read(reader);
      const state = model?.inlineCompletionState.read(reader);
      return !!state?.inlineCompletion && state?.primaryGhostText !== void 0 && !state?.primaryGhostText.isEmpty();
    }));
    const firstGhostTextPos = derived(this, (reader) => {
      const model = this.model.read(reader);
      const state = model?.inlineCompletionState.read(reader);
      const primaryGhostText = state?.primaryGhostText;
      if (!primaryGhostText || primaryGhostText.isEmpty()) {
        return void 0;
      }
      const firstPartPos = new Position(primaryGhostText.lineNumber, primaryGhostText.parts[0].column);
      return firstPartPos;
    });
    this._register(contextKeySvcObs.bind(InlineCompletionContextKeys.cursorBeforeGhostText, (reader) => {
      const firstPartPos = firstGhostTextPos.read(reader);
      if (!firstPartPos) {
        return false;
      }
      const cursorPos = this._editorObs.cursorPosition.read(reader);
      if (!cursorPos) {
        return false;
      }
      return firstPartPos.equals(cursorPos);
    }));
    this._register(this._instantiationService.createInstance(TextModelChangeRecorder, this.editor));
  }
  playAccessibilitySignal(tx) {
    this._playAccessibilitySignal.trigger(tx);
  }
  _provideScreenReaderUpdate(content) {
    const accessibleViewShowing = this._contextKeyService.getContextKeyValue("accessibleViewIsShown");
    const accessibleViewKeybinding = this._keybindingService.lookupKeybinding("editor.action.accessibleView");
    let hint;
    if (!accessibleViewShowing && accessibleViewKeybinding && this.editor.getOption(
      169
      /* EditorOption.inlineCompletionsAccessibilityVerbose */
    )) {
      hint = localize(1196, "Inspect this in the accessible view ({0})", accessibleViewKeybinding.getAriaLabel());
    }
    alert(hint ? content + ", " + hint : content);
  }
  shouldShowHoverAt(range) {
    const ghostText = this.model.get()?.primaryGhostText.get();
    if (!ghostText) {
      return false;
    }
    return ghostText.parts.some((p) => range.containsPosition(new Position(ghostText.lineNumber, p.column)));
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    return this._view.shouldShowHoverAtViewZone(viewZoneId);
  }
  reject() {
    transaction((tx) => {
      const m = this.model.get();
      if (m) {
        m.stop("explicitCancel", tx);
        if (this._focusIsInEditorOrMenu.get()) {
          for (const ctrl of InlineCompletionsController_1._instances) {
            if (ctrl !== this) {
              ctrl.model.get()?.stop("automatic", tx);
            }
          }
        }
      }
    });
  }
  jump() {
    const m = this.model.get();
    if (m) {
      m.jump();
    }
  }
}, InlineCompletionsController_1 = _a49, _a49._instances = /* @__PURE__ */ new Set(), _a49.hot = createHotClass(InlineCompletionsController_1), _a49.ID = "editor.contrib.inlineCompletionsController", _a49);
InlineCompletionsController = InlineCompletionsController_1 = __decorate78([
  __param78(1, IInstantiationService),
  __param78(2, IContextKeyService),
  __param78(3, IConfigurationService),
  __param78(4, ICommandService),
  __param78(5, ILanguageFeatureDebounceService),
  __param78(6, ILanguageFeaturesService),
  __param78(7, IAccessibilitySignalService),
  __param78(8, IKeybindingService),
  __param78(9, IAccessibilityService)
], InlineCompletionsController);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/controller/commands.js
var _ShowNextInlineSuggestionAction = class _ShowNextInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: _ShowNextInlineSuggestionAction.ID,
      label: localize2(1174, "Show Next Inline Suggestion"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 94
      }
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.get(editor2);
    controller?.model.get()?.next();
  }
};
_ShowNextInlineSuggestionAction.ID = showNextInlineSuggestionActionId;
var ShowNextInlineSuggestionAction = _ShowNextInlineSuggestionAction;
var _ShowPreviousInlineSuggestionAction = class _ShowPreviousInlineSuggestionAction extends EditorAction {
  constructor() {
    super({
      id: _ShowPreviousInlineSuggestionAction.ID,
      label: localize2(1175, "Show Previous Inline Suggestion"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 92
      }
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.get(editor2);
    controller?.model.get()?.previous();
  }
};
_ShowPreviousInlineSuggestionAction.ID = showPreviousInlineSuggestionActionId;
var ShowPreviousInlineSuggestionAction = _ShowPreviousInlineSuggestionAction;
var TriggerInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: localize2(1176, "Trigger Inline Suggestion"),
      precondition: EditorContextKeys.writable
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.get(editor2);
    await asyncTransaction(async (tx) => {
      await controller?.model.get()?.triggerExplicitly(tx);
      controller?.playAccessibilitySignal(tx);
    });
  }
};
var ExplicitTriggerInlineEditAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.triggerInlineEditExplicit",
      label: localize2(1177, "Trigger Next Edit Suggestion"),
      precondition: EditorContextKeys.writable
    });
  }
  async run(accessor, editor2) {
    const notificationService = accessor.get(INotificationService);
    const controller = InlineCompletionsController.get(editor2);
    await controller?.model.get()?.triggerExplicitly(void 0, true);
    if (!controller?.model.get()?.inlineEditAvailable.get()) {
      notificationService.notify({
        severity: Severity.Info,
        message: localize(1165, "No inline edit is available.")
      });
    }
  }
};
var TriggerInlineEditAction = class extends EditorCommand {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.triggerInlineEdit",
      precondition: EditorContextKeys.writable
    });
  }
  async runEditorCommand(accessor, editor2, args) {
    const controller = InlineCompletionsController.get(editor2);
    await controller?.model.get()?.trigger(void 0, { onlyFetchInlineEdits: true });
  }
};
var AcceptNextWordOfInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextWord",
      label: localize2(1178, "Accept Next Word Of Inline Suggestion"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100 + 1,
        primary: 2048 | 17,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible, InlineCompletionContextKeys.cursorBeforeGhostText, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate())
      },
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize(1166, "Accept Word"),
        group: "primary",
        order: 2
      }]
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.get(editor2);
    await controller?.model.get()?.acceptNextWord();
  }
};
var AcceptNextLineOfInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextLine",
      label: localize2(1179, "Accept Next Line Of Inline Suggestion"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, InlineCompletionContextKeys.inlineSuggestionVisible),
      kbOpts: {
        weight: 100 + 1
      },
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize(1167, "Accept Line"),
        group: "secondary",
        order: 2
      }]
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.get(editor2);
    await controller?.model.get()?.acceptNextLine();
  }
};
var AcceptInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: inlineSuggestCommitId,
      label: localize2(1180, "Accept Inline Suggestion"),
      precondition: ContextKeyExpr.or(InlineCompletionContextKeys.inlineSuggestionVisible, InlineCompletionContextKeys.inlineEditVisible),
      menuOpts: [{
        menuId: MenuId.InlineSuggestionToolbar,
        title: localize(1168, "Accept"),
        group: "primary",
        order: 2
      }, {
        menuId: MenuId.InlineEditsActions,
        title: localize(1169, "Accept"),
        group: "primary",
        order: 2
      }],
      kbOpts: [
        {
          primary: 2,
          weight: 200,
          kbExpr: ContextKeyExpr.or(ContextKeyExpr.and(InlineCompletionContextKeys.inlineSuggestionVisible, EditorContextKeys.tabMovesFocus.toNegated(), Context.Visible.toNegated(), EditorContextKeys.hoverFocused.toNegated(), InlineCompletionContextKeys.hasSelection.toNegated(), InlineCompletionContextKeys.inlineSuggestionHasIndentationLessThanTabSize), ContextKeyExpr.and(InlineCompletionContextKeys.inlineEditVisible, EditorContextKeys.tabMovesFocus.toNegated(), Context.Visible.toNegated(), EditorContextKeys.hoverFocused.toNegated(), InlineCompletionContextKeys.tabShouldAcceptInlineEdit))
        }
      ]
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.getInFocusedEditorOrParent(accessor);
    if (controller) {
      controller.model.get()?.accept(controller.editor);
      controller.editor.focus();
    }
  }
};
KeybindingsRegistry.registerKeybindingRule({
  id: inlineSuggestCommitId,
  weight: 202,
  // greater than jump
  primary: 2,
  when: ContextKeyExpr.and(InlineCompletionContextKeys.inInlineEditsPreviewEditor)
});
var JumpToNextInlineEdit = class extends EditorAction {
  constructor() {
    super({
      id: jumpToNextInlineEditId,
      label: localize2(1181, "Jump to next inline edit"),
      precondition: InlineCompletionContextKeys.inlineEditVisible,
      menuOpts: [{
        menuId: MenuId.InlineEditsActions,
        title: localize(1170, "Jump"),
        group: "primary",
        order: 1,
        when: InlineCompletionContextKeys.cursorAtInlineEdit.toNegated()
      }],
      kbOpts: {
        primary: 2,
        weight: 201,
        kbExpr: ContextKeyExpr.and(InlineCompletionContextKeys.inlineEditVisible, EditorContextKeys.tabMovesFocus.toNegated(), Context.Visible.toNegated(), EditorContextKeys.hoverFocused.toNegated(), InlineCompletionContextKeys.tabShouldJumpToInlineEdit)
      }
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.get(editor2);
    if (controller) {
      controller.jump();
    }
  }
};
var _HideInlineCompletion = class _HideInlineCompletion extends EditorAction {
  constructor() {
    super({
      id: _HideInlineCompletion.ID,
      label: localize2(1182, "Hide Inline Suggestion"),
      precondition: ContextKeyExpr.or(InlineCompletionContextKeys.inlineSuggestionVisible, InlineCompletionContextKeys.inlineEditVisible),
      kbOpts: {
        weight: 100 + 90,
        // same as hiding the suggest widget
        primary: 9
      },
      menuOpts: [{
        menuId: MenuId.InlineEditsActions,
        title: localize(1171, "Reject"),
        group: "primary",
        order: 3
      }]
    });
  }
  async run(accessor, editor2) {
    const controller = InlineCompletionsController.getInFocusedEditorOrParent(accessor);
    transaction((tx) => {
      controller?.model.get()?.stop("explicitCancel", tx);
    });
    controller?.editor.focus();
  }
};
_HideInlineCompletion.ID = hideInlineCompletionId;
var HideInlineCompletion = _HideInlineCompletion;
var _ToggleInlineCompletionShowCollapsed = class _ToggleInlineCompletionShowCollapsed extends EditorAction {
  constructor() {
    super({
      id: _ToggleInlineCompletionShowCollapsed.ID,
      label: localize2(1183, "Toggle Inline Suggestions Show Collapsed"),
      precondition: ContextKeyExpr.true()
    });
  }
  async run(accessor, editor2) {
    const configurationService = accessor.get(IConfigurationService);
    const showCollapsed = configurationService.getValue("editor.inlineSuggest.edits.showCollapsed");
    configurationService.updateValue("editor.inlineSuggest.edits.showCollapsed", !showCollapsed);
  }
};
_ToggleInlineCompletionShowCollapsed.ID = toggleShowCollapsedId;
var ToggleInlineCompletionShowCollapsed = _ToggleInlineCompletionShowCollapsed;
KeybindingsRegistry.registerKeybindingRule({
  id: HideInlineCompletion.ID,
  weight: -1,
  // very weak
  primary: 9,
  secondary: [
    1024 | 9
    /* KeyCode.Escape */
  ],
  when: ContextKeyExpr.and(InlineCompletionContextKeys.inInlineEditsPreviewEditor)
});
var _ToggleAlwaysShowInlineSuggestionToolbar = class _ToggleAlwaysShowInlineSuggestionToolbar extends Action2 {
  constructor() {
    super({
      id: _ToggleAlwaysShowInlineSuggestionToolbar.ID,
      title: localize(1172, "Always Show Toolbar"),
      f1: false,
      precondition: void 0,
      menu: [{
        id: MenuId.InlineSuggestionToolbar,
        group: "secondary",
        order: 10
      }],
      toggled: ContextKeyExpr.equals("config.editor.inlineSuggest.showToolbar", "always")
    });
  }
  async run(accessor) {
    const configService = accessor.get(IConfigurationService);
    const currentValue = configService.getValue("editor.inlineSuggest.showToolbar");
    const newValue = currentValue === "always" ? "onHover" : "always";
    configService.updateValue("editor.inlineSuggest.showToolbar", newValue);
  }
};
_ToggleAlwaysShowInlineSuggestionToolbar.ID = "editor.action.inlineSuggest.toggleAlwaysShowToolbar";
var ToggleAlwaysShowInlineSuggestionToolbar = _ToggleAlwaysShowInlineSuggestionToolbar;
var DevExtractReproSample = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.dev.extractRepro",
      label: localize(1173, "Developer: Extract Inline Suggest State"),
      alias: "Developer: Inline Suggest Extract Repro",
      precondition: ContextKeyExpr.or(InlineCompletionContextKeys.inlineEditVisible, InlineCompletionContextKeys.inlineSuggestionVisible)
    });
  }
  async run(accessor, editor2) {
    const clipboardService = accessor.get(IClipboardService);
    const controller = InlineCompletionsController.get(editor2);
    const m = controller?.model.get();
    if (!m) {
      return;
    }
    const repro = m.extractReproSample();
    const inlineCompletionLines = splitLines(JSON.stringify({ inlineCompletion: repro.inlineCompletion }, null, 4));
    const json = inlineCompletionLines.map((l) => "// " + l).join("\n");
    const reproStr = `${repro.documentValue}

// <json>
${json}
// </json>
`;
    await clipboardService.writeText(reproStr);
    return { reproCase: reproStr };
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/hintsWidget/hoverParticipant.js
init_dom();
init_htmlContent();
init_lifecycle();
init_observable();
init_range();
init_language();
init_nls();
init_instantiation();
init_telemetry();
var __decorate79 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param79 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsHover = class {
  constructor(owner, range, controller) {
    this.owner = owner;
    this.range = range;
    this.controller = controller;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, accessibilityService, _instantiationService, _telemetryService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.accessibilityService = accessibilityService;
    this._instantiationService = _instantiationService;
    this._telemetryService = _telemetryService;
    this.hoverOrdinal = 4;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = InlineCompletionsController.get(this._editor);
    if (!controller) {
      return null;
    }
    const target = mouseEvent.target;
    if (target.type === 8) {
      const viewZoneData = target.detail;
      if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
        return new HoverForeignElementAnchor(1e3, this, Range.fromPositions(this._editor.getModel().validatePosition(viewZoneData.positionBefore || viewZoneData.position)), mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 7) {
      if (controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 6) {
      const mightBeForeignElement = target.detail.mightBeForeignElement;
      if (mightBeForeignElement && controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    if (target.type === 9 && target.element) {
      const ctx = GhostTextView.getWarningWidgetContext(target.element);
      if (ctx && controller.shouldShowHoverAt(ctx.range)) {
        return new HoverForeignElementAnchor(1e3, this, ctx.range, mouseEvent.event.posx, mouseEvent.event.posy, false);
      }
    }
    return null;
  }
  computeSync(anchor, lineDecorations) {
    if (this._editor.getOption(
      71
      /* EditorOption.inlineSuggest */
    ).showToolbar !== "onHover") {
      return [];
    }
    const controller = InlineCompletionsController.get(this._editor);
    if (controller && controller.shouldShowHoverAt(anchor.range)) {
      return [new InlineCompletionsHover(this, anchor.range, controller)];
    }
    return [];
  }
  renderHoverParts(context, hoverParts) {
    const disposables = new DisposableStore();
    const part = hoverParts[0];
    this._telemetryService.publicLog2("inlineCompletionHover.shown");
    if (this.accessibilityService.isScreenReaderOptimized() && !this._editor.getOption(
      12
      /* EditorOption.screenReaderAnnounceInlineSuggestion */
    )) {
      disposables.add(this.renderScreenReaderText(context, part));
    }
    const model = part.controller.model.get();
    const widgetNode = document.createElement("div");
    context.fragment.appendChild(widgetNode);
    disposables.add(autorunWithStore((reader, store) => {
      const w = store.add(this._instantiationService.createInstance(InlineSuggestionHintsContentWidget.hot.read(reader), this._editor, false, constObservable(null), model.selectedInlineCompletionIndex, model.inlineCompletionsCount, model.activeCommands, model.warning, () => {
        context.onContentsChanged();
      }));
      widgetNode.replaceChildren(w.getDomNode());
    }));
    model.triggerExplicitly();
    const renderedHoverPart = {
      hoverPart: part,
      hoverElement: widgetNode,
      dispose() {
        disposables.dispose();
      }
    };
    return new RenderedHoverParts([renderedHoverPart]);
  }
  renderScreenReaderText(context, part) {
    const disposables = new DisposableStore();
    const $13 = $;
    const markdownHoverElement = $13("div.hover-row.markdown-hover");
    const hoverContentsElement = append(markdownHoverElement, $13("div.hover-contents", { ["aria-live"]: "assertive" }));
    const renderer = new MarkdownRenderer({ editor: this._editor }, this._languageService, this._openerService);
    const render = (code) => {
      const inlineSuggestionAvailable = localize(1197, "Suggestion:");
      const renderedContents = disposables.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code), {
        asyncRenderCallback: () => {
          hoverContentsElement.className = "hover-contents code-hover-contents";
          context.onContentsChanged();
        }
      }));
      hoverContentsElement.replaceChildren(renderedContents.element);
    };
    disposables.add(autorun((reader) => {
      const ghostText = part.controller.model.read(reader)?.primaryGhostText.read(reader);
      if (ghostText) {
        const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
        render(ghostText.renderForScreenReader(lineText));
      } else {
        reset(hoverContentsElement);
      }
    }));
    context.fragment.appendChild(markdownHoverElement);
    return disposables;
  }
};
InlineCompletionsHoverParticipant = __decorate79([
  __param79(1, ILanguageService),
  __param79(2, IOpenerService),
  __param79(3, IAccessibilityService),
  __param79(4, IInstantiationService),
  __param79(5, ITelemetryService)
], InlineCompletionsHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsAccessibleView.js
var InlineCompletionsAccessibleView = class {
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletions.contribution.js
registerEditorContribution(
  InlineCompletionsController.ID,
  wrapInHotClass1(InlineCompletionsController.hot),
  3
  /* EditorContributionInstantiation.Eventually */
);
registerEditorAction(TriggerInlineSuggestionAction);
registerEditorAction(ExplicitTriggerInlineEditAction);
registerEditorCommand(new TriggerInlineEditAction());
registerEditorAction(ShowNextInlineSuggestionAction);
registerEditorAction(ShowPreviousInlineSuggestionAction);
registerEditorAction(AcceptNextWordOfInlineCompletion);
registerEditorAction(AcceptNextLineOfInlineCompletion);
registerEditorAction(AcceptInlineCompletion);
registerEditorAction(ToggleInlineCompletionShowCollapsed);
registerEditorAction(HideInlineCompletion);
registerEditorAction(JumpToNextInlineEdit);
registerAction2(ToggleAlwaysShowInlineSuggestionToolbar);
registerEditorAction(DevExtractReproSample);
registerAction2(SnoozeInlineCompletion);
registerAction2(CancelSnoozeInlineCompletion);
HoverParticipantRegistry.register(InlineCompletionsHoverParticipant);
AccessibleViewRegistry.register(new InlineCompletionsAccessibleView());

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
init_async();
init_errors();
init_htmlContent();
init_lifecycle();
init_editorState();
init_editorExtensions();
init_range();
init_language();
init_resolverService();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.css";
init_nls();
init_contextkey();
init_languageFeatures();
init_textModel();
var __decorate80 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param80 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GotoDefinitionAtPositionEditorContribution_1;
var _a50;
var GotoDefinitionAtPositionEditorContribution = (_a50 = class {
  constructor(editor2, textModelResolverService, languageService, languageFeaturesService) {
    this.textModelResolverService = textModelResolverService;
    this.languageService = languageService;
    this.languageFeaturesService = languageFeaturesService;
    this.toUnhook = new DisposableStore();
    this.toUnhookForKeyboard = new DisposableStore();
    this.currentWordAtPosition = null;
    this.previousPromise = null;
    this.editor = editor2;
    this.linkDecorations = this.editor.createDecorationsCollection();
    const linkGesture = new ClickLinkGesture(editor2);
    this.toUnhook.add(linkGesture);
    this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this.startFindDefinitionFromMouse(mouseEvent, keyboardEvent ?? void 0);
    }));
    this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
      if (this.isEnabled(mouseEvent)) {
        this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).catch((error) => {
          onUnexpectedError(error);
        }).finally(() => {
          this.removeLinkDecorations();
        });
      }
    }));
    this.toUnhook.add(linkGesture.onCancel(() => {
      this.removeLinkDecorations();
      this.currentWordAtPosition = null;
    }));
  }
  static get(editor2) {
    return editor2.getContribution(GotoDefinitionAtPositionEditorContribution_1.ID);
  }
  async startFindDefinitionFromCursor(position) {
    await this.startFindDefinition(position);
    this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      this.toUnhookForKeyboard.clear();
    }));
    this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
      if (e) {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        this.toUnhookForKeyboard.clear();
      }
    }));
  }
  startFindDefinitionFromMouse(mouseEvent, withKey) {
    if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
      return;
    }
    if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    const position = mouseEvent.target.position;
    this.startFindDefinition(position);
  }
  async startFindDefinition(position) {
    this.toUnhookForKeyboard.clear();
    const word = position ? this.editor.getModel()?.getWordAtPosition(position) : null;
    if (!word) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
      return;
    }
    this.currentWordAtPosition = word;
    const state = new EditorState(
      this.editor,
      4 | 1 | 2 | 8
      /* CodeEditorStateFlag.Scroll */
    );
    if (this.previousPromise) {
      this.previousPromise.cancel();
      this.previousPromise = null;
    }
    this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
    let results;
    try {
      results = await this.previousPromise;
    } catch (error) {
      onUnexpectedError(error);
      return;
    }
    if (!results || !results.length || !state.validate(this.editor)) {
      this.removeLinkDecorations();
      return;
    }
    const linkRange = results[0].originSelectionRange ? Range.lift(results[0].originSelectionRange) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
    if (results.length > 1) {
      let combinedRange = linkRange;
      for (const { originSelectionRange } of results) {
        if (originSelectionRange) {
          combinedRange = Range.plusRange(combinedRange, originSelectionRange);
        }
      }
      this.addDecoration(combinedRange, new MarkdownString().appendText(localize(1072, "Click to show {0} definitions.", results.length)));
    } else {
      const result = results[0];
      if (!result.uri) {
        return;
      }
      return this.textModelResolverService.createModelReference(result.uri).then((ref) => {
        if (!ref.object || !ref.object.textEditorModel) {
          ref.dispose();
          return;
        }
        const { object: { textEditorModel } } = ref;
        const { startLineNumber } = result.range;
        if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
          ref.dispose();
          return;
        }
        const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
        const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
        this.addDecoration(linkRange, previewValue ? new MarkdownString().appendCodeblock(languageId ? languageId : "", previewValue) : void 0);
        ref.dispose();
      });
    }
  }
  getPreviewValue(textEditorModel, startLineNumber, result) {
    let rangeToUse = result.range;
    const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
    if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution_1.MAX_SOURCE_PREVIEW_LINES) {
      rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
    }
    rangeToUse = textEditorModel.validateRange(rangeToUse);
    const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
    return previewValue;
  }
  stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let minIndent = startIndent;
    for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      minIndent = Math.min(minIndent, endIndent);
    }
    const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
    return previewValue;
  }
  getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution_1.MAX_SOURCE_PREVIEW_LINES);
    let endLineNumber = startLineNumber + 1;
    for (; endLineNumber < maxLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      if (startIndent === endIndent) {
        break;
      }
    }
    return new Range(startLineNumber, 1, endLineNumber + 1, 1);
  }
  addDecoration(range, hoverMessage) {
    const newDecorations = {
      range,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage
      }
    };
    this.linkDecorations.set([newDecorations]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(mouseEvent, withKey) {
    return this.editor.hasModel() && mouseEvent.isLeftClick && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && !(mouseEvent.target.detail.injectedText?.options instanceof ModelDecorationInjectedTextOptions) && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(position, token) {
    const model = this.editor.getModel();
    if (!model) {
      return Promise.resolve(null);
    }
    return getDefinitionsAtPosition(this.languageFeaturesService.definitionProvider, model, position, false, token);
  }
  gotoDefinition(position, openToSide) {
    this.editor.setPosition(position);
    return this.editor.invokeWithinContext((accessor) => {
      const canPeek = !openToSide && this.editor.getOption(
        101
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(accessor);
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
      return action.run(accessor);
    });
  }
  isInPeekEditor(accessor) {
    const contextKeyService = accessor.get(IContextKeyService);
    return PeekContext.inPeekEditor.getValue(contextKeyService);
  }
  dispose() {
    this.toUnhook.dispose();
    this.toUnhookForKeyboard.dispose();
  }
}, GotoDefinitionAtPositionEditorContribution_1 = _a50, _a50.ID = "editor.contrib.gotodefinitionatposition", _a50.MAX_SOURCE_PREVIEW_LINES = 8, _a50);
GotoDefinitionAtPositionEditorContribution = GotoDefinitionAtPositionEditorContribution_1 = __decorate80([
  __param80(1, ITextModelService),
  __param80(2, ILanguageService),
  __param80(3, ILanguageFeaturesService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(
  GotoDefinitionAtPositionEditorContribution.ID,
  GotoDefinitionAtPositionEditorContribution,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
init_codicons();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/markerNavigationService.js
init_arrays();
init_event();
init_lifecycle();
init_linkedList();
init_strings();
init_uri();
init_range();
init_extensions();
init_instantiation();
init_configuration();
init_resources();
var __decorate81 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param81 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerCoordinate = class {
  constructor(marker, index, total) {
    this.marker = marker;
    this.index = index;
    this.total = total;
  }
};
var MarkerList = class MarkerList2 {
  constructor(resourceFilter, _markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._dispoables = new DisposableStore();
    this._markers = [];
    this._nextIdx = -1;
    if (URI.isUri(resourceFilter)) {
      this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
    } else if (resourceFilter) {
      this._resourceFilter = resourceFilter;
    }
    const compareOrder = this._configService.getValue("problems.sortOrder");
    const compareMarker = (a, b) => {
      let res = compare(a.resource.toString(), b.resource.toString());
      if (res === 0) {
        if (compareOrder === "position") {
          res = Range.compareRangesUsingStarts(a, b) || MarkerSeverity.compare(a.severity, b.severity);
        } else {
          res = MarkerSeverity.compare(a.severity, b.severity) || Range.compareRangesUsingStarts(a, b);
        }
      }
      return res;
    };
    const updateMarker = () => {
      let newMarkers = this._markerService.read({
        resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
        severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
      });
      if (typeof resourceFilter === "function") {
        newMarkers = newMarkers.filter((m) => this._resourceFilter(m.resource));
      }
      newMarkers.sort(compareMarker);
      if (equals(newMarkers, this._markers, (a, b) => a.resource.toString() === b.resource.toString() && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn && a.severity === b.severity && a.message === b.message)) {
        return false;
      }
      this._markers = newMarkers;
      return true;
    };
    updateMarker();
    this._dispoables.add(_markerService.onMarkerChanged((uris) => {
      if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
        if (updateMarker()) {
          this._nextIdx = -1;
          this._onDidChange.fire();
        }
      }
    }));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  matches(uri) {
    if (!this._resourceFilter && !uri) {
      return true;
    }
    if (!this._resourceFilter || !uri) {
      return false;
    }
    return this._resourceFilter(uri);
  }
  get selected() {
    const marker = this._markers[this._nextIdx];
    return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(model, position, fwd) {
    let idx = this._markers.findIndex((marker) => isEqual(marker.resource, model.uri));
    if (idx < 0) {
      idx = binarySearch2(this._markers.length, (idx2) => compare(this._markers[idx2].resource.toString(), model.uri.toString()));
      if (idx < 0) {
        idx = ~idx;
      }
      if (fwd) {
        this._nextIdx = idx;
      } else {
        this._nextIdx = (this._markers.length + idx - 1) % this._markers.length;
      }
    } else {
      let found = false;
      let wentPast = false;
      for (let i2 = idx; i2 < this._markers.length; i2++) {
        let range = Range.lift(this._markers[i2]);
        if (range.isEmpty()) {
          const word = model.getWordAtPosition(range.getStartPosition());
          if (word) {
            range = new Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
          }
        }
        if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
          this._nextIdx = i2;
          found = true;
          wentPast = !range.containsPosition(position);
          break;
        }
        if (this._markers[i2].resource.toString() !== model.uri.toString()) {
          break;
        }
      }
      if (!found) {
        this._nextIdx = fwd ? 0 : this._markers.length - 1;
      } else if (wentPast && !fwd) {
        this._nextIdx -= 1;
      }
    }
    if (this._nextIdx < 0) {
      this._nextIdx = this._markers.length - 1;
    }
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(fwd, model, position) {
    if (this._markers.length === 0) {
      return false;
    }
    const oldIdx = this._nextIdx;
    if (this._nextIdx === -1) {
      this._initIdx(model, position, fwd);
    } else if (fwd) {
      this._nextIdx = (this._nextIdx + 1) % this._markers.length;
    } else if (!fwd) {
      this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
    }
    if (oldIdx !== this._nextIdx) {
      return true;
    }
    return false;
  }
  find(uri, position) {
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
    if (idx < 0) {
      return void 0;
    }
    for (; idx < this._markers.length; idx++) {
      if (Range.containsPosition(this._markers[idx], position)) {
        return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
      }
    }
    return void 0;
  }
};
MarkerList = __decorate81([
  __param81(1, IMarkerService),
  __param81(2, IConfigurationService)
], MarkerList);
var IMarkerNavigationService = createDecorator("IMarkerNavigationService");
var MarkerNavigationService = class MarkerNavigationService2 {
  constructor(_markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._provider = new LinkedList();
  }
  getMarkerList(resource) {
    for (const provider of this._provider) {
      const result = provider.getMarkerList(resource);
      if (result) {
        return result;
      }
    }
    return new MarkerList(resource, this._markerService, this._configService);
  }
};
MarkerNavigationService = __decorate81([
  __param81(0, IMarkerService),
  __param81(1, IConfigurationService)
], MarkerNavigationService);
registerSingleton(
  IMarkerNavigationService,
  MarkerNavigationService,
  1
  /* InstantiationType.Delayed */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
init_nls();
init_actions2();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
init_dom();
init_arrays();
init_color();
init_event();
init_lifecycle();
init_resources();
init_strings();
init_range();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/media/gotoErrorWidget.css";
init_nls();
init_actions2();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/base/browser/ui/severityIcon/severityIcon.js
init_codicons();
init_themables();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/base/browser/ui/severityIcon/media/severityIcon.css";
var SeverityIcon;
(function(SeverityIcon2) {
  function className(severity) {
    switch (severity) {
      case severity_default.Ignore:
        return "severity-ignore " + ThemeIcon.asClassName(Codicon.info);
      case severity_default.Info:
        return ThemeIcon.asClassName(Codicon.info);
      case severity_default.Warning:
        return ThemeIcon.asClassName(Codicon.warning);
      case severity_default.Error:
        return ThemeIcon.asClassName(Codicon.error);
      default:
        return "";
    }
  }
  SeverityIcon2.className = className;
})(SeverityIcon || (SeverityIcon = {}));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
init_colorRegistry();
init_themeService();
var __decorate82 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param82 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerNavigationWidget_1;
var MessageWidget2 = class {
  constructor(parent, editor2, onRelatedInformation, _openerService, _labelService) {
    this._openerService = _openerService;
    this._labelService = _labelService;
    this._lines = 0;
    this._longestLineLength = 0;
    this._relatedDiagnostics = /* @__PURE__ */ new WeakMap();
    this._disposables = new DisposableStore();
    this._editor = editor2;
    const domNode = document.createElement("div");
    domNode.className = "descriptioncontainer";
    this._messageBlock = document.createElement("div");
    this._messageBlock.classList.add("message");
    this._messageBlock.setAttribute("aria-live", "assertive");
    this._messageBlock.setAttribute("role", "alert");
    domNode.appendChild(this._messageBlock);
    this._relatedBlock = document.createElement("div");
    domNode.appendChild(this._relatedBlock);
    this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
      event.preventDefault();
      const related = this._relatedDiagnostics.get(event.target);
      if (related) {
        onRelatedInformation(related);
      }
    }));
    this._scrollable = new ScrollableElement(domNode, {
      horizontal: 1,
      vertical: 1,
      useShadows: false,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    });
    parent.appendChild(this._scrollable.getDomNode());
    this._disposables.add(this._scrollable.onScroll((e) => {
      domNode.style.left = `-${e.scrollLeft}px`;
      domNode.style.top = `-${e.scrollTop}px`;
    }));
    this._disposables.add(this._scrollable);
  }
  dispose() {
    dispose(this._disposables);
  }
  update(marker) {
    const { source, message, relatedInformation, code } = marker;
    let sourceAndCodeLength = (source?.length || 0) + "()".length;
    if (code) {
      if (typeof code === "string") {
        sourceAndCodeLength += code.length;
      } else {
        sourceAndCodeLength += code.value.length;
      }
    }
    const lines = splitLines(message);
    this._lines = lines.length;
    this._longestLineLength = 0;
    for (const line of lines) {
      this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
    }
    clearNode(this._messageBlock);
    this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
    this._editor.applyFontInfo(this._messageBlock);
    let lastLineElement = this._messageBlock;
    for (const line of lines) {
      lastLineElement = document.createElement("div");
      lastLineElement.innerText = line;
      if (line === "") {
        lastLineElement.style.height = this._messageBlock.style.lineHeight;
      }
      this._messageBlock.appendChild(lastLineElement);
    }
    if (source || code) {
      const detailsElement = document.createElement("span");
      detailsElement.classList.add("details");
      lastLineElement.appendChild(detailsElement);
      if (source) {
        const sourceElement = document.createElement("span");
        sourceElement.innerText = source;
        sourceElement.classList.add("source");
        detailsElement.appendChild(sourceElement);
      }
      if (code) {
        if (typeof code === "string") {
          const codeElement = document.createElement("span");
          codeElement.innerText = `(${code})`;
          codeElement.classList.add("code");
          detailsElement.appendChild(codeElement);
        } else {
          this._codeLink = $("a.code-link");
          this._codeLink.setAttribute("href", `${code.target.toString()}`);
          this._codeLink.onclick = (e) => {
            this._openerService.open(code.target, { allowCommands: true });
            e.preventDefault();
            e.stopPropagation();
          };
          const codeElement = append(this._codeLink, $("span"));
          codeElement.innerText = code.value;
          detailsElement.appendChild(this._codeLink);
        }
      }
    }
    clearNode(this._relatedBlock);
    this._editor.applyFontInfo(this._relatedBlock);
    if (isNonEmptyArray(relatedInformation)) {
      const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
      relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(
        75
        /* EditorOption.lineHeight */
      ) * 0.66)}px`;
      this._lines += 1;
      for (const related of relatedInformation) {
        const container = document.createElement("div");
        const relatedResource = document.createElement("a");
        relatedResource.classList.add("filename");
        relatedResource.innerText = `${this._labelService.getUriBasenameLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
        relatedResource.title = this._labelService.getUriLabel(related.resource);
        this._relatedDiagnostics.set(relatedResource, related);
        const relatedMessage = document.createElement("span");
        relatedMessage.innerText = related.message;
        container.appendChild(relatedResource);
        container.appendChild(relatedMessage);
        this._lines += 1;
        relatedInformationNode.appendChild(container);
      }
    }
    const fontInfo = this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
    const scrollHeight = fontInfo.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });
  }
  layout(height, width) {
    this._scrollable.getDomNode().style.height = `${height}px`;
    this._scrollable.getDomNode().style.width = `${width}px`;
    this._scrollable.setScrollDimensions({ width, height });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(marker) {
    let severityLabel = "";
    switch (marker.severity) {
      case MarkerSeverity.Error:
        severityLabel = localize(1019, "Error");
        break;
      case MarkerSeverity.Warning:
        severityLabel = localize(1020, "Warning");
        break;
      case MarkerSeverity.Info:
        severityLabel = localize(1021, "Info");
        break;
      case MarkerSeverity.Hint:
        severityLabel = localize(1022, "Hint");
        break;
    }
    let ariaLabel = localize(1023, "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
    const model = this._editor.getModel();
    if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
      const lineContent = model.getLineContent(marker.startLineNumber);
      ariaLabel = `${lineContent}, ${ariaLabel}`;
    }
    return ariaLabel;
  }
};
var _a51;
var MarkerNavigationWidget = (_a51 = class extends PeekViewWidget {
  constructor(editor2, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
    super(editor2, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._labelService = _labelService;
    this._callOnDispose = new DisposableStore();
    this._onDidSelectRelatedInformation = new Emitter();
    this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
    this._severity = MarkerSeverity.Warning;
    this._backgroundColor = Color.white;
    this._applyTheme(_themeService.getColorTheme());
    this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this.create();
  }
  _applyTheme(theme) {
    this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
    let colorId = editorMarkerNavigationError;
    let headerBackground = editorMarkerNavigationErrorHeader;
    if (this._severity === MarkerSeverity.Warning) {
      colorId = editorMarkerNavigationWarning;
      headerBackground = editorMarkerNavigationWarningHeader;
    } else if (this._severity === MarkerSeverity.Info) {
      colorId = editorMarkerNavigationInfo;
      headerBackground = editorMarkerNavigationInfoHeader;
    }
    const frameColor = theme.getColor(colorId);
    const headerBg = theme.getColor(headerBackground);
    this.style({
      arrowColor: frameColor,
      frameColor,
      headerBackgroundColor: headerBg,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _applyStyles() {
    if (this._parentContainer) {
      this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
    }
    super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose();
    super.dispose();
  }
  _fillHead(container) {
    super._fillHead(container);
    this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((e) => this.editor.focus()));
    const menu = this._menuService.getMenuActions(MarkerNavigationWidget_1.TitleMenu, this._contextKeyService);
    const actions = getFlatActionBarActions(menu);
    this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });
  }
  _fillTitleIcon(container) {
    this._icon = append(container, $(""));
  }
  _fillBody(container) {
    this._parentContainer = container;
    container.classList.add("marker-widget");
    this._parentContainer.tabIndex = 0;
    this._parentContainer.setAttribute("role", "tooltip");
    this._container = document.createElement("div");
    container.appendChild(this._container);
    this._message = new MessageWidget2(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
    this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(marker, markerIdx, markerCount) {
    this._container.classList.remove("stale");
    this._message.update(marker);
    this._severity = marker.severity;
    this._applyTheme(this._themeService.getColorTheme());
    const range = Range.lift(marker);
    const editorPosition = this.editor.getPosition();
    const position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
    super.show(position, this.computeRequiredHeight());
    const model = this.editor.getModel();
    if (model) {
      const detail = markerCount > 1 ? localize(1024, "{0} of {1} problems", markerIdx, markerCount) : localize(1025, "{0} of {1} problem", markerIdx, markerCount);
      this.setTitle(basename2(model.uri), detail);
    }
    this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
    this.editor.revealPositionNearTop(
      position,
      0
      /* ScrollType.Smooth */
    );
    this.editor.focus();
  }
  updateMarker(marker) {
    this._container.classList.remove("stale");
    this._message.update(marker);
  }
  showStale() {
    this._container.classList.add("stale");
    this._relayout();
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._heightInPixel = heightInPixel;
    this._message.layout(heightInPixel, widthInPixel);
    this._container.style.height = `${heightInPixel}px`;
  }
  _onWidth(widthInPixel) {
    this._message.layout(this._heightInPixel, widthInPixel);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
}, MarkerNavigationWidget_1 = _a51, _a51.TitleMenu = new MenuId("gotoErrorTitleMenu"), _a51);
MarkerNavigationWidget = MarkerNavigationWidget_1 = __decorate82([
  __param82(1, IThemeService),
  __param82(2, IOpenerService),
  __param82(3, IMenuService),
  __param82(4, IInstantiationService),
  __param82(5, IContextKeyService),
  __param82(6, ILabelService)
], MarkerNavigationWidget);
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
var editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize(1026, "Editor marker navigation widget error color."));
var editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", { dark: transparent(editorMarkerNavigationError, 0.1), light: transparent(editorMarkerNavigationError, 0.1), hcDark: null, hcLight: null }, localize(1027, "Editor marker navigation widget error heading background."));
var editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize(1028, "Editor marker navigation widget warning color."));
var editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", { dark: transparent(editorMarkerNavigationWarning, 0.1), light: transparent(editorMarkerNavigationWarning, 0.1), hcDark: "#0C141F", hcLight: transparent(editorMarkerNavigationWarning, 0.2) }, localize(1029, "Editor marker navigation widget warning heading background."));
var editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize(1030, "Editor marker navigation widget info color."));
var editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", { dark: transparent(editorMarkerNavigationInfo, 0.1), light: transparent(editorMarkerNavigationInfo, 0.1), hcDark: null, hcLight: null }, localize(1031, "Editor marker navigation widget info heading background."));
var editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", editorBackground, localize(1032, "Editor marker navigation widget background."));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
var __decorate83 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param83 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerController_1;
var _a52;
var MarkerController = (_a52 = class {
  static get(editor2) {
    return editor2.getContribution(MarkerController_1.ID);
  }
  constructor(editor2, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
    this._markerNavigationService = _markerNavigationService;
    this._contextKeyService = _contextKeyService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._sessionDispoables = new DisposableStore();
    this._editor = editor2;
    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp();
    this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset();
    this._sessionDispoables.clear();
    this._widget = void 0;
    this._model = void 0;
  }
  _getOrCreateModel(uri) {
    if (this._model && this._model.matches(uri)) {
      return this._model;
    }
    let reusePosition = false;
    if (this._model) {
      reusePosition = true;
      this._cleanUp();
    }
    this._model = this._markerNavigationService.getMarkerList(uri);
    if (reusePosition) {
      this._model.move(true, this._editor.getModel(), this._editor.getPosition());
    }
    this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
    this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
    this._widgetVisible.set(true);
    this._sessionDispoables.add(this._model);
    this._sessionDispoables.add(this._widget);
    this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
      if (!this._model?.selected || !Range.containsPosition(this._model?.selected.marker, e.position)) {
        this._model?.resetIndex();
      }
    }));
    this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model) {
        return;
      }
      const info = this._model.find(this._editor.getModel().uri, this._widget.position);
      if (info) {
        this._widget.updateMarker(info.marker);
      } else {
        this._widget.showStale();
      }
    }));
    this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
      this._editorService.openCodeEditor({
        resource: related.resource,
        options: { pinned: true, revealIfOpened: true, selection: Range.lift(related).collapseToStart() }
      }, this._editor);
      this.close(false);
    }));
    this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
    return this._model;
  }
  close(focusEditor = true) {
    this._cleanUp();
    if (focusEditor) {
      this._editor.focus();
    }
  }
  showAtMarker(marker) {
    if (!this._editor.hasModel()) {
      return;
    }
    const textModel = this._editor.getModel();
    const model = this._getOrCreateModel(textModel.uri);
    model.resetIndex();
    model.move(true, textModel, new Position(marker.startLineNumber, marker.startColumn));
    if (model.selected) {
      this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
    }
  }
  async navigate(next, multiFile) {
    if (!this._editor.hasModel()) {
      return;
    }
    const textModel = this._editor.getModel();
    const model = this._getOrCreateModel(multiFile ? void 0 : textModel.uri);
    model.move(next, textModel, this._editor.getPosition());
    if (!model.selected) {
      return;
    }
    if (model.selected.marker.resource.toString() !== textModel.uri.toString()) {
      this._cleanUp();
      const otherEditor = await this._editorService.openCodeEditor({
        resource: model.selected.marker.resource,
        options: { pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker }
      }, this._editor);
      if (otherEditor) {
        MarkerController_1.get(otherEditor)?.close();
        MarkerController_1.get(otherEditor)?.navigate(next, multiFile);
      }
    } else {
      this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
    }
  }
}, MarkerController_1 = _a52, _a52.ID = "editor.contrib.markerController", _a52);
MarkerController = MarkerController_1 = __decorate83([
  __param83(1, IMarkerNavigationService),
  __param83(2, IContextKeyService),
  __param83(3, ICodeEditorService),
  __param83(4, IInstantiationService)
], MarkerController);
var MarkerNavigationAction = class extends EditorAction {
  constructor(_next, _multiFile, opts) {
    super(opts);
    this._next = _next;
    this._multiFile = _multiFile;
  }
  async run(_accessor, editor2) {
    if (editor2.hasModel()) {
      await MarkerController.get(editor2)?.navigate(this._next, this._multiFile);
    }
  }
};
var _NextMarkerAction = class _NextMarkerAction extends MarkerNavigationAction {
  constructor() {
    super(true, false, {
      id: _NextMarkerAction.ID,
      label: _NextMarkerAction.LABEL,
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: _NextMarkerAction.LABEL.value,
        icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize(1011, "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
};
_NextMarkerAction.ID = "editor.action.marker.next";
_NextMarkerAction.LABEL = localize2(1015, "Go to Next Problem (Error, Warning, Info)");
var NextMarkerAction = _NextMarkerAction;
var _PrevMarkerAction = class _PrevMarkerAction extends MarkerNavigationAction {
  constructor() {
    super(false, false, {
      id: _PrevMarkerAction.ID,
      label: _PrevMarkerAction.LABEL,
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 512 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: _PrevMarkerAction.LABEL.value,
        icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize(1012, "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
};
_PrevMarkerAction.ID = "editor.action.marker.prev";
_PrevMarkerAction.LABEL = localize2(1016, "Go to Previous Problem (Error, Warning, Info)");
var PrevMarkerAction = _PrevMarkerAction;
var NextMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, true, {
      id: "editor.action.marker.nextInFiles",
      label: localize2(1017, "Go to Next Problem in Files (Error, Warning, Info)"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize(1013, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
};
var PrevMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, true, {
      id: "editor.action.marker.prevInFiles",
      label: localize2(1018, "Go to Previous Problem in Files (Error, Warning, Info)"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize(1014, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
};
registerEditorContribution(
  MarkerController.ID,
  MarkerController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
var MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
  id: "closeMarkersNavigation",
  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
  handler: (x) => x.close(),
  kbOpts: {
    weight: 100 + 50,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/gpu/browser/gpuActions.js
init_dom();
init_buffer();
init_uri();
init_nls();
init_configuration();
init_contextkey();
init_instantiation();
init_log();
init_editorExtensions();
var DebugEditorGpuRendererAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.debugEditorGpuRenderer",
      label: localize2(1096, "Developer: Debug Editor GPU Renderer"),
      // TODO: Why doesn't `ContextKeyExpr.equals('config:editor.experimentalGpuAcceleration', 'on')` work?
      precondition: ContextKeyExpr.true()
    });
  }
  async run(accessor, editor2) {
    const instantiationService = accessor.get(IInstantiationService);
    const quickInputService = accessor.get(IQuickInputService);
    const choice = await quickInputService.pick([
      {
        label: localize(1093, "Log Texture Atlas Stats"),
        id: "logTextureAtlasStats"
      },
      {
        label: localize(1094, "Save Texture Atlas"),
        id: "saveTextureAtlas"
      },
      {
        label: localize(1095, "Draw Glyph"),
        id: "drawGlyph"
      }
    ], { canPickMany: false });
    if (!choice) {
      return;
    }
    switch (choice.id) {
      case "logTextureAtlasStats":
        instantiationService.invokeFunction((accessor2) => {
          const logService = accessor2.get(ILogService);
          const atlas = ViewGpuContext.atlas;
          if (!ViewGpuContext.atlas) {
            logService.error("No texture atlas found");
            return;
          }
          const stats = atlas.getStats();
          logService.info(["Texture atlas stats", ...stats].join("\n\n"));
        });
        break;
      case "saveTextureAtlas":
        instantiationService.invokeFunction(async (accessor2) => {
          const workspaceContextService = accessor2.get(IWorkspaceContextService);
          const fileService = accessor2.get(IFileService);
          const folders = workspaceContextService.getWorkspace().folders;
          if (folders.length > 0) {
            const atlas = ViewGpuContext.atlas;
            const promises = [];
            for (const [layerIndex, page] of atlas.pages.entries()) {
              promises.push(...[
                fileService.writeFile(URI.joinPath(folders[0].uri, `textureAtlasPage${layerIndex}_actual.png`), VSBuffer.wrap(new Uint8Array(await (await page.source.convertToBlob()).arrayBuffer()))),
                fileService.writeFile(URI.joinPath(folders[0].uri, `textureAtlasPage${layerIndex}_usage.png`), VSBuffer.wrap(new Uint8Array(await (await page.getUsagePreview()).arrayBuffer())))
              ]);
            }
            await Promise.all(promises);
          }
        });
        break;
      case "drawGlyph":
        instantiationService.invokeFunction(async (accessor2) => {
          const configurationService = accessor2.get(IConfigurationService);
          const fileService = accessor2.get(IFileService);
          const quickInputService2 = accessor2.get(IQuickInputService);
          const workspaceContextService = accessor2.get(IWorkspaceContextService);
          const folders = workspaceContextService.getWorkspace().folders;
          if (folders.length === 0) {
            return;
          }
          const atlas = ViewGpuContext.atlas;
          const fontFamily = configurationService.getValue("editor.fontFamily");
          const fontSize = configurationService.getValue("editor.fontSize");
          const rasterizer = new GlyphRasterizer(fontSize, fontFamily, getActiveWindow().devicePixelRatio, ViewGpuContext.decorationStyleCache);
          let chars = await quickInputService2.input({
            prompt: "Enter a character to draw (prefix with 0x for code point))"
          });
          if (!chars) {
            return;
          }
          const codePoint = chars.match(/0x(?<codePoint>[0-9a-f]+)/i)?.groups?.codePoint;
          if (codePoint !== void 0) {
            chars = String.fromCodePoint(parseInt(codePoint, 16));
          }
          const tokenMetadata = 0;
          const charMetadata = 0;
          const rasterizedGlyph = atlas.getGlyph(rasterizer, chars, tokenMetadata, charMetadata, 0);
          if (!rasterizedGlyph) {
            return;
          }
          const imageData = atlas.pages[rasterizedGlyph.pageIndex].source.getContext("2d")?.getImageData(rasterizedGlyph.x, rasterizedGlyph.y, rasterizedGlyph.w, rasterizedGlyph.h);
          if (!imageData) {
            return;
          }
          const canvas = new OffscreenCanvas(imageData.width, imageData.height);
          const ctx = ensureNonNullable(canvas.getContext("2d"));
          ctx.putImageData(imageData, 0, 0);
          const blob = await canvas.convertToBlob({ type: "image/png" });
          const resource = URI.joinPath(folders[0].uri, `glyph_${chars}_${tokenMetadata}_${fontSize}px_${fontFamily.replaceAll(/[,\\\/\.'\s]/g, "_")}.png`);
          await fileService.writeFile(resource, VSBuffer.wrap(new Uint8Array(await blob.arrayBuffer())));
        });
        break;
    }
  }
};
registerEditorAction(DebugEditorGpuRendererAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverActions.js
init_keyCodes();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languages();
init_nls();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.css";
var HoverFocusBehavior;
(function(HoverFocusBehavior2) {
  HoverFocusBehavior2["NoAutoFocus"] = "noAutoFocus";
  HoverFocusBehavior2["FocusIfVisible"] = "focusIfVisible";
  HoverFocusBehavior2["AutoFocusImmediately"] = "autoFocusImmediately";
})(HoverFocusBehavior || (HoverFocusBehavior = {}));
var ShowOrFocusHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: SHOW_OR_FOCUS_HOVER_ACTION_ID,
      label: localize2(1102, "Show or Focus Hover"),
      metadata: {
        description: localize2(1103, "Show or focus the editor hover which shows documentation, references, and other content for a symbol at the current cursor position."),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "focus": {
                description: "Controls if and when the hover should take focus upon being triggered by this action.",
                enum: [HoverFocusBehavior.NoAutoFocus, HoverFocusBehavior.FocusIfVisible, HoverFocusBehavior.AutoFocusImmediately],
                enumDescriptions: [
                  localize(1099, "The hover will not automatically take focus."),
                  localize(1100, "The hover will take focus only if it is already visible."),
                  localize(1101, "The hover will automatically take focus when it appears.")
                ],
                default: HoverFocusBehavior.FocusIfVisible
              }
            }
          }
        }]
      },
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 39
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const focusArgument = args?.focus;
    let focusOption = HoverFocusBehavior.FocusIfVisible;
    if (Object.values(HoverFocusBehavior).includes(focusArgument)) {
      focusOption = focusArgument;
    } else if (typeof focusArgument === "boolean" && focusArgument) {
      focusOption = HoverFocusBehavior.AutoFocusImmediately;
    }
    const showContentHover = (focus) => {
      const position = editor2.getPosition();
      const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
      controller.showContentHover(range, 1, 2, focus);
    };
    const accessibilitySupportEnabled = editor2.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2;
    if (controller.isHoverVisible) {
      if (focusOption !== HoverFocusBehavior.NoAutoFocus) {
        controller.focus();
      } else {
        showContentHover(accessibilitySupportEnabled);
      }
    } else {
      showContentHover(accessibilitySupportEnabled || focusOption === HoverFocusBehavior.AutoFocusImmediately);
    }
  }
};
var ShowDefinitionPreviewHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: SHOW_DEFINITION_PREVIEW_HOVER_ACTION_ID,
      label: localize2(1104, "Show Definition Preview Hover"),
      precondition: void 0,
      metadata: {
        description: localize2(1105, "Show the definition preview hover in the editor.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    if (!position) {
      return;
    }
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const goto = GotoDefinitionAtPositionEditorContribution.get(editor2);
    if (!goto) {
      return;
    }
    const promise = goto.startFindDefinitionFromCursor(position);
    promise.then(() => {
      controller.showContentHover(range, 1, 2, true);
    });
  }
};
var HideContentHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: HIDE_HOVER_ACTION_ID,
      label: localize2(1106, "Hide Hover"),
      alias: "Hide Content Hover",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    ContentHoverController.get(editor2)?.hideContentHover();
  }
};
var ScrollUpHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: SCROLL_UP_HOVER_ACTION_ID,
      label: localize2(1107, "Scroll Up Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1108, "Scroll up the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollUp();
  }
};
var ScrollDownHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: SCROLL_DOWN_HOVER_ACTION_ID,
      label: localize2(1109, "Scroll Down Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1110, "Scroll down the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollDown();
  }
};
var ScrollLeftHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: SCROLL_LEFT_HOVER_ACTION_ID,
      label: localize2(1111, "Scroll Left Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1112, "Scroll left the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollLeft();
  }
};
var ScrollRightHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: SCROLL_RIGHT_HOVER_ACTION_ID,
      label: localize2(1113, "Scroll Right Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1114, "Scroll right the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.scrollRight();
  }
};
var PageUpHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: PAGE_UP_HOVER_ACTION_ID,
      label: localize2(1115, "Page Up Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 11,
        secondary: [
          512 | 16
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1116, "Page up the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.pageUp();
  }
};
var PageDownHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: PAGE_DOWN_HOVER_ACTION_ID,
      label: localize2(1117, "Page Down Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 12,
        secondary: [
          512 | 18
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1118, "Page down the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.pageDown();
  }
};
var GoToTopHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: GO_TO_TOP_HOVER_ACTION_ID,
      label: localize2(1119, "Go To Top Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 14,
        secondary: [
          2048 | 16
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1120, "Go to the top of the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.goToTop();
  }
};
var GoToBottomHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: GO_TO_BOTTOM_HOVER_ACTION_ID,
      label: localize2(1121, "Go To Bottom Hover"),
      precondition: EditorContextKeys.hoverFocused,
      kbOpts: {
        kbExpr: EditorContextKeys.hoverFocused,
        primary: 13,
        secondary: [
          2048 | 18
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1122, "Go to the bottom of the editor hover.")
      }
    });
  }
  run(accessor, editor2) {
    const controller = ContentHoverController.get(editor2);
    if (!controller) {
      return;
    }
    controller.goToBottom();
  }
};
var IncreaseHoverVerbosityLevel = class extends EditorAction {
  constructor() {
    super({
      id: INCREASE_HOVER_VERBOSITY_ACTION_ID,
      label: INCREASE_HOVER_VERBOSITY_ACTION_LABEL,
      alias: "Increase Hover Verbosity Level",
      precondition: EditorContextKeys.hoverVisible
    });
  }
  run(accessor, editor2, args) {
    const hoverController = ContentHoverController.get(editor2);
    if (!hoverController) {
      return;
    }
    const index = args?.index !== void 0 ? args.index : hoverController.focusedHoverPartIndex();
    hoverController.updateHoverVerbosityLevel(HoverVerbosityAction.Increase, index, args?.focus);
  }
};
var DecreaseHoverVerbosityLevel = class extends EditorAction {
  constructor() {
    super({
      id: DECREASE_HOVER_VERBOSITY_ACTION_ID,
      label: DECREASE_HOVER_VERBOSITY_ACTION_LABEL,
      alias: "Decrease Hover Verbosity Level",
      precondition: EditorContextKeys.hoverVisible
    });
  }
  run(accessor, editor2, args) {
    const hoverController = ContentHoverController.get(editor2);
    if (!hoverController) {
      return;
    }
    const index = args?.index !== void 0 ? args.index : hoverController.focusedHoverPartIndex();
    ContentHoverController.get(editor2)?.updateHoverVerbosityLevel(HoverVerbosityAction.Decrease, index, args?.focus);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverContribution.js
init_editorExtensions();
init_colorRegistry();
init_themeService();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markerHoverParticipant.js
init_dom();
init_arrays();
init_async();
init_errors();
init_lifecycle();
init_resources();
init_range();
init_languageFeatures();
init_nls();
init_themables();
init_codicons();
var __decorate84 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param84 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $10 = $;
var MarkerHover = class {
  constructor(owner, range, marker) {
    this.owner = owner;
    this.range = range;
    this.marker = marker;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var markerCodeActionTrigger = {
  type: 1,
  filter: { include: CodeActionKind.QuickFix },
  triggerAction: CodeActionTriggerSource.QuickFixHover
};
var MarkerHoverParticipant = class MarkerHoverParticipant2 {
  constructor(_editor, _markerDecorationsService, _openerService, _languageFeaturesService) {
    this._editor = _editor;
    this._markerDecorationsService = _markerDecorationsService;
    this._openerService = _openerService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 1;
    this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1 && !anchor.supportsMarkerHover) {
      return [];
    }
    const model = this._editor.getModel();
    const anchorRange = anchor.range;
    if (!model.isValidRange(anchor.range)) {
      return [];
    }
    const lineNumber = anchorRange.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const marker = this._markerDecorationsService.getMarker(model.uri, d);
      if (!marker) {
        continue;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkerHover(this, range, marker));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    if (!hoverParts.length) {
      return new RenderedHoverParts([]);
    }
    const renderedHoverParts = [];
    hoverParts.forEach((hoverPart) => {
      const renderedMarkerHover = this._renderMarkerHover(hoverPart);
      context.fragment.appendChild(renderedMarkerHover.hoverElement);
      renderedHoverParts.push(renderedMarkerHover);
    });
    const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
    const disposables = this._renderMarkerStatusbar(context, markerHoverForStatusbar);
    return new RenderedHoverParts(renderedHoverParts, disposables);
  }
  _renderMarkerHover(markerHover) {
    const disposables = new DisposableStore();
    const hoverElement = $10("div.hover-row");
    const markerElement = append(hoverElement, $10("div.marker.hover-contents"));
    const { source, message, code, relatedInformation } = markerHover.marker;
    this._editor.applyFontInfo(markerElement);
    const messageElement = append(markerElement, $10("span"));
    messageElement.style.whiteSpace = "pre-wrap";
    messageElement.innerText = message;
    if (source || code) {
      if (code && typeof code !== "string") {
        const sourceAndCodeElement = $10("span");
        if (source) {
          const sourceElement = append(sourceAndCodeElement, $10("span"));
          sourceElement.innerText = source;
        }
        const codeLink = append(sourceAndCodeElement, $10("a.code-link"));
        codeLink.setAttribute("href", code.target.toString(true));
        disposables.add(addDisposableListener(codeLink, "click", (e) => {
          this._openerService.open(code.target, { allowCommands: true });
          e.preventDefault();
          e.stopPropagation();
        }));
        const codeElement = append(codeLink, $10("span"));
        codeElement.innerText = code.value;
        const detailsElement = append(markerElement, sourceAndCodeElement);
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
      } else {
        const detailsElement = append(markerElement, $10("span"));
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
        detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
      }
    }
    if (isNonEmptyArray(relatedInformation)) {
      for (const { message: message2, resource, startLineNumber, startColumn } of relatedInformation) {
        const relatedInfoContainer = append(markerElement, $10("div"));
        relatedInfoContainer.style.marginTop = "8px";
        const a = append(relatedInfoContainer, $10("a"));
        a.innerText = `${basename2(resource)}(${startLineNumber}, ${startColumn}): `;
        a.style.cursor = "pointer";
        disposables.add(addDisposableListener(a, "click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (this._openerService) {
            const editorOptions = { selection: { startLineNumber, startColumn } };
            this._openerService.open(resource, {
              fromUserGesture: true,
              editorOptions
            }).catch(onUnexpectedError);
          }
        }));
        const messageElement2 = append(relatedInfoContainer, $10("span"));
        messageElement2.innerText = message2;
        this._editor.applyFontInfo(messageElement2);
      }
    }
    const renderedHoverPart = {
      hoverPart: markerHover,
      hoverElement,
      dispose: () => disposables.dispose()
    };
    return renderedHoverPart;
  }
  _renderMarkerStatusbar(context, markerHover) {
    const disposables = new DisposableStore();
    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
      const markerController = MarkerController.get(this._editor);
      if (markerController) {
        context.statusBar.addAction({
          label: localize(1132, "View Problem"),
          commandId: NextMarkerAction.ID,
          run: () => {
            context.hide();
            markerController.showAtMarker(markerHover.marker);
            this._editor.focus();
          }
        });
      }
    }
    if (!this._editor.getOption(
      104
      /* EditorOption.readOnly */
    )) {
      const quickfixPlaceholderElement = context.statusBar.append($10("div"));
      if (this.recentMarkerCodeActionsInfo) {
        if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
          if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
            quickfixPlaceholderElement.textContent = localize(1133, "No quick fixes available");
          }
        } else {
          this.recentMarkerCodeActionsInfo = void 0;
        }
      }
      const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposableTimeout(() => quickfixPlaceholderElement.textContent = localize(1134, "Checking for quick fixes..."), 200, disposables);
      if (!quickfixPlaceholderElement.textContent) {
        quickfixPlaceholderElement.textContent = String.fromCharCode(160);
      }
      const codeActionsPromise = this.getCodeActions(markerHover.marker);
      disposables.add(toDisposable(() => codeActionsPromise.cancel()));
      codeActionsPromise.then((actions) => {
        updatePlaceholderDisposable.dispose();
        this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
        if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
          actions.dispose();
          quickfixPlaceholderElement.textContent = localize(1135, "No quick fixes available");
          return;
        }
        quickfixPlaceholderElement.style.display = "none";
        let showing = false;
        disposables.add(toDisposable(() => {
          if (!showing) {
            actions.dispose();
          }
        }));
        context.statusBar.addAction({
          label: localize(1136, "Quick Fix..."),
          commandId: quickFixCommandId,
          run: (target) => {
            showing = true;
            const controller = CodeActionController.get(this._editor);
            const elementPosition = getDomNodePagePosition(target);
            context.hide();
            controller?.showCodeActions(markerCodeActionTrigger, actions, {
              x: elementPosition.left,
              y: elementPosition.top,
              width: elementPosition.width,
              height: elementPosition.height
            });
          }
        });
        const aiCodeAction = actions.validActions.find((action) => action.action.isAI);
        if (aiCodeAction) {
          context.statusBar.addAction({
            label: aiCodeAction.action.title,
            commandId: aiCodeAction.action.command?.id ?? "",
            iconClass: ThemeIcon.asClassName(Codicon.sparkle),
            run: () => {
              const controller = CodeActionController.get(this._editor);
              controller?.applyCodeAction(aiCodeAction, false, false, ApplyCodeActionReason.FromProblemsHover);
            }
          });
        }
        context.onContentsChanged();
      }, onUnexpectedError);
    }
    return disposables;
  }
  getCodeActions(marker) {
    return createCancelablePromise((cancellationToken) => {
      return getCodeActions(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
    });
  }
};
MarkerHoverParticipant = __decorate84([
  __param84(1, IMarkerDecorationsService),
  __param84(2, IOpenerService),
  __param84(3, ILanguageFeaturesService)
], MarkerHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/glyphHoverController.js
init_lifecycle();
init_instantiation();
init_async();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/glyphHoverWidget.js
init_dom();
init_lifecycle();
init_language();

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/glyphHoverComputer.js
init_arrays();
init_htmlContent();
init_model2();
var GlyphHoverComputer = class {
  constructor(_editor) {
    this._editor = _editor;
  }
  computeSync(opts) {
    const toHoverMessage = (contents) => {
      return {
        value: contents
      };
    };
    const lineDecorations = this._editor.getLineDecorations(opts.lineNumber);
    const result = [];
    const isLineHover = opts.laneOrLine === "lineNo";
    if (!lineDecorations) {
      return result;
    }
    for (const d of lineDecorations) {
      const lane = d.options.glyphMargin?.position ?? GlyphMarginLane.Center;
      if (!isLineHover && lane !== opts.laneOrLine) {
        continue;
      }
      const hoverMessage = isLineHover ? d.options.lineNumberHoverMessage : d.options.glyphMarginHoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      result.push(...asArray(hoverMessage).map(toHoverMessage));
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/glyphHoverWidget.js
var __decorate85 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param85 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GlyphHoverWidget_1;
var $11 = $;
var _a53;
var GlyphHoverWidget = (_a53 = class extends Disposable {
  constructor(editor2, languageService, openerService) {
    super();
    this._renderDisposeables = this._register(new DisposableStore());
    this._editor = editor2;
    this._isVisible = false;
    this._messages = [];
    this._hover = this._register(new HoverWidget(true));
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this._markdownRenderer = new MarkdownRenderer({ editor: this._editor }, languageService, openerService);
    this._hoverOperation = this._register(new HoverOperation(this._editor, new GlyphHoverComputer(this._editor)));
    this._register(this._hoverOperation.onResult((result) => this._withResult(result)));
    this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    this._register(addStandardDisposableListener(this._hover.containerDomNode, "mouseleave", (e) => {
      this._onMouseLeave(e);
    }));
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._hoverComputerOptions = void 0;
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return GlyphHoverWidget_1.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _onModelDecorationsChanged() {
    if (this._isVisible && this._hoverComputerOptions) {
      this._hoverOperation.cancel();
      this._hoverOperation.start(0, this._hoverComputerOptions);
    }
  }
  showsOrWillShow(mouseEvent) {
    const target = mouseEvent.target;
    if (target.type === 2 && target.detail.glyphMarginLane) {
      this._startShowingAt(target.position.lineNumber, target.detail.glyphMarginLane);
      return true;
    }
    if (target.type === 3) {
      this._startShowingAt(target.position.lineNumber, "lineNo");
      return true;
    }
    return false;
  }
  _startShowingAt(lineNumber, laneOrLine) {
    if (this._hoverComputerOptions && this._hoverComputerOptions.lineNumber === lineNumber && this._hoverComputerOptions.laneOrLine === laneOrLine) {
      return;
    }
    this._hoverOperation.cancel();
    this.hide();
    this._hoverComputerOptions = { lineNumber, laneOrLine };
    this._hoverOperation.start(0, this._hoverComputerOptions);
  }
  hide() {
    this._hoverComputerOptions = void 0;
    this._hoverOperation.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
  }
  _withResult(result) {
    this._messages = result.value;
    if (this._messages.length > 0) {
      this._renderMessages(result.options.lineNumber, result.options.laneOrLine, this._messages);
    } else {
      this.hide();
    }
  }
  _renderMessages(lineNumber, laneOrLine, messages) {
    this._renderDisposeables.clear();
    const fragment = document.createDocumentFragment();
    for (const msg of messages) {
      const markdownHoverElement = $11("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $11("div.hover-contents"));
      const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
      hoverContentsElement.appendChild(renderedContents.element);
      fragment.appendChild(markdownHoverElement);
    }
    this._updateContents(fragment);
    this._showAt(lineNumber, laneOrLine);
  }
  _updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._updateFont();
  }
  _showAt(lineNumber, laneOrLine) {
    if (!this._isVisible) {
      this._isVisible = true;
      this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    }
    const editorLayout = this._editor.getLayoutInfo();
    const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
    const editorScrollTop = this._editor.getScrollTop();
    const lineHeight = this._editor.getOption(
      75
      /* EditorOption.lineHeight */
    );
    const nodeHeight = this._hover.containerDomNode.clientHeight;
    const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
    const left = editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth + (laneOrLine === "lineNo" ? editorLayout.lineNumbersWidth : 0);
    this._hover.containerDomNode.style.left = `${left}px`;
    this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
    this._hover.containerDomNode.style.zIndex = "11";
  }
  _onMouseLeave(e) {
    const editorDomNode = this._editor.getDomNode();
    const isMousePositionOutsideOfEditor = !editorDomNode || !isMousePositionWithinElement(editorDomNode, e.x, e.y);
    if (isMousePositionOutsideOfEditor) {
      this.hide();
    }
  }
}, GlyphHoverWidget_1 = _a53, _a53.ID = "editor.contrib.modesGlyphHoverWidget", _a53);
GlyphHoverWidget = GlyphHoverWidget_1 = __decorate85([
  __param85(1, ILanguageService),
  __param85(2, IOpenerService)
], GlyphHoverWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/glyphHoverController.js
var __decorate86 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param86 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _sticky3 = false;
var _a54;
var GlyphHoverController = (_a54 = class extends Disposable {
  constructor(_editor, _instantiationService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this.shouldKeepOpenOnEditorMouseMoveOrLeave = false;
    this._listenersStore = new DisposableStore();
    this._hoverState = {
      mouseDown: false
    };
    this._reactToEditorMouseMoveRunner = this._register(new RunOnceScheduler(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0));
    this._hookListeners();
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        69
        /* EditorOption.hover */
      )) {
        this._unhookListeners();
        this._hookListeners();
      }
    }));
  }
  _hookListeners() {
    const hoverOpts = this._editor.getOption(
      69
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: hoverOpts.enabled,
      sticky: hoverOpts.sticky,
      hidingDelay: hoverOpts.hidingDelay
    };
    if (hoverOpts.enabled) {
      this._listenersStore.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp()));
      this._listenersStore.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._listenersStore.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    } else {
      this._listenersStore.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._listenersStore.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    }
    this._listenersStore.add(this._editor.onMouseLeave((e) => this._onEditorMouseLeave(e)));
    this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler();
      this.hideGlyphHover();
    }));
    this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler()));
    this._listenersStore.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0;
    this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this.hideGlyphHover();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._hoverState.mouseDown = true;
    const shouldNotHideCurrentHoverWidget = this._isMouseOnGlyphHoverWidget(mouseEvent);
    if (shouldNotHideCurrentHoverWidget) {
      return;
    }
    this.hideGlyphHover();
  }
  _isMouseOnGlyphHoverWidget(mouseEvent) {
    const glyphHoverWidgetNode = this._glyphWidget?.getDomNode();
    if (glyphHoverWidgetNode) {
      return isMousePositionWithinElement(glyphHoverWidgetNode, mouseEvent.event.posx, mouseEvent.event.posy);
    }
    return false;
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = false;
  }
  _onEditorMouseLeave(mouseEvent) {
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave) {
      return;
    }
    this._cancelScheduler();
    const shouldNotHideCurrentHoverWidget = this._isMouseOnGlyphHoverWidget(mouseEvent);
    if (shouldNotHideCurrentHoverWidget) {
      return;
    }
    if (_sticky3) {
      return;
    }
    this.hideGlyphHover();
  }
  _shouldNotRecomputeCurrentHoverWidget(mouseEvent) {
    const isHoverSticky = this._hoverSettings.sticky;
    const isMouseOnGlyphHoverWidget = this._isMouseOnGlyphHoverWidget(mouseEvent);
    return isHoverSticky && isMouseOnGlyphHoverWidget;
  }
  _onEditorMouseMove(mouseEvent) {
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave) {
      return;
    }
    this._mouseMoveEvent = mouseEvent;
    const shouldNotRecomputeCurrentHoverWidget = this._shouldNotRecomputeCurrentHoverWidget(mouseEvent);
    if (shouldNotRecomputeCurrentHoverWidget) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    this._reactToEditorMouseMove(mouseEvent);
  }
  _reactToEditorMouseMove(mouseEvent) {
    if (!mouseEvent) {
      return;
    }
    const glyphWidgetShowsOrWillShow = this._tryShowHoverWidget(mouseEvent);
    if (glyphWidgetShowsOrWillShow) {
      return;
    }
    if (_sticky3) {
      return;
    }
    this.hideGlyphHover();
  }
  _tryShowHoverWidget(mouseEvent) {
    const glyphWidget = this._getOrCreateGlyphWidget();
    return glyphWidget.showsOrWillShow(mouseEvent);
  }
  _onKeyDown(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4) {
      return;
    }
    this.hideGlyphHover();
  }
  hideGlyphHover() {
    if (_sticky3) {
      return;
    }
    this._glyphWidget?.hide();
  }
  _getOrCreateGlyphWidget() {
    if (!this._glyphWidget) {
      this._glyphWidget = this._instantiationService.createInstance(GlyphHoverWidget, this._editor);
    }
    return this._glyphWidget;
  }
  dispose() {
    super.dispose();
    this._unhookListeners();
    this._listenersStore.dispose();
    this._glyphWidget?.dispose();
  }
}, _a54.ID = "editor.contrib.marginHover", _a54);
GlyphHoverController = __decorate86([
  __param86(1, IInstantiationService)
], GlyphHoverController);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverContribution.js
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverAccessibleViews.js
var HoverAccessibleView = class {
};
var HoverAccessibilityHelp = class {
};
var ExtHoverAccessibleView = class {
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverContribution.js
registerEditorContribution(
  ContentHoverController.ID,
  ContentHoverController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorContribution(
  GlyphHoverController.ID,
  GlyphHoverController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(ShowOrFocusHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
registerEditorAction(HideContentHoverAction);
registerEditorAction(ScrollUpHoverAction);
registerEditorAction(ScrollDownHoverAction);
registerEditorAction(ScrollLeftHoverAction);
registerEditorAction(ScrollRightHoverAction);
registerEditorAction(PageUpHoverAction);
registerEditorAction(PageDownHoverAction);
registerEditorAction(GoToTopHoverAction);
registerEditorAction(GoToBottomHoverAction);
registerEditorAction(IncreaseHoverVerbosityLevel);
registerEditorAction(DecreaseHoverVerbosityLevel);
HoverParticipantRegistry.register(MarkdownHoverParticipant);
HoverParticipantRegistry.register(MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
  }
});
AccessibleViewRegistry.register(new HoverAccessibleView());
AccessibleViewRegistry.register(new HoverAccessibilityHelp());
AccessibleViewRegistry.register(new ExtHoverAccessibleView());

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_lifecycle();
init_strings();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_model();

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/common/indentUtils.js
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    if (str.charAt(i2) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    const tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i2 = 0; i2 < tabsCnt; i2++) {
      result += "	";
    }
  }
  for (let i2 = 0; i2 < spacesCnt; i2++) {
    result += " ";
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_nls();

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/common/indentation.js
init_strings();
init_indentation();
init_selection();
function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  const indentationRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;
  if (!indentationRulesSupport) {
    return [];
  }
  const processedIndentRulesSupport = new ProcessedIndentRulesSupport(model, indentationRulesSupport, languageConfigurationService);
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!processedIndentRulesSupport.shouldIgnore(startLineNumber)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const { tabSize, indentSize, insertSpaces } = model.getOptions();
  const shiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const unshiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const indentEdits = [];
  const currentLineText = model.getLineContent(startLineNumber);
  let globalIndent = getLeadingWhitespace(currentLineText);
  let idealIndentForNextLine = globalIndent;
  if (processedIndentRulesSupport.shouldIncrease(startLineNumber)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (processedIndentRulesSupport.shouldIndentNextLine(startLineNumber)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    if (doesLineStartWithString(model, lineNumber)) {
      continue;
    }
    const text = model.getLineContent(lineNumber);
    const oldIndentation = getLeadingWhitespace(text);
    const currentIdealIndent = idealIndentForNextLine;
    if (processedIndentRulesSupport.shouldDecrease(lineNumber, currentIdealIndent)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (processedIndentRulesSupport.shouldIgnore(lineNumber)) {
      continue;
    } else if (processedIndentRulesSupport.shouldIncrease(lineNumber, currentIdealIndent)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (processedIndentRulesSupport.shouldIndentNextLine(lineNumber, currentIdealIndent)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
function doesLineStartWithString(model, lineNumber) {
  if (!model.tokenization.isCheapToTokenize(lineNumber)) {
    return false;
  }
  const lineTokens = model.tokenization.getLineTokens(lineNumber);
  return lineTokens.getStandardTokenType(0) === 2;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_lineTokens();
var __decorate87 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param87 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _IndentationToSpacesAction = class _IndentationToSpacesAction extends EditorAction {
  constructor() {
    super({
      id: _IndentationToSpacesAction.ID,
      label: localize2(1141, "Convert Indentation to Spaces"),
      precondition: EditorContextKeys.writable,
      metadata: {
        description: localize2(1142, "Convert the tab indentation to spaces.")
      }
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: true
    });
  }
};
_IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
var IndentationToSpacesAction = _IndentationToSpacesAction;
var _IndentationToTabsAction = class _IndentationToTabsAction extends EditorAction {
  constructor() {
    super({
      id: _IndentationToTabsAction.ID,
      label: localize2(1143, "Convert Indentation to Tabs"),
      precondition: EditorContextKeys.writable,
      metadata: {
        description: localize2(1144, "Convert the spaces indentation to tabs.")
      }
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: false
    });
  }
};
_IndentationToTabsAction.ID = "editor.action.indentationToTabs";
var IndentationToTabsAction = _IndentationToTabsAction;
var ChangeIndentationSizeAction = class extends EditorAction {
  constructor(insertSpaces, displaySizeOnly, opts) {
    super(opts);
    this.insertSpaces = insertSpaces;
    this.displaySizeOnly = displaySizeOnly;
  }
  run(accessor, editor2) {
    const quickInputService = accessor.get(IQuickInputService);
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    const modelOpts = model.getOptions();
    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n2) => ({
      id: n2.toString(),
      label: n2.toString(),
      // add description for tabSize value set in the configuration
      description: n2 === creationOpts.tabSize && n2 === modelOpts.tabSize ? localize(1137, "Configured Tab Size") : n2 === creationOpts.tabSize ? localize(1138, "Default Tab Size") : n2 === modelOpts.tabSize ? localize(1139, "Current Tab Size") : void 0
    }));
    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
    setTimeout(
      () => {
        quickInputService.pick(picks, { placeHolder: localize(1140, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then((pick) => {
          if (pick) {
            if (model && !model.isDisposed()) {
              const pickedVal = parseInt(pick.label, 10);
              if (this.displaySizeOnly) {
                model.updateOptions({
                  tabSize: pickedVal
                });
              } else {
                model.updateOptions({
                  tabSize: pickedVal,
                  indentSize: pickedVal,
                  insertSpaces: this.insertSpaces
                });
              }
            }
          }
        });
      },
      50
      /* quick input is sensitive to being opened so soon after another */
    );
  }
};
var _IndentUsingTabs = class _IndentUsingTabs extends ChangeIndentationSizeAction {
  constructor() {
    super(false, false, {
      id: _IndentUsingTabs.ID,
      label: localize2(1145, "Indent Using Tabs"),
      precondition: void 0,
      metadata: {
        description: localize2(1146, "Use indentation with tabs.")
      }
    });
  }
};
_IndentUsingTabs.ID = "editor.action.indentUsingTabs";
var IndentUsingTabs = _IndentUsingTabs;
var _IndentUsingSpaces = class _IndentUsingSpaces extends ChangeIndentationSizeAction {
  constructor() {
    super(true, false, {
      id: _IndentUsingSpaces.ID,
      label: localize2(1147, "Indent Using Spaces"),
      precondition: void 0,
      metadata: {
        description: localize2(1148, "Use indentation with spaces.")
      }
    });
  }
};
_IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
var IndentUsingSpaces = _IndentUsingSpaces;
var _ChangeTabDisplaySize = class _ChangeTabDisplaySize extends ChangeIndentationSizeAction {
  constructor() {
    super(true, true, {
      id: _ChangeTabDisplaySize.ID,
      label: localize2(1149, "Change Tab Display Size"),
      precondition: void 0,
      metadata: {
        description: localize2(1150, "Change the space size equivalent of the tab.")
      }
    });
  }
};
_ChangeTabDisplaySize.ID = "editor.action.changeTabDisplaySize";
var ChangeTabDisplaySize = _ChangeTabDisplaySize;
var _DetectIndentation = class _DetectIndentation extends EditorAction {
  constructor() {
    super({
      id: _DetectIndentation.ID,
      label: localize2(1151, "Detect Indentation from Content"),
      precondition: void 0,
      metadata: {
        description: localize2(1152, "Detect the indentation from content.")
      }
    });
  }
  run(accessor, editor2) {
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
  }
};
_DetectIndentation.ID = "editor.action.detectIndentation";
var DetectIndentation = _DetectIndentation;
var ReindentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: localize2(1153, "Reindent Lines"),
      precondition: EditorContextKeys.writable,
      metadata: {
        description: localize2(1154, "Reindent the lines of the editor.")
      }
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
var ReindentSelectedLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: localize2(1155, "Reindent Selected Lines"),
      precondition: EditorContextKeys.writable,
      metadata: {
        description: localize2(1156, "Reindent the selected lines of the editor.")
      }
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const edits = [];
    for (const selection of selections) {
      let startLineNumber = selection.startLineNumber;
      let endLineNumber = selection.endLineNumber;
      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      if (startLineNumber === 1) {
        if (startLineNumber === endLineNumber) {
          continue;
        }
      } else {
        startLineNumber--;
      }
      const editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);
      edits.push(...editOperations);
    }
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
var AutoIndentOnPasteCommand = class {
  constructor(edits, initialSelection) {
    this._initialSelection = initialSelection;
    this._edits = [];
    this._selectionId = null;
    for (const edit of edits) {
      if (edit.range && typeof edit.text === "string") {
        this._edits.push(edit);
      }
    }
  }
  getEditOperations(model, builder) {
    for (const edit of this._edits) {
      builder.addEditOperation(Range.lift(edit.range), edit.text);
    }
    let selectionIsSet = false;
    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, true);
      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, false);
      }
    }
    if (!selectionIsSet) {
      this._selectionId = builder.trackSelection(this._initialSelection);
    }
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
var _a55;
var AutoIndentOnPaste = (_a55 = class {
  constructor(editor2, _languageConfigurationService) {
    this.editor = editor2;
    this._languageConfigurationService = _languageConfigurationService;
    this.callOnDispose = new DisposableStore();
    this.callOnModel = new DisposableStore();
    this.callOnDispose.add(editor2.onDidChangeConfiguration(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModel(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear();
    if (!this.editor.getOption(
      17
      /* EditorOption.autoIndentOnPaste */
    ) || this.editor.getOption(
      16
      /* EditorOption.autoIndent */
    ) < 4) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
      this.trigger(range);
    }));
  }
  trigger(range) {
    const selections = this.editor.getSelections();
    if (selections === null || selections.length > 1) {
      return;
    }
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    const containsOnlyWhitespace = this.rangeContainsOnlyWhitespaceCharacters(model, range);
    if (containsOnlyWhitespace) {
      return;
    }
    if (!this.editor.getOption(
      18
      /* EditorOption.autoIndentOnPasteWithinString */
    ) && isStartOrEndInString(model, range)) {
      return;
    }
    if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber)) {
      return;
    }
    const autoIndent = this.editor.getOption(
      16
      /* EditorOption.autoIndent */
    );
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const textEdits = [];
    const indentConverter = {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
    let startLineNumber = range.startLineNumber;
    let firstLineText = model.getLineContent(startLineNumber);
    if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
      const indentOfFirstLine = getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter, this._languageConfigurationService);
      if (indentOfFirstLine !== null) {
        const oldIndentation = getLeadingWhitespace(firstLineText);
        const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        if (newSpaceCnt !== oldSpaceCnt) {
          const newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
          textEdits.push({
            range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
            text: newIndent
          });
          firstLineText = newIndent + firstLineText.substring(oldIndentation.length);
        } else {
          const indentMetadata = getIndentMetadata(model, startLineNumber, this._languageConfigurationService);
          if (indentMetadata === 0 || indentMetadata === 8) {
            return;
          }
        }
      }
    }
    const firstLineNumber = startLineNumber;
    while (startLineNumber < range.endLineNumber) {
      if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber !== range.endLineNumber) {
      const virtualModel = {
        tokenization: {
          getLineTokens: (lineNumber) => {
            return model.tokenization.getLineTokens(lineNumber);
          },
          getLanguageId: () => {
            return model.getLanguageId();
          },
          getLanguageIdAtPosition: (lineNumber, column) => {
            return model.getLanguageIdAtPosition(lineNumber, column);
          }
        },
        getLineContent: (lineNumber) => {
          if (lineNumber === firstLineNumber) {
            return firstLineText;
          } else {
            return model.getLineContent(lineNumber);
          }
        }
      };
      const indentOfSecondLine = getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter, this._languageConfigurationService);
      if (indentOfSecondLine !== null) {
        const newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
        const oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
          const spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
          for (let i2 = startLineNumber + 1; i2 <= range.endLineNumber; i2++) {
            const lineContent = model.getLineContent(i2);
            const originalIndent = getLeadingWhitespace(lineContent);
            const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            const newSpacesCnt = originalSpacesCnt + spaceCntOffset;
            const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
              textEdits.push({
                range: new Range(i2, 1, i2, originalIndent.length + 1),
                text: newIndent
              });
            }
          }
        }
      }
    }
    if (textEdits.length > 0) {
      this.editor.pushUndoStop();
      const cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", cmd);
      this.editor.pushUndoStop();
    }
  }
  rangeContainsOnlyWhitespaceCharacters(model, range) {
    const lineContainsOnlyWhitespace = (content) => {
      return content.trim().length === 0;
    };
    let containsOnlyWhitespace = true;
    if (range.startLineNumber === range.endLineNumber) {
      const lineContent = model.getLineContent(range.startLineNumber);
      const linePart = lineContent.substring(range.startColumn - 1, range.endColumn - 1);
      containsOnlyWhitespace = lineContainsOnlyWhitespace(linePart);
    } else {
      for (let i2 = range.startLineNumber; i2 <= range.endLineNumber; i2++) {
        const lineContent = model.getLineContent(i2);
        if (i2 === range.startLineNumber) {
          const linePart = lineContent.substring(range.startColumn - 1);
          containsOnlyWhitespace = lineContainsOnlyWhitespace(linePart);
        } else if (i2 === range.endLineNumber) {
          const linePart = lineContent.substring(0, range.endColumn - 1);
          containsOnlyWhitespace = lineContainsOnlyWhitespace(linePart);
        } else {
          containsOnlyWhitespace = model.getLineFirstNonWhitespaceColumn(i2) === 0;
        }
        if (!containsOnlyWhitespace) {
          break;
        }
      }
    }
    return containsOnlyWhitespace;
  }
  dispose() {
    this.callOnDispose.dispose();
    this.callOnModel.dispose();
  }
}, _a55.ID = "editor.contrib.autoIndentOnPaste", _a55);
AutoIndentOnPaste = __decorate87([
  __param87(1, ILanguageConfigurationService)
], AutoIndentOnPaste);
function isStartOrEndInString(model, range) {
  const isPositionInString = (position) => {
    const tokenType = getStandardTokenTypeAtPosition(model, position);
    return tokenType === 2;
  };
  return isPositionInString(range.getStartPosition()) || isPositionInString(range.getEndPosition());
}
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i2 = 0; i2 < tabSize; i2++) {
    spaces += " ";
  }
  const spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
var IndentationToSpacesCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, true);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
var IndentationToTabsCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, false);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
registerEditorContribution(
  AutoIndentOnPaste.ID,
  AutoIndentOnPaste,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(ChangeTabDisplaySize);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsContribution.js
init_editorExtensions();
registerEditorContribution(
  InlayHintsController.ID,
  InlayHintsController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
HoverParticipantRegistry.register(InlayHintsHover);

// node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_inPlaceReplace2 = __toESM(require_inPlaceReplace());

// node_modules/monaco-editor/esm/vs/editor/contrib/insertFinalNewLine/browser/insertFinalNewLine.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/insertFinalNewLine/browser/insertFinalNewLineCommand.js
init_strings();
init_position();
var InsertFinalNewLineCommand = class {
  constructor(selection) {
    this._selection = selection;
    this._selectionId = null;
  }
  getEditOperations(model, builder) {
    const op = insertFinalNewLine(model);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
function insertFinalNewLine(model) {
  const lineCount = model.getLineCount();
  const lastLine = model.getLineContent(lineCount);
  const lastLineIsEmptyOrWhitespace = lastNonWhitespaceIndex(lastLine) === -1;
  if (!lineCount || lastLineIsEmptyOrWhitespace) {
    return;
  }
  return EditOperation.insert(new Position(lineCount, model.getLineMaxColumn(lineCount)), model.getEOL());
}

// node_modules/monaco-editor/esm/vs/editor/contrib/insertFinalNewLine/browser/insertFinalNewLine.js
init_editorContextKeys();
init_nls();
var _InsertFinalNewLineAction = class _InsertFinalNewLineAction extends EditorAction {
  constructor() {
    super({
      id: _InsertFinalNewLineAction.ID,
      label: localize2(1232, "Insert Final New Line"),
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2, args) {
    const selection = editor2.getSelection();
    if (selection === null) {
      return;
    }
    const command = new InsertFinalNewLineCommand(selection);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
  }
};
_InsertFinalNewLineAction.ID = "editor.action.insertFinalNewLine";
var InsertFinalNewLineAction = _InsertFinalNewLineAction;
registerEditorAction(InsertFinalNewLineAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/lineSelection/browser/lineSelection.js
init_editorExtensions();
init_editorContextKeys();
init_nls();
var ExpandLineSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "expandLineSelection",
      label: localize2(1233, "Expand Line Selection"),
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 42
        /* KeyCode.KeyL */
      }
    });
  }
  run(_accessor, editor2, args) {
    args = args || {};
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    viewModel.model.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
    viewModel.revealAllCursors(args.source, true);
  }
};
registerEditorAction(ExpandLineSelectionAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_keyCodes();
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js
init_strings();
init_range();
var TrimTrailingWhitespaceCommand = class {
  constructor(selection, cursors, trimInRegexesAndStrings) {
    this._selection = selection;
    this._cursors = cursors;
    this._selectionId = null;
    this._trimInRegexesAndStrings = trimInRegexesAndStrings;
  }
  getEditOperations(model, builder) {
    const ops = trimTrailingWhitespace(model, this._cursors, this._trimInRegexesAndStrings);
    for (let i2 = 0, len = ops.length; i2 < len; i2++) {
      const op = ops[i2];
      builder.addEditOperation(op.range, op.text);
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
function trimTrailingWhitespace(model, cursors, trimInRegexesAndStrings) {
  cursors.sort((a, b) => {
    if (a.lineNumber === b.lineNumber) {
      return a.column - b.column;
    }
    return a.lineNumber - b.lineNumber;
  });
  for (let i2 = cursors.length - 2; i2 >= 0; i2--) {
    if (cursors[i2].lineNumber === cursors[i2 + 1].lineNumber) {
      cursors.splice(i2, 1);
    }
  }
  const r = [];
  let rLen = 0;
  let cursorIndex = 0;
  const cursorLen = cursors.length;
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    const lineContent = model.getLineContent(lineNumber);
    const maxLineColumn = lineContent.length + 1;
    let minEditColumn = 0;
    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
      minEditColumn = cursors[cursorIndex].column;
      cursorIndex++;
      if (minEditColumn === maxLineColumn) {
        continue;
      }
    }
    if (lineContent.length === 0) {
      continue;
    }
    const lastNonWhitespaceIndex2 = lastNonWhitespaceIndex(lineContent);
    let fromColumn = 0;
    if (lastNonWhitespaceIndex2 === -1) {
      fromColumn = 1;
    } else if (lastNonWhitespaceIndex2 !== lineContent.length - 1) {
      fromColumn = lastNonWhitespaceIndex2 + 2;
    } else {
      continue;
    }
    if (!trimInRegexesAndStrings) {
      if (!model.tokenization.hasAccurateTokensForLine(lineNumber)) {
        continue;
      }
      const lineTokens = model.tokenization.getLineTokens(lineNumber);
      const fromColumnType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(fromColumn));
      if (fromColumnType === 2 || fromColumnType === 3) {
        continue;
      }
    }
    fromColumn = Math.max(minEditColumn, fromColumn);
    r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));
  }
  return r;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_position();
init_range();
init_selection();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/copyLinesCommand.js
init_range();
init_selection();
var CopyLinesCommand = class {
  constructor(selection, isCopyingDown, noop) {
    this._selection = selection;
    this._isCopyingDown = isCopyingDown;
    this._noop = noop || false;
    this._selectionDirection = 0;
    this._selectionId = null;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._endLineNumberDelta = 1;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const sourceLines = [];
    for (let i2 = s.startLineNumber; i2 <= s.endLineNumber; i2++) {
      sourceLines.push(model.getLineContent(i2));
    }
    const sourceText = sourceLines.join("\n");
    if (sourceText === "") {
      if (this._isCopyingDown) {
        this._startLineNumberDelta++;
        this._endLineNumberDelta++;
      }
    }
    if (this._noop) {
      builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
    } else {
      if (!this._isCopyingDown) {
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
      } else {
        builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
      }
    }
    this._selectionId = builder.trackSelection(s);
    this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let startLineNumber = result.startLineNumber;
      let startColumn = result.startColumn;
      let endLineNumber = result.endLineNumber;
      let endColumn = result.endColumn;
      if (this._startLineNumberDelta !== 0) {
        startLineNumber = startLineNumber + this._startLineNumberDelta;
        startColumn = 1;
      }
      if (this._endLineNumberDelta !== 0) {
        endLineNumber = endLineNumber + this._endLineNumberDelta;
        endColumn = 1;
      }
      result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js
init_strings();
init_range();
init_selection();
init_languageConfiguration();
init_languageConfigurationRegistry();
var __decorate88 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param88 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MoveLinesCommand = class MoveLinesCommand2 {
  constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {
    this._languageConfigurationService = _languageConfigurationService;
    this._selection = selection;
    this._isMovingDown = isMovingDown;
    this._autoIndent = autoIndent;
    this._selectionId = null;
    this._moveEndLineSelectionShrink = false;
  }
  getEditOperations(model, builder) {
    const getLanguageId = () => {
      return model.getLanguageId();
    };
    const getLanguageIdAtPosition = (lineNumber, column) => {
      return model.getLanguageIdAtPosition(lineNumber, column);
    };
    const modelLineCount = model.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = false;
    let s = this._selection;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
      const lineNumber = s.startLineNumber;
      const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
      if (model.getLineMaxColumn(otherLineNumber) === 1) {
        builder.addEditOperation(new Range(1, 1, 1, 1), null);
      } else {
        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
      }
      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
    } else {
      let movingLineNumber;
      let movingLineText;
      if (this._isMovingDown) {
        movingLineNumber = s.endLineNumber + 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
        let insertingText = movingLineText;
        if (this.shouldAutoIndent(model, s)) {
          const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
          if (movingLineMatchResult !== null) {
            const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
            const newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
            const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
            insertingText = newIndentation + this.trimStart(movingLineText);
          } else {
            const virtualModel = {
              tokenization: {
                getLineTokens: (lineNumber) => {
                  if (lineNumber === s.startLineNumber) {
                    return model.tokenization.getLineTokens(movingLineNumber);
                  } else {
                    return model.tokenization.getLineTokens(lineNumber);
                  }
                },
                getLanguageId,
                getLanguageIdAtPosition
              },
              getLineContent: (lineNumber) => {
                if (lineNumber === s.startLineNumber) {
                  return model.getLineContent(movingLineNumber);
                } else {
                  return model.getLineContent(lineNumber);
                }
              }
            };
            const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfMovingLine !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimStart(movingLineText);
              }
            }
          }
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
          const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            const virtualModel = {
              tokenization: {
                getLineTokens: (lineNumber) => {
                  if (lineNumber === s.startLineNumber) {
                    return model.tokenization.getLineTokens(movingLineNumber);
                  } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                    return model.tokenization.getLineTokens(lineNumber - 1);
                  } else {
                    return model.tokenization.getLineTokens(lineNumber);
                  }
                },
                getLanguageId,
                getLanguageIdAtPosition
              },
              getLineContent: (lineNumber) => {
                if (lineNumber === s.startLineNumber) {
                  return insertingText;
                } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                  return model.getLineContent(lineNumber - 1);
                } else {
                  return model.getLineContent(lineNumber);
                }
              }
            };
            const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);
            if (newIndentatOfMovingBlock !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        } else {
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
        }
      } else {
        movingLineNumber = s.startLineNumber - 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
        if (this.shouldAutoIndent(model, s)) {
          const virtualModel = {
            tokenization: {
              getLineTokens: (lineNumber) => {
                if (lineNumber === movingLineNumber) {
                  return model.tokenization.getLineTokens(s.startLineNumber);
                } else {
                  return model.tokenization.getLineTokens(lineNumber);
                }
              },
              getLanguageId,
              getLanguageIdAtPosition
            },
            getLineContent: (lineNumber) => {
              if (lineNumber === movingLineNumber) {
                return model.getLineContent(s.startLineNumber);
              } else {
                return model.getLineContent(lineNumber);
              }
            }
          };
          const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfFirstLine !== null) {
              const oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  buildIndentConverter(tabSize, indentSize, insertSpaces) {
    return {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
  }
  parseEnterResult(model, indentConverter, tabSize, line, enter) {
    if (enter) {
      let enterPrefix = enter.indentation;
      if (enter.indentAction === IndentAction.None) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.Indent) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.IndentOutdent) {
        enterPrefix = enter.indentation;
      } else if (enter.indentAction === IndentAction.Outdent) {
        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
      }
      const movingLineText = model.getLineContent(line);
      if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {
        const oldIndentation = getLeadingWhitespace(model.getLineContent(line));
        let newIndentation = getLeadingWhitespace(enterPrefix);
        const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);
        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
          newIndentation = indentConverter.unshiftIndent(newIndentation);
        }
        const newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        return newSpaceCnt - oldSpaceCnt;
      }
    }
    return null;
  }
  /**
   *
   * @param model
   * @param indentConverter
   * @param tabSize
   * @param line the line moving down
   * @param futureAboveLineNumber the line which will be at the `line` position
   * @param futureAboveLineText
   */
  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
    if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
      const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
      const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    } else {
      let validPrecedingLine = line - 1;
      while (validPrecedingLine >= 1) {
        const lineContent = model.getLineContent(validPrecedingLine);
        const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
        if (nonWhitespaceIdx >= 0) {
          break;
        }
        validPrecedingLine--;
      }
      if (validPrecedingLine < 1 || line > model.getLineCount()) {
        return null;
      }
      const maxColumn = model.getLineMaxColumn(validPrecedingLine);
      const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    }
  }
  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
    let validPrecedingLine = oneLineAbove;
    while (validPrecedingLine >= 1) {
      let lineContent;
      if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) {
        lineContent = previousLineText;
      } else {
        lineContent = model.getLineContent(validPrecedingLine);
      }
      const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
      if (nonWhitespaceIdx >= 0) {
        break;
      }
      validPrecedingLine--;
    }
    if (validPrecedingLine < 1 || line > model.getLineCount()) {
      return null;
    }
    const maxColumn = model.getLineMaxColumn(validPrecedingLine);
    const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
  }
  trimStart(str) {
    return str.replace(/^\s+/, "");
  }
  shouldAutoIndent(model, selection) {
    if (this._autoIndent < 4) {
      return false;
    }
    if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {
      return false;
    }
    const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
    const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
    if (languageAtSelectionStart !== languageAtSelectionEnd) {
      return false;
    }
    if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {
      return false;
    }
    return true;
  }
  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
    for (let i2 = s.startLineNumber; i2 <= s.endLineNumber; i2++) {
      const lineContent = model.getLineContent(i2);
      const originalIndent = getLeadingWhitespace(lineContent);
      const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
      const newSpacesCnt = originalSpacesCnt + offset;
      const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
      if (newIndent !== originalIndent) {
        builder.addEditOperation(new Range(i2, 1, i2, originalIndent.length + 1), newIndent);
        if (i2 === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
          this._moveEndLineSelectionShrink = true;
        }
      }
    }
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
      result = result.setEndPosition(result.endLineNumber, 2);
    }
    return result;
  }
};
MoveLinesCommand = __decorate88([
  __param88(3, ILanguageConfigurationService)
], MoveLinesCommand);

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/sortLinesCommand.js
init_date();
init_range();
var _SortLinesCommand = class _SortLinesCommand {
  constructor(selection, descending) {
    this.selection = selection;
    this.descending = descending;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    const op = sortLines(model, this.selection, this.descending);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this.selectionId = builder.trackSelection(this.selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
  static canRun(model, selection, descending) {
    if (model === null) {
      return false;
    }
    const data = getSortData(model, selection, descending);
    if (!data) {
      return false;
    }
    for (let i2 = 0, len = data.before.length; i2 < len; i2++) {
      if (data.before[i2] !== data.after[i2]) {
        return true;
      }
    }
    return false;
  }
};
_SortLinesCommand._COLLATOR = safeIntl.Collator();
var SortLinesCommand = _SortLinesCommand;
function getSortData(model, selection, descending) {
  const startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  const linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand._COLLATOR.value.compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
function sortLines(model, selection, descending) {
  const data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_nls();
init_actions2();
init_languageConfigurationRegistry();
init_configuration();
var AbstractCopyLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignore: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i2 = 1; i2 < selections.length; i2++) {
      const curr = selections[i2];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignore = true;
        } else {
          prev.ignore = true;
          prev = curr;
        }
      }
    }
    const commands = [];
    for (const selection of selections) {
      commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var CopyLinesUpAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.copyLinesUpAction",
      label: localize2(1239, "Copy Line Up"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 16,
        linux: {
          primary: 2048 | 512 | 1024 | 16
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize(1234, "&&Copy Line Up"),
        order: 1
      }
    });
  }
};
var CopyLinesDownAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.copyLinesDownAction",
      label: localize2(1240, "Copy Line Down"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 18,
        linux: {
          primary: 2048 | 512 | 1024 | 18
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize(1235, "Co&&py Line Down"),
        order: 2
      }
    });
  }
};
var DuplicateSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: localize2(1241, "Duplicate Selection"),
      precondition: EditorContextKeys.writable,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize(1236, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    const model = editor2.getModel();
    for (const selection of selections) {
      if (selection.isEmpty()) {
        commands.push(new CopyLinesCommand(selection, true));
      } else {
        const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
        commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var AbstractMoveLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const commands = [];
    const selections = editor2.getSelections() || [];
    const autoIndent = editor2.getOption(
      16
      /* EditorOption.autoIndent */
    );
    for (const selection of selections) {
      commands.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var MoveLinesUpAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.moveLinesUpAction",
      label: localize2(1242, "Move Line Up"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 16,
        linux: {
          primary: 512 | 16
          /* KeyCode.UpArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize(1237, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
};
var MoveLinesDownAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.moveLinesDownAction",
      label: localize2(1243, "Move Line Down"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 18,
        linux: {
          primary: 512 | 18
          /* KeyCode.DownArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize(1238, "Move &&Line Down"),
        order: 4
      }
    });
  }
};
var AbstractSortLinesAction = class extends EditorAction {
  constructor(descending, opts) {
    super(opts);
    this.descending = descending;
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    let selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      selections = [new Selection(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))];
    }
    for (const selection of selections) {
      if (!SortLinesCommand.canRun(editor2.getModel(), selection, this.descending)) {
        return;
      }
    }
    const commands = [];
    for (let i2 = 0, len = selections.length; i2 < len; i2++) {
      commands[i2] = new SortLinesCommand(selections[i2], this.descending);
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var SortLinesAscendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.sortLinesAscending",
      label: localize2(1244, "Sort Lines Ascending"),
      precondition: EditorContextKeys.writable
    });
  }
};
var SortLinesDescendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.sortLinesDescending",
      label: localize2(1245, "Sort Lines Descending"),
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteDuplicateLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: localize2(1246, "Delete Duplicate Lines"),
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let linesDeleted = 0;
    let updateSelection = true;
    let selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      selections = [new Selection(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))];
      updateSelection = false;
    }
    for (const selection of selections) {
      const uniqueLines = /* @__PURE__ */ new Set();
      const lines = [];
      for (let i2 = selection.startLineNumber; i2 <= selection.endLineNumber; i2++) {
        const line = model.getLineContent(i2);
        if (uniqueLines.has(line)) {
          continue;
        }
        lines.push(line);
        uniqueLines.add(line);
      }
      const selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));
      const adjustedSelectionStart = selection.startLineNumber - linesDeleted;
      const finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);
      edits.push(EditOperation.replace(selectionToReplace, lines.join("\n")));
      endCursorState.push(finalSelection);
      linesDeleted += selection.endLineNumber - selection.startLineNumber + 1 - lines.length;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, updateSelection ? endCursorState : void 0);
    editor2.pushUndoStop();
  }
};
var ReverseLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reverseLines",
      label: localize2(1247, "Reverse lines"),
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const originalSelections = editor2.getSelections();
    let selections = originalSelections;
    if (selections.length === 1 && selections[0].isEmpty()) {
      selections = [new Selection(1, 1, model.getLineCount(), model.getLineMaxColumn(model.getLineCount()))];
    }
    const edits = [];
    const resultingSelections = [];
    for (let i2 = 0; i2 < selections.length; i2++) {
      const selection = selections[i2];
      const originalSelection = originalSelections[i2];
      let endLineNumber = selection.endLineNumber;
      if (selection.startLineNumber < selection.endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      let range = new Range(selection.startLineNumber, 1, endLineNumber, model.getLineMaxColumn(endLineNumber));
      if (endLineNumber === model.getLineCount() && model.getLineContent(range.endLineNumber) === "") {
        range = range.setEndPosition(range.endLineNumber - 1, model.getLineMaxColumn(range.endLineNumber - 1));
      }
      const lines = [];
      for (let i3 = range.endLineNumber; i3 >= range.startLineNumber; i3--) {
        lines.push(model.getLineContent(i3));
      }
      const edit = EditOperation.replace(range, lines.join("\n"));
      edits.push(edit);
      const updateLineNumber = function(lineNumber) {
        return lineNumber <= range.endLineNumber ? range.endLineNumber - lineNumber + range.startLineNumber : lineNumber;
      };
      const updateSelection = function(sel) {
        if (sel.isEmpty()) {
          return new Selection(updateLineNumber(sel.positionLineNumber), sel.positionColumn, updateLineNumber(sel.positionLineNumber), sel.positionColumn);
        } else {
          const newSelectionStart = updateLineNumber(sel.selectionStartLineNumber);
          const newPosition = updateLineNumber(sel.positionLineNumber);
          const newSelectionStartColumn = sel.selectionStartColumn;
          const newPositionColumn = sel.positionColumn;
          return new Selection(newSelectionStart, newSelectionStartColumn, newPosition, newPositionColumn);
        }
      };
      resultingSelections.push(updateSelection(originalSelection));
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, resultingSelections);
    editor2.pushUndoStop();
  }
};
var _TrimTrailingWhitespaceAction = class _TrimTrailingWhitespaceAction extends EditorAction {
  constructor() {
    super({
      id: _TrimTrailingWhitespaceAction.ID,
      label: localize2(1248, "Trim Trailing Whitespace"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(
          2048 | 41,
          2048 | 54
          /* KeyCode.KeyX */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2, args) {
    let cursors = [];
    if (args.reason === "auto-save") {
      cursors = (editor2.getSelections() || []).map((s) => new Position(s.positionLineNumber, s.positionColumn));
    }
    const selection = editor2.getSelection();
    if (selection === null) {
      return;
    }
    const config = _accessor.get(IConfigurationService);
    const model = editor2.getModel();
    const trimInRegexAndStrings = config.getValue("files.trimTrailingWhitespaceInRegexAndStrings", { overrideIdentifier: model?.getLanguageId(), resource: model?.uri });
    const command = new TrimTrailingWhitespaceCommand(selection, cursors, trimInRegexAndStrings);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
  }
};
_TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
var TrimTrailingWhitespaceAction = _TrimTrailingWhitespaceAction;
var DeleteLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: localize2(1249, "Delete Line"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 41,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const ops = this._getLinesToRemove(editor2);
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let linesDeleted = 0;
    const edits = [];
    const cursorState = [];
    for (let i2 = 0, len = ops.length; i2 < len; i2++) {
      const op = ops[i2];
      let startLineNumber = op.startLineNumber;
      let endLineNumber = op.endLineNumber;
      let startColumn = 1;
      let endColumn = model.getLineMaxColumn(endLineNumber);
      if (endLineNumber < model.getLineCount()) {
        endLineNumber += 1;
        endColumn = 1;
      } else if (startLineNumber > 1) {
        startLineNumber -= 1;
        startColumn = model.getLineMaxColumn(startLineNumber);
      }
      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
      linesDeleted += op.endLineNumber - op.startLineNumber + 1;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, cursorState);
    editor2.pushUndoStop();
  }
  _getLinesToRemove(editor2) {
    const operations = editor2.getSelections().map((s) => {
      let endLineNumber = s.endLineNumber;
      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
        endLineNumber -= 1;
      }
      return {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber,
        positionColumn: s.positionColumn
      };
    });
    operations.sort((a, b) => {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    });
    const mergedOperations = [];
    let previousOperation = operations[0];
    for (let i2 = 1; i2 < operations.length; i2++) {
      if (previousOperation.endLineNumber + 1 >= operations[i2].startLineNumber) {
        previousOperation.endLineNumber = operations[i2].endLineNumber;
      } else {
        mergedOperations.push(previousOperation);
        previousOperation = operations[i2];
      }
    }
    mergedOperations.push(previousOperation);
    return mergedOperations;
  }
};
var IndentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: localize2(1250, "Indent Line"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 94,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
    editor2.pushUndoStop();
  }
};
var OutdentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: localize2(1251, "Outdent Line"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 92,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor2, null);
  }
};
var InsertLineBeforeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: localize2(1252, "Insert Line Above"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, EnterOperation.lineInsertBefore(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
var InsertLineAfterAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: localize2(1253, "Insert Line Below"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, EnterOperation.lineInsertAfter(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
var AbstractDeleteAllToBoundaryAction = class extends EditorAction {
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const primaryCursor = editor2.getSelection();
    const rangesToDelete = this._getRangesToDelete(editor2);
    const effectiveRanges = [];
    for (let i2 = 0, count = rangesToDelete.length - 1; i2 < count; i2++) {
      const range = rangesToDelete[i2];
      const nextRange = rangesToDelete[i2 + 1];
      if (Range.intersectRanges(range, nextRange) === null) {
        effectiveRanges.push(range);
      } else {
        rangesToDelete[i2 + 1] = Range.plusRange(range, nextRange);
      }
    }
    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
    const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
    const edits = effectiveRanges.map((range) => {
      return EditOperation.replace(range, "");
    });
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: localize2(1254, "Delete All Left"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 2048 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    let deletedLines = 0;
    rangesToDelete.forEach((range) => {
      let endCursor;
      if (range.endColumn === 1 && deletedLines > 0) {
        const newStartLine = range.startLineNumber - deletedLines;
        endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);
      } else {
        endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      deletedLines += range.endLineNumber - range.startLineNumber;
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    });
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections;
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    rangesToDelete = rangesToDelete.map((selection) => {
      if (selection.isEmpty()) {
        if (selection.startColumn === 1) {
          const deleteFromLine = Math.max(1, selection.startLineNumber - 1);
          const deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineLength(deleteFromLine) + 1;
          return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
        } else {
          return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
        }
      } else {
        return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
      }
    });
    return rangesToDelete;
  }
};
var DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllRight",
      label: localize2(1255, "Delete All Right"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 41, secondary: [
          2048 | 20
          /* KeyCode.Delete */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    for (let i2 = 0, len = rangesToDelete.length, offset = 0; i2 < len; i2++) {
      const range = rangesToDelete[i2];
      const endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    }
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    const rangesToDelete = selections.map((sel) => {
      if (sel.isEmpty()) {
        const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
        if (sel.startColumn === maxColumn) {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
        } else {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
        }
      }
      return sel;
    });
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    return rangesToDelete;
  }
};
var JoinLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: localize2(1256, "Join Lines"),
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        mac: {
          primary: 256 | 40
          /* KeyCode.KeyJ */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let primaryCursor = editor2.getSelection();
    if (primaryCursor === null) {
      return;
    }
    selections.sort(Range.compareRangesUsingStarts);
    const reducedSelections = [];
    const lastSelection = selections.reduce((previousValue, currentValue) => {
      if (previousValue.isEmpty()) {
        if (previousValue.endLineNumber === currentValue.startLineNumber) {
          if (primaryCursor.equalsSelection(previousValue)) {
            primaryCursor = currentValue;
          }
          return currentValue;
        }
        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      } else {
        if (currentValue.startLineNumber > previousValue.endLineNumber) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      }
    });
    reducedSelections.push(lastSelection);
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let endPrimaryCursor = primaryCursor;
    let lineOffset = 0;
    for (let i2 = 0, len = reducedSelections.length; i2 < len; i2++) {
      const selection = reducedSelections[i2];
      const startLineNumber = selection.startLineNumber;
      const startColumn = 1;
      let columnDeltaOffset = 0;
      let endLineNumber, endColumn;
      const selectionEndPositionOffset = model.getLineLength(selection.endLineNumber) - selection.endColumn;
      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
        const position = selection.getStartPosition();
        if (position.lineNumber < model.getLineCount()) {
          endLineNumber = startLineNumber + 1;
          endColumn = model.getLineMaxColumn(endLineNumber);
        } else {
          endLineNumber = position.lineNumber;
          endColumn = model.getLineMaxColumn(position.lineNumber);
        }
      } else {
        endLineNumber = selection.endLineNumber;
        endColumn = model.getLineMaxColumn(endLineNumber);
      }
      let trimmedLinesContent = model.getLineContent(startLineNumber);
      for (let i3 = startLineNumber + 1; i3 <= endLineNumber; i3++) {
        const lineText = model.getLineContent(i3);
        const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i3);
        if (firstNonWhitespaceIdx >= 1) {
          let insertSpace = true;
          if (trimmedLinesContent === "") {
            insertSpace = false;
          }
          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
            insertSpace = false;
            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
          }
          const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
          trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
          if (insertSpace) {
            columnDeltaOffset = lineTextWithoutIndent.length + 1;
          } else {
            columnDeltaOffset = lineTextWithoutIndent.length;
          }
        } else {
          columnDeltaOffset = 0;
        }
      }
      const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      if (!deleteSelection.isEmpty()) {
        let resultSelection;
        if (selection.isEmpty()) {
          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
        } else {
          if (selection.startLineNumber === selection.endLineNumber) {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
          } else {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
          }
        }
        if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
          endPrimaryCursor = resultSelection;
        } else {
          endCursorState.push(resultSelection);
        }
      }
      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
    }
    endCursorState.unshift(endPrimaryCursor);
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var TransposeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: localize2(1257, "Transpose Characters around the Cursor"),
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const commands = [];
    for (let i2 = 0, len = selections.length; i2 < len; i2++) {
      const selection = selections[i2];
      if (!selection.isEmpty()) {
        continue;
      }
      const cursor = selection.getStartPosition();
      const maxColumn = model.getLineMaxColumn(cursor.lineNumber);
      if (cursor.column >= maxColumn) {
        if (cursor.lineNumber === model.getLineCount()) {
          continue;
        }
        const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
      } else {
        const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var AbstractCaseAction = class extends EditorAction {
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const wordSeparators = editor2.getOption(
      148
      /* EditorOption.wordSeparators */
    );
    const textEdits = [];
    for (const selection of selections) {
      if (selection.isEmpty()) {
        const cursor = selection.getStartPosition();
        const word = editor2.getConfiguredWordAtPosition(cursor);
        if (!word) {
          continue;
        }
        const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
        const text = model.getValueInRange(wordRange);
        textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));
      } else {
        const text = model.getValueInRange(selection);
        textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, textEdits);
    editor2.pushUndoStop();
  }
};
var UpperCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: localize2(1258, "Transform to Uppercase"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleUpperCase();
  }
};
var LowerCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: localize2(1259, "Transform to Lowercase"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleLowerCase();
  }
};
var BackwardsCompatibleRegExp = class {
  constructor(_pattern, _flags) {
    this._pattern = _pattern;
    this._flags = _flags;
    this._actual = null;
    this._evaluated = false;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = true;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch (err) {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
};
var _TitleCaseAction = class _TitleCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: localize2(1260, "Transform to Title Case"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const titleBoundary = _TitleCaseAction.titleBoundary.get();
    if (!titleBoundary) {
      return text;
    }
    return text.toLocaleLowerCase().replace(titleBoundary, (b) => b.toLocaleUpperCase());
  }
};
_TitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
var TitleCaseAction = _TitleCaseAction;
var _SnakeCaseAction = class _SnakeCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: localize2(1261, "Transform to Snake Case"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const caseBoundary = _SnakeCaseAction.caseBoundary.get();
    const singleLetters = _SnakeCaseAction.singleLetters.get();
    if (!caseBoundary || !singleLetters) {
      return text;
    }
    return text.replace(caseBoundary, "$1_$2").replace(singleLetters, "$1_$2$3").toLocaleLowerCase();
  }
};
_SnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
_SnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
var SnakeCaseAction = _SnakeCaseAction;
var _CamelCaseAction = class _CamelCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToCamelcase",
      label: localize2(1262, "Transform to Camel Case"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const wordBoundary = /\r\n|\r|\n/.test(text) ? _CamelCaseAction.multiLineWordBoundary.get() : _CamelCaseAction.singleLineWordBoundary.get();
    const validWordStart = _CamelCaseAction.validWordStart.get();
    if (!wordBoundary || !validWordStart) {
      return text;
    }
    const words = text.split(wordBoundary);
    const firstWord = words.shift()?.replace(validWordStart, (start) => start.toLocaleLowerCase());
    return firstWord + words.map((word) => word.substring(0, 1).toLocaleUpperCase() + word.substring(1)).join("");
  }
};
_CamelCaseAction.singleLineWordBoundary = new BackwardsCompatibleRegExp("[_\\s-]+", "gm");
_CamelCaseAction.multiLineWordBoundary = new BackwardsCompatibleRegExp("[_-]+", "gm");
_CamelCaseAction.validWordStart = new BackwardsCompatibleRegExp("^(\\p{Lu}[^\\p{Lu}])", "gmu");
var CamelCaseAction = _CamelCaseAction;
var _PascalCaseAction = class _PascalCaseAction extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToPascalcase",
      label: localize2(1263, "Transform to Pascal Case"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const wordBoundary = _PascalCaseAction.wordBoundary.get();
    const wordBoundaryToMaintain = _PascalCaseAction.wordBoundaryToMaintain.get();
    if (!wordBoundary || !wordBoundaryToMaintain) {
      return text;
    }
    const wordsWithMaintainBoundaries = text.split(wordBoundaryToMaintain);
    const words = wordsWithMaintainBoundaries.map((word) => word.split(wordBoundary)).flat();
    return words.map((word) => word.substring(0, 1).toLocaleUpperCase() + word.substring(1)).join("");
  }
};
_PascalCaseAction.wordBoundary = new BackwardsCompatibleRegExp("[_ \\t-]", "gm");
_PascalCaseAction.wordBoundaryToMaintain = new BackwardsCompatibleRegExp("(?<=\\.)", "gm");
var PascalCaseAction = _PascalCaseAction;
var _KebabCaseAction = class _KebabCaseAction extends AbstractCaseAction {
  static isSupported() {
    const areAllRegexpsSupported = [
      this.caseBoundary,
      this.singleLetters,
      this.underscoreBoundary
    ].every((regexp) => regexp.isSupported());
    return areAllRegexpsSupported;
  }
  constructor() {
    super({
      id: "editor.action.transformToKebabcase",
      label: localize2(1264, "Transform to Kebab Case"),
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, _) {
    const caseBoundary = _KebabCaseAction.caseBoundary.get();
    const singleLetters = _KebabCaseAction.singleLetters.get();
    const underscoreBoundary = _KebabCaseAction.underscoreBoundary.get();
    if (!caseBoundary || !singleLetters || !underscoreBoundary) {
      return text;
    }
    return text.replace(underscoreBoundary, "$1-$3").replace(caseBoundary, "$1-$2").replace(singleLetters, "$1-$2").toLocaleLowerCase();
  }
};
_KebabCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
_KebabCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
_KebabCaseAction.underscoreBoundary = new BackwardsCompatibleRegExp("(\\S)(_)(\\S)", "gm");
var KebabCaseAction = _KebabCaseAction;
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(DeleteDuplicateLinesAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
registerEditorAction(ReverseLinesAction);
if (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {
  registerEditorAction(SnakeCaseAction);
}
if (CamelCaseAction.singleLineWordBoundary.isSupported() && CamelCaseAction.multiLineWordBoundary.isSupported()) {
  registerEditorAction(CamelCaseAction);
}
if (PascalCaseAction.wordBoundary.isSupported()) {
  registerEditorAction(PascalCaseAction);
}
if (TitleCaseAction.titleBoundary.isSupported()) {
  registerEditorAction(TitleCaseAction);
}
if (KebabCaseAction.isSupported()) {
  registerEditorAction(KebabCaseAction);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.js
init_arrays();
init_async();
init_cancellation();
init_color();
init_errors();
init_event();
init_lifecycle();
init_strings();
init_uri();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_textModel();
init_languageConfigurationRegistry();
init_nls();
init_contextkey();
init_languageFeatures();
init_colorRegistry();
init_languageFeatureDebounce();
init_stopwatch();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.css";
var __decorate89 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param89 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LinkedEditingContribution_1;
var CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
var DECORATION_CLASS_NAME2 = "linked-editing-decoration";
var _a56;
var LinkedEditingContribution = (_a56 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkedEditingContribution_1.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService, languageConfigurationService, languageFeatureDebounceService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._syncRangesToken = 0;
    this._localToDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._providers = languageFeaturesService.linkedEditingRangeProvider;
    this._enabled = false;
    this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._debounceInformation = languageFeatureDebounceService.for(this._providers, "Linked Editing", { max: 200 });
    this._currentDecorations = this._editor.createDecorationsCollection();
    this._languageWordPattern = null;
    this._currentWordPattern = null;
    this._ignoreChangeEvent = false;
    this._localToDispose = this._register(new DisposableStore());
    this._rangeUpdateTriggerPromise = null;
    this._rangeSyncTriggerPromise = null;
    this._currentRequestCts = null;
    this._currentRequestPosition = null;
    this._currentRequestModelVersion = null;
    this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        78
        /* EditorOption.linkedEditing */
      ) || e.hasChanged(
        106
        /* EditorOption.renameOnType */
      )) {
        this.reinitialize(false);
      }
    }));
    this._register(this._providers.onDidChange(() => this.reinitialize(false)));
    this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
    this.reinitialize(true);
  }
  reinitialize(forceRefresh) {
    const model = this._editor.getModel();
    const isEnabled = model !== null && (this._editor.getOption(
      78
      /* EditorOption.linkedEditing */
    ) || this._editor.getOption(
      106
      /* EditorOption.renameOnType */
    )) && this._providers.has(model);
    if (isEnabled === this._enabled && !forceRefresh) {
      return;
    }
    this._enabled = isEnabled;
    this.clearRanges();
    this._localToDispose.clear();
    if (!isEnabled || model === null) {
      return;
    }
    this._localToDispose.add(Event.runAndSubscribe(model.onDidChangeLanguageConfiguration, () => {
      this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
    }));
    const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));
    const triggerRangeUpdate = () => {
      this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), this._debounceDuration ?? this._debounceInformation.get(model));
    };
    const rangeSyncScheduler = new Delayer(0);
    const triggerRangeSync = (token) => {
      this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(token));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      triggerRangeUpdate();
    }));
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._ignoreChangeEvent) {
        if (this._currentDecorations.length > 0) {
          const referenceRange = this._currentDecorations.getRange(0);
          if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
            triggerRangeSync(this._syncRangesToken);
            return;
          }
        }
      }
      triggerRangeUpdate();
    }));
    this._localToDispose.add({
      dispose: () => {
        rangeUpdateScheduler.dispose();
        rangeSyncScheduler.dispose();
      }
    });
    this.updateRanges();
  }
  _syncRanges(token) {
    if (!this._editor.hasModel() || token !== this._syncRangesToken || this._currentDecorations.length === 0) {
      return;
    }
    const model = this._editor.getModel();
    const referenceRange = this._currentDecorations.getRange(0);
    if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
      return this.clearRanges();
    }
    const referenceValue = model.getValueInRange(referenceRange);
    if (this._currentWordPattern) {
      const match = referenceValue.match(this._currentWordPattern);
      const matchLength = match ? match[0].length : 0;
      if (matchLength !== referenceValue.length) {
        return this.clearRanges();
      }
    }
    const edits = [];
    for (let i2 = 1, len = this._currentDecorations.length; i2 < len; i2++) {
      const mirrorRange = this._currentDecorations.getRange(i2);
      if (!mirrorRange) {
        continue;
      }
      if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
        edits.push({
          range: mirrorRange,
          text: referenceValue
        });
      } else {
        let oldValue = model.getValueInRange(mirrorRange);
        let newValue = referenceValue;
        let rangeStartColumn = mirrorRange.startColumn;
        let rangeEndColumn = mirrorRange.endColumn;
        const commonPrefixLength2 = commonPrefixLength(oldValue, newValue);
        rangeStartColumn += commonPrefixLength2;
        oldValue = oldValue.substr(commonPrefixLength2);
        newValue = newValue.substr(commonPrefixLength2);
        const commonSuffixLength2 = commonSuffixLength(oldValue, newValue);
        rangeEndColumn -= commonSuffixLength2;
        oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength2);
        newValue = newValue.substr(0, newValue.length - commonSuffixLength2);
        if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
          edits.push({
            range: new Range(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
            text: newValue
          });
        }
      }
    }
    if (edits.length === 0) {
      return;
    }
    try {
      this._editor.popUndoStop();
      this._ignoreChangeEvent = true;
      const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
      this._editor.executeEdits("linkedEditing", edits);
      this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
  dispose() {
    this.clearRanges();
    super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(false);
    this._currentDecorations.clear();
    if (this._currentRequestCts) {
      this._currentRequestCts.cancel();
      this._currentRequestCts = null;
      this._currentRequestPosition = null;
    }
  }
  async updateRanges(force = false) {
    if (!this._editor.hasModel()) {
      this.clearRanges();
      return;
    }
    const position = this._editor.getPosition();
    if (!this._enabled && !force || this._editor.getSelections().length > 1) {
      this.clearRanges();
      return;
    }
    const model = this._editor.getModel();
    const modelVersionId = model.getVersionId();
    if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
      if (position.equals(this._currentRequestPosition)) {
        return;
      }
      if (this._currentDecorations.length > 0) {
        const range = this._currentDecorations.getRange(0);
        if (range && range.containsPosition(position)) {
          return;
        }
      }
    }
    if (!this._currentRequestPosition?.equals(position)) {
      const currentRange = this._currentDecorations.getRange(0);
      if (!currentRange?.containsPosition(position)) {
        this.clearRanges();
      }
    }
    this._currentRequestPosition = position;
    this._currentRequestModelVersion = modelVersionId;
    const currentRequestCts = this._currentRequestCts = new CancellationTokenSource();
    try {
      const sw = new StopWatch(false);
      const response = await getLinkedEditingRanges(this._providers, model, position, currentRequestCts.token);
      this._debounceInformation.update(model, sw.elapsed());
      if (currentRequestCts !== this._currentRequestCts) {
        return;
      }
      this._currentRequestCts = null;
      if (modelVersionId !== model.getVersionId()) {
        return;
      }
      let ranges = [];
      if (response?.ranges) {
        ranges = response.ranges;
      }
      this._currentWordPattern = response?.wordPattern || this._languageWordPattern;
      let foundReferenceRange = false;
      for (let i2 = 0, len = ranges.length; i2 < len; i2++) {
        if (Range.containsPosition(ranges[i2], position)) {
          foundReferenceRange = true;
          if (i2 !== 0) {
            const referenceRange = ranges[i2];
            ranges.splice(i2, 1);
            ranges.unshift(referenceRange);
          }
          break;
        }
      }
      if (!foundReferenceRange) {
        this.clearRanges();
        return;
      }
      const decorations = ranges.map((range) => ({ range, options: LinkedEditingContribution_1.DECORATION }));
      this._visibleContextKey.set(true);
      this._currentDecorations.set(decorations);
      this._syncRangesToken++;
    } catch (err) {
      if (!isCancellationError(err)) {
        onUnexpectedError(err);
      }
      if (this._currentRequestCts === currentRequestCts || !this._currentRequestCts) {
        this.clearRanges();
      }
    }
  }
}, LinkedEditingContribution_1 = _a56, _a56.ID = "editor.contrib.linkedEditing", _a56.DECORATION = ModelDecorationOptions.register({
  description: "linked-editing",
  stickiness: 0,
  className: DECORATION_CLASS_NAME2
}), _a56);
LinkedEditingContribution = LinkedEditingContribution_1 = __decorate89([
  __param89(1, IContextKeyService),
  __param89(2, ILanguageFeaturesService),
  __param89(3, ILanguageConfigurationService),
  __param89(4, ILanguageFeatureDebounceService)
], LinkedEditingContribution);
var LinkedEditingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: localize2(1266, "Start Linked Editing"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(_accessor, editor2) {
    const controller = LinkedEditingContribution.get(editor2);
    if (controller) {
      return Promise.resolve(controller.updateRanges(true));
    }
    return Promise.resolve();
  }
};
var LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);
registerEditorCommand(new LinkedEditingCommand({
  id: "cancelLinkedEditingInput",
  precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
  handler: (x) => x.clearRanges(),
  kbOpts: {
    kbExpr: EditorContextKeys.editorTextFocus,
    weight: 100 + 99,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
function getLinkedEditingRanges(providers, model, position, token) {
  const orderedByScore = providers.ordered(model);
  return first(orderedByScore.map((provider) => async () => {
    try {
      return await provider.provideLinkedEditingRanges(model, position, token);
    } catch (e) {
      onUnexpectedExternalError(e);
      return void 0;
    }
  }), (result) => !!result && isNonEmptyArray(result?.ranges));
}
var editorLinkedEditingBackground = registerColor("editor.linkedEditingBackground", { dark: Color.fromHex("#f00").transparent(0.3), light: Color.fromHex("#f00").transparent(0.3), hcDark: Color.fromHex("#f00").transparent(0.3), hcLight: Color.white }, localize(1265, "Background color when the editor auto renames on type."));
registerModelAndPositionCommand("_executeLinkedEditingProvider", (_accessor, model, position) => {
  const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);
  return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);
});
registerEditorContribution(
  LinkedEditingContribution.ID,
  LinkedEditingContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(LinkedEditingAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
init_async();
init_cancellation();
init_errors();
init_htmlContent();
init_lifecycle();
init_network();
init_platform();
init_resources();
init_stopwatch();
init_uri();
init_editorExtensions();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/getLinks.js
init_arrays();
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_range();
init_model();
init_commands();
init_languageFeatures();
var Link = class {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  async resolve(token) {
    if (this._link.url) {
      return this._link.url;
    }
    if (typeof this._provider.resolveLink === "function") {
      return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
        this._link = value || this._link;
        if (this._link.url) {
          return this.resolve(token);
        }
        return Promise.reject(new Error("missing"));
      });
    }
    return Promise.reject(new Error("missing"));
  }
};
var _LinksList = class _LinksList {
  constructor(tuples) {
    this._disposables = new DisposableStore();
    let links = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map((link) => new Link(link, provider));
      links = _LinksList._union(links, newLinks);
      if (isDisposable(list)) {
        this._disposables ??= new DisposableStore();
        this._disposables.add(list);
      }
    }
    this.links = links;
  }
  dispose() {
    this._disposables?.dispose();
    this.links.length = 0;
  }
  static _union(oldLinks, newLinks) {
    const result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
};
_LinksList.Empty = new _LinksList([]);
var LinksList = _LinksList;
async function getLinks(providers, model, token) {
  const lists = [];
  const promises = providers.ordered(model).reverse().map(async (provider, i2) => {
    try {
      const result = await provider.provideLinks(model, token);
      if (result) {
        lists[i2] = [result, provider];
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
  });
  await Promise.all(promises);
  let res = new LinksList(coalesce(lists));
  if (token.isCancellationRequested) {
    res.dispose();
    res = LinksList.Empty;
  }
  return res;
}
CommandsRegistry.registerCommand("_executeLinkProvider", async (accessor, ...args) => {
  let [uri, resolveCount] = args;
  assertType(uri instanceof URI);
  if (typeof resolveCount !== "number") {
    resolveCount = 0;
  }
  const { linkProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = await getLinks(linkProvider, model, CancellationToken.None);
  if (!list) {
    return [];
  }
  for (let i2 = 0; i2 < Math.min(resolveCount, list.links.length); i2++) {
    await list.links[i2].resolve(CancellationToken.None);
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
});

// node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
init_nls();
var __decorate90 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param90 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LinkDetector_1;
var _a57;
var LinkDetector = (_a57 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkDetector_1.ID);
  }
  constructor(editor2, openerService, notificationService, languageFeaturesService, languageFeatureDebounceService) {
    super();
    this.editor = editor2;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this.languageFeaturesService = languageFeaturesService;
    this.providers = this.languageFeaturesService.linkProvider;
    this.debounceInformation = languageFeatureDebounceService.for(this.providers, "Links", { min: 1e3, max: 4e3 });
    this.computeLinks = this._register(new RunOnceScheduler(() => this.computeLinksNow(), 1e3));
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    const clickLinkGesture = this._register(new ClickLinkGesture(editor2));
    this._register(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this._register(clickLinkGesture.onExecute((e) => {
      this.onEditorMouseUp(e);
    }));
    this._register(clickLinkGesture.onCancel((e) => {
      this.cleanUpActiveLinkDecoration();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (!e.hasChanged(
        79
        /* EditorOption.links */
      )) {
        return;
      }
      this.updateDecorations([]);
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (!this.editor.hasModel()) {
        return;
      }
      this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelLanguage((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(this.providers.onDidChange((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this.computeLinks.schedule(0);
  }
  async computeLinksNow() {
    if (!this.editor.hasModel() || !this.editor.getOption(
      79
      /* EditorOption.links */
    )) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForSyncing()) {
      return;
    }
    if (!this.providers.has(model)) {
      return;
    }
    if (this.activeLinksList) {
      this.activeLinksList.dispose();
      this.activeLinksList = null;
    }
    this.computePromise = createCancelablePromise((token) => getLinks(this.providers, model, token));
    try {
      const sw = new StopWatch(false);
      this.activeLinksList = await this.computePromise;
      this.debounceInformation.update(model, sw.elapsed());
      if (model.isDisposed()) {
        return;
      }
      this.updateDecorations(this.activeLinksList.links);
    } catch (err) {
      onUnexpectedError(err);
    } finally {
      this.computePromise = null;
    }
  }
  updateDecorations(links) {
    const useMetaKey = this.editor.getOption(
      86
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    const oldDecorations = [];
    const keys = Object.keys(this.currentOccurrences);
    for (const decorationId of keys) {
      const occurence = this.currentOccurrences[decorationId];
      oldDecorations.push(occurence.decorationId);
    }
    const newDecorations = [];
    if (links) {
      for (const link of links) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    this.editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      for (let i2 = 0, len = decorations.length; i2 < len; i2++) {
        const occurence = new LinkOccurrence(links[i2], decorations[i2]);
        this.currentOccurrences[occurence.decorationId] = occurence;
      }
    });
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(
      86
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(
      86
      /* EditorOption.multiCursorModifier */
    ) === "altKey";
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(
      occurrence,
      mouseEvent.hasSideBySideModifier,
      true
      /* from user gesture */
    );
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const { link } = occurrence;
    link.resolve(CancellationToken.None).then((uri) => {
      if (typeof uri === "string" && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
          const parsedUri = URI.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath2 = null;
            if (fsPath.startsWith("/./") || fsPath.startsWith("\\.\\")) {
              relativePath2 = `.${fsPath.substr(1)}`;
            } else if (fsPath.startsWith("//./") || fsPath.startsWith("\\\\.\\")) {
              relativePath2 = `.${fsPath.substr(2)}`;
            }
            if (relativePath2) {
              uri = joinPath(modelUri, relativePath2);
            }
          }
        }
      }
      return this.openerService.open(uri, { openToSide, fromUserGesture, allowContributedOpeners: true, allowCommands: true, fromWorkspace: true });
    }, (err) => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === "invalid") {
        this.notificationService.warn(localize(1267, "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
      } else if (messageOrError === "missing") {
        this.notificationService.warn(localize(1268, "Failed to open this link because its target is missing."));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration3 of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration3.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey || mouseEvent.isMiddleClick && mouseEvent.mouseMiddleClickAction === "openLink"));
  }
  stop() {
    this.computeLinks.cancel();
    if (this.activeLinksList) {
      this.activeLinksList?.dispose();
      this.activeLinksList = null;
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    super.dispose();
    this.stop();
  }
}, LinkDetector_1 = _a57, _a57.ID = "editor.linkDetector", _a57);
LinkDetector = LinkDetector_1 = __decorate90([
  __param90(1, IOpenerService),
  __param90(2, INotificationService),
  __param90(3, ILanguageFeaturesService),
  __param90(4, ILanguageFeatureDebounceService)
], LinkDetector);
var decoration = {
  general: ModelDecorationOptions.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link"
  }),
  active: ModelDecorationOptions.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link-active"
  })
};
var LinkOccurrence = class _LinkOccurrence {
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: _LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = { ...isActive ? decoration.active : decoration.general };
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, _LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, _LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
};
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize(1269, "Execute command") : localize(1270, "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize(1271, "cmd + click") : localize(1272, "ctrl + click") : isMacintosh ? localize(1273, "option + click") : localize(1274, "alt + click");
  if (link.url) {
    let nativeLabel = "";
    if (/^command:/i.test(link.url.toString())) {
      const match = link.url.toString().match(/^command:([^?#]+)/);
      if (match) {
        const commandId = match[1];
        nativeLabel = localize(1275, "Execute command {0}", commandId);
      }
    }
    const hoverMessage = new MarkdownString("", true).appendLink(link.url.toString(true).replace(/ /g, "%20"), label, nativeLabel).appendMarkdown(` (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
var OpenLinkAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: localize2(1276, "Open Link"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const linkDetector = LinkDetector.get(editor2);
    if (!linkDetector) {
      return;
    }
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    for (const sel of selections) {
      const link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
};
registerEditorContribution(
  LinkDetector.ID,
  LinkDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(OpenLinkAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js
init_lifecycle();
init_editorExtensions();
var _LongLinesHelper = class _LongLinesHelper extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(this._editor.onMouseDown((e) => {
      const stopRenderingLineAfter = this._editor.getOption(
        133
        /* EditorOption.stopRenderingLineAfter */
      );
      if (stopRenderingLineAfter >= 0 && e.target.type === 6 && e.target.position.column >= stopRenderingLineAfter) {
        this._editor.updateOptions({
          stopRenderingLineAfter: -1
        });
      }
    }));
  }
};
_LongLinesHelper.ID = "editor.contrib.longLinesHelper";
var LongLinesHelper = _LongLinesHelper;
registerEditorContribution(
  LongLinesHelper.ID,
  LongLinesHelper,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/middleScroll/browser/middleScroll.contribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/middleScroll/browser/middleScrollController.js
init_dom();
init_lifecycle();
init_observable();
init_observableCodeEditor();
init_point();
init_utils2();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/middleScroll/browser/middleScroll.css";
var _MiddleScrollController = class _MiddleScrollController extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    const obsEditor = observableCodeEditor(this._editor);
    const scrollOnMiddleClick = obsEditor.getOption(
      171
      /* EditorOption.scrollOnMiddleClick */
    );
    this._register(autorun((reader) => {
      if (!scrollOnMiddleClick.read(reader)) {
        return;
      }
      const editorDomNode = obsEditor.domNode.read(reader);
      if (!editorDomNode) {
        return;
      }
      const scrollingSession = reader.store.add(disposableObservableValue("scrollingSession", void 0));
      reader.store.add(this._editor.onMouseDown((e) => {
        const session = scrollingSession.read(void 0);
        if (session) {
          scrollingSession.set(void 0, void 0);
          return;
        }
        if (!e.event.middleButton) {
          return;
        }
        e.event.stopPropagation();
        e.event.preventDefault();
        const store = new DisposableStore();
        const initialPos = new Point(e.event.posx, e.event.posy);
        const mousePos = observeWindowMousePos(getWindow(editorDomNode), initialPos, store);
        const mouseDeltaAfterThreshold = mousePos.map((v) => v.subtract(initialPos).withThreshold(5));
        const editorDomNodeRect = editorDomNode.getBoundingClientRect();
        const initialMousePosInEditor = new Point(initialPos.x - editorDomNodeRect.left, initialPos.y - editorDomNodeRect.top);
        scrollingSession.set({
          mouseDeltaAfterThreshold,
          initialMousePosInEditor,
          didScroll: false,
          dispose: () => store.dispose()
        }, void 0);
        store.add(this._editor.onMouseUp((e2) => {
          const session2 = scrollingSession.read(void 0);
          if (session2 && session2.didScroll) {
            scrollingSession.set(void 0, void 0);
          }
        }));
        store.add(this._editor.onKeyDown((e2) => {
          scrollingSession.set(void 0, void 0);
        }));
      }));
      reader.store.add(autorun((reader2) => {
        const session = scrollingSession.read(reader2);
        if (!session) {
          return;
        }
        let lastTime = Date.now();
        reader2.store.add(autorun((reader3) => {
          AnimationFrameScheduler.instance.invalidateOnNextAnimationFrame(reader3);
          const curTime = Date.now();
          const frameDurationMs = curTime - lastTime;
          lastTime = curTime;
          const mouseDelta = session.mouseDeltaAfterThreshold.read(void 0);
          const factor = frameDurationMs / 32;
          const scrollDelta = mouseDelta.scale(factor);
          const scrollPos = new Point(this._editor.getScrollLeft(), this._editor.getScrollTop());
          this._editor.setScrollPosition(toScrollPosition(scrollPos.add(scrollDelta)));
          if (!scrollDelta.isZero()) {
            session.didScroll = true;
          }
        }));
        const directionAttr = derived((reader3) => {
          const delta = session.mouseDeltaAfterThreshold.read(reader3);
          let direction = "";
          direction += delta.y < 0 ? "n" : delta.y > 0 ? "s" : "";
          direction += delta.x < 0 ? "w" : delta.x > 0 ? "e" : "";
          return direction;
        });
        reader2.store.add(autorun((reader3) => {
          editorDomNode.setAttribute("data-scroll-direction", directionAttr.read(reader3));
        }));
      }));
      const dotDomElem = reader.store.add(n.div({
        class: ["scroll-editor-on-middle-click-dot", scrollingSession.map((session) => session ? "" : "hidden")],
        style: {
          left: scrollingSession.map((session) => session ? session.initialMousePosInEditor.x : 0),
          top: scrollingSession.map((session) => session ? session.initialMousePosInEditor.y : 0)
        }
      }).toDisposableLiveElement());
      reader.store.add(appendRemoveOnDispose(editorDomNode, dotDomElem.element));
      reader.store.add(autorun((reader2) => {
        const session = scrollingSession.read(reader2);
        editorDomNode.classList.toggle("scroll-editor-on-middle-click-editor", !!session);
      }));
    }));
  }
};
_MiddleScrollController.ID = "editor.contrib.middleScroll";
var MiddleScrollController = _MiddleScrollController;
function observeWindowMousePos(window, initialPos, store) {
  const val = observableValue("pos", initialPos);
  store.add(addDisposableListener(window, "mousemove", (e) => {
    val.set(new Point(e.pageX, e.pageY), void 0);
  }));
  return val;
}
function toScrollPosition(p) {
  return {
    scrollLeft: p.x,
    scrollTop: p.y
  };
}

// node_modules/monaco-editor/esm/vs/editor/contrib/middleScroll/browser/middleScroll.contribution.js
registerEditorContribution(
  MiddleScrollController.ID,
  MiddleScrollController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
init_async();
init_keyCodes();
init_lifecycle();
init_editorExtensions();
init_range();
init_selection();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js
init_model2();
init_textModel();
init_languages();
init_nls();
init_colorRegistry();
init_themeService();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.css";
var wordHighlightBackground = registerColor("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hcDark: null, hcLight: null }, localize(1548, "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hcDark: null, hcLight: null }, localize(1549, "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightTextBackground", wordHighlightBackground, localize(1550, "Background color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), true);
var wordHighlightBorder = registerColor("editor.wordHighlightBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize(1551, "Border color of a symbol during read-access, like reading a variable."));
registerColor("editor.wordHighlightStrongBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize(1552, "Border color of a symbol during write-access, like writing to a variable."));
registerColor("editor.wordHighlightTextBorder", wordHighlightBorder, localize(1553, "Border color of a textual occurrence for a symbol."));
var overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", "#A0A0A0CC", localize(1554, "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", "#C0A0C0CC", localize(1555, "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightTextForeground = registerColor("editorOverviewRuler.wordHighlightTextForeground", overviewRulerSelectionHighlightForeground, localize(1556, "Overview ruler marker color of a textual occurrence for a symbol. The color must not be opaque so as not to hide underlying decorations."), true);
var _WRITE_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: 1
    /* MinimapPosition.Inline */
  }
});
var _TEXT_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-text",
  stickiness: 1,
  className: "wordHighlightText",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightTextForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: 1
    /* MinimapPosition.Inline */
  }
});
var _SELECTION_HIGHLIGHT_OPTIONS = ModelDecorationOptions.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: 1
    /* MinimapPosition.Inline */
  }
});
var _SELECTION_HIGHLIGHT_OPTIONS_NO_OVERVIEW = ModelDecorationOptions.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
});
var _REGULAR_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: 1
    /* MinimapPosition.Inline */
  }
});
function getHighlightDecorationOptions(kind) {
  if (kind === DocumentHighlightKind.Write) {
    return _WRITE_OPTIONS;
  } else if (kind === DocumentHighlightKind.Text) {
    return _TEXT_OPTIONS;
  } else {
    return _REGULAR_OPTIONS;
  }
}
function getSelectionHighlightDecorationOptions(hasSemanticHighlights) {
  return hasSemanticHighlights ? _SELECTION_HIGHLIGHT_OPTIONS_NO_OVERVIEW : _SELECTION_HIGHLIGHT_OPTIONS;
}
registerThemingParticipant((theme, collector) => {
  const selectionHighlight = theme.getColor(editorSelectionHighlight);
  if (selectionHighlight) {
    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
init_instantiation();
var __decorate91 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param91 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SelectionHighlighter_1;
function announceCursorChange(previousCursorState, cursorState) {
  const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
  if (cursorDiff.length >= 1) {
    const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
    const msg = cursorDiff.length === 1 ? localize(1278, "Cursor added: {0}", cursorPositions) : localize(1279, "Cursors added: {0}", cursorPositions);
    status(msg);
  }
}
var InsertCursorAbove = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: localize2(1288, "Add Cursor Above"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 16,
        linux: {
          primary: 1024 | 512 | 16,
          secondary: [
            2048 | 1024 | 16
            /* KeyCode.UpArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize(1280, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealTopMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorBelow = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: localize2(1289, "Add Cursor Below"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 18,
        linux: {
          primary: 1024 | 512 | 18,
          secondary: [
            2048 | 1024 | 18
            /* KeyCode.DownArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize(1281, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealBottomMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: localize2(1290, "Add Cursors to Line Ends"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 39,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize(1282, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(selection, model, result) {
    if (selection.isEmpty()) {
      return;
    }
    for (let i2 = selection.startLineNumber; i2 < selection.endLineNumber; i2++) {
      const currentLineMaxColumn = model.getLineMaxColumn(i2);
      result.push(new Selection(i2, currentLineMaxColumn, i2, currentLineMaxColumn));
    }
    if (selection.endColumn > 1) {
      result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
    }
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    const newSelections = [];
    selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtEndOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: localize2(1291, "Add Cursors to Bottom"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const lineCount = editor2.getModel().getLineCount();
    const newSelections = [];
    for (let i2 = selections[0].startLineNumber; i2 <= lineCount; i2++) {
      newSelections.push(new Selection(i2, selections[0].startColumn, i2, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtTopOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: localize2(1292, "Add Cursors to Top"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const newSelections = [];
    for (let i2 = selections[0].startLineNumber; i2 >= 1; i2--) {
      newSelections.push(new Selection(i2, selections[0].startColumn, i2, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var MultiCursorSessionResult = class {
  constructor(selections, revealRange, revealScrollType) {
    this.selections = selections;
    this.revealRange = revealRange;
    this.revealScrollType = revealScrollType;
  }
};
var MultiCursorSession = class _MultiCursorSession {
  static create(editor2, findController) {
    if (!editor2.hasModel()) {
      return null;
    }
    const findState = findController.getState();
    if (!editor2.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
      return new _MultiCursorSession(editor2, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
    }
    let isDisconnectedFromFindController = false;
    let wholeWord;
    let matchCase;
    const selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      isDisconnectedFromFindController = true;
      wholeWord = true;
      matchCase = true;
    } else {
      wholeWord = findState.wholeWord;
      matchCase = findState.matchCase;
    }
    const s = editor2.getSelection();
    let searchText;
    let currentMatch = null;
    if (s.isEmpty()) {
      const word = editor2.getConfiguredWordAtPosition(s.getStartPosition());
      if (!word) {
        return null;
      }
      searchText = word.word;
      currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
    } else {
      searchText = editor2.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
    }
    return new _MultiCursorSession(editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
  }
  constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
    this._editor = _editor;
    this.findController = findController;
    this.isDisconnectedFromFindController = isDisconnectedFromFindController;
    this.searchText = searchText;
    this.wholeWord = wholeWord;
    this.matchCase = matchCase;
    this.currentMatch = currentMatch;
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.concat(nextMatch),
      nextMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.slice(0, allSelections.length - 1).concat(nextMatch),
      nextMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  _getNextMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (!nextMatch) {
      return null;
    }
    return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.concat(previousMatch),
      previousMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(
      allSelections.slice(0, allSelections.length - 1).concat(previousMatch),
      previousMatch,
      0
      /* ScrollType.Smooth */
    );
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null, false);
    if (!previousMatch) {
      return null;
    }
    return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
  }
  selectAll(searchScope) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this.findController.highlightFindOptions();
    const editorModel = this._editor.getModel();
    if (searchScope) {
      return editorModel.findMatches(
        this.searchText,
        searchScope,
        false,
        this.matchCase,
        this.wholeWord ? this._editor.getOption(
          148
          /* EditorOption.wordSeparators */
        ) : null,
        false,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      );
    }
    return editorModel.findMatches(
      this.searchText,
      true,
      false,
      this.matchCase,
      this.wholeWord ? this._editor.getOption(
        148
        /* EditorOption.wordSeparators */
      ) : null,
      false,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
  }
};
var _MultiCursorSelectionController = class _MultiCursorSelectionController extends Disposable {
  static get(editor2) {
    return editor2.getContribution(_MultiCursorSelectionController.ID);
  }
  constructor(editor2) {
    super();
    this._sessionDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._ignoreSelectionChange = false;
    this._session = null;
  }
  dispose() {
    this._endSession();
    super.dispose();
  }
  _beginSessionIfNeeded(findController) {
    if (!this._session) {
      const session = MultiCursorSession.create(this._editor, findController);
      if (!session) {
        return;
      }
      this._session = session;
      const newState = { searchString: this._session.searchText };
      if (this._session.isDisconnectedFromFindController) {
        newState.wholeWordOverride = 1;
        newState.matchCaseOverride = 1;
        newState.isRegexOverride = 2;
      }
      findController.getState().change(newState, false);
      this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
        if (this._ignoreSelectionChange) {
          return;
        }
        this._endSession();
      }));
      this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      }));
      this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
        if (e.matchCase || e.wholeWord) {
          this._endSession();
        }
      }));
    }
  }
  _endSession() {
    this._sessionDispose.clear();
    if (this._session && this._session.isDisconnectedFromFindController) {
      const newState = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(newState, false);
    }
    this._session = null;
  }
  _setSelections(selections) {
    this._ignoreSelectionChange = true;
    this._editor.setSelections(selections);
    this._ignoreSelectionChange = false;
  }
  _expandEmptyToWord(model, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
    if (!word) {
      return selection;
    }
    return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
  }
  _applySessionResult(result) {
    if (!result) {
      return;
    }
    this._setSelections(result.selections);
    if (result.revealRange) {
      this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
    }
  }
  getSession(findController) {
    return this._session;
  }
  addSelectionToNextFindMatch(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._session) {
      const allSelections = this._editor.getSelections();
      if (allSelections.length > 1) {
        const findState = findController.getState();
        const matchCase = findState.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          const model = this._editor.getModel();
          const resultingSelections = [];
          for (let i2 = 0, len = allSelections.length; i2 < len; i2++) {
            resultingSelections[i2] = this._expandEmptyToWord(model, allSelections[i2]);
          }
          this._editor.setSelections(resultingSelections);
          return;
        }
      }
    }
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
  }
  moveSelectionToNextFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
  }
  moveSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
  }
  selectAll(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    let matches = null;
    const findState = findController.getState();
    if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
      const editorModel = this._editor.getModel();
      if (findState.searchScope) {
        matches = editorModel.findMatches(
          findState.searchString,
          findState.searchScope,
          findState.isRegex,
          findState.matchCase,
          findState.wholeWord ? this._editor.getOption(
            148
            /* EditorOption.wordSeparators */
          ) : null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
      } else {
        matches = editorModel.findMatches(
          findState.searchString,
          true,
          findState.isRegex,
          findState.matchCase,
          findState.wholeWord ? this._editor.getOption(
            148
            /* EditorOption.wordSeparators */
          ) : null,
          false,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        );
      }
    } else {
      this._beginSessionIfNeeded(findController);
      if (!this._session) {
        return;
      }
      matches = this._session.selectAll(findState.searchScope);
    }
    if (matches.length > 0) {
      const editorSelection = this._editor.getSelection();
      for (let i2 = 0, len = matches.length; i2 < len; i2++) {
        const match = matches[i2];
        const intersection = match.range.intersectRanges(editorSelection);
        if (intersection) {
          matches[i2] = matches[0];
          matches[0] = match;
          break;
        }
      }
      this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
    }
  }
};
_MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
var MultiCursorSelectionController = _MultiCursorSelectionController;
var MultiCursorSelectionControllerAction = class extends EditorAction {
  run(accessor, editor2) {
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel) {
      const previousCursorState = viewModel.getCursorStates();
      const findController = CommonFindController.get(editor2);
      if (findController) {
        this._run(multiCursorController, findController);
      } else {
        const newFindController = accessor.get(IInstantiationService).createInstance(CommonFindController, editor2);
        this._run(multiCursorController, newFindController);
        newFindController.dispose();
      }
      announceCursorChange(previousCursorState, viewModel.getCursorStates());
    }
  }
};
var AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: localize2(1293, "Add Selection to Next Find Match"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 34,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize(1283, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToNextFindMatch(findController);
  }
};
var AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: localize2(1294, "Add Selection to Previous Find Match"),
      precondition: void 0,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize(1284, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToPreviousFindMatch(findController);
  }
};
var MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: localize2(1295, "Move Last Selection to Next Find Match"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: KeyChord(
          2048 | 41,
          2048 | 34
          /* KeyCode.KeyD */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToNextFindMatch(findController);
  }
};
var MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: localize2(1296, "Move Last Selection to Previous Find Match"),
      precondition: void 0
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToPreviousFindMatch(findController);
  }
};
var SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: localize2(1297, "Select All Occurrences of Find Match"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 42,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize(1285, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var CompatChangeAll = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: localize2(1298, "Change All Occurrences"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var SelectionHighlighterState = class {
  constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {
    this._model = _model;
    this._searchText = _searchText;
    this._matchCase = _matchCase;
    this._wordSeparators = _wordSeparators;
    this._cachedFindMatches = null;
    this._modelVersionId = this._model.getVersionId();
    if (prevState && this._model === prevState._model && this._searchText === prevState._searchText && this._matchCase === prevState._matchCase && this._wordSeparators === prevState._wordSeparators && this._modelVersionId === prevState._modelVersionId) {
      this._cachedFindMatches = prevState._cachedFindMatches;
    }
  }
  findMatches() {
    if (this._cachedFindMatches === null) {
      this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map((m) => m.range);
      this._cachedFindMatches.sort(Range.compareRangesUsingStarts);
    }
    return this._cachedFindMatches;
  }
};
var _a58;
var SelectionHighlighter = (_a58 = class extends Disposable {
  constructor(editor2, _languageFeaturesService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this.editor = editor2;
    this._isEnabled = editor2.getOption(
      122
      /* EditorOption.selectionHighlight */
    );
    this._isEnabledMultiline = editor2.getOption(
      124
      /* EditorOption.selectionHighlightMultiline */
    );
    this._maxLength = editor2.getOption(
      123
      /* EditorOption.selectionHighlightMaxLength */
    );
    this._decorations = editor2.createDecorationsCollection();
    this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
    this.state = null;
    this._register(editor2.onDidChangeConfiguration((e) => {
      this._isEnabled = editor2.getOption(
        122
        /* EditorOption.selectionHighlight */
      );
      this._isEnabledMultiline = editor2.getOption(
        124
        /* EditorOption.selectionHighlightMultiline */
      );
      this._maxLength = editor2.getOption(
        123
        /* EditorOption.selectionHighlightMaxLength */
      );
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (!this._isEnabled) {
        return;
      }
      if (e.selection.isEmpty()) {
        if (e.reason === 3) {
          if (this.state) {
            this._setState(null);
          }
          this.updateSoon.schedule();
        } else {
          this._setState(null);
        }
      } else {
        this._update();
      }
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._setState(null);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (this._isEnabled) {
        this.updateSoon.schedule();
      }
    }));
    const findController = CommonFindController.get(editor2);
    if (findController) {
      this._register(findController.getState().onFindReplaceStateChange((e) => {
        this._update();
      }));
    }
    this.updateSoon.schedule();
  }
  _update() {
    this._setState(SelectionHighlighter_1._createState(this.state, this._isEnabled, this._isEnabledMultiline, this._maxLength, this.editor));
  }
  static _createState(oldState, isEnabled, isEnabledMultiline, maxLength, editor2) {
    if (!isEnabled) {
      return null;
    }
    if (!editor2.hasModel()) {
      return null;
    }
    if (!isEnabledMultiline) {
      const s = editor2.getSelection();
      if (s.startLineNumber !== s.endLineNumber) {
        return null;
      }
    }
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return null;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return null;
    }
    let r = multiCursorController.getSession(findController);
    if (!r) {
      const allSelections = editor2.getSelections();
      if (allSelections.length > 1) {
        const findState2 = findController.getState();
        const matchCase = findState2.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(editor2.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          return null;
        }
      }
      r = MultiCursorSession.create(editor2, findController);
    }
    if (!r) {
      return null;
    }
    if (r.currentMatch) {
      return null;
    }
    if (/^[ \t]+$/.test(r.searchText)) {
      return null;
    }
    if (maxLength > 0 && r.searchText.length > maxLength) {
      return null;
    }
    const findState = findController.getState();
    const caseSensitive = findState.matchCase;
    if (findState.isRevealed) {
      let findStateSearchString = findState.searchString;
      if (!caseSensitive) {
        findStateSearchString = findStateSearchString.toLowerCase();
      }
      let mySearchString = r.searchText;
      if (!caseSensitive) {
        mySearchString = mySearchString.toLowerCase();
      }
      if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
        return null;
      }
    }
    return new SelectionHighlighterState(editor2.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor2.getOption(
      148
      /* EditorOption.wordSeparators */
    ) : null, oldState);
  }
  _setState(newState) {
    this.state = newState;
    if (!this.state) {
      this._decorations.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForTokenization()) {
      return;
    }
    const allMatches = this.state.findMatches();
    const selections = this.editor.getSelections();
    selections.sort(Range.compareRangesUsingStarts);
    const matches = [];
    for (let i2 = 0, j = 0, len = allMatches.length, lenJ = selections.length; i2 < len; ) {
      const match = allMatches[i2];
      if (j >= lenJ) {
        matches.push(match);
        i2++;
      } else {
        const cmp = Range.compareRangesUsingStarts(match, selections[j]);
        if (cmp < 0) {
          if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {
            matches.push(match);
          }
          i2++;
        } else if (cmp > 0) {
          j++;
        } else {
          i2++;
          j++;
        }
      }
    }
    const occurrenceHighlighting = this.editor.getOption(
      90
      /* EditorOption.occurrencesHighlight */
    ) !== "off";
    const hasSemanticHighlights = this._languageFeaturesService.documentHighlightProvider.has(model) && occurrenceHighlighting;
    const decorations = matches.map((r) => {
      return {
        range: r,
        options: getSelectionHighlightDecorationOptions(hasSemanticHighlights)
      };
    });
    this._decorations.set(decorations);
  }
  dispose() {
    this._setState(null);
    super.dispose();
  }
}, SelectionHighlighter_1 = _a58, _a58.ID = "editor.contrib.selectionHighlighter", _a58);
SelectionHighlighter = SelectionHighlighter_1 = __decorate91([
  __param91(1, ILanguageFeaturesService)
], SelectionHighlighter);
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i2 = 1, len = ranges.length; i2 < len; i2++) {
    const range = ranges[i2];
    if (range.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
function getValueInRange(model, range, toLowerCase) {
  const text = model.getValueInRange(range);
  return toLowerCase ? text.toLowerCase() : text;
}
var FocusNextCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusNextCursor",
      label: localize2(1299, "Focus Next Cursor"),
      metadata: {
        description: localize(1286, "Focuses the next cursor"),
        args: []
      },
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.shift();
    if (!firstCursor) {
      return;
    }
    previousCursorState.push(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var FocusPreviousCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusPreviousCursor",
      label: localize2(1300, "Focus Previous Cursor"),
      metadata: {
        description: localize(1287, "Focuses the previous cursor"),
        args: []
      },
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.pop();
    if (!firstCursor) {
      return;
    }
    previousCursorState.unshift(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
registerEditorContribution(
  MultiCursorSelectionController.ID,
  MultiCursorSelectionController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorContribution(
  SelectionHighlighter.ID,
  SelectionHighlighter,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);
registerEditorAction(FocusNextCursor);
registerEditorAction(FocusPreviousCursor);

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
init_lazy();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_languages();
init_languageFeatures();

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
init_async();
init_errors();
init_event();
init_lifecycle();
init_characterClassifier();
init_languages();

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js
init_cancellation();
init_errors();
init_types();
init_uri();
init_position();
init_languages();
init_languageFeatures();
init_resolverService();
init_commands();
init_contextkey();
var Context2 = {
  Visible: new RawContextKey("parameterHintsVisible", false),
  MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
async function provideSignatureHelp(registry, model, position, context, token) {
  const supports = registry.ordered(model);
  for (const support of supports) {
    try {
      const result = await support.provideSignatureHelp(model, position, token, context);
      if (result) {
        return result;
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
  }
  return void 0;
}
CommandsRegistry.registerCommand("_executeSignatureHelpProvider", async (accessor, ...args) => {
  const [uri, position, triggerCharacter] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const ref = await accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = await provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position.lift(position), {
      triggerKind: SignatureHelpTriggerKind.Invoke,
      isRetrigger: false,
      triggerCharacter
    }, CancellationToken.None);
    if (!result) {
      return void 0;
    }
    setTimeout(() => result.dispose(), 0);
    return result.value;
  } finally {
    ref.dispose();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
var ParameterHintState;
(function(ParameterHintState2) {
  ParameterHintState2.Default = {
    type: 0
    /* Type.Default */
  };
  class Pending {
    constructor(request, previouslyActiveHints) {
      this.request = request;
      this.previouslyActiveHints = previouslyActiveHints;
      this.type = 2;
    }
  }
  ParameterHintState2.Pending = Pending;
  class Active {
    constructor(hints) {
      this.hints = hints;
      this.type = 1;
    }
  }
  ParameterHintState2.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
var _ParameterHintsModel = class _ParameterHintsModel extends Disposable {
  // ms
  constructor(editor2, providers, delay = _ParameterHintsModel.DEFAULT_DELAY) {
    super();
    this._onChangedHints = this._register(new Emitter());
    this.onChangedHints = this._onChangedHints.event;
    this.triggerOnType = false;
    this._state = ParameterHintState.Default;
    this._pendingTriggers = [];
    this._lastSignatureHelpResult = this._register(new MutableDisposable());
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    this.triggerId = 0;
    this.editor = editor2;
    this.providers = providers;
    this.throttledDelayer = new Delayer(delay);
    this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
    this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
    this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
    this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
    this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
    this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
    this._register(this.providers.onDidChange(this.onModelChanged, this));
    this._register(this.editor.onDidType((text) => this.onDidType(text)));
    this.onEditorConfigurationChange();
    this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state.type === 2) {
      this._state.request.cancel();
    }
    this._state = value;
  }
  cancel(silent = false) {
    this.state = ParameterHintState.Default;
    this.throttledDelayer.cancel();
    if (!silent) {
      this._onChangedHints.fire(void 0);
    }
  }
  trigger(context, delay) {
    const model = this.editor.getModel();
    if (!model || !this.providers.has(model)) {
      return;
    }
    const triggerId = ++this.triggerId;
    this._pendingTriggers.push(context);
    this.throttledDelayer.trigger(() => {
      return this.doTrigger(triggerId);
    }, delay).catch(onUnexpectedError);
  }
  next() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const last = activeSignature % length === length - 1;
    const cycle = this.editor.getOption(
      98
      /* EditorOption.parameterHints */
    ).cycle;
    if ((length < 2 || last) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
  }
  previous() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const first2 = activeSignature === 0;
    const cycle = this.editor.getOption(
      98
      /* EditorOption.parameterHints */
    ).cycle;
    if ((length < 2 || first2) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(first2 && cycle ? length - 1 : activeSignature - 1);
  }
  updateActiveSignature(activeSignature) {
    if (this.state.type !== 1) {
      return;
    }
    this.state = new ParameterHintState.Active({ ...this.state.hints, activeSignature });
    this._onChangedHints.fire(this.state.hints);
  }
  async doTrigger(triggerId) {
    const isRetrigger = this.state.type === 1 || this.state.type === 2;
    const activeSignatureHelp = this.getLastActiveHints();
    this.cancel(true);
    if (this._pendingTriggers.length === 0) {
      return false;
    }
    const context = this._pendingTriggers.reduce(mergeTriggerContexts);
    this._pendingTriggers = [];
    const triggerContext = {
      triggerKind: context.triggerKind,
      triggerCharacter: context.triggerCharacter,
      isRetrigger,
      activeSignatureHelp
    };
    if (!this.editor.hasModel()) {
      return false;
    }
    const model = this.editor.getModel();
    const position = this.editor.getPosition();
    this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
    try {
      const result = await this.state.request;
      if (triggerId !== this.triggerId) {
        result?.dispose();
        return false;
      }
      if (!result || !result.value.signatures || result.value.signatures.length === 0) {
        result?.dispose();
        this._lastSignatureHelpResult.clear();
        this.cancel();
        return false;
      } else {
        this.state = new ParameterHintState.Active(result.value);
        this._lastSignatureHelpResult.value = result;
        this._onChangedHints.fire(this.state.hints);
        return true;
      }
    } catch (error) {
      if (triggerId === this.triggerId) {
        this.state = ParameterHintState.Default;
      }
      onUnexpectedError(error);
      return false;
    }
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return void 0;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel();
    this.triggerChars.clear();
    this.retriggerChars.clear();
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    for (const support of this.providers.ordered(model)) {
      for (const ch of support.signatureHelpTriggerCharacters || []) {
        if (ch.length) {
          const charCode = ch.charCodeAt(0);
          this.triggerChars.add(charCode);
          this.retriggerChars.add(charCode);
        }
      }
      for (const ch of support.signatureHelpRetriggerCharacters || []) {
        if (ch.length) {
          this.retriggerChars.add(ch.charCodeAt(0));
        }
      }
    }
  }
  onDidType(text) {
    if (!this.triggerOnType) {
      return;
    }
    const lastCharIndex = text.length - 1;
    const triggerCharCode = text.charCodeAt(lastCharIndex);
    if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
      this.trigger({
        triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
        triggerCharacter: text.charAt(lastCharIndex)
      });
    }
  }
  onCursorChange(e) {
    if (e.source === "mouse") {
      this.cancel();
    } else if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onModelContentChange() {
    if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(
      98
      /* EditorOption.parameterHints */
    ).enabled;
    if (!this.triggerOnType) {
      this.cancel();
    }
  }
  dispose() {
    this.cancel(true);
    super.dispose();
  }
};
_ParameterHintsModel.DEFAULT_DELAY = 120;
var ParameterHintsModel = _ParameterHintsModel;
function mergeTriggerContexts(previous, current) {
  switch (current.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current;
  }
}

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
init_nls();
init_contextkey();
init_instantiation();

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js
init_dom();
init_codicons();
init_event();
init_lifecycle();
init_strings();
init_types();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.css";
init_language();
init_nls();
init_contextkey();
init_colorRegistry();
init_themables();
var __decorate92 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param92 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsWidget_1;
var $12 = $;
var parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize(1302, "Icon for show next parameter hint."));
var parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize(1303, "Icon for show previous parameter hint."));
var _a59;
var ParameterHintsWidget = (_a59 = class extends Disposable {
  constructor(editor2, model, contextKeyService, openerService, languageService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = new MarkdownRenderer({ editor: editor2 }, languageService, openerService);
    this.keyVisible = Context2.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context2.MultipleSignatures.bindTo(contextKeyService);
  }
  createParameterHintDOMNodes() {
    const element = $12(".editor-widget.parameter-hints-widget");
    const wrapper = append(element, $12(".phwrapper"));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $12(".controls"));
    const previous = append(controls, $12(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
    const overloads = append(controls, $12(".overloads"));
    const next = append(controls, $12(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
    this._register(addDisposableListener(previous, "click", (e) => {
      EventHelper.stop(e);
      this.previous();
    }));
    this._register(addDisposableListener(next, "click", (e) => {
      EventHelper.stop(e);
      this.next();
    }));
    const body = $12(".body");
    const scrollbar = new DomScrollableElement(body, {
      alwaysConsumeMouseWheel: true
    });
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body, $12(".signature"));
    const docs = append(body, $12(".docs"));
    element.style.userSelect = "text";
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection((e) => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = () => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(
        59
        /* EditorOption.fontInfo */
      );
      const element2 = this.domNodes.element;
      element2.style.fontSize = `${fontInfo.fontSize}px`;
      element2.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
      element2.style.setProperty("--vscode-parameterHintsWidget-editorFontFamily", fontInfo.fontFamily);
      element2.style.setProperty("--vscode-parameterHintsWidget-editorFontFamilyDefault", EDITOR_FONT_DEFAULTS.fontFamily);
    };
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor), ($13) => $13.filter((e) => e.hasChanged(
      59
      /* EditorOption.fontInfo */
    )))(updateFont));
    this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      this.domNodes?.element.classList.add("visible");
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    this.domNodes?.element.classList.remove("visible");
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [
          1,
          2
          /* ContentWidgetPositionPreference.BELOW */
        ]
      };
    }
    return null;
  }
  render(hints) {
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = "";
    this.domNodes.docs.innerText = "";
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code = append(this.domNodes.signature, $12(".code"));
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = signature.activeParameter ?? hints.activeParameter;
    if (!hasParameters) {
      const label = append(code, $12("span"));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter?.documentation) {
      const documentation = $12("span.documentation");
      if (typeof activeParameter.documentation === "string") {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $12("p", {}, documentation));
    }
    if (signature.documentation === void 0) {
    } else if (typeof signature.documentation === "string") {
      append(this.domNodes.docs, $12("p", {}, signature.documentation));
    } else {
      const renderedContents = this.renderMarkdownDocs(signature.documentation);
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    this.domNodes.signature.classList.toggle("has-docs", hasDocs);
    this.domNodes.docs.classList.toggle("empty", !hasDocs);
    this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
    if (activeParameter) {
      let labelToAnnounce = "";
      const param = signature.parameters[activeParameterIndex];
      if (Array.isArray(param.label)) {
        labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
      } else {
        labelToAnnounce = param.label;
      }
      if (param.documentation) {
        labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
      }
      if (signature.documentation) {
        labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
      }
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localize(1304, "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(markdown) {
    const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
      asyncRenderCallback: () => {
        this.domNodes?.scrollbar.scanDomNode();
      }
    }));
    renderedContents.element.classList.add("markdown-docs");
    return renderedContents;
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === "string" && assertReturnsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === "object" && assertReturnsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "string" && assertReturnsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "object" && assertReturnsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement("span");
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement("span");
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = "parameter active";
    const afterSpan = document.createElement("span");
    afterSpan.textContent = signature.label.substring(end);
    append(parent, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else if (!param.label.length) {
      return [0, 0];
    } else {
      const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
      regex.test(signature.label);
      const idx = regex.lastIndex - param.label.length;
      return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget_1.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
}, ParameterHintsWidget_1 = _a59, _a59.ID = "editor.widget.parameterHintsWidget", _a59);
ParameterHintsWidget = ParameterHintsWidget_1 = __decorate92([
  __param92(2, IContextKeyService),
  __param92(3, IOpenerService),
  __param92(4, ILanguageService)
], ParameterHintsWidget);
registerColor("editorHoverWidget.highlightForeground", listHighlightForeground, localize(1305, "Foreground color of the active item in the parameter hint."));

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
var __decorate93 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param93 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsController_1;
var _a60;
var ParameterHintsController = (_a60 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(ParameterHintsController_1.ID);
  }
  constructor(editor2, instantiationService, languageFeaturesService) {
    super();
    this.editor = editor2;
    this.model = this._register(new ParameterHintsModel(editor2, languageFeaturesService.signatureHelpProvider));
    this._register(this.model.onChangedHints((newParameterHints) => {
      if (newParameterHints) {
        this.widget.value.show();
        this.widget.value.render(newParameterHints);
      } else {
        this.widget.rawValue?.hide();
      }
    }));
    this.widget = new Lazy(() => this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    this.widget.rawValue?.previous();
  }
  next() {
    this.widget.rawValue?.next();
  }
  trigger(context) {
    this.model.trigger(context, 0);
  }
}, ParameterHintsController_1 = _a60, _a60.ID = "editor.controller.parameterHints", _a60);
ParameterHintsController = ParameterHintsController_1 = __decorate93([
  __param93(1, IInstantiationService),
  __param93(2, ILanguageFeaturesService)
], ParameterHintsController);
var TriggerParameterHintsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: localize2(1301, "Trigger Parameter Hints"),
      precondition: EditorContextKeys.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 10,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2) {
    const controller = ParameterHintsController.get(editor2);
    controller?.trigger({
      triggerKind: SignatureHelpTriggerKind.Invoke
    });
  }
};
registerEditorContribution(
  ParameterHintsController.ID,
  ParameterHintsController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
registerEditorAction(TriggerParameterHintsAction);
var weight3 = 100 + 75;
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
  id: "closeParameterHints",
  precondition: Context2.Visible,
  handler: (x) => x.cancel(),
  kbOpts: {
    weight: weight3,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showPrevParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.previous(),
  kbOpts: {
    weight: weight3,
    kbExpr: EditorContextKeys.focus,
    primary: 16,
    secondary: [
      512 | 16
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      512 | 16,
      256 | 46
      /* KeyCode.KeyP */
    ] }
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showNextParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.next(),
  kbOpts: {
    weight: weight3,
    kbExpr: EditorContextKeys.focus,
    primary: 18,
    secondary: [
      512 | 18
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      512 | 18,
      256 | 44
      /* KeyCode.KeyN */
    ] }
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/placeholderText/browser/placeholderText.contribution.js
init_editorExtensions();
init_editorColorRegistry();
init_nls();
init_colorUtils();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/placeholderText/browser/placeholderText.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/placeholderText/browser/placeholderTextContribution.js
init_dom();
init_equals();
init_lifecycle();
init_observable();
init_observableCodeEditor();
var _PlaceholderTextContribution = class _PlaceholderTextContribution extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._editorObs = observableCodeEditor(this._editor);
    this._placeholderText = this._editorObs.getOption(
      100
      /* EditorOption.placeholder */
    );
    this._state = derivedOpts({ owner: this, equalsFn: structuralEquals }, (reader) => {
      const p = this._placeholderText.read(reader);
      if (!p) {
        return void 0;
      }
      if (!this._editorObs.valueIsEmpty.read(reader)) {
        return void 0;
      }
      return { placeholder: p };
    });
    this._shouldViewBeAlive = isOrWasTrue(this, (reader) => this._state.read(reader)?.placeholder !== void 0);
    this._view = derived((reader) => {
      if (!this._shouldViewBeAlive.read(reader)) {
        return;
      }
      const element = h("div.editorPlaceholder");
      reader.store.add(autorun((reader2) => {
        const data = this._state.read(reader2);
        const shouldBeVisibile = data?.placeholder !== void 0;
        element.root.style.display = shouldBeVisibile ? "block" : "none";
        element.root.innerText = data?.placeholder ?? "";
      }));
      reader.store.add(autorun((reader2) => {
        const info = this._editorObs.layoutInfo.read(reader2);
        element.root.style.left = `${info.contentLeft}px`;
        element.root.style.width = info.contentWidth - info.verticalScrollbarWidth + "px";
        element.root.style.top = `${this._editor.getTopForLineNumber(0)}px`;
      }));
      reader.store.add(autorun((reader2) => {
        element.root.style.fontFamily = this._editorObs.getOption(
          58
          /* EditorOption.fontFamily */
        ).read(reader2);
        element.root.style.fontSize = this._editorObs.getOption(
          61
          /* EditorOption.fontSize */
        ).read(reader2) + "px";
        element.root.style.lineHeight = this._editorObs.getOption(
          75
          /* EditorOption.lineHeight */
        ).read(reader2) + "px";
      }));
      reader.store.add(this._editorObs.createOverlayWidget({
        allowEditorOverflow: false,
        minContentWidthInPx: constObservable(0),
        position: constObservable(null),
        domNode: element.root
      }));
    });
    this._view.recomputeInitiallyAndOnChange(this._store);
  }
};
_PlaceholderTextContribution.ID = "editor.contrib.placeholderText";
var PlaceholderTextContribution = _PlaceholderTextContribution;
function isOrWasTrue(owner, fn) {
  return derivedObservableWithCache(owner, (reader, lastValue) => {
    if (lastValue === true) {
      return true;
    }
    return fn(reader);
  });
}

// node_modules/monaco-editor/esm/vs/platform/observable/common/wrapInReloadableClass.js
init_observable();
init_instantiation();
var __decorate94 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param94 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BaseClass2 = class {
  constructor(instantiationService) {
    this.instantiationService = instantiationService;
  }
  init(...params) {
  }
};
function createWrapper2(getClass, B) {
  return class ReloadableWrapper extends B {
    constructor() {
      super(...arguments);
      this._autorun = void 0;
    }
    init(...params) {
      this._autorun = autorunWithStore((reader, store) => {
        const clazz = readHotReloadableExport(getClass(), reader);
        store.add(this.instantiationService.createInstance(clazz, ...params));
      });
    }
    dispose() {
      this._autorun?.dispose();
    }
  };
}
function wrapInReloadableClass1(getClass) {
  return !isHotReloadEnabled() ? getClass() : createWrapper2(getClass, BaseClass13);
}
var BaseClass13 = class BaseClass14 extends BaseClass2 {
  constructor(param1, i2) {
    super(i2);
    this.init(param1);
  }
};
BaseClass13 = __decorate94([
  __param94(1, IInstantiationService)
], BaseClass13);

// node_modules/monaco-editor/esm/vs/editor/contrib/placeholderText/browser/placeholderText.contribution.js
registerEditorContribution(
  PlaceholderTextContribution.ID,
  wrapInReloadableClass1(() => PlaceholderTextContribution),
  0
  /* EditorContributionInstantiation.Eager */
);
registerColor("editor.placeholder.foreground", ghostTextForeground, localize(1324, "Foreground color of the placeholder text in the editor."));

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
init_async();
init_cancellation();
init_errors();
init_htmlContent();
init_lifecycle();
init_types();
init_uri();
init_nls();
init_actions2();
init_configurationRegistry();
init_contextkey();
init_instantiation();
init_log();
init_platform2();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_languages();
init_languageFeatures();
init_textModelEditSource();
init_editorState();

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameWidget.js
init_dom();
init_keyboardEvent();
init_iconLabels2();
init_arrays();
init_async();
init_cancellation();
init_codicons();
init_event();
init_lifecycle();
init_stopwatch();
init_types();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameWidget.css";
init_position();
init_range();
init_languages();
init_nls();
init_contextkey();
init_log();
init_colorRegistry();
init_themeService();
var __decorate95 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param95 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _sticky4 = false;
var CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize(1376, "Whether the rename input widget is visible"));
var CONTEXT_RENAME_INPUT_FOCUSED = new RawContextKey("renameInputFocused", false, localize(1377, "Whether the rename input widget is focused"));
var RenameWidget = class RenameWidget2 {
  constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService, _logService) {
    this._editor = _editor;
    this._acceptKeybindings = _acceptKeybindings;
    this._themeService = _themeService;
    this._keybindingService = _keybindingService;
    this._logService = _logService;
    this.allowEditorOverflow = true;
    this._disposables = new DisposableStore();
    this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._isEditingRenameCandidate = false;
    this._nRenameSuggestionsInvocations = 0;
    this._hadAutomaticRenameSuggestionsInvocation = false;
    this._candidates = /* @__PURE__ */ new Set();
    this._beforeFirstInputFieldEditSW = new StopWatch();
    this._inputWithButton = new InputWithButton();
    this._disposables.add(this._inputWithButton);
    this._editor.addContentWidget(this);
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        59
        /* EditorOption.fontInfo */
      )) {
        this._updateFont();
      }
    }));
    this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "monaco-editor rename-box";
      this._domNode.appendChild(this._inputWithButton.domNode);
      this._renameCandidateListView = this._disposables.add(new RenameCandidateListView(this._domNode, {
        fontInfo: this._editor.getOption(
          59
          /* EditorOption.fontInfo */
        ),
        onFocusChange: (newSymbolName) => {
          this._inputWithButton.input.value = newSymbolName;
          this._isEditingRenameCandidate = false;
        },
        onSelectionChange: () => {
          this._isEditingRenameCandidate = false;
          this.acceptInput(false);
        }
      }));
      this._disposables.add(this._inputWithButton.onDidInputChange(() => {
        if (this._renameCandidateListView?.focusedCandidate !== void 0) {
          this._isEditingRenameCandidate = true;
        }
        this._timeBeforeFirstInputFieldEdit ??= this._beforeFirstInputFieldEditSW.elapsed();
        if (this._renameCandidateProvidersCts?.token.isCancellationRequested === false) {
          this._renameCandidateProvidersCts.cancel();
        }
        this._renameCandidateListView?.clearFocus();
      }));
      this._label = document.createElement("div");
      this._label.className = "rename-label";
      this._domNode.appendChild(this._label);
      this._updateFont();
      this._updateStyles(this._themeService.getColorTheme());
    }
    return this._domNode;
  }
  _updateStyles(theme) {
    if (!this._domNode) {
      return;
    }
    const widgetShadowColor = theme.getColor(widgetShadow);
    const widgetBorderColor = theme.getColor(widgetBorder);
    this._domNode.style.backgroundColor = String(theme.getColor(editorWidgetBackground) ?? "");
    this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
    this._domNode.style.border = widgetBorderColor ? `1px solid ${widgetBorderColor}` : "";
    this._domNode.style.color = String(theme.getColor(inputForeground) ?? "");
    const border = theme.getColor(inputBorder);
    this._inputWithButton.domNode.style.backgroundColor = String(theme.getColor(inputBackground) ?? "");
    this._inputWithButton.input.style.backgroundColor = String(theme.getColor(inputBackground) ?? "");
    this._inputWithButton.domNode.style.borderWidth = border ? "1px" : "0px";
    this._inputWithButton.domNode.style.borderStyle = border ? "solid" : "none";
    this._inputWithButton.domNode.style.borderColor = border?.toString() ?? "none";
  }
  _updateFont() {
    if (this._domNode === void 0) {
      return;
    }
    assertType(this._label !== void 0, "RenameWidget#_updateFont: _label must not be undefined given _domNode is defined");
    this._editor.applyFontInfo(this._inputWithButton.input);
    const fontInfo = this._editor.getOption(
      59
      /* EditorOption.fontInfo */
    );
    this._label.style.fontSize = `${this._computeLabelFontSize(fontInfo.fontSize)}px`;
  }
  _computeLabelFontSize(editorFontSize) {
    return editorFontSize * 0.8;
  }
  getPosition() {
    if (!this._visible) {
      return null;
    }
    if (!this._editor.hasModel() || // @ulugbekna: shouldn't happen
    !this._editor.getDomNode()) {
      return null;
    }
    const bodyBox = getClientArea(this.getDomNode().ownerDocument.body);
    const editorBox = getDomNodePagePosition(this._editor.getDomNode());
    const cursorBoxTop = this._getTopForPosition();
    this._nPxAvailableAbove = cursorBoxTop + editorBox.top;
    this._nPxAvailableBelow = bodyBox.height - this._nPxAvailableAbove;
    const lineHeight = this._editor.getOption(
      75
      /* EditorOption.lineHeight */
    );
    const { totalHeight: candidateViewHeight } = RenameCandidateView.getLayoutInfo({ lineHeight });
    const positionPreference = this._nPxAvailableBelow > candidateViewHeight * 6 ? [
      2,
      1
      /* ContentWidgetPositionPreference.ABOVE */
    ] : [
      1,
      2
      /* ContentWidgetPositionPreference.BELOW */
    ];
    return {
      position: this._position,
      preference: positionPreference
    };
  }
  beforeRender() {
    const [accept, preview] = this._acceptKeybindings;
    this._label.innerText = localize(1378, "{0} to Rename, {1} to Preview", this._keybindingService.lookupKeybinding(accept)?.getLabel(), this._keybindingService.lookupKeybinding(preview)?.getLabel());
    this._domNode.style.minWidth = `200px`;
    return null;
  }
  afterRender(position) {
    if (position === null) {
      this.cancelInput(true, "afterRender (because position is null)");
      return;
    }
    if (!this._editor.hasModel() || // shouldn't happen
    !this._editor.getDomNode()) {
      return;
    }
    assertType(this._renameCandidateListView);
    assertType(this._nPxAvailableAbove !== void 0);
    assertType(this._nPxAvailableBelow !== void 0);
    const inputBoxHeight = getTotalHeight(this._inputWithButton.domNode);
    const labelHeight = getTotalHeight(this._label);
    let totalHeightAvailable;
    if (position === 2) {
      totalHeightAvailable = this._nPxAvailableBelow;
    } else {
      totalHeightAvailable = this._nPxAvailableAbove;
    }
    this._renameCandidateListView.layout({
      height: totalHeightAvailable - labelHeight - inputBoxHeight,
      width: getTotalWidth(this._inputWithButton.domNode)
    });
  }
  acceptInput(wantsPreview) {
    this._trace(`invoking acceptInput`);
    this._currentAcceptInput?.(wantsPreview);
  }
  cancelInput(focusEditor, caller) {
    this._currentCancelInput?.(focusEditor);
  }
  focusNextRenameSuggestion() {
    if (!this._renameCandidateListView?.focusNext()) {
      this._inputWithButton.input.value = this._currentName;
    }
  }
  focusPreviousRenameSuggestion() {
    if (!this._renameCandidateListView?.focusPrevious()) {
      this._inputWithButton.input.value = this._currentName;
    }
  }
  /**
   * @param requestRenameCandidates is `undefined` when there are no rename suggestion providers
   */
  getInput(where, currentName, supportPreview, requestRenameCandidates, cts) {
    const { start: selectionStart, end: selectionEnd } = this._getSelection(where, currentName);
    this._renameCts = cts;
    const disposeOnDone = new DisposableStore();
    this._nRenameSuggestionsInvocations = 0;
    this._hadAutomaticRenameSuggestionsInvocation = false;
    if (requestRenameCandidates === void 0) {
      this._inputWithButton.button.style.display = "none";
    } else {
      this._inputWithButton.button.style.display = "flex";
      this._requestRenameCandidatesOnce = requestRenameCandidates;
      this._requestRenameCandidates(currentName, false);
      disposeOnDone.add(addDisposableListener(this._inputWithButton.button, "click", () => this._requestRenameCandidates(currentName, true)));
      disposeOnDone.add(addDisposableListener(this._inputWithButton.button, EventType.KEY_DOWN, (e) => {
        const keyEvent = new StandardKeyboardEvent(e);
        if (keyEvent.equals(
          3
          /* KeyCode.Enter */
        ) || keyEvent.equals(
          10
          /* KeyCode.Space */
        )) {
          keyEvent.stopPropagation();
          keyEvent.preventDefault();
          this._requestRenameCandidates(currentName, true);
        }
      }));
    }
    this._isEditingRenameCandidate = false;
    this._domNode.classList.toggle("preview", supportPreview);
    this._position = new Position(where.startLineNumber, where.startColumn);
    this._currentName = currentName;
    this._inputWithButton.input.value = currentName;
    this._inputWithButton.input.setAttribute("selectionStart", selectionStart.toString());
    this._inputWithButton.input.setAttribute("selectionEnd", selectionEnd.toString());
    this._inputWithButton.input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
    this._beforeFirstInputFieldEditSW.reset();
    disposeOnDone.add(toDisposable(() => {
      this._renameCts = void 0;
      cts.dispose(true);
    }));
    disposeOnDone.add(toDisposable(() => {
      if (this._renameCandidateProvidersCts !== void 0) {
        this._renameCandidateProvidersCts.dispose(true);
        this._renameCandidateProvidersCts = void 0;
      }
    }));
    disposeOnDone.add(toDisposable(() => this._candidates.clear()));
    const inputResult = new DeferredPromise();
    inputResult.p.finally(() => {
      disposeOnDone.dispose();
      this._hide();
    });
    this._currentCancelInput = (focusEditor) => {
      this._trace("invoking _currentCancelInput");
      this._currentAcceptInput = void 0;
      this._currentCancelInput = void 0;
      this._renameCandidateListView?.clearCandidates();
      inputResult.complete(focusEditor);
      return true;
    };
    this._currentAcceptInput = (wantsPreview) => {
      this._trace("invoking _currentAcceptInput");
      assertType(this._renameCandidateListView !== void 0);
      const nRenameSuggestions = this._renameCandidateListView.nCandidates;
      let newName;
      let source;
      const focusedCandidate = this._renameCandidateListView.focusedCandidate;
      if (focusedCandidate !== void 0) {
        this._trace("using new name from renameSuggestion");
        newName = focusedCandidate;
        source = { k: "renameSuggestion" };
      } else {
        this._trace("using new name from inputField");
        newName = this._inputWithButton.input.value;
        source = this._isEditingRenameCandidate ? { k: "userEditedRenameSuggestion" } : { k: "inputField" };
      }
      if (newName === currentName || newName.trim().length === 0) {
        this.cancelInput(true, "_currentAcceptInput (because newName === value || newName.trim().length === 0)");
        return;
      }
      this._currentAcceptInput = void 0;
      this._currentCancelInput = void 0;
      this._renameCandidateListView.clearCandidates();
      inputResult.complete({
        newName,
        wantsPreview: supportPreview && wantsPreview,
        stats: {
          source,
          nRenameSuggestions,
          timeBeforeFirstInputFieldEdit: this._timeBeforeFirstInputFieldEdit,
          nRenameSuggestionsInvocations: this._nRenameSuggestionsInvocations,
          hadAutomaticRenameSuggestionsInvocation: this._hadAutomaticRenameSuggestionsInvocation
        }
      });
    };
    disposeOnDone.add(cts.token.onCancellationRequested(() => this.cancelInput(true, "cts.token.onCancellationRequested")));
    if (!_sticky4) {
      disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(!this._domNode?.ownerDocument.hasFocus(), "editor.onDidBlurEditorWidget")));
    }
    this._show();
    return inputResult.p;
  }
  _requestRenameCandidates(currentName, isManuallyTriggered) {
    if (this._requestRenameCandidatesOnce === void 0) {
      return;
    }
    if (this._renameCandidateProvidersCts !== void 0) {
      this._renameCandidateProvidersCts.dispose(true);
    }
    assertType(this._renameCts);
    if (this._inputWithButton.buttonState !== "stop") {
      this._renameCandidateProvidersCts = new CancellationTokenSource();
      const triggerKind = isManuallyTriggered ? NewSymbolNameTriggerKind.Invoke : NewSymbolNameTriggerKind.Automatic;
      const candidates = this._requestRenameCandidatesOnce(triggerKind, this._renameCandidateProvidersCts.token);
      if (candidates.length === 0) {
        this._inputWithButton.setSparkleButton();
        return;
      }
      if (!isManuallyTriggered) {
        this._hadAutomaticRenameSuggestionsInvocation = true;
      }
      this._nRenameSuggestionsInvocations += 1;
      this._inputWithButton.setStopButton();
      this._updateRenameCandidates(candidates, currentName, this._renameCts.token);
    }
  }
  /**
   * This allows selecting only part of the symbol name in the input field based on the selection in the editor
   */
  _getSelection(where, currentName) {
    assertType(this._editor.hasModel());
    const selection = this._editor.getSelection();
    let start = 0;
    let end = currentName.length;
    if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(where, selection)) {
      start = Math.max(0, selection.startColumn - where.startColumn);
      end = Math.min(where.endColumn, selection.endColumn) - where.startColumn;
    }
    return { start, end };
  }
  _show() {
    this._trace("invoking _show");
    this._editor.revealLineInCenterIfOutsideViewport(
      this._position.lineNumber,
      0
      /* ScrollType.Smooth */
    );
    this._visible = true;
    this._visibleContextKey.set(true);
    this._editor.layoutContentWidget(this);
    setTimeout(() => {
      this._inputWithButton.input.focus();
      this._inputWithButton.input.setSelectionRange(parseInt(this._inputWithButton.input.getAttribute("selectionStart")), parseInt(this._inputWithButton.input.getAttribute("selectionEnd")));
    }, 100);
  }
  async _updateRenameCandidates(candidates, currentName, token) {
    const trace = (...args) => this._trace("_updateRenameCandidates", ...args);
    trace("start");
    const namesListResults = await raceCancellation(Promise.allSettled(candidates), token);
    this._inputWithButton.setSparkleButton();
    if (namesListResults === void 0) {
      trace("returning early - received updateRenameCandidates results - undefined");
      return;
    }
    const newNames = namesListResults.flatMap((namesListResult) => namesListResult.status === "fulfilled" && isDefined(namesListResult.value) ? namesListResult.value : []);
    trace(`received updateRenameCandidates results - total (unfiltered) ${newNames.length} candidates.`);
    const distinctNames = distinct(newNames, (v) => v.newSymbolName);
    trace(`distinct candidates - ${distinctNames.length} candidates.`);
    const validDistinctNames = distinctNames.filter(({ newSymbolName }) => newSymbolName.trim().length > 0 && newSymbolName !== this._inputWithButton.input.value && newSymbolName !== currentName && !this._candidates.has(newSymbolName));
    trace(`valid distinct candidates - ${newNames.length} candidates.`);
    validDistinctNames.forEach((n2) => this._candidates.add(n2.newSymbolName));
    if (validDistinctNames.length < 1) {
      trace("returning early - no valid distinct candidates");
      return;
    }
    trace("setting candidates");
    this._renameCandidateListView.setCandidates(validDistinctNames);
    trace("asking editor to re-layout");
    this._editor.layoutContentWidget(this);
  }
  _hide() {
    this._trace("invoked _hide");
    this._visible = false;
    this._visibleContextKey.reset();
    this._editor.layoutContentWidget(this);
  }
  _getTopForPosition() {
    const visibleRanges = this._editor.getVisibleRanges();
    let firstLineInViewport;
    if (visibleRanges.length > 0) {
      firstLineInViewport = visibleRanges[0].startLineNumber;
    } else {
      this._logService.warn("RenameWidget#_getTopForPosition: this should not happen - visibleRanges is empty");
      firstLineInViewport = Math.max(1, this._position.lineNumber - 5);
    }
    return this._editor.getTopForLineNumber(this._position.lineNumber) - this._editor.getTopForLineNumber(firstLineInViewport);
  }
  _trace(...args) {
    this._logService.trace("RenameWidget", ...args);
  }
};
RenameWidget = __decorate95([
  __param95(2, IThemeService),
  __param95(3, IKeybindingService),
  __param95(4, IContextKeyService),
  __param95(5, ILogService)
], RenameWidget);
var RenameCandidateListView = class _RenameCandidateListView {
  // FIXME@ulugbekna: rewrite using event emitters
  constructor(parent, opts) {
    this._disposables = new DisposableStore();
    this._availableHeight = 0;
    this._minimumWidth = 0;
    this._lineHeight = opts.fontInfo.lineHeight;
    this._typicalHalfwidthCharacterWidth = opts.fontInfo.typicalHalfwidthCharacterWidth;
    this._listContainer = document.createElement("div");
    this._listContainer.className = "rename-box rename-candidate-list-container";
    parent.appendChild(this._listContainer);
    this._listWidget = _RenameCandidateListView._createListWidget(this._listContainer, this._candidateViewHeight, opts.fontInfo);
    this._disposables.add(this._listWidget.onDidChangeFocus((e) => {
      if (e.elements.length === 1) {
        opts.onFocusChange(e.elements[0].newSymbolName);
      }
    }, this._disposables));
    this._disposables.add(this._listWidget.onDidChangeSelection((e) => {
      if (e.elements.length === 1) {
        opts.onSelectionChange();
      }
    }, this._disposables));
    this._disposables.add(this._listWidget.onDidBlur((e) => {
      this._listWidget.setFocus([]);
    }));
    this._listWidget.style(getListStyles({
      listInactiveFocusForeground: quickInputListFocusForeground,
      listInactiveFocusBackground: quickInputListFocusBackground
    }));
  }
  dispose() {
    this._listWidget.dispose();
    this._disposables.dispose();
  }
  // height - max height allowed by parent element
  layout({ height, width }) {
    this._availableHeight = height;
    this._minimumWidth = width;
  }
  setCandidates(candidates) {
    this._listWidget.splice(0, 0, candidates);
    const height = this._pickListHeight(this._listWidget.length);
    const width = this._pickListWidth(candidates);
    this._listWidget.layout(height, width);
    this._listContainer.style.height = `${height}px`;
    this._listContainer.style.width = `${width}px`;
    status(localize(1379, "Received {0} rename suggestions", candidates.length));
  }
  clearCandidates() {
    this._listContainer.style.height = "0px";
    this._listContainer.style.width = "0px";
    this._listWidget.splice(0, this._listWidget.length, []);
  }
  get nCandidates() {
    return this._listWidget.length;
  }
  get focusedCandidate() {
    if (this._listWidget.length === 0) {
      return;
    }
    const selectedElement = this._listWidget.getSelectedElements()[0];
    if (selectedElement !== void 0) {
      return selectedElement.newSymbolName;
    }
    const focusedElement = this._listWidget.getFocusedElements()[0];
    if (focusedElement !== void 0) {
      return focusedElement.newSymbolName;
    }
    return;
  }
  focusNext() {
    if (this._listWidget.length === 0) {
      return false;
    }
    const focusedIxs = this._listWidget.getFocus();
    if (focusedIxs.length === 0) {
      this._listWidget.focusFirst();
      this._listWidget.reveal(0);
      return true;
    } else {
      if (focusedIxs[0] === this._listWidget.length - 1) {
        this._listWidget.setFocus([]);
        this._listWidget.reveal(0);
        return false;
      } else {
        this._listWidget.focusNext();
        const focused = this._listWidget.getFocus()[0];
        this._listWidget.reveal(focused);
        return true;
      }
    }
  }
  /**
   * @returns true if focus is moved to previous element
   */
  focusPrevious() {
    if (this._listWidget.length === 0) {
      return false;
    }
    const focusedIxs = this._listWidget.getFocus();
    if (focusedIxs.length === 0) {
      this._listWidget.focusLast();
      const focused = this._listWidget.getFocus()[0];
      this._listWidget.reveal(focused);
      return true;
    } else {
      if (focusedIxs[0] === 0) {
        this._listWidget.setFocus([]);
        return false;
      } else {
        this._listWidget.focusPrevious();
        const focused = this._listWidget.getFocus()[0];
        this._listWidget.reveal(focused);
        return true;
      }
    }
  }
  clearFocus() {
    this._listWidget.setFocus([]);
  }
  get _candidateViewHeight() {
    const { totalHeight } = RenameCandidateView.getLayoutInfo({ lineHeight: this._lineHeight });
    return totalHeight;
  }
  _pickListHeight(nCandidates) {
    const heightToFitAllCandidates = this._candidateViewHeight * nCandidates;
    const MAX_N_CANDIDATES = 7;
    const height = Math.min(heightToFitAllCandidates, this._availableHeight, this._candidateViewHeight * MAX_N_CANDIDATES);
    return height;
  }
  _pickListWidth(candidates) {
    const longestCandidateWidth = Math.ceil(Math.max(...candidates.map((c) => c.newSymbolName.length)) * this._typicalHalfwidthCharacterWidth);
    const width = Math.max(
      this._minimumWidth,
      4 + 16 + 5 + longestCandidateWidth + 10
      /* (possibly visible) scrollbar width */
      // TODO@ulugbekna: approximate calc - clean this up
    );
    return width;
  }
  static _createListWidget(container, candidateViewHeight, fontInfo) {
    const virtualDelegate = new class {
      getTemplateId(element) {
        return "candidate";
      }
      getHeight(element) {
        return candidateViewHeight;
      }
    }();
    const renderer = new class {
      constructor() {
        this.templateId = "candidate";
      }
      renderTemplate(container2) {
        return new RenameCandidateView(container2, fontInfo);
      }
      renderElement(candidate, index, templateData) {
        templateData.populate(candidate);
      }
      disposeTemplate(templateData) {
        templateData.dispose();
      }
    }();
    return new List("NewSymbolNameCandidates", container, virtualDelegate, [renderer], {
      keyboardSupport: false,
      // @ulugbekna: because we handle keyboard events through proper commands & keybinding service, see `rename.ts`
      mouseSupport: true,
      multipleSelectionSupport: false
    });
  }
};
var InputWithButton = class {
  constructor() {
    this._buttonHoverContent = "";
    this._onDidInputChange = new Emitter();
    this.onDidInputChange = this._onDidInputChange.event;
    this._disposables = new DisposableStore();
  }
  get domNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "rename-input-with-button";
      this._domNode.style.display = "flex";
      this._domNode.style.flexDirection = "row";
      this._domNode.style.alignItems = "center";
      this._inputNode = document.createElement("input");
      this._inputNode.className = "rename-input";
      this._inputNode.type = "text";
      this._inputNode.style.border = "none";
      this._inputNode.setAttribute("aria-label", localize(1380, "Rename input. Type new name and press Enter to commit."));
      this._domNode.appendChild(this._inputNode);
      this._buttonNode = document.createElement("div");
      this._buttonNode.className = "rename-suggestions-button";
      this._buttonNode.setAttribute("tabindex", "0");
      this._buttonGenHoverText = localize(1381, "Generate new name suggestions");
      this._buttonCancelHoverText = localize(1382, "Cancel");
      this._buttonHoverContent = this._buttonGenHoverText;
      this._disposables.add(getBaseLayerHoverDelegate().setupDelayedHover(this._buttonNode, () => ({
        content: this._buttonHoverContent,
        appearance: {
          showPointer: true,
          compact: true
        }
      })));
      this._domNode.appendChild(this._buttonNode);
      this._disposables.add(addDisposableListener(this.input, EventType.INPUT, () => this._onDidInputChange.fire()));
      this._disposables.add(addDisposableListener(this.input, EventType.KEY_DOWN, (e) => {
        const keyEvent = new StandardKeyboardEvent(e);
        if (keyEvent.keyCode === 15 || keyEvent.keyCode === 17) {
          this._onDidInputChange.fire();
        }
      }));
      this._disposables.add(addDisposableListener(this.input, EventType.CLICK, () => this._onDidInputChange.fire()));
      this._disposables.add(addDisposableListener(this.input, EventType.FOCUS, () => {
        this.domNode.style.outlineWidth = "1px";
        this.domNode.style.outlineStyle = "solid";
        this.domNode.style.outlineOffset = "-1px";
        this.domNode.style.outlineColor = "var(--vscode-focusBorder)";
      }));
      this._disposables.add(addDisposableListener(this.input, EventType.BLUR, () => {
        this.domNode.style.outline = "none";
      }));
    }
    return this._domNode;
  }
  get input() {
    assertType(this._inputNode);
    return this._inputNode;
  }
  get button() {
    assertType(this._buttonNode);
    return this._buttonNode;
  }
  get buttonState() {
    return this._buttonState;
  }
  setSparkleButton() {
    this._buttonState = "sparkle";
    this._sparkleIcon ??= renderIcon(Codicon.sparkle);
    clearNode(this.button);
    this.button.appendChild(this._sparkleIcon);
    this.button.setAttribute("aria-label", "Generating new name suggestions");
    this._buttonHoverContent = this._buttonGenHoverText;
    this.input.focus();
  }
  setStopButton() {
    this._buttonState = "stop";
    this._stopIcon ??= renderIcon(Codicon.stopCircle);
    clearNode(this.button);
    this.button.appendChild(this._stopIcon);
    this.button.setAttribute("aria-label", "Cancel generating new name suggestions");
    this._buttonHoverContent = this._buttonCancelHoverText;
    this.input.focus();
  }
  dispose() {
    this._disposables.dispose();
  }
};
var _RenameCandidateView = class _RenameCandidateView {
  constructor(parent, fontInfo) {
    this._domNode = document.createElement("div");
    this._domNode.className = "rename-box rename-candidate";
    this._domNode.style.display = `flex`;
    this._domNode.style.columnGap = `5px`;
    this._domNode.style.alignItems = `center`;
    this._domNode.style.height = `${fontInfo.lineHeight}px`;
    this._domNode.style.padding = `${_RenameCandidateView._PADDING}px`;
    const iconContainer = document.createElement("div");
    iconContainer.style.display = `flex`;
    iconContainer.style.alignItems = `center`;
    iconContainer.style.width = iconContainer.style.height = `${fontInfo.lineHeight * 0.8}px`;
    this._domNode.appendChild(iconContainer);
    this._icon = renderIcon(Codicon.sparkle);
    this._icon.style.display = `none`;
    iconContainer.appendChild(this._icon);
    this._label = document.createElement("div");
    applyFontInfo(this._label, fontInfo);
    this._domNode.appendChild(this._label);
    parent.appendChild(this._domNode);
  }
  populate(value) {
    this._updateIcon(value);
    this._updateLabel(value);
  }
  _updateIcon(value) {
    const isAIGenerated = !!value.tags?.includes(NewSymbolNameTag.AIGenerated);
    this._icon.style.display = isAIGenerated ? "inherit" : "none";
  }
  _updateLabel(value) {
    this._label.innerText = value.newSymbolName;
  }
  static getLayoutInfo({ lineHeight }) {
    const totalHeight = lineHeight + _RenameCandidateView._PADDING * 2;
    return { totalHeight };
  }
  dispose() {
  }
};
_RenameCandidateView._PADDING = 2;
var RenameCandidateView = _RenameCandidateView;

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
var __decorate96 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param96 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RenameController_1;
var RenameSkeleton = class {
  constructor(model, position, registry) {
    this.model = model;
    this.position = position;
    this._providerRenameIdx = 0;
    this._providers = registry.ordered(model);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  async resolveRenameLocation(token) {
    const rejects = [];
    for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
      const provider = this._providers[this._providerRenameIdx];
      if (!provider.resolveRenameLocation) {
        break;
      }
      const res = await provider.resolveRenameLocation(this.model, this.position, token);
      if (!res) {
        continue;
      }
      if (res.rejectReason) {
        rejects.push(res.rejectReason);
        continue;
      }
      return res;
    }
    this._providerRenameIdx = 0;
    const word = this.model.getWordAtPosition(this.position);
    if (!word) {
      return {
        range: Range.fromPositions(this.position),
        text: "",
        rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
      };
    }
    return {
      range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
      text: word.word,
      rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
    };
  }
  async provideRenameEdits(newName, token) {
    return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
  }
  async _provideRenameEdits(newName, i2, rejects, token) {
    const provider = this._providers[i2];
    if (!provider) {
      return {
        edits: [],
        rejectReason: rejects.join("\n")
      };
    }
    const result = await provider.provideRenameEdits(this.model, this.position, newName, token);
    if (!result) {
      return this._provideRenameEdits(newName, i2 + 1, rejects.concat(localize(1365, "No result.")), token);
    } else if (result.rejectReason) {
      return this._provideRenameEdits(newName, i2 + 1, rejects.concat(result.rejectReason), token);
    }
    return result;
  }
};
async function rename(registry, model, position, newName) {
  const skeleton = new RenameSkeleton(model, position, registry);
  const loc = await skeleton.resolveRenameLocation(CancellationToken.None);
  if (loc?.rejectReason) {
    return { edits: [], rejectReason: loc.rejectReason };
  }
  return skeleton.provideRenameEdits(newName, CancellationToken.None);
}
var _a61;
var RenameController = (_a61 = class {
  static get(editor2) {
    return editor2.getContribution(RenameController_1.ID);
  }
  constructor(editor2, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService) {
    this.editor = editor2;
    this._instaService = _instaService;
    this._notificationService = _notificationService;
    this._bulkEditService = _bulkEditService;
    this._progressService = _progressService;
    this._logService = _logService;
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._disposableStore = new DisposableStore();
    this._cts = new CancellationTokenSource();
    this._renameWidget = this._disposableStore.add(this._instaService.createInstance(RenameWidget, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]));
  }
  dispose() {
    this._disposableStore.dispose();
    this._cts.dispose(true);
  }
  async run() {
    const trace = this._logService.trace.bind(this._logService, "[rename]");
    this._cts.dispose(true);
    this._cts = new CancellationTokenSource();
    if (!this.editor.hasModel()) {
      trace("editor has no model");
      return void 0;
    }
    const position = this.editor.getPosition();
    const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
    if (!skeleton.hasProvider()) {
      trace("skeleton has no provider");
      return void 0;
    }
    const cts1 = new EditorStateCancellationTokenSource(this.editor, 4 | 1, void 0, this._cts.token);
    let loc;
    try {
      trace("resolving rename location");
      const resolveLocationOperation = skeleton.resolveRenameLocation(cts1.token);
      this._progressService.showWhile(resolveLocationOperation, 250);
      loc = await resolveLocationOperation;
      trace("resolved rename location");
    } catch (e) {
      if (e instanceof CancellationError) {
        trace("resolve rename location cancelled", JSON.stringify(e, null, "	"));
      } else {
        trace("resolve rename location failed", e instanceof Error ? e : JSON.stringify(e, null, "	"));
        if (typeof e === "string" || isMarkdownString(e)) {
          MessageController.get(this.editor)?.showMessage(e || localize(1366, "An unknown error occurred while resolving rename location"), position);
        }
      }
      return void 0;
    } finally {
      cts1.dispose();
    }
    if (!loc) {
      trace("returning early - no loc");
      return void 0;
    }
    if (loc.rejectReason) {
      trace(`returning early - rejected with reason: ${loc.rejectReason}`, loc.rejectReason);
      MessageController.get(this.editor)?.showMessage(loc.rejectReason, position);
      return void 0;
    }
    if (cts1.token.isCancellationRequested) {
      trace("returning early - cts1 cancelled");
      return void 0;
    }
    const cts2 = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range, this._cts.token);
    const model = this.editor.getModel();
    const newSymbolNamesProviders = this._languageFeaturesService.newSymbolNamesProvider.all(model);
    const resolvedNewSymbolnamesProviders = await Promise.all(newSymbolNamesProviders.map(async (p) => [p, await p.supportsAutomaticNewSymbolNamesTriggerKind ?? false]));
    const requestRenameSuggestions = (triggerKind, cts) => {
      let providers = resolvedNewSymbolnamesProviders.slice();
      if (triggerKind === NewSymbolNameTriggerKind.Automatic) {
        providers = providers.filter(([_, supportsAutomatic]) => supportsAutomatic);
      }
      return providers.map(([p]) => p.provideNewSymbolNames(model, loc.range, triggerKind, cts));
    };
    trace("creating rename input field and awaiting its result");
    const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
    const inputFieldResult = await this._renameWidget.getInput(loc.range, loc.text, supportPreview, newSymbolNamesProviders.length > 0 ? requestRenameSuggestions : void 0, cts2);
    trace("received response from rename input field");
    if (typeof inputFieldResult === "boolean") {
      trace(`returning early - rename input field response - ${inputFieldResult}`);
      if (inputFieldResult) {
        this.editor.focus();
      }
      cts2.dispose();
      return void 0;
    }
    this.editor.focus();
    trace("requesting rename edits");
    const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, cts2.token), cts2.token).then(async (renameResult) => {
      if (!renameResult) {
        trace("returning early - no rename edits result");
        return;
      }
      if (!this.editor.hasModel()) {
        trace("returning early - no model after rename edits are provided");
        return;
      }
      if (renameResult.rejectReason) {
        trace(`returning early - rejected with reason: ${renameResult.rejectReason}`);
        this._notificationService.info(renameResult.rejectReason);
        return;
      }
      this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));
      trace("applying edits");
      this._bulkEditService.apply(renameResult, {
        editor: this.editor,
        showPreview: inputFieldResult.wantsPreview,
        label: localize(1367, "Renaming '{0}' to '{1}'", loc?.text, inputFieldResult.newName),
        code: "undoredo.rename",
        quotableLabel: localize(1368, "Renaming {0} to {1}", loc?.text, inputFieldResult.newName),
        respectAutoSaveConfig: true,
        reason: EditSources.rename()
      }).then((result) => {
        trace("edits applied");
        if (result.ariaSummary) {
          alert(localize(1369, "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
        }
      }).catch((err) => {
        trace(`error when applying edits ${JSON.stringify(err, null, "	")}`);
        this._notificationService.error(localize(1370, "Rename failed to apply edits"));
        this._logService.error(err);
      });
    }, (err) => {
      trace("error when providing rename edits", JSON.stringify(err, null, "	"));
      this._notificationService.error(localize(1371, "Rename failed to compute edits"));
      this._logService.error(err);
    }).finally(() => {
      cts2.dispose();
    });
    trace("returning rename operation");
    this._progressService.showWhile(renameOperation, 250);
    return renameOperation;
  }
  acceptRenameInput(wantsPreview) {
    this._renameWidget.acceptInput(wantsPreview);
  }
  cancelRenameInput() {
    this._renameWidget.cancelInput(true, "cancelRenameInput command");
  }
  focusNextRenameSuggestion() {
    this._renameWidget.focusNextRenameSuggestion();
  }
  focusPreviousRenameSuggestion() {
    this._renameWidget.focusPreviousRenameSuggestion();
  }
}, RenameController_1 = _a61, _a61.ID = "editor.contrib.renameController", _a61);
RenameController = RenameController_1 = __decorate96([
  __param96(1, IInstantiationService),
  __param96(2, INotificationService),
  __param96(3, IBulkEditService),
  __param96(4, IEditorProgressService),
  __param96(5, ILogService),
  __param96(6, ITextResourceConfigurationService),
  __param96(7, ILanguageFeaturesService)
], RenameController);
var RenameAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.rename",
      label: localize2(1373, "Rename Symbol"),
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 60,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(accessor, editor2) {
    const logService = accessor.get(ILogService);
    const controller = RenameController.get(editor2);
    if (controller) {
      logService.trace("[RenameAction] got controller, running...");
      return controller.run();
    }
    logService.trace("[RenameAction] returning early - controller missing");
    return Promise.resolve();
  }
};
registerEditorContribution(
  RenameController.ID,
  RenameController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.acceptRenameInput(false),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInputWithPreview",
  precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
  handler: (x) => x.acceptRenameInput(true),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 2048 + 3
    /* KeyCode.Enter */
  }
}));
registerEditorCommand(new RenameCommand({
  id: "cancelRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.cancelRenameInput(),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [
      1024 | 9
      /* KeyCode.Escape */
    ]
  }
}));
registerAction2(class FocusNextRenameSuggestion extends Action2 {
  constructor() {
    super({
      id: "focusNextRenameSuggestion",
      title: {
        ...localize2(1374, "Focus Next Rename Suggestion")
      },
      precondition: CONTEXT_RENAME_INPUT_VISIBLE,
      keybinding: [
        {
          primary: 18,
          weight: 100 + 99
        }
      ]
    });
  }
  run(accessor) {
    const currentEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (!currentEditor) {
      return;
    }
    const controller = RenameController.get(currentEditor);
    if (!controller) {
      return;
    }
    controller.focusNextRenameSuggestion();
  }
});
registerAction2(class FocusPreviousRenameSuggestion extends Action2 {
  constructor() {
    super({
      id: "focusPreviousRenameSuggestion",
      title: {
        ...localize2(1375, "Focus Previous Rename Suggestion")
      },
      precondition: CONTEXT_RENAME_INPUT_VISIBLE,
      keybinding: [
        {
          primary: 16,
          weight: 100 + 99
        }
      ]
    });
  }
  run(accessor) {
    const currentEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (!currentEditor) {
      return;
    }
    const controller = RenameController.get(currentEditor);
    if (!controller) {
      return;
    }
    controller.focusPreviousRenameSuggestion();
  }
});
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(accessor, model, position, ...args) {
  const [newName] = args;
  assertType(typeof newName === "string");
  const { renameProvider } = accessor.get(ILanguageFeaturesService);
  return rename(renameProvider, model, position, newName);
});
registerModelAndPositionCommand("_executePrepareRename", async function(accessor, model, position) {
  const { renameProvider } = accessor.get(ILanguageFeaturesService);
  const skeleton = new RenameSkeleton(model, position, renameProvider);
  const loc = await skeleton.resolveRenameLocation(CancellationToken.None);
  if (loc?.rejectReason) {
    throw new Error(loc.rejectReason);
  }
  return loc;
});
Registry.as(Extensions.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 6,
      description: localize(1372, "Enable/disable the ability to preview changes before renaming"),
      default: true,
      type: "boolean"
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/sectionHeaders/browser/sectionHeaders.js
init_async();
init_lifecycle();
init_editorExtensions();
init_languageConfigurationRegistry();
init_textModel();
init_editorWorker();
var __decorate97 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param97 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a62;
var SectionHeaderDetector = (_a62 = class extends Disposable {
  constructor(editor2, languageConfigurationService, editorWorkerService) {
    super();
    this.editor = editor2;
    this.languageConfigurationService = languageConfigurationService;
    this.editorWorkerService = editorWorkerService;
    this.decorations = this.editor.createDecorationsCollection();
    this.options = this.createOptions(editor2.getOption(
      81
      /* EditorOption.minimap */
    ));
    this.computePromise = null;
    this.currentOccurrences = {};
    this._register(editor2.onDidChangeModel((e) => {
      this.currentOccurrences = {};
      this.options = this.createOptions(editor2.getOption(
        81
        /* EditorOption.minimap */
      ));
      this.stop();
      this.computeSectionHeaders.schedule(0);
    }));
    this._register(editor2.onDidChangeModelLanguage((e) => {
      this.currentOccurrences = {};
      this.options = this.createOptions(editor2.getOption(
        81
        /* EditorOption.minimap */
      ));
      this.stop();
      this.computeSectionHeaders.schedule(0);
    }));
    this._register(languageConfigurationService.onDidChange((e) => {
      const editorLanguageId = this.editor.getModel()?.getLanguageId();
      if (editorLanguageId && e.affects(editorLanguageId)) {
        this.currentOccurrences = {};
        this.options = this.createOptions(editor2.getOption(
          81
          /* EditorOption.minimap */
        ));
        this.stop();
        this.computeSectionHeaders.schedule(0);
      }
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (this.options && !e.hasChanged(
        81
        /* EditorOption.minimap */
      )) {
        return;
      }
      this.options = this.createOptions(editor2.getOption(
        81
        /* EditorOption.minimap */
      ));
      this.updateDecorations([]);
      this.stop();
      this.computeSectionHeaders.schedule(0);
    }));
    this._register(this.editor.onDidChangeModelContent((e) => {
      this.computeSectionHeaders.schedule();
    }));
    this._register(editor2.onDidChangeModelTokens((e) => {
      if (!this.computeSectionHeaders.isScheduled()) {
        this.computeSectionHeaders.schedule(1e3);
      }
    }));
    this.computeSectionHeaders = this._register(new RunOnceScheduler(() => {
      this.findSectionHeaders();
    }, 250));
    this.computeSectionHeaders.schedule(0);
  }
  createOptions(minimap) {
    if (!minimap || !this.editor.hasModel()) {
      return void 0;
    }
    const languageId = this.editor.getModel().getLanguageId();
    if (!languageId) {
      return void 0;
    }
    const commentsConfiguration = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    const foldingRules = this.languageConfigurationService.getLanguageConfiguration(languageId).foldingRules;
    if (!commentsConfiguration && !foldingRules?.markers) {
      return void 0;
    }
    return {
      foldingRules,
      markSectionHeaderRegex: minimap.markSectionHeaderRegex,
      findMarkSectionHeaders: minimap.showMarkSectionHeaders,
      findRegionSectionHeaders: minimap.showRegionSectionHeaders
    };
  }
  findSectionHeaders() {
    if (!this.editor.hasModel() || !this.options?.findMarkSectionHeaders && !this.options?.findRegionSectionHeaders) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isDisposed() || model.isTooLargeForSyncing()) {
      return;
    }
    const modelVersionId = model.getVersionId();
    this.editorWorkerService.findSectionHeaders(model.uri, this.options).then((sectionHeaders) => {
      if (model.isDisposed() || model.getVersionId() !== modelVersionId) {
        return;
      }
      this.updateDecorations(sectionHeaders);
    });
  }
  updateDecorations(sectionHeaders) {
    const model = this.editor.getModel();
    if (model) {
      sectionHeaders = sectionHeaders.filter((sectionHeader) => {
        if (!sectionHeader.shouldBeInComments) {
          return true;
        }
        const validRange = model.validateRange(sectionHeader.range);
        const tokens = model.tokenization.getLineTokens(validRange.startLineNumber);
        const idx = tokens.findTokenIndexAtOffset(validRange.startColumn - 1);
        const tokenType = tokens.getStandardTokenType(idx);
        const languageId = tokens.getLanguageId(idx);
        return languageId === model.getLanguageId() && tokenType === 1;
      });
    }
    const oldDecorations = Object.values(this.currentOccurrences).map((occurrence) => occurrence.decorationId);
    const newDecorations = sectionHeaders.map((sectionHeader) => decoration2(sectionHeader));
    this.editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
      this.currentOccurrences = {};
      for (let i2 = 0, len = decorations.length; i2 < len; i2++) {
        const occurrence = { sectionHeader: sectionHeaders[i2], decorationId: decorations[i2] };
        this.currentOccurrences[occurrence.decorationId] = occurrence;
      }
    });
  }
  stop() {
    this.computeSectionHeaders.cancel();
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    super.dispose();
    this.stop();
    this.decorations.clear();
  }
}, _a62.ID = "editor.sectionHeaderDetector", _a62);
SectionHeaderDetector = __decorate97([
  __param97(1, ILanguageConfigurationService),
  __param97(2, IEditorWorkerService)
], SectionHeaderDetector);
function decoration2(sectionHeader) {
  return {
    range: sectionHeader.range,
    options: ModelDecorationOptions.createDynamic({
      description: "section-header",
      stickiness: 3,
      collapseOnReplaceEdit: true,
      minimap: {
        color: void 0,
        position: 1,
        sectionHeaderStyle: sectionHeader.hasSeparatorLine ? 2 : 1,
        sectionHeaderText: sectionHeader.text
      }
    })
  };
}
registerEditorContribution(
  SectionHeaderDetector.ID,
  SectionHeaderDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_map();
init_stopwatch();
init_configuration();
init_themeService();
init_languageFeatureDebounce();
init_languageFeatures();
init_model();

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js
init_cancellation();
init_errors();
init_uri();
init_model();
init_commands();
init_types();

// node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js
init_buffer();
init_platform();
function reverseEndianness(arr) {
  for (let i2 = 0, len = arr.length; i2 < len; i2 += 4) {
    const b0 = arr[i2 + 0];
    const b1 = arr[i2 + 1];
    const b2 = arr[i2 + 2];
    const b3 = arr[i2 + 3];
    arr[i2 + 0] = b3;
    arr[i2 + 1] = b2;
    arr[i2 + 2] = b1;
    arr[i2 + 3] = b0;
  }
}
function toLittleEndianBuffer(arr) {
  const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
  if (!isLittleEndian()) {
    reverseEndianness(uint8Arr);
  }
  return VSBuffer.wrap(uint8Arr);
}
function encodeSemanticTokensDto(semanticTokens) {
  const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
  let offset = 0;
  dest[offset++] = semanticTokens.id;
  if (semanticTokens.type === "full") {
    dest[offset++] = 1;
    dest[offset++] = semanticTokens.data.length;
    dest.set(semanticTokens.data, offset);
    offset += semanticTokens.data.length;
  } else {
    dest[offset++] = 2;
    dest[offset++] = semanticTokens.deltas.length;
    for (const delta of semanticTokens.deltas) {
      dest[offset++] = delta.start;
      dest[offset++] = delta.deleteCount;
      if (delta.data) {
        dest[offset++] = delta.data.length;
        dest.set(delta.data, offset);
        offset += delta.data.length;
      } else {
        dest[offset++] = 0;
      }
    }
  }
  return toLittleEndianBuffer(dest);
}
function encodeSemanticTokensDtoSize(semanticTokens) {
  let result = 0;
  result += 1 + 1;
  if (semanticTokens.type === "full") {
    result += 1 + semanticTokens.data.length;
  } else {
    result += 1;
    result += (1 + 1 + 1) * semanticTokens.deltas.length;
    for (const delta of semanticTokens.deltas) {
      if (delta.data) {
        result += delta.data.length;
      }
    }
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js
init_range();
init_languageFeatures();
function isSemanticTokens(v) {
  return v && !!v.data;
}
function isSemanticTokensEdits(v) {
  return v && Array.isArray(v.edits);
}
var DocumentSemanticTokensResult = class {
  constructor(provider, tokens, error) {
    this.provider = provider;
    this.tokens = tokens;
    this.error = error;
  }
};
function hasDocumentSemanticTokensProvider(registry, model) {
  return registry.has(model);
}
function getDocumentSemanticTokensProviders(registry, model) {
  const groups = registry.orderedGroups(model);
  return groups.length > 0 ? groups[0] : [];
}
async function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {
  const providers = getDocumentSemanticTokensProviders(registry, model);
  const results = await Promise.all(providers.map(async (provider) => {
    let result;
    let error = null;
    try {
      result = await provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);
    } catch (err) {
      error = err;
      result = null;
    }
    if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {
      result = null;
    }
    return new DocumentSemanticTokensResult(provider, result, error);
  }));
  for (const result of results) {
    if (result.error) {
      throw result.error;
    }
    if (result.tokens) {
      return result;
    }
  }
  if (results.length > 0) {
    return results[0];
  }
  return null;
}
function _getDocumentSemanticTokensProviderHighestGroup(registry, model) {
  const result = registry.orderedGroups(model);
  return result.length > 0 ? result[0] : null;
}
var DocumentRangeSemanticTokensResult = class {
  constructor(provider, tokens) {
    this.provider = provider;
    this.tokens = tokens;
  }
};
function hasDocumentRangeSemanticTokensProvider(providers, model) {
  return providers.has(model);
}
function getDocumentRangeSemanticTokensProviders(providers, model) {
  const groups = providers.orderedGroups(model);
  return groups.length > 0 ? groups[0] : [];
}
async function getDocumentRangeSemanticTokens(registry, model, range, token) {
  const providers = getDocumentRangeSemanticTokensProviders(registry, model);
  const results = await Promise.all(providers.map(async (provider) => {
    let result;
    try {
      result = await provider.provideDocumentRangeSemanticTokens(model, range, token);
    } catch (err) {
      onUnexpectedExternalError(err);
      result = null;
    }
    if (!result || !isSemanticTokens(result)) {
      result = null;
    }
    return new DocumentRangeSemanticTokensResult(provider, result);
  }));
  for (const result of results) {
    if (result.tokens) {
      return result;
    }
  }
  if (results.length > 0) {
    return results[0];
  }
  return null;
}
CommandsRegistry.registerCommand("_provideDocumentSemanticTokensLegend", async (accessor, ...args) => {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);
  if (!providers) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokensLegend", uri);
  }
  return providers[0].getLegend();
});
CommandsRegistry.registerCommand("_provideDocumentSemanticTokens", async (accessor, ...args) => {
  const [uri] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {
    return accessor.get(ICommandService).executeCommand("_provideDocumentRangeSemanticTokens", uri, model.getFullModelRange());
  }
  const r = await getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);
  if (!r) {
    return void 0;
  }
  const { provider, tokens } = r;
  if (!tokens || !isSemanticTokens(tokens)) {
    return void 0;
  }
  const buff = encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: tokens.data
  });
  if (tokens.resultId) {
    provider.releaseDocumentSemanticTokens(tokens.resultId);
  }
  return buff;
});
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokensLegend", async (accessor, ...args) => {
  const [uri, range] = args;
  assertType(uri instanceof URI);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);
  if (providers.length === 0) {
    return void 0;
  }
  if (providers.length === 1) {
    return providers[0].getLegend();
  }
  if (!range || !Range.isIRange(range)) {
    console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);
    return providers[0].getLegend();
  }
  const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
  if (!result) {
    return void 0;
  }
  return result.provider.getLegend();
});
CommandsRegistry.registerCommand("_provideDocumentRangeSemanticTokens", async (accessor, ...args) => {
  const [uri, range] = args;
  assertType(uri instanceof URI);
  assertType(Range.isIRange(range));
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return void 0;
  }
  const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);
  const result = await getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);
  if (!result || !result.tokens) {
    return void 0;
  }
  return encodeSemanticTokensDto({
    id: 0,
    type: "full",
    data: result.tokens.data
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/semanticTokensConfig.js
var SEMANTIC_HIGHLIGHTING_SETTING_ID = "editor.semanticHighlighting";
function isSemanticColoringEnabled(model, themeService, configurationService) {
  const setting = configurationService.getValue(SEMANTIC_HIGHLIGHTING_SETTING_ID, { overrideIdentifier: model.getLanguageId(), resource: model.uri })?.enabled;
  if (typeof setting === "boolean") {
    return setting;
  }
  return themeService.getColorTheme().semanticHighlighting;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/documentSemanticTokens.js
var __decorate98 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param98 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModelSemanticColoring_1;
var DocumentSemanticTokensFeature = class DocumentSemanticTokensFeature2 extends Disposable {
  constructor(semanticTokensStylingService, modelService, themeService, configurationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._watchers = new ResourceMap();
    const register = (model) => {
      this._watchers.get(model.uri)?.dispose();
      this._watchers.set(model.uri, new ModelSemanticColoring(model, semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService));
    };
    const deregister = (model, modelSemanticColoring) => {
      modelSemanticColoring.dispose();
      this._watchers.delete(model.uri);
    };
    const handleSettingOrThemeChange = () => {
      for (const model of modelService.getModels()) {
        const curr = this._watchers.get(model.uri);
        if (isSemanticColoringEnabled(model, themeService, configurationService)) {
          if (!curr) {
            register(model);
          }
        } else {
          if (curr) {
            deregister(model, curr);
          }
        }
      }
    };
    modelService.getModels().forEach((model) => {
      if (isSemanticColoringEnabled(model, themeService, configurationService)) {
        register(model);
      }
    });
    this._register(modelService.onModelAdded((model) => {
      if (isSemanticColoringEnabled(model, themeService, configurationService)) {
        register(model);
      }
    }));
    this._register(modelService.onModelRemoved((model) => {
      const curr = this._watchers.get(model.uri);
      if (curr) {
        deregister(model, curr);
      }
    }));
    this._register(configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        handleSettingOrThemeChange();
      }
    }));
    this._register(themeService.onDidColorThemeChange(handleSettingOrThemeChange));
  }
  dispose() {
    dispose(this._watchers.values());
    this._watchers.clear();
    super.dispose();
  }
};
DocumentSemanticTokensFeature = __decorate98([
  __param98(0, ISemanticTokensStylingService),
  __param98(1, IModelService),
  __param98(2, IThemeService),
  __param98(3, IConfigurationService),
  __param98(4, ILanguageFeatureDebounceService),
  __param98(5, ILanguageFeaturesService)
], DocumentSemanticTokensFeature);
var _a63;
var ModelSemanticColoring = (_a63 = class extends Disposable {
  constructor(model, _semanticTokensStylingService, themeService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._semanticTokensStylingService = _semanticTokensStylingService;
    this._isDisposed = false;
    this._model = model;
    this._provider = languageFeaturesService.documentSemanticTokensProvider;
    this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentSemanticTokens", { min: ModelSemanticColoring_1.REQUEST_MIN_DELAY, max: ModelSemanticColoring_1.REQUEST_MAX_DELAY });
    this._fetchDocumentSemanticTokens = this._register(new RunOnceScheduler(() => this._fetchDocumentSemanticTokensNow(), ModelSemanticColoring_1.REQUEST_MIN_DELAY));
    this._currentDocumentResponse = null;
    this._currentDocumentRequestCancellationTokenSource = null;
    this._documentProvidersChangeListeners = [];
    this._providersChangedDuringRequest = false;
    this._register(this._model.onDidChangeContent(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    }));
    this._register(this._model.onDidChangeAttached(() => {
      if (!this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    }));
    this._register(this._model.onDidChangeLanguage(() => {
      if (this._currentDocumentResponse) {
        this._currentDocumentResponse.dispose();
        this._currentDocumentResponse = null;
      }
      if (this._currentDocumentRequestCancellationTokenSource) {
        this._currentDocumentRequestCancellationTokenSource.cancel();
        this._currentDocumentRequestCancellationTokenSource = null;
      }
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(0);
    }));
    const bindDocumentChangeListeners = () => {
      dispose(this._documentProvidersChangeListeners);
      this._documentProvidersChangeListeners = [];
      for (const provider of this._provider.all(model)) {
        if (typeof provider.onDidChange === "function") {
          this._documentProvidersChangeListeners.push(provider.onDidChange(() => {
            if (this._currentDocumentRequestCancellationTokenSource) {
              this._providersChangedDuringRequest = true;
              return;
            }
            this._fetchDocumentSemanticTokens.schedule(0);
          }));
        }
      }
    };
    bindDocumentChangeListeners();
    this._register(this._provider.onDidChange(() => {
      bindDocumentChangeListeners();
      this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    }));
    this._register(themeService.onDidColorThemeChange((_) => {
      this._setDocumentSemanticTokens(null, null, null, []);
      this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
    }));
    this._fetchDocumentSemanticTokens.schedule(0);
  }
  dispose() {
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._currentDocumentRequestCancellationTokenSource) {
      this._currentDocumentRequestCancellationTokenSource.cancel();
      this._currentDocumentRequestCancellationTokenSource = null;
    }
    dispose(this._documentProvidersChangeListeners);
    this._documentProvidersChangeListeners = [];
    this._setDocumentSemanticTokens(null, null, null, []);
    this._isDisposed = true;
    super.dispose();
  }
  _fetchDocumentSemanticTokensNow() {
    if (this._currentDocumentRequestCancellationTokenSource) {
      return;
    }
    if (!hasDocumentSemanticTokensProvider(this._provider, this._model)) {
      if (this._currentDocumentResponse) {
        this._model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    if (!this._model.isAttachedToEditor()) {
      return;
    }
    const cancellationTokenSource = new CancellationTokenSource();
    const lastProvider = this._currentDocumentResponse ? this._currentDocumentResponse.provider : null;
    const lastResultId = this._currentDocumentResponse ? this._currentDocumentResponse.resultId || null : null;
    const request = getDocumentSemanticTokens(this._provider, this._model, lastProvider, lastResultId, cancellationTokenSource.token);
    this._currentDocumentRequestCancellationTokenSource = cancellationTokenSource;
    this._providersChangedDuringRequest = false;
    const pendingChanges = [];
    const contentChangeListener = this._model.onDidChangeContent((e) => {
      pendingChanges.push(e);
    });
    const sw = new StopWatch(false);
    request.then((res) => {
      this._debounceInformation.update(this._model, sw.elapsed());
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (!res) {
        this._setDocumentSemanticTokens(null, null, null, pendingChanges);
      } else {
        const { provider, tokens } = res;
        const styling = this._semanticTokensStylingService.getStyling(provider);
        this._setDocumentSemanticTokens(provider, tokens || null, styling, pendingChanges);
      }
    }, (err) => {
      const isExpectedError = err && (isCancellationError(err) || typeof err.message === "string" && err.message.indexOf("busy") !== -1);
      if (!isExpectedError) {
        onUnexpectedError(err);
      }
      this._currentDocumentRequestCancellationTokenSource = null;
      contentChangeListener.dispose();
      if (pendingChanges.length > 0 || this._providersChangedDuringRequest) {
        if (!this._fetchDocumentSemanticTokens.isScheduled()) {
          this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
        }
      }
    });
  }
  static _copy(src, srcOffset, dest, destOffset, length) {
    length = Math.min(length, dest.length - destOffset, src.length - srcOffset);
    for (let i2 = 0; i2 < length; i2++) {
      dest[destOffset + i2] = src[srcOffset + i2];
    }
  }
  _setDocumentSemanticTokens(provider, tokens, styling, pendingChanges) {
    const currentResponse = this._currentDocumentResponse;
    const rescheduleIfNeeded = () => {
      if ((pendingChanges.length > 0 || this._providersChangedDuringRequest) && !this._fetchDocumentSemanticTokens.isScheduled()) {
        this._fetchDocumentSemanticTokens.schedule(this._debounceInformation.get(this._model));
      }
    };
    if (this._currentDocumentResponse) {
      this._currentDocumentResponse.dispose();
      this._currentDocumentResponse = null;
    }
    if (this._isDisposed) {
      if (provider && tokens) {
        provider.releaseDocumentSemanticTokens(tokens.resultId);
      }
      return;
    }
    if (!provider || !styling) {
      this._model.tokenization.setSemanticTokens(null, false);
      return;
    }
    if (!tokens) {
      this._model.tokenization.setSemanticTokens(null, true);
      rescheduleIfNeeded();
      return;
    }
    if (isSemanticTokensEdits(tokens)) {
      if (!currentResponse) {
        this._model.tokenization.setSemanticTokens(null, true);
        return;
      }
      if (tokens.edits.length === 0) {
        tokens = {
          resultId: tokens.resultId,
          data: currentResponse.data
        };
      } else {
        let deltaLength = 0;
        for (const edit of tokens.edits) {
          deltaLength += (edit.data ? edit.data.length : 0) - edit.deleteCount;
        }
        const srcData = currentResponse.data;
        const destData = new Uint32Array(srcData.length + deltaLength);
        let srcLastStart = srcData.length;
        let destLastStart = destData.length;
        for (let i2 = tokens.edits.length - 1; i2 >= 0; i2--) {
          const edit = tokens.edits[i2];
          if (edit.start > srcData.length) {
            styling.warnInvalidEditStart(currentResponse.resultId, tokens.resultId, i2, edit.start, srcData.length);
            this._model.tokenization.setSemanticTokens(null, true);
            return;
          }
          const copyCount = srcLastStart - (edit.start + edit.deleteCount);
          if (copyCount > 0) {
            ModelSemanticColoring_1._copy(srcData, srcLastStart - copyCount, destData, destLastStart - copyCount, copyCount);
            destLastStart -= copyCount;
          }
          if (edit.data) {
            ModelSemanticColoring_1._copy(edit.data, 0, destData, destLastStart - edit.data.length, edit.data.length);
            destLastStart -= edit.data.length;
          }
          srcLastStart = edit.start;
        }
        if (srcLastStart > 0) {
          ModelSemanticColoring_1._copy(srcData, 0, destData, 0, srcLastStart);
        }
        tokens = {
          resultId: tokens.resultId,
          data: destData
        };
      }
    }
    if (isSemanticTokens(tokens)) {
      this._currentDocumentResponse = new SemanticTokensResponse(provider, tokens.resultId, tokens.data);
      const result = toMultilineTokens2(tokens, styling, this._model.getLanguageId());
      if (pendingChanges.length > 0) {
        for (const change of pendingChanges) {
          for (const area of result) {
            for (const singleChange of change.changes) {
              area.applyEdit(singleChange.range, singleChange.text);
            }
          }
        }
      }
      this._model.tokenization.setSemanticTokens(result, true);
    } else {
      this._model.tokenization.setSemanticTokens(null, true);
    }
    rescheduleIfNeeded();
  }
}, ModelSemanticColoring_1 = _a63, _a63.REQUEST_MIN_DELAY = 300, _a63.REQUEST_MAX_DELAY = 2e3, _a63);
ModelSemanticColoring = ModelSemanticColoring_1 = __decorate98([
  __param98(1, ISemanticTokensStylingService),
  __param98(2, IThemeService),
  __param98(3, ILanguageFeatureDebounceService),
  __param98(4, ILanguageFeaturesService)
], ModelSemanticColoring);
var SemanticTokensResponse = class {
  constructor(provider, resultId, data) {
    this.provider = provider;
    this.resultId = resultId;
    this.data = data;
  }
  dispose() {
    this.provider.releaseDocumentSemanticTokens(this.resultId);
  }
};
registerEditorFeature(DocumentSemanticTokensFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/browser/viewportSemanticTokens.js
init_async();
init_lifecycle();
init_editorExtensions();
init_configuration();
init_themeService();
init_languageFeatureDebounce();
init_stopwatch();
init_languageFeatures();
var __decorate99 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param99 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a64;
var ViewportSemanticTokensContribution = (_a64 = class extends Disposable {
  constructor(editor2, _semanticTokensStylingService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this._semanticTokensStylingService = _semanticTokensStylingService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._editor = editor2;
    this._provider = languageFeaturesService.documentRangeSemanticTokensProvider;
    this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 });
    this._tokenizeViewport = this._register(new RunOnceScheduler(() => this._tokenizeViewportNow(), 100));
    this._outstandingRequests = [];
    const scheduleTokenizeViewport = () => {
      if (this._editor.hasModel()) {
        this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
      }
    };
    this._register(this._editor.onDidScrollChange(() => {
      scheduleTokenizeViewport();
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._provider.onDidChange(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        this._cancelAll();
        scheduleTokenizeViewport();
      }
    }));
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll();
      scheduleTokenizeViewport();
    }));
    scheduleTokenizeViewport();
  }
  _cancelAll() {
    for (const request of this._outstandingRequests) {
      request.cancel();
    }
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(req) {
    for (let i2 = 0, len = this._outstandingRequests.length; i2 < len; i2++) {
      if (this._outstandingRequests[i2] === req) {
        this._outstandingRequests.splice(i2, 1);
        return;
      }
    }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    if (model.tokenization.hasCompleteSemanticTokens()) {
      return;
    }
    if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
      if (model.tokenization.hasSomeSemanticTokens()) {
        model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    if (!hasDocumentRangeSemanticTokensProvider(this._provider, model)) {
      if (model.tokenization.hasSomeSemanticTokens()) {
        model.tokenization.setSemanticTokens(null, false);
      }
      return;
    }
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range)));
  }
  _requestRange(model, range) {
    const requestVersionId = model.getVersionId();
    const request = createCancelablePromise((token) => Promise.resolve(getDocumentRangeSemanticTokens(this._provider, model, range, token)));
    const sw = new StopWatch(false);
    request.then((r) => {
      this._debounceInformation.update(model, sw.elapsed());
      if (!r || !r.tokens || model.isDisposed() || model.getVersionId() !== requestVersionId) {
        return;
      }
      const { provider, tokens: result } = r;
      const styling = this._semanticTokensStylingService.getStyling(provider);
      model.tokenization.setPartialSemanticTokens(range, toMultilineTokens2(result, styling, model.getLanguageId()));
    }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
    return request;
  }
}, _a64.ID = "editor.contrib.viewportSemanticTokens", _a64);
ViewportSemanticTokensContribution = __decorate99([
  __param99(1, ISemanticTokensStylingService),
  __param99(2, IThemeService),
  __param99(3, IConfigurationService),
  __param99(4, ILanguageFeatureDebounceService),
  __param99(5, ILanguageFeaturesService)
], ViewportSemanticTokensContribution);
registerEditorContribution(
  ViewportSemanticTokensContribution.ID,
  ViewportSemanticTokensContribution,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
init_arrays();
init_cancellation();
init_errors();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_editorContextKeys();

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/wordSelections.js
init_strings();
init_range();
var WordSelectionRangeProvider = class {
  constructor(selectSubwords = true) {
    this.selectSubwords = selectSubwords;
  }
  provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      if (this.selectSubwords) {
        this._addInWordRanges(bucket, model, position);
      }
      this._addWordRanges(bucket, model, position);
      this._addWhitespaceLine(bucket, model, position);
      bucket.push({ range: model.getFullModelRange() });
    }
    return result;
  }
  _addInWordRanges(bucket, model, pos) {
    const obj = model.getWordAtPosition(pos);
    if (!obj) {
      return;
    }
    const { word, startColumn } = obj;
    const offset = pos.column - startColumn;
    let start = offset;
    let end = offset;
    let lastCh = 0;
    for (; start >= 0; start--) {
      const ch = word.charCodeAt(start);
      if (start !== offset && (ch === 95 || ch === 45)) {
        break;
      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
        break;
      }
      lastCh = ch;
    }
    start += 1;
    for (; end < word.length; end++) {
      const ch = word.charCodeAt(end);
      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
        break;
      } else if (ch === 95 || ch === 45) {
        break;
      }
      lastCh = ch;
    }
    if (start < end) {
      bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
    }
  }
  _addWordRanges(bucket, model, pos) {
    const word = model.getWordAtPosition(pos);
    if (word) {
      bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
    }
  }
  _addWhitespaceLine(bucket, model, pos) {
    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
      bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
init_nls();
init_actions2();
init_commands();
init_languageFeatures();
init_resolverService();
init_types();
init_uri();
var __decorate100 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param100 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SmartSelectController_1;
var SelectionRanges = class _SelectionRanges {
  constructor(index, ranges) {
    this.index = index;
    this.ranges = ranges;
  }
  mov(fwd) {
    const index = this.index + (fwd ? 1 : -1);
    if (index < 0 || index >= this.ranges.length) {
      return this;
    }
    const res = new _SelectionRanges(index, this.ranges);
    if (res.ranges[index].equalsRange(this.ranges[this.index])) {
      return res.mov(fwd);
    }
    return res;
  }
};
var _a65;
var SmartSelectController = (_a65 = class {
  static get(editor2) {
    return editor2.getContribution(SmartSelectController_1.ID);
  }
  constructor(_editor, _languageFeaturesService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._ignoreSelection = false;
  }
  dispose() {
    this._selectionListener?.dispose();
  }
  async run(forward) {
    if (!this._editor.hasModel()) {
      return;
    }
    const selections = this._editor.getSelections();
    const model = this._editor.getModel();
    if (!this._state) {
      await provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map((s) => s.getPosition()), this._editor.getOption(
        129
        /* EditorOption.smartSelect */
      ), CancellationToken.None).then((ranges) => {
        if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
          return;
        }
        if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
          return;
        }
        for (let i2 = 0; i2 < ranges.length; i2++) {
          ranges[i2] = ranges[i2].filter((range) => {
            return range.containsPosition(selections[i2].getStartPosition()) && range.containsPosition(selections[i2].getEndPosition());
          });
          ranges[i2].unshift(selections[i2]);
        }
        this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
        this._selectionListener?.dispose();
        this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
          if (!this._ignoreSelection) {
            this._selectionListener?.dispose();
            this._state = void 0;
          }
        });
      });
    }
    if (!this._state) {
      return;
    }
    this._state = this._state.map((state) => state.mov(forward));
    const newSelections = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
    this._ignoreSelection = true;
    try {
      this._editor.setSelections(newSelections);
    } finally {
      this._ignoreSelection = false;
    }
  }
}, SmartSelectController_1 = _a65, _a65.ID = "editor.contrib.smartSelectController", _a65);
SmartSelectController = SmartSelectController_1 = __decorate100([
  __param100(1, ILanguageFeaturesService)
], SmartSelectController);
var AbstractSmartSelect = class extends EditorAction {
  constructor(forward, opts) {
    super(opts);
    this._forward = forward;
  }
  async run(_accessor, editor2) {
    const controller = SmartSelectController.get(editor2);
    if (controller) {
      await controller.run(this._forward);
    }
  }
};
var GrowSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(true, {
      id: "editor.action.smartSelect.expand",
      label: localize2(1385, "Expand Selection"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 17,
        mac: {
          primary: 2048 | 256 | 1024 | 17,
          secondary: [
            256 | 1024 | 17
            /* KeyCode.RightArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize(1383, "&&Expand Selection"),
        order: 2
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
var ShrinkSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(false, {
      id: "editor.action.smartSelect.shrink",
      label: localize2(1386, "Shrink Selection"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 15,
        mac: {
          primary: 2048 | 256 | 1024 | 15,
          secondary: [
            256 | 1024 | 15
            /* KeyCode.LeftArrow */
          ]
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize(1384, "&&Shrink Selection"),
        order: 3
      }
    });
  }
};
registerEditorContribution(
  SmartSelectController.ID,
  SmartSelectController,
  4
  /* EditorContributionInstantiation.Lazy */
);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
async function provideSelectionRanges(registry, model, positions, options, token) {
  const providers = registry.all(model).concat(new WordSelectionRangeProvider(options.selectSubwords));
  if (providers.length === 1) {
    providers.unshift(new BracketSelectionRangeProvider());
  }
  const work = [];
  const allRawRanges = [];
  for (const provider of providers) {
    work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
      if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
        for (let i2 = 0; i2 < positions.length; i2++) {
          if (!allRawRanges[i2]) {
            allRawRanges[i2] = [];
          }
          for (const oneProviderRanges of allProviderRanges[i2]) {
            if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i2])) {
              allRawRanges[i2].push(Range.lift(oneProviderRanges.range));
            }
          }
        }
      }
    }, onUnexpectedExternalError));
  }
  await Promise.all(work);
  return allRawRanges.map((oneRawRanges) => {
    if (oneRawRanges.length === 0) {
      return [];
    }
    oneRawRanges.sort((a, b) => {
      if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
        return 1;
      } else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
        return -1;
      } else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
        return -1;
      } else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
        return 1;
      } else {
        return 0;
      }
    });
    const oneRanges = [];
    let last;
    for (const range of oneRawRanges) {
      if (!last || Range.containsRange(range, last) && !Range.equalsRange(range, last)) {
        oneRanges.push(range);
        last = range;
      }
    }
    if (!options.selectLeadingAndTrailingWhitespace) {
      return oneRanges;
    }
    const oneRangesWithTrivia = [oneRanges[0]];
    for (let i2 = 1; i2 < oneRanges.length; i2++) {
      const prev = oneRanges[i2 - 1];
      const cur = oneRanges[i2];
      if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
        const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
        if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
          oneRangesWithTrivia.push(rangeNoWhitespace);
        }
        const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
        if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
          oneRangesWithTrivia.push(rangeFull);
        }
      }
      oneRangesWithTrivia.push(cur);
    }
    return oneRangesWithTrivia;
  });
}
CommandsRegistry.registerCommand("_executeSelectionRangeProvider", async function(accessor, ...args) {
  const [resource, positions] = args;
  assertType(URI.isUri(resource));
  const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
  const reference = await accessor.get(ITextModelService).createModelReference(resource);
  try {
    return provideSelectionRanges(registry, reference.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true, selectSubwords: true }, CancellationToken.None);
  } finally {
    reference.dispose();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollContribution.js
init_editorExtensions();

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
init_editorExtensions();
init_nls();

// node_modules/monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js
init_nls();
var Categories = Object.freeze({
  View: localize2(1623, "View"),
  Help: localize2(1624, "Help"),
  Test: localize2(1625, "Test"),
  File: localize2(1626, "File"),
  Preferences: localize2(1627, "Preferences"),
  Developer: localize2(1628, "Developer")
});

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
init_actions2();
init_configuration();
init_contextkey();
init_editorContextKeys();
var ToggleStickyScroll = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.toggleStickyScroll",
      title: {
        ...localize2(1433, "Toggle Editor Sticky Scroll"),
        mnemonicTitle: localize(1429, "&&Toggle Editor Sticky Scroll")
      },
      metadata: {
        description: localize2(1434, "Toggle/enable the editor sticky scroll which shows the nested scopes at the top of the viewport")
      },
      category: Categories.View,
      toggled: {
        condition: ContextKeyExpr.equals("config.editor.stickyScroll.enabled", true),
        title: localize(1430, "Sticky Scroll"),
        mnemonicTitle: localize(1431, "&&Sticky Scroll")
      },
      menu: [
        { id: MenuId.CommandPalette },
        { id: MenuId.MenubarAppearanceMenu, group: "4_editor", order: 3 },
        { id: MenuId.StickyScrollContext }
      ]
    });
  }
  async runEditorCommand(accessor, editor2) {
    const configurationService = accessor.get(IConfigurationService);
    const newValue = !configurationService.getValue("editor.stickyScroll.enabled");
    const isFocused = StickyScrollController.get(editor2)?.isFocused();
    configurationService.updateValue("editor.stickyScroll.enabled", newValue);
    if (isFocused) {
      editor2.focus();
    }
  }
};
var weight4 = 100;
var FocusStickyScroll = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.focusStickyScroll",
      title: {
        ...localize2(1435, "Focus Editor Sticky Scroll"),
        mnemonicTitle: localize(1432, "&&Focus Editor Sticky Scroll")
      },
      precondition: ContextKeyExpr.and(ContextKeyExpr.has("config.editor.stickyScroll.enabled"), EditorContextKeys.stickyScrollVisible),
      menu: [
        { id: MenuId.CommandPalette }
      ]
    });
  }
  runEditorCommand(_accessor, editor2) {
    StickyScrollController.get(editor2)?.focus();
  }
};
var SelectNextStickyScrollLine = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectNextStickyScrollLine",
      title: localize2(1436, "Select the next editor sticky scroll line"),
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight4,
        primary: 18
        /* KeyCode.DownArrow */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    StickyScrollController.get(editor2)?.focusNext();
  }
};
var SelectPreviousStickyScrollLine = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectPreviousStickyScrollLine",
      title: localize2(1437, "Select the previous sticky scroll line"),
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight4,
        primary: 16
        /* KeyCode.UpArrow */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    StickyScrollController.get(editor2)?.focusPrevious();
  }
};
var GoToStickyScrollLine = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.goToFocusedStickyScrollLine",
      title: localize2(1438, "Go to the focused sticky scroll line"),
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight4,
        primary: 3
        /* KeyCode.Enter */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    StickyScrollController.get(editor2)?.goToFocused();
  }
};
var SelectEditor = class extends EditorAction2 {
  constructor() {
    super({
      id: "editor.action.selectEditor",
      title: localize2(1439, "Select Editor"),
      precondition: EditorContextKeys.stickyScrollFocused.isEqualTo(true),
      keybinding: {
        weight: weight4,
        primary: 9
        /* KeyCode.Escape */
      }
    });
  }
  runEditorCommand(_accessor, editor2) {
    StickyScrollController.get(editor2)?.selectEditor();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollContribution.js
init_actions2();
registerEditorContribution(
  StickyScrollController.ID,
  StickyScrollController,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
registerAction2(ToggleStickyScroll);
registerAction2(FocusStickyScroll);
registerAction2(SelectPreviousStickyScrollLine);
registerAction2(SelectNextStickyScrollLine);
registerAction2(GoToStickyScrollLine);
registerAction2(SelectEditor);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js
init_cancellation();
init_filters();
init_iterator();
init_lifecycle();
init_codeEditorService();
init_range();
init_languageFeatures();
var __decorate101 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param101 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestInlineCompletion = class {
  constructor(range, insertText, filterText, additionalTextEdits, command, action, completion) {
    this.range = range;
    this.insertText = insertText;
    this.filterText = filterText;
    this.additionalTextEdits = additionalTextEdits;
    this.command = command;
    this.action = action;
    this.completion = completion;
  }
};
var InlineCompletionResults = class InlineCompletionResults2 extends RefCountedDisposable {
  constructor(model, line, word, completionModel, completions, _suggestMemoryService) {
    super(completions.disposable);
    this.model = model;
    this.line = line;
    this.word = word;
    this.completionModel = completionModel;
    this._suggestMemoryService = _suggestMemoryService;
  }
  canBeReused(model, line, word) {
    return this.model === model && this.line === line && this.word.word.length > 0 && this.word.startColumn === word.startColumn && this.word.endColumn < word.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    const result = [];
    const { items } = this.completionModel;
    const selectedIndex = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, items);
    const first2 = Iterable.slice(items, selectedIndex);
    const second = Iterable.slice(items, 0, selectedIndex);
    let resolveCount = 5;
    for (const item of Iterable.concat(first2, second)) {
      if (item.score === FuzzyScore.Default) {
        continue;
      }
      const range = new Range(
        item.editStart.lineNumber,
        item.editStart.column,
        item.editInsertEnd.lineNumber,
        item.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
        // end PLUS character delta
      );
      const insertText = item.completion.insertTextRules && item.completion.insertTextRules & 4 ? { snippet: item.completion.insertText } : item.completion.insertText;
      result.push(new SuggestInlineCompletion(range, insertText, item.filterTextLow ?? item.labelLow, item.completion.additionalTextEdits, item.completion.command, item.completion.action, item));
      if (resolveCount-- >= 0) {
        item.resolve(CancellationToken.None);
      }
    }
    return result;
  }
};
InlineCompletionResults = __decorate101([
  __param101(5, ISuggestMemoryService)
], InlineCompletionResults);
var SuggestInlineCompletions = class SuggestInlineCompletions2 extends Disposable {
  constructor(_languageFeatureService, _clipboardService, _suggestMemoryService, _editorService) {
    super();
    this._languageFeatureService = _languageFeatureService;
    this._clipboardService = _clipboardService;
    this._suggestMemoryService = _suggestMemoryService;
    this._editorService = _editorService;
    this._store.add(_languageFeatureService.inlineCompletionsProvider.register("*", this));
  }
  async provideInlineCompletions(model, position, context, token) {
    if (context.selectedSuggestionInfo) {
      return;
    }
    let editor2;
    for (const candidate of this._editorService.listCodeEditors()) {
      if (candidate.getModel() === model) {
        editor2 = candidate;
        break;
      }
    }
    if (!editor2) {
      return;
    }
    const config = editor2.getOption(
      102
      /* EditorOption.quickSuggestions */
    );
    if (QuickSuggestionsOptions.isAllOff(config)) {
      return;
    }
    model.tokenization.tokenizeIfCheap(position.lineNumber);
    const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
    const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
    if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "inline") {
      return void 0;
    }
    let wordInfo = model.getWordAtPosition(position);
    let triggerCharacterInfo;
    if (!wordInfo?.word) {
      triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
    }
    if (!wordInfo?.word && !triggerCharacterInfo) {
      return;
    }
    if (!wordInfo) {
      wordInfo = model.getWordUntilPosition(position);
    }
    if (wordInfo.endColumn !== position.column) {
      return;
    }
    let result;
    const leadingLineContents = model.getValueInRange(new Range(position.lineNumber, 1, position.lineNumber, position.column));
    if (!triggerCharacterInfo && this._lastResult?.canBeReused(model, position.lineNumber, wordInfo)) {
      const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
      this._lastResult.completionModel.lineContext = newLineContext;
      this._lastResult.acquire();
      result = this._lastResult;
    } else {
      const completions = await provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(void 0, SuggestModel.createSuggestFilter(editor2).itemKind, triggerCharacterInfo?.providers), triggerCharacterInfo && { triggerKind: 1, triggerCharacter: triggerCharacterInfo.ch }, token);
      let clipboardText;
      if (completions.needsClipboard) {
        clipboardText = await this._clipboardService.readText();
      }
      const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, editor2.getOption(
        134
        /* EditorOption.suggest */
      ), editor2.getOption(
        128
        /* EditorOption.snippetSuggestions */
      ), { boostFullMatch: false, firstMatchCanBeWeak: false }, clipboardText);
      result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
    }
    this._lastResult = result;
    return result;
  }
  handleItemDidShow(_completions, item) {
    item.completion.resolve(CancellationToken.None);
  }
  disposeInlineCompletions(result) {
    result.release();
  }
  _getTriggerCharacterInfo(model, position) {
    const ch = model.getValueInRange(Range.fromPositions({ lineNumber: position.lineNumber, column: position.column - 1 }, position));
    const providers = /* @__PURE__ */ new Set();
    for (const provider of this._languageFeatureService.completionProvider.all(model)) {
      if (provider.triggerCharacters?.includes(ch)) {
        providers.add(provider);
      }
    }
    if (providers.size === 0) {
      return void 0;
    }
    return { providers, ch };
  }
};
SuggestInlineCompletions = __decorate101([
  __param101(0, ILanguageFeaturesService),
  __param101(1, IClipboardService),
  __param101(2, ISuggestMemoryService),
  __param101(3, ICodeEditorService)
], SuggestInlineCompletions);
registerEditorFeature(SuggestInlineCompletions);

// node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/browser/tokenization.js
init_stopwatch();
init_editorExtensions();
init_nls();
var ForceRetokenizeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: localize2(1517, "Developer: Force Retokenize"),
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    model.tokenization.resetTokenization();
    const sw = new StopWatch();
    model.tokenization.forceTokenization(model.getLineCount());
    sw.stop();
    console.log(`tokenization took ${sw.elapsed()}`);
  }
};
registerEditorAction(ForceRetokenizeAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js
init_nls();
init_actions2();
var _ToggleTabFocusModeAction = class _ToggleTabFocusModeAction extends Action2 {
  constructor() {
    super({
      id: _ToggleTabFocusModeAction.ID,
      title: localize2(1515, "Toggle Tab Key Moves Focus"),
      precondition: void 0,
      keybinding: {
        primary: 2048 | 43,
        mac: {
          primary: 256 | 1024 | 43
          /* KeyCode.KeyM */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: localize2(1516, "Determines whether the tab key moves focus around the workbench or inserts the tab character in the current editor. This is also called tab trapping, tab navigation, or tab focus mode.")
      },
      f1: true
    });
  }
  run() {
    const oldValue = TabFocus.getTabFocusMode();
    const newValue = !oldValue;
    TabFocus.setTabFocusMode(newValue);
    if (newValue) {
      alert(localize(1513, "Pressing Tab will now move focus to the next focusable element"));
    } else {
      alert(localize(1514, "Pressing Tab will now insert the tab character"));
    }
  }
};
_ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
var ToggleTabFocusModeAction = _ToggleTabFocusModeAction;
registerAction2(ToggleTabFocusModeAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
init_async();
init_codicons();
init_htmlContent();
init_lifecycle();
init_platform();
init_strings();
init_editorExtensions();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.css";
init_textModel();
init_editorWorker();
init_language();

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
init_nls();
init_dom();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.css";
init_actions();
init_lifecycle();
init_instantiation();

// node_modules/monaco-editor/esm/vs/platform/opener/browser/link.js
init_dom();
init_keyboardEvent();
init_event();
init_lifecycle();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/platform/opener/browser/link.css";
var __decorate102 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param102 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var Link2 = class Link3 extends Disposable {
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    if (enabled) {
      this.el.setAttribute("aria-disabled", "false");
      this.el.tabIndex = 0;
      this.el.style.pointerEvents = "auto";
      this.el.style.opacity = "1";
      this.el.style.cursor = "pointer";
      this._enabled = false;
    } else {
      this.el.setAttribute("aria-disabled", "true");
      this.el.tabIndex = -1;
      this.el.style.pointerEvents = "none";
      this.el.style.opacity = "0.4";
      this.el.style.cursor = "default";
      this._enabled = true;
    }
    this._enabled = enabled;
  }
  constructor(container, _link, options = {}, _hoverService, openerService) {
    super();
    this._link = _link;
    this._hoverService = _hoverService;
    this._enabled = true;
    this.el = append(container, $("a.monaco-link", {
      tabIndex: _link.tabIndex ?? 0,
      href: _link.href
    }, _link.label));
    this.hoverDelegate = options.hoverDelegate ?? getDefaultHoverDelegate("mouse");
    this.setTooltip(_link.title);
    this.el.setAttribute("role", "button");
    const onClickEmitter = this._register(new DomEmitter(this.el, "click"));
    const onKeyPress = this._register(new DomEmitter(this.el, "keypress"));
    const onEnterPress = Event.chain(onKeyPress.event, ($13) => $13.map((e) => new StandardKeyboardEvent(e)).filter(
      (e) => e.keyCode === 3
      /* KeyCode.Enter */
    ));
    const onTap = this._register(new DomEmitter(this.el, EventType2.Tap)).event;
    this._register(Gesture.addTarget(this.el));
    const onOpen = Event.any(onClickEmitter.event, onEnterPress, onTap);
    this._register(onOpen((e) => {
      if (!this.enabled) {
        return;
      }
      EventHelper.stop(e, true);
      if (options?.opener) {
        options.opener(this._link.href);
      } else {
        openerService.open(this._link.href, { allowCommands: true });
      }
    }));
    this.enabled = true;
  }
  setTooltip(title) {
    if (!this.hover && title) {
      this.hover = this._register(this._hoverService.setupManagedHover(this.hoverDelegate, this.el, title));
    } else if (this.hover) {
      this.hover.update(title);
    }
  }
};
Link2 = __decorate102([
  __param102(3, IHoverService),
  __param102(4, IOpenerService)
], Link2);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
init_themables();
var __decorate103 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param103 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BANNER_ELEMENT_HEIGHT = 26;
var BannerController = class BannerController2 extends Disposable {
  constructor(_editor, instantiationService) {
    super();
    this._editor = _editor;
    this.instantiationService = instantiationService;
    this.banner = this._register(this.instantiationService.createInstance(Banner));
  }
  hide() {
    this._editor.setBanner(null, 0);
    this.banner.clear();
  }
  show(item) {
    this.banner.show({
      ...item,
      onClose: () => {
        this.hide();
        item.onClose?.();
      }
    });
    this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
  }
};
BannerController = __decorate103([
  __param103(1, IInstantiationService)
], BannerController);
var Banner = class Banner2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.instantiationService = instantiationService;
    this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    this.element = $("div.editor-banner");
    this.element.tabIndex = 0;
  }
  getAriaLabel(item) {
    if (item.ariaLabel) {
      return item.ariaLabel;
    }
    if (typeof item.message === "string") {
      return item.message;
    }
    return void 0;
  }
  getBannerMessage(message) {
    if (typeof message === "string") {
      const element = $("span");
      element.innerText = message;
      return element;
    }
    return this.markdownRenderer.render(message).element;
  }
  clear() {
    clearNode(this.element);
  }
  show(item) {
    clearNode(this.element);
    const ariaLabel = this.getAriaLabel(item);
    if (ariaLabel) {
      this.element.setAttribute("aria-label", ariaLabel);
    }
    const iconContainer = append(this.element, $("div.icon-container"));
    iconContainer.setAttribute("aria-hidden", "true");
    if (item.icon) {
      iconContainer.appendChild($(`div${ThemeIcon.asCSSSelector(item.icon)}`));
    }
    const messageContainer = append(this.element, $("div.message-container"));
    messageContainer.setAttribute("aria-hidden", "true");
    messageContainer.appendChild(this.getBannerMessage(item.message));
    this.messageActionsContainer = append(this.element, $("div.message-actions-container"));
    if (item.actions) {
      for (const action of item.actions) {
        this._register(this.instantiationService.createInstance(Link2, this.messageActionsContainer, { ...action, tabIndex: -1 }, {}));
      }
    }
    const actionBarContainer = append(this.element, $("div.action-container"));
    this.actionBar = this._register(new ActionBar(actionBarContainer));
    this.actionBar.push(this._register(new Action("banner.close", localize(1518, "Close Banner"), ThemeIcon.asClassName(widgetClose), true, () => {
      if (typeof item.onClose === "function") {
        item.onClose();
      }
    })), { icon: true, label: false });
    this.actionBar.setFocusable(false);
  }
};
Banner = __decorate103([
  __param103(0, IInstantiationService)
], Banner);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
init_nls();
init_configuration();
init_instantiation();
init_actions2();
init_date();
var __decorate104 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param104 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var warningIcon = registerIcon("extensions-warning-message", Codicon.warning, localize(1519, "Icon shown with a warning message in the extensions editor."));
var _a66;
var UnicodeHighlighter = (_a66 = class extends Disposable {
  constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
    super();
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._workspaceTrustService = _workspaceTrustService;
    this._highlighter = null;
    this._bannerClosed = false;
    this._updateState = (state) => {
      if (state && state.hasMore) {
        if (this._bannerClosed) {
          return;
        }
        const max = Math.max(state.ambiguousCharacterCount, state.nonBasicAsciiCharacterCount, state.invisibleCharacterCount);
        let data;
        if (state.nonBasicAsciiCharacterCount >= max) {
          data = {
            message: localize(1520, "This document contains many non-basic ASCII unicode characters"),
            command: new DisableHighlightingOfNonBasicAsciiCharactersAction()
          };
        } else if (state.ambiguousCharacterCount >= max) {
          data = {
            message: localize(1521, "This document contains many ambiguous unicode characters"),
            command: new DisableHighlightingOfAmbiguousCharactersAction()
          };
        } else if (state.invisibleCharacterCount >= max) {
          data = {
            message: localize(1522, "This document contains many invisible unicode characters"),
            command: new DisableHighlightingOfInvisibleCharactersAction()
          };
        } else {
          throw new Error("Unreachable");
        }
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: data.message,
          icon: warningIcon,
          actions: [
            {
              label: data.command.shortLabel,
              href: `command:${data.command.desc.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = true;
          }
        });
      } else {
        this._bannerController.hide();
      }
    };
    this._bannerController = this._register(instantiationService.createInstance(BannerController, _editor));
    this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = false;
      this._updateHighlighter();
    }));
    this._options = _editor.getOption(
      142
      /* EditorOption.unicodeHighlighting */
    );
    this._register(_workspaceTrustService.onDidChangeTrust((e) => {
      this._updateHighlighter();
    }));
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        142
        /* EditorOption.unicodeHighlighting */
      )) {
        this._options = _editor.getOption(
          142
          /* EditorOption.unicodeHighlighting */
        );
        this._updateHighlighter();
      }
    }));
    this._updateHighlighter();
  }
  dispose() {
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    super.dispose();
  }
  _updateHighlighter() {
    this._updateState(null);
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const options = resolveOptions(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      options.nonBasicASCII,
      options.ambiguousCharacters,
      options.invisibleCharacters
    ].every((option2) => option2 === false)) {
      return;
    }
    const highlightOptions = {
      nonBasicASCII: options.nonBasicASCII,
      ambiguousCharacters: options.ambiguousCharacters,
      invisibleCharacters: options.invisibleCharacters,
      includeComments: options.includeComments,
      includeStrings: options.includeStrings,
      allowedCodePoints: Object.keys(options.allowedCharacters).map((c) => c.codePointAt(0)),
      allowedLocales: Object.keys(options.allowedLocales).map((locale) => {
        if (locale === "_os") {
          const osLocale = safeIntl.NumberFormat().value.resolvedOptions().locale;
          return osLocale;
        } else if (locale === "_vscode") {
          return language;
        }
        return locale;
      })
    };
    if (this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri)) {
      this._highlighter = new DocumentUnicodeHighlighter(this._editor, highlightOptions, this._updateState, this._editorWorkerService);
    } else {
      this._highlighter = new ViewportUnicodeHighlighter(this._editor, highlightOptions, this._updateState);
    }
  }
  getDecorationInfo(decoration3) {
    if (this._highlighter) {
      return this._highlighter.getDecorationInfo(decoration3);
    }
    return null;
  }
}, _a66.ID = "editor.contrib.unicodeHighlighter", _a66);
UnicodeHighlighter = __decorate104([
  __param104(1, IEditorWorkerService),
  __param104(2, IWorkspaceTrustManagementService),
  __param104(3, IInstantiationService)
], UnicodeHighlighter);
function resolveOptions(trusted, options) {
  return {
    nonBasicASCII: options.nonBasicASCII === inUntrustedWorkspace ? !trusted : options.nonBasicASCII,
    ambiguousCharacters: options.ambiguousCharacters,
    invisibleCharacters: options.invisibleCharacters,
    includeComments: options.includeComments === inUntrustedWorkspace ? !trusted : options.includeComments,
    includeStrings: options.includeStrings === inUntrustedWorkspace ? !trusted : options.includeStrings,
    allowedCharacters: options.allowedCharacters,
    allowedLocales: options.allowedLocales
  };
}
var DocumentUnicodeHighlighter = class DocumentUnicodeHighlighter2 extends Disposable {
  constructor(_editor, _options, _updateState, _editorWorkerService) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._editorWorkerService = _editorWorkerService;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const modelVersionId = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((info) => {
      if (this._model.isDisposed()) {
        return;
      }
      if (this._model.getVersionId() !== modelVersionId) {
        return;
      }
      this._updateState(info);
      const decorations = [];
      if (!info.hasMore) {
        for (const range of info.ranges) {
          decorations.push({
            range,
            options: Decorations.instance.getDecorationFromOptions(this._options)
          });
        }
      }
      this._decorations.set(decorations);
    });
  }
  getDecorationInfo(decoration3) {
    if (!this._decorations.has(decoration3)) {
      return null;
    }
    const model = this._editor.getModel();
    if (!isModelDecorationVisible(model, decoration3)) {
      return null;
    }
    const text = model.getValueInRange(decoration3.range);
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration3),
      inString: isModelDecorationInString(model, decoration3)
    };
  }
};
DocumentUnicodeHighlighter = __decorate104([
  __param104(3, IEditorWorkerService)
], DocumentUnicodeHighlighter);
var ViewportUnicodeHighlighter = class extends Disposable {
  constructor(_editor, _options, _updateState) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const ranges = this._editor.getVisibleRanges();
    const decorations = [];
    const totalResult = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: false
    };
    for (const range of ranges) {
      const result = UnicodeTextModelHighlighter.computeUnicodeHighlights(this._model, this._options, range);
      for (const r of result.ranges) {
        totalResult.ranges.push(r);
      }
      totalResult.ambiguousCharacterCount += totalResult.ambiguousCharacterCount;
      totalResult.invisibleCharacterCount += totalResult.invisibleCharacterCount;
      totalResult.nonBasicAsciiCharacterCount += totalResult.nonBasicAsciiCharacterCount;
      totalResult.hasMore = totalResult.hasMore || result.hasMore;
    }
    if (!totalResult.hasMore) {
      for (const range of totalResult.ranges) {
        decorations.push({ range, options: Decorations.instance.getDecorationFromOptions(this._options) });
      }
    }
    this._updateState(totalResult);
    this._decorations.set(decorations);
  }
  getDecorationInfo(decoration3) {
    if (!this._decorations.has(decoration3)) {
      return null;
    }
    const model = this._editor.getModel();
    const text = model.getValueInRange(decoration3.range);
    if (!isModelDecorationVisible(model, decoration3)) {
      return null;
    }
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration3),
      inString: isModelDecorationInString(model, decoration3)
    };
  }
};
var configureUnicodeHighlightOptionsStr = localize(1523, "Configure Unicode Highlight Options");
var UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant2 {
  constructor(_editor, _languageService, _openerService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.hoverOrdinal = 5;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const unicodeHighlighter = this._editor.getContribution(UnicodeHighlighter.ID);
    if (!unicodeHighlighter) {
      return [];
    }
    const result = [];
    const existedReason = /* @__PURE__ */ new Set();
    let index = 300;
    for (const d of lineDecorations) {
      const highlightInfo = unicodeHighlighter.getDecorationInfo(d);
      if (!highlightInfo) {
        continue;
      }
      const char = model.getValueInRange(d.range);
      const codePoint = char.codePointAt(0);
      const codePointStr = formatCodePointMarkdown(codePoint);
      let reason;
      switch (highlightInfo.reason.kind) {
        case 0: {
          if (isBasicASCII(highlightInfo.reason.confusableWith)) {
            reason = localize(1524, "The character {0} could be confused with the ASCII character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          } else {
            reason = localize(1525, "The character {0} could be confused with the character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          }
          break;
        }
        case 1:
          reason = localize(1526, "The character {0} is invisible.", codePointStr);
          break;
        case 2:
          reason = localize(1527, "The character {0} is not a basic ASCII character.", codePointStr);
          break;
      }
      if (existedReason.has(reason)) {
        continue;
      }
      existedReason.add(reason);
      const adjustSettingsArgs = {
        codePoint,
        reason: highlightInfo.reason,
        inComment: highlightInfo.inComment,
        inString: highlightInfo.inString
      };
      const adjustSettings = localize(1528, "Adjust settings");
      const uri = createCommandUri(ShowExcludeOptions.ID, adjustSettingsArgs);
      const markdown = new MarkdownString("", true).appendMarkdown(reason).appendText(" ").appendLink(uri, adjustSettings, configureUnicodeHighlightOptionsStr);
      result.push(new MarkdownHover(this, d.range, [markdown], false, index++));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
};
UnicodeHighlighterHoverParticipant = __decorate104([
  __param104(1, ILanguageService),
  __param104(2, IOpenerService)
], UnicodeHighlighterHoverParticipant);
function codePointToHex(codePoint) {
  return `U+${codePoint.toString(16).padStart(4, "0")}`;
}
function formatCodePointMarkdown(codePoint) {
  let value = `\`${codePointToHex(codePoint)}\``;
  if (!InvisibleCharacters.isInvisibleCharacter(codePoint)) {
    value += ` "${`${renderCodePointAsInlineCode(codePoint)}`}"`;
  }
  return value;
}
function renderCodePointAsInlineCode(codePoint) {
  if (codePoint === 96) {
    return "`` ` ``";
  }
  return "`" + String.fromCodePoint(codePoint) + "`";
}
function computeReason(char, options) {
  return UnicodeTextModelHighlighter.computeUnicodeHighlightReason(char, options);
}
var _Decorations = class _Decorations {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  getDecorationFromOptions(options) {
    return this.getDecoration(!options.includeComments, !options.includeStrings);
  }
  getDecoration(hideInComments, hideInStrings) {
    const key = `${hideInComments}${hideInStrings}`;
    let options = this.map.get(key);
    if (!options) {
      options = ModelDecorationOptions.createDynamic({
        description: "unicode-highlight",
        stickiness: 1,
        className: "unicode-highlight",
        showIfCollapsed: true,
        overviewRuler: null,
        minimap: null,
        hideInCommentTokens: hideInComments,
        hideInStringTokens: hideInStrings
      });
      this.map.set(key, options);
    }
    return options;
  }
};
_Decorations.instance = new _Decorations();
var Decorations = _Decorations;
var DisableHighlightingInCommentsAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize2(1537, "Disable highlighting of characters in comments"),
      precondition: void 0
    });
    this.shortLabel = localize(1529, "Disable Highlight In Comments");
  }
  async run(accessor, editor2, args) {
    const configurationService = accessor.get(IConfigurationService);
    if (configurationService) {
      this.runAction(configurationService);
    }
  }
  async runAction(configurationService) {
    await configurationService.updateValue(
      unicodeHighlightConfigKeys.includeComments,
      false,
      2
      /* ConfigurationTarget.USER */
    );
  }
};
var DisableHighlightingInStringsAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize2(1538, "Disable highlighting of characters in strings"),
      precondition: void 0
    });
    this.shortLabel = localize(1530, "Disable Highlight In Strings");
  }
  async run(accessor, editor2, args) {
    const configurationService = accessor.get(IConfigurationService);
    if (configurationService) {
      this.runAction(configurationService);
    }
  }
  async runAction(configurationService) {
    await configurationService.updateValue(
      unicodeHighlightConfigKeys.includeStrings,
      false,
      2
      /* ConfigurationTarget.USER */
    );
  }
};
var _DisableHighlightingOfAmbiguousCharactersAction = class _DisableHighlightingOfAmbiguousCharactersAction extends Action2 {
  constructor() {
    super({
      id: _DisableHighlightingOfAmbiguousCharactersAction.ID,
      title: localize2(1539, "Disable highlighting of ambiguous characters"),
      precondition: void 0,
      f1: false
    });
    this.shortLabel = localize(1531, "Disable Ambiguous Highlight");
  }
  async run(accessor, editor2, args) {
    const configurationService = accessor.get(IConfigurationService);
    if (configurationService) {
      this.runAction(configurationService);
    }
  }
  async runAction(configurationService) {
    await configurationService.updateValue(
      unicodeHighlightConfigKeys.ambiguousCharacters,
      false,
      2
      /* ConfigurationTarget.USER */
    );
  }
};
_DisableHighlightingOfAmbiguousCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
var DisableHighlightingOfAmbiguousCharactersAction = _DisableHighlightingOfAmbiguousCharactersAction;
var _DisableHighlightingOfInvisibleCharactersAction = class _DisableHighlightingOfInvisibleCharactersAction extends Action2 {
  constructor() {
    super({
      id: _DisableHighlightingOfInvisibleCharactersAction.ID,
      title: localize2(1540, "Disable highlighting of invisible characters"),
      precondition: void 0,
      f1: false
    });
    this.shortLabel = localize(1532, "Disable Invisible Highlight");
  }
  async run(accessor, editor2, args) {
    const configurationService = accessor.get(IConfigurationService);
    if (configurationService) {
      this.runAction(configurationService);
    }
  }
  async runAction(configurationService) {
    await configurationService.updateValue(
      unicodeHighlightConfigKeys.invisibleCharacters,
      false,
      2
      /* ConfigurationTarget.USER */
    );
  }
};
_DisableHighlightingOfInvisibleCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
var DisableHighlightingOfInvisibleCharactersAction = _DisableHighlightingOfInvisibleCharactersAction;
var _DisableHighlightingOfNonBasicAsciiCharactersAction = class _DisableHighlightingOfNonBasicAsciiCharactersAction extends Action2 {
  constructor() {
    super({
      id: _DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
      title: localize2(1541, "Disable highlighting of non basic ASCII characters"),
      precondition: void 0,
      f1: false
    });
    this.shortLabel = localize(1533, "Disable Non ASCII Highlight");
  }
  async run(accessor, editor2, args) {
    const configurationService = accessor.get(IConfigurationService);
    if (configurationService) {
      this.runAction(configurationService);
    }
  }
  async runAction(configurationService) {
    await configurationService.updateValue(
      unicodeHighlightConfigKeys.nonBasicASCII,
      false,
      2
      /* ConfigurationTarget.USER */
    );
  }
};
_DisableHighlightingOfNonBasicAsciiCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
var DisableHighlightingOfNonBasicAsciiCharactersAction = _DisableHighlightingOfNonBasicAsciiCharactersAction;
var _ShowExcludeOptions = class _ShowExcludeOptions extends Action2 {
  constructor() {
    super({
      id: _ShowExcludeOptions.ID,
      title: localize2(1542, "Show Exclude Options"),
      precondition: void 0,
      f1: false
    });
  }
  async run(accessor, args) {
    const { codePoint, reason, inString, inComment } = args;
    const char = String.fromCodePoint(codePoint);
    const quickPickService = accessor.get(IQuickInputService);
    const configurationService = accessor.get(IConfigurationService);
    function getExcludeCharFromBeingHighlightedLabel(codePoint2) {
      if (InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
        return localize(1534, "Exclude {0} (invisible character) from being highlighted", codePointToHex(codePoint2));
      }
      return localize(1535, "Exclude {0} from being highlighted", `${codePointToHex(codePoint2)} "${char}"`);
    }
    const options = [];
    if (reason.kind === 0) {
      for (const locale of reason.notAmbiguousInLocales) {
        options.push({
          label: localize(1536, 'Allow unicode characters that are more common in the language "{0}".', locale),
          run: async () => {
            excludeLocaleFromBeingHighlighted(configurationService, [locale]);
          }
        });
      }
    }
    options.push({
      label: getExcludeCharFromBeingHighlightedLabel(codePoint),
      run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
    });
    if (inComment) {
      const action = new DisableHighlightingInCommentsAction();
      options.push({ label: action.label, run: async () => action.runAction(configurationService) });
    } else if (inString) {
      const action = new DisableHighlightingInStringsAction();
      options.push({ label: action.label, run: async () => action.runAction(configurationService) });
    }
    function getTitle(options2) {
      return typeof options2.desc.title === "string" ? options2.desc.title : options2.desc.title.value;
    }
    if (reason.kind === 0) {
      const action = new DisableHighlightingOfAmbiguousCharactersAction();
      options.push({ label: getTitle(action), run: async () => action.runAction(configurationService) });
    } else if (reason.kind === 1) {
      const action = new DisableHighlightingOfInvisibleCharactersAction();
      options.push({ label: getTitle(action), run: async () => action.runAction(configurationService) });
    } else if (reason.kind === 2) {
      const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
      options.push({ label: getTitle(action), run: async () => action.runAction(configurationService) });
    } else {
      expectNever(reason);
    }
    const result = await quickPickService.pick(options, { title: configureUnicodeHighlightOptionsStr });
    if (result) {
      await result.run();
    }
  }
};
_ShowExcludeOptions.ID = "editor.action.unicodeHighlight.showExcludeOptions";
var ShowExcludeOptions = _ShowExcludeOptions;
async function excludeCharFromBeingHighlighted(configurationService, charCodes) {
  const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
  let value;
  if (typeof existingValue === "object" && existingValue) {
    value = existingValue;
  } else {
    value = {};
  }
  for (const charCode of charCodes) {
    value[String.fromCodePoint(charCode)] = true;
  }
  await configurationService.updateValue(
    unicodeHighlightConfigKeys.allowedCharacters,
    value,
    2
    /* ConfigurationTarget.USER */
  );
}
async function excludeLocaleFromBeingHighlighted(configurationService, locales) {
  const existingValue = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user?.value;
  let value;
  if (typeof existingValue === "object" && existingValue) {
    value = Object.assign({}, existingValue);
  } else {
    value = {};
  }
  for (const locale of locales) {
    value[locale] = true;
  }
  await configurationService.updateValue(
    unicodeHighlightConfigKeys.allowedLocales,
    value,
    2
    /* ConfigurationTarget.USER */
  );
}
function expectNever(value) {
  throw new Error(`Unexpected value: ${value}`);
}
registerAction2(DisableHighlightingOfAmbiguousCharactersAction);
registerAction2(DisableHighlightingOfInvisibleCharactersAction);
registerAction2(DisableHighlightingOfNonBasicAsciiCharactersAction);
registerAction2(ShowExcludeOptions);
registerEditorContribution(
  UnicodeHighlighter.ID,
  UnicodeHighlighter,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
HoverParticipantRegistry.register(UnicodeHighlighterHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js
init_lifecycle();
init_resources();
init_editorExtensions();
init_codeEditorService();
init_nls();
var __decorate105 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param105 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
var _a67;
var UnusualLineTerminatorsDetector = (_a67 = class extends Disposable {
  constructor(_editor, _dialogService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._dialogService = _dialogService;
    this._codeEditorService = _codeEditorService;
    this._isPresentingDialog = false;
    this._config = this._editor.getOption(
      143
      /* EditorOption.unusualLineTerminators */
    );
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(
        143
        /* EditorOption.unusualLineTerminators */
      )) {
        this._config = this._editor.getOption(
          143
          /* EditorOption.unusualLineTerminators */
        );
        this._checkForUnusualLineTerminators();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      if (e.isUndoing) {
        return;
      }
      this._checkForUnusualLineTerminators();
    }));
    this._checkForUnusualLineTerminators();
  }
  async _checkForUnusualLineTerminators() {
    if (this._config === "off") {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    if (!model.mightContainUnusualLineTerminators()) {
      return;
    }
    const ignoreState = readIgnoreState(this._codeEditorService, model);
    if (ignoreState === true) {
      return;
    }
    if (this._editor.getOption(
      104
      /* EditorOption.readOnly */
    )) {
      return;
    }
    if (this._config === "auto") {
      model.removeUnusualLineTerminators(this._editor.getSelections());
      return;
    }
    if (this._isPresentingDialog) {
      return;
    }
    let result;
    try {
      this._isPresentingDialog = true;
      result = await this._dialogService.confirm({
        title: localize(1543, "Unusual Line Terminators"),
        message: localize(1544, "Detected unusual line terminators"),
        detail: localize(1545, "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename2(model.uri)),
        primaryButton: localize(1546, "&&Remove Unusual Line Terminators"),
        cancelButton: localize(1547, "Ignore")
      });
    } finally {
      this._isPresentingDialog = false;
    }
    if (!result.confirmed) {
      writeIgnoreState(this._codeEditorService, model, true);
      return;
    }
    model.removeUnusualLineTerminators(this._editor.getSelections());
  }
}, _a67.ID = "editor.contrib.unusualLineTerminatorsDetector", _a67);
UnusualLineTerminatorsDetector = __decorate105([
  __param105(1, IDialogService),
  __param105(2, ICodeEditorService)
], UnusualLineTerminatorsDetector);
registerEditorContribution(
  UnusualLineTerminatorsDetector.ID,
  UnusualLineTerminatorsDetector,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
init_nls();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_map();
init_network();
init_resources();
init_configuration();
init_contextkey();
init_log();
init_editorExtensions();
init_codeEditorService();
init_range();
init_editorContextKeys();
init_model2();
init_languageFeatures();
init_resolverService();

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/textualHighlightProvider.js
init_wordHelper();
init_languageFeatures();
init_languages();
init_lifecycle();
init_map();
var __decorate106 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param106 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var TextualDocumentHighlightProvider = class {
  constructor() {
    this.selector = { language: "*" };
  }
  provideDocumentHighlights(model, position, token) {
    const result = [];
    const word = model.getWordAtPosition({
      lineNumber: position.lineNumber,
      column: position.column
    });
    if (!word) {
      return Promise.resolve(result);
    }
    if (model.isDisposed()) {
      return;
    }
    const matches = model.findMatches(word.word, true, false, true, USUAL_WORD_SEPARATORS, false);
    return matches.map((m) => ({
      range: m.range,
      kind: DocumentHighlightKind.Text
    }));
  }
  provideMultiDocumentHighlights(primaryModel, position, otherModels, token) {
    const result = new ResourceMap();
    const word = primaryModel.getWordAtPosition({
      lineNumber: position.lineNumber,
      column: position.column
    });
    if (!word) {
      return Promise.resolve(result);
    }
    for (const model of [primaryModel, ...otherModels]) {
      if (model.isDisposed()) {
        continue;
      }
      const matches = model.findMatches(word.word, true, false, true, USUAL_WORD_SEPARATORS, false);
      const highlights = matches.map((m) => ({
        range: m.range,
        kind: DocumentHighlightKind.Text
      }));
      if (highlights) {
        result.set(model.uri, highlights);
      }
    }
    return result;
  }
};
var TextualMultiDocumentHighlightFeature = class TextualMultiDocumentHighlightFeature2 extends Disposable {
  constructor(languageFeaturesService) {
    super();
    this._register(languageFeaturesService.documentHighlightProvider.register("*", new TextualDocumentHighlightProvider()));
    this._register(languageFeaturesService.multiDocumentHighlightProvider.register("*", new TextualDocumentHighlightProvider()));
  }
};
TextualMultiDocumentHighlightFeature = __decorate106([
  __param106(0, ILanguageFeaturesService)
], TextualMultiDocumentHighlightFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
var __decorate107 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param107 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WordHighlighter_1;
var WordHighlighterContribution_1;
var ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(registry, model, position, token) {
  const orderedByScore = registry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), (result) => result !== void 0 && result !== null).then((result) => {
    if (result) {
      const map = new ResourceMap();
      map.set(model.uri, result);
      return map;
    }
    return new ResourceMap();
  });
}
function getOccurrencesAcrossMultipleModels(registry, model, position, token, otherModels) {
  const orderedByScore = registry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    const filteredModels = otherModels.filter((otherModel) => {
      return shouldSynchronizeModel(otherModel);
    }).filter((otherModel) => {
      return score(provider.selector, otherModel.uri, otherModel.getLanguageId(), true, void 0, void 0) > 0;
    });
    return Promise.resolve(provider.provideMultiDocumentHighlights(model, position, filteredModels, token)).then(void 0, onUnexpectedExternalError);
  }), (result) => result !== void 0 && result !== null);
}
var OccurenceAtPositionRequest = class {
  constructor(_model, _selection, _wordSeparators) {
    this._model = _model;
    this._selection = _selection;
    this._wordSeparators = _wordSeparators;
    this._wordRange = this._getCurrentWordRange(_model, _selection);
    this._result = null;
  }
  get result() {
    if (!this._result) {
      this._result = createCancelablePromise((token) => this._compute(this._model, this._selection, this._wordSeparators, token));
    }
    return this._result;
  }
  _getCurrentWordRange(model, selection) {
    const word = model.getWordAtPosition(selection.getPosition());
    if (word) {
      return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    }
    return null;
  }
  cancel() {
    this.result.cancel();
  }
};
var SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators, providers) {
    super(model, selection, wordSeparators);
    this._providers = providers;
  }
  _compute(model, selection, wordSeparators, token) {
    return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then((value) => {
      if (!value) {
        return new ResourceMap();
      }
      return value;
    });
  }
};
var MultiModelOccurenceRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators, providers, otherModels) {
    super(model, selection, wordSeparators);
    this._providers = providers;
    this._otherModels = otherModels;
  }
  _compute(model, selection, wordSeparators, token) {
    return getOccurrencesAcrossMultipleModels(this._providers, model, selection.getPosition(), token, this._otherModels).then((value) => {
      if (!value) {
        return new ResourceMap();
      }
      return value;
    });
  }
};
function computeOccurencesAtPosition(registry, model, selection, wordSeparators) {
  return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);
}
function computeOccurencesMultiModel(registry, model, selection, wordSeparators, otherModels) {
  return new MultiModelOccurenceRequest(model, selection, wordSeparators, registry, otherModels);
}
registerModelAndPositionCommand("_executeDocumentHighlights", async (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const map = await getOccurrencesAtPosition(languageFeaturesService.documentHighlightProvider, model, position, CancellationToken.None);
  return map?.get(model.uri);
});
var _a68;
var WordHighlighter = (_a68 = class {
  constructor(editor2, providers, multiProviders, contextKeyService, textModelService, codeEditorService, configurationService, logService) {
    this.toUnhook = new DisposableStore();
    this.workerRequestTokenId = 0;
    this.workerRequestCompleted = false;
    this.workerRequestValue = new ResourceMap();
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = void 0;
    this.runDelayer = this.toUnhook.add(new Delayer(50));
    this.editor = editor2;
    this.providers = providers;
    this.multiDocumentProviders = multiProviders;
    this.codeEditorService = codeEditorService;
    this.textModelService = textModelService;
    this.configurationService = configurationService;
    this.logService = logService;
    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
    this._ignorePositionChangeEvent = false;
    this.occurrencesHighlightEnablement = this.editor.getOption(
      90
      /* EditorOption.occurrencesHighlight */
    );
    this.occurrencesHighlightDelay = this.configurationService.getValue("editor.occurrencesHighlightDelay");
    this.model = this.editor.getModel();
    this.toUnhook.add(editor2.onDidChangeCursorPosition((e) => {
      if (this._ignorePositionChangeEvent) {
        return;
      }
      if (this.occurrencesHighlightEnablement === "off") {
        return;
      }
      this.runDelayer.trigger(() => {
        this._onPositionChanged(e);
      });
    }));
    this.toUnhook.add(editor2.onDidFocusEditorText((e) => {
      if (this.occurrencesHighlightEnablement === "off") {
        return;
      }
      if (!this.workerRequest) {
        this.runDelayer.trigger(() => {
          this._run();
        });
      }
    }));
    this.toUnhook.add(editor2.onDidChangeModelContent((e) => {
      if (!matchesScheme(this.model.uri, "output")) {
        this._stopAll();
      }
    }));
    this.toUnhook.add(editor2.onDidChangeModel((e) => {
      if (!e.newModelUrl && e.oldModelUrl) {
        this._stopSingular();
      } else if (WordHighlighter_1.query) {
        this._run();
      }
    }));
    this.toUnhook.add(editor2.onDidChangeConfiguration((e) => {
      const newEnablement = this.editor.getOption(
        90
        /* EditorOption.occurrencesHighlight */
      );
      if (this.occurrencesHighlightEnablement !== newEnablement) {
        this.occurrencesHighlightEnablement = newEnablement;
        switch (newEnablement) {
          case "off":
            this._stopAll();
            break;
          case "singleFile":
            this._stopAll(WordHighlighter_1.query?.modelInfo?.modelURI);
            break;
          case "multiFile":
            if (WordHighlighter_1.query) {
              this._run(true);
            }
            break;
          default:
            console.warn("Unknown occurrencesHighlight setting value:", newEnablement);
            break;
        }
      }
    }));
    this.toUnhook.add(this.configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("editor.occurrencesHighlightDelay")) {
        const newDelay = configurationService.getValue("editor.occurrencesHighlightDelay");
        if (this.occurrencesHighlightDelay !== newDelay) {
          this.occurrencesHighlightDelay = newDelay;
        }
      }
    }));
    this.toUnhook.add(editor2.onDidBlurEditorWidget(() => {
      const activeEditor = this.codeEditorService.getFocusedCodeEditor();
      if (!activeEditor) {
        this._stopAll();
      } else if (activeEditor.getModel()?.uri.scheme === Schemas.vscodeNotebookCell && this.editor.getModel()?.uri.scheme !== Schemas.vscodeNotebookCell) {
        this._stopAll();
      }
    }));
    this.decorations = this.editor.createDecorationsCollection();
    this.workerRequestTokenId = 0;
    this.workerRequest = null;
    this.workerRequestCompleted = false;
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = void 0;
    if (WordHighlighter_1.query) {
      this._run();
    }
  }
  hasDecorations() {
    return this.decorations.length > 0;
  }
  restore(delay) {
    if (this.occurrencesHighlightEnablement === "off") {
      return;
    }
    this.runDelayer.cancel();
    this.runDelayer.trigger(() => {
      this._run(false, delay);
    });
  }
  stop() {
    if (this.occurrencesHighlightEnablement === "off") {
      return;
    }
    this._stopAll();
  }
  _getSortedHighlights() {
    return this.decorations.getRanges().sort(Range.compareRangesUsingStarts);
  }
  moveNext() {
    const highlights = this._getSortedHighlights();
    const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index + 1) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  moveBack() {
    const highlights = this._getSortedHighlights();
    const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index - 1 + highlights.length) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  _removeSingleDecorations() {
    if (!this.editor.hasModel()) {
      return;
    }
    const currentDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(this.editor.getModel().uri);
    if (!currentDecorationIDs) {
      return;
    }
    this.editor.removeDecorations(currentDecorationIDs);
    WordHighlighter_1.storedDecorationIDs.delete(this.editor.getModel().uri);
    if (this.decorations.length > 0) {
      this.decorations.clear();
      this._hasWordHighlights.set(false);
    }
  }
  _removeAllDecorations(preservedModel) {
    const currentEditors = this.codeEditorService.listCodeEditors();
    const deleteURI = [];
    for (const editor2 of currentEditors) {
      if (!editor2.hasModel() || isEqual(editor2.getModel().uri, preservedModel)) {
        continue;
      }
      const currentDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(editor2.getModel().uri);
      if (!currentDecorationIDs) {
        continue;
      }
      editor2.removeDecorations(currentDecorationIDs);
      deleteURI.push(editor2.getModel().uri);
      const editorHighlighterContrib = WordHighlighterContribution.get(editor2);
      if (!editorHighlighterContrib?.wordHighlighter) {
        continue;
      }
      if (editorHighlighterContrib.wordHighlighter.decorations.length > 0) {
        editorHighlighterContrib.wordHighlighter.decorations.clear();
        editorHighlighterContrib.wordHighlighter.workerRequest = null;
        editorHighlighterContrib.wordHighlighter._hasWordHighlights.set(false);
      }
    }
    for (const uri of deleteURI) {
      WordHighlighter_1.storedDecorationIDs.delete(uri);
    }
  }
  _stopSingular() {
    this._removeSingleDecorations();
    if (this.editor.hasTextFocus()) {
      if (this.editor.getModel()?.uri.scheme !== Schemas.vscodeNotebookCell && WordHighlighter_1.query?.modelInfo?.modelURI.scheme !== Schemas.vscodeNotebookCell) {
        WordHighlighter_1.query = null;
        this._run();
      } else {
        if (WordHighlighter_1.query?.modelInfo) {
          WordHighlighter_1.query.modelInfo = null;
        }
      }
    }
    if (this.renderDecorationsTimer !== void 0) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = void 0;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _stopAll(preservedModel) {
    this._removeAllDecorations(preservedModel);
    if (this.renderDecorationsTimer !== void 0) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = void 0;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _onPositionChanged(e) {
    if (this.occurrencesHighlightEnablement === "off") {
      this._stopAll();
      return;
    }
    if (e.source !== "api" && e.reason !== 3) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    const editorSelection = this.editor.getSelection();
    const lineNumber = editorSelection.startLineNumber;
    const startColumn = editorSelection.startColumn;
    if (this.model.isDisposed()) {
      return null;
    }
    return this.model.getWordAtPosition({
      lineNumber,
      column: startColumn
    });
  }
  getOtherModelsToHighlight(model) {
    if (!model) {
      return [];
    }
    const isNotebookEditor = model.uri.scheme === Schemas.vscodeNotebookCell;
    if (isNotebookEditor) {
      const currentModels2 = [];
      const currentEditors2 = this.codeEditorService.listCodeEditors();
      for (const editor2 of currentEditors2) {
        const tempModel = editor2.getModel();
        if (tempModel && tempModel !== model && tempModel.uri.scheme === Schemas.vscodeNotebookCell) {
          currentModels2.push(tempModel);
        }
      }
      return currentModels2;
    }
    const currentModels = [];
    const currentEditors = this.codeEditorService.listCodeEditors();
    for (const editor2 of currentEditors) {
      if (!isDiffEditor(editor2)) {
        continue;
      }
      const diffModel = editor2.getModel();
      if (!diffModel) {
        continue;
      }
      if (model === diffModel.modified) {
        currentModels.push(diffModel.modified);
      }
    }
    if (currentModels.length) {
      return currentModels;
    }
    if (this.occurrencesHighlightEnablement === "singleFile") {
      return [];
    }
    for (const editor2 of currentEditors) {
      const tempModel = editor2.getModel();
      const isValidModel = tempModel && tempModel !== model;
      if (isValidModel) {
        currentModels.push(tempModel);
      }
    }
    return currentModels;
  }
  async _run(multiFileConfigChange, delay) {
    const hasTextFocus = this.editor.hasTextFocus();
    if (!hasTextFocus) {
      if (!WordHighlighter_1.query) {
        this._stopAll();
        return;
      }
    } else {
      const editorSelection = this.editor.getSelection();
      if (!editorSelection || editorSelection.startLineNumber !== editorSelection.endLineNumber) {
        WordHighlighter_1.query = null;
        this._stopAll();
        return;
      }
      const startColumn = editorSelection.startColumn;
      const endColumn = editorSelection.endColumn;
      const word = this._getWord();
      if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
        WordHighlighter_1.query = null;
        this._stopAll();
        return;
      }
      WordHighlighter_1.query = {
        modelInfo: {
          modelURI: this.model.uri,
          selection: editorSelection
        }
      };
    }
    this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime();
    if (isEqual(this.editor.getModel().uri, WordHighlighter_1.query.modelInfo?.modelURI)) {
      if (!multiFileConfigChange) {
        const currentModelDecorationRanges = this.decorations.getRanges();
        for (const storedRange of currentModelDecorationRanges) {
          if (storedRange.containsPosition(this.editor.getPosition())) {
            return;
          }
        }
      }
      this._stopAll(multiFileConfigChange ? this.model.uri : void 0);
      const myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      const otherModelsToHighlight = this.getOtherModelsToHighlight(this.editor.getModel());
      if (!WordHighlighter_1.query || !WordHighlighter_1.query.modelInfo) {
        return;
      }
      const queryModelRef = await this.textModelService.createModelReference(WordHighlighter_1.query.modelInfo.modelURI);
      try {
        this.workerRequest = this.computeWithModel(queryModelRef.object.textEditorModel, WordHighlighter_1.query.modelInfo.selection, otherModelsToHighlight);
        this.workerRequest?.result.then((data) => {
          if (myRequestId === this.workerRequestTokenId) {
            this.workerRequestCompleted = true;
            this.workerRequestValue = data || [];
            this._beginRenderDecorations(delay ?? this.occurrencesHighlightDelay);
          }
        }, onUnexpectedError);
      } catch (e) {
        this.logService.error("Unexpected error during occurrence request. Log: ", e);
      } finally {
        queryModelRef.dispose();
      }
    } else if (this.model.uri.scheme === Schemas.vscodeNotebookCell) {
      const myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      if (!WordHighlighter_1.query || !WordHighlighter_1.query.modelInfo) {
        return;
      }
      const queryModelRef = await this.textModelService.createModelReference(WordHighlighter_1.query.modelInfo.modelURI);
      try {
        this.workerRequest = this.computeWithModel(queryModelRef.object.textEditorModel, WordHighlighter_1.query.modelInfo.selection, [this.model]);
        this.workerRequest?.result.then((data) => {
          if (myRequestId === this.workerRequestTokenId) {
            this.workerRequestCompleted = true;
            this.workerRequestValue = data || [];
            this._beginRenderDecorations(delay ?? this.occurrencesHighlightDelay);
          }
        }, onUnexpectedError);
      } catch (e) {
        this.logService.error("Unexpected error during occurrence request. Log: ", e);
      } finally {
        queryModelRef.dispose();
      }
    }
  }
  computeWithModel(model, selection, otherModels) {
    if (!otherModels.length) {
      return computeOccurencesAtPosition(this.providers, model, selection, this.editor.getOption(
        148
        /* EditorOption.wordSeparators */
      ));
    } else {
      return computeOccurencesMultiModel(this.multiDocumentProviders, model, selection, this.editor.getOption(
        148
        /* EditorOption.wordSeparators */
      ), otherModels);
    }
  }
  _beginRenderDecorations(delay) {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const minimumRenderTime = this.lastCursorPositionChangeTime + delay;
    if (currentTime >= minimumRenderTime) {
      this.renderDecorationsTimer = void 0;
      this.renderDecorations();
    } else {
      this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, minimumRenderTime - currentTime);
    }
  }
  renderDecorations() {
    this.renderDecorationsTimer = void 0;
    const currentEditors = this.codeEditorService.listCodeEditors();
    for (const editor2 of currentEditors) {
      const editorHighlighterContrib = WordHighlighterContribution.get(editor2);
      if (!editorHighlighterContrib) {
        continue;
      }
      const newDecorations = [];
      const uri = editor2.getModel()?.uri;
      if (uri && this.workerRequestValue.has(uri)) {
        const oldDecorationIDs = WordHighlighter_1.storedDecorationIDs.get(uri);
        const newDocumentHighlights = this.workerRequestValue.get(uri);
        if (newDocumentHighlights) {
          for (const highlight of newDocumentHighlights) {
            if (!highlight.range) {
              continue;
            }
            newDecorations.push({
              range: highlight.range,
              options: getHighlightDecorationOptions(highlight.kind)
            });
          }
        }
        let newDecorationIDs = [];
        editor2.changeDecorations((changeAccessor) => {
          newDecorationIDs = changeAccessor.deltaDecorations(oldDecorationIDs ?? [], newDecorations);
        });
        WordHighlighter_1.storedDecorationIDs = WordHighlighter_1.storedDecorationIDs.set(uri, newDecorationIDs);
        if (newDecorations.length > 0) {
          editorHighlighterContrib.wordHighlighter?.decorations.set(newDecorations);
          editorHighlighterContrib.wordHighlighter?._hasWordHighlights.set(true);
        }
      }
    }
    this.workerRequest = null;
  }
  dispose() {
    this._stopSingular();
    this.toUnhook.dispose();
  }
}, WordHighlighter_1 = _a68, _a68.storedDecorationIDs = new ResourceMap(), _a68.query = null, _a68);
WordHighlighter = WordHighlighter_1 = __decorate107([
  __param107(4, ITextModelService),
  __param107(5, ICodeEditorService),
  __param107(6, IConfigurationService),
  __param107(7, ILogService)
], WordHighlighter);
var _a69;
var WordHighlighterContribution = (_a69 = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(WordHighlighterContribution_1.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService, codeEditorService, textModelService, configurationService, logService) {
    super();
    this._wordHighlighter = null;
    const createWordHighlighterIfPossible = () => {
      if (editor2.hasModel() && !editor2.getModel().isTooLargeForTokenization() && editor2.getModel().uri.scheme !== Schemas.accessibleView) {
        this._wordHighlighter = new WordHighlighter(editor2, languageFeaturesService.documentHighlightProvider, languageFeaturesService.multiDocumentHighlightProvider, contextKeyService, textModelService, codeEditorService, configurationService, logService);
      }
    };
    this._register(editor2.onDidChangeModel((e) => {
      if (this._wordHighlighter) {
        if (!e.newModelUrl && e.oldModelUrl?.scheme !== Schemas.vscodeNotebookCell) {
          this.wordHighlighter?.stop();
        }
        this._wordHighlighter.dispose();
        this._wordHighlighter = null;
      }
      createWordHighlighterIfPossible();
    }));
    createWordHighlighterIfPossible();
  }
  get wordHighlighter() {
    return this._wordHighlighter;
  }
  saveViewState() {
    if (this._wordHighlighter && this._wordHighlighter.hasDecorations()) {
      return true;
    }
    return false;
  }
  moveNext() {
    this._wordHighlighter?.moveNext();
  }
  moveBack() {
    this._wordHighlighter?.moveBack();
  }
  restoreViewState(state) {
    if (this._wordHighlighter && state) {
      this._wordHighlighter.restore(250);
    }
  }
  dispose() {
    if (this._wordHighlighter) {
      this._wordHighlighter.dispose();
      this._wordHighlighter = null;
    }
    super.dispose();
  }
}, WordHighlighterContribution_1 = _a69, _a69.ID = "editor.contrib.wordHighlighter", _a69);
WordHighlighterContribution = WordHighlighterContribution_1 = __decorate107([
  __param107(1, IContextKeyService),
  __param107(2, ILanguageFeaturesService),
  __param107(3, ICodeEditorService),
  __param107(4, ITextModelService),
  __param107(5, IConfigurationService),
  __param107(6, ILogService)
], WordHighlighterContribution);
var WordHighlightNavigationAction = class extends EditorAction {
  constructor(next, opts) {
    super(opts);
    this._isNext = next;
  }
  run(accessor, editor2) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    if (this._isNext) {
      controller.moveNext();
    } else {
      controller.moveBack();
    }
  }
};
var NextWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(true, {
      id: "editor.action.wordHighlight.next",
      label: localize2(1557, "Go to Next Symbol Highlight"),
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var PrevWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(false, {
      id: "editor.action.wordHighlight.prev",
      label: localize2(1558, "Go to Previous Symbol Highlight"),
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 65,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var TriggerWordHighlightAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: localize2(1559, "Trigger Symbol Highlight"),
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor, editor2, args) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    controller.restoreViewState(true);
  }
};
registerEditorContribution(
  WordHighlighterContribution.ID,
  WordHighlighterContribution,
  0
  /* EditorContributionInstantiation.Eager */
);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);
registerEditorFeature(TextualMultiDocumentHighlightFeature);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/browser/wordOperations.js
init_editorExtensions();
init_wordCharacterClassifier();
init_position();
init_range();
init_selection();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_nls();
init_contextkey();
var MoveWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._inSelectionMode = opts.inSelectionMode;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      148
      /* EditorOption.wordSeparators */
    ), editor2.getOption(
      147
      /* EditorOption.wordSegmenterLocales */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const hasMulticursor = selections.length > 1;
    const result = selections.map((sel) => {
      const inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
      const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType, hasMulticursor);
      return this._moveTo(sel, outPosition, this._inSelectionMode);
    });
    model.pushStackElement();
    editor2._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState.fromModelSelection(r)));
    if (result.length === 1) {
      const pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
      editor2.revealPosition(
        pos,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  _moveTo(from, to, inSelectionMode) {
    if (inSelectionMode) {
      return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
    } else {
      return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
    }
  }
};
var WordLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType, hasMulticursor) {
    return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType, hasMulticursor);
  }
};
var WordRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType, hasMulticursor) {
    return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
  }
};
var CursorWordStartLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
};
var CursorWordEndLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
};
var CursorWordLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
        primary: 2048 | 15,
        mac: {
          primary: 512 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordStartLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
        primary: 2048 | 1024 | 15,
        mac: {
          primary: 512 | 1024 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordAccessibilityLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(wordCharacterClassifier, model, position, wordNavigationType, hasMulticursor) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType, hasMulticursor);
  }
};
var CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(wordCharacterClassifier, model, position, wordNavigationType, hasMulticursor) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType, hasMulticursor);
  }
};
var CursorWordStartRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
};
var CursorWordEndRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
        primary: 2048 | 17,
        mac: {
          primary: 512 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
};
var CursorWordStartRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)?.negate()),
        primary: 2048 | 1024 | 17,
        mac: {
          primary: 512 | 1024 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordAccessibilityRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(wordCharacterClassifier, model, position, wordNavigationType, hasMulticursor) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType, hasMulticursor);
  }
};
var CursorWordAccessibilityRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(wordCharacterClassifier, model, position, wordNavigationType, hasMulticursor) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType, hasMulticursor);
  }
};
var DeleteWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._whitespaceHeuristics = opts.whitespaceHeuristics;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor?.get(ILanguageConfigurationService);
    if (!editor2.hasModel() || !languageConfigurationService) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      148
      /* EditorOption.wordSeparators */
    ), editor2.getOption(
      147
      /* EditorOption.wordSegmenterLocales */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const autoClosingBrackets = editor2.getOption(
      10
      /* EditorOption.autoClosingBrackets */
    );
    const autoClosingQuotes = editor2.getOption(
      15
      /* EditorOption.autoClosingQuotes */
    );
    const autoClosingPairs = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getAutoClosingPairs();
    const viewModel = editor2._getViewModel();
    const commands = selections.map((sel) => {
      const deleteRange = this._delete({
        wordSeparators,
        model,
        selection: sel,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: editor2.getOption(
          13
          /* EditorOption.autoClosingDelete */
        ),
        autoClosingBrackets,
        autoClosingQuotes,
        autoClosingPairs,
        autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var DeleteWordLeftCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
var DeleteWordRightCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordRight(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var DeleteWordStartLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1,
        mac: {
          primary: 512 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var DeleteWordStartRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 20,
        mac: {
          primary: 512 | 20
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var DeleteInsideWord = class extends EditorAction {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: EditorContextKeys.writable,
      label: localize2(1560, "Delete Word")
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(
      148
      /* EditorOption.wordSeparators */
    ), editor2.getOption(
      147
      /* EditorOption.wordSegmenterLocales */
    ));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const commands = selections.map((sel) => {
      const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());
registerEditorAction(DeleteInsideWord);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/browser/wordPartOperations.js
init_editorExtensions();
init_range();
init_editorContextKeys();
init_commands();
var DeleteWordPartLeft = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartLeft(ctx);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
var DeleteWordPartRight = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 20
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartRight(ctx);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var WordPartLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType, hasMulticursor) {
    return WordPartOperations.moveWordPartLeft(wordSeparators, model, position, hasMulticursor);
  }
};
var CursorWordPartLeft = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
var CursorWordPartLeftSelect = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1024 | 15
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
var WordPartRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType, hasMulticursor) {
    return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
  }
};
var CursorWordPartRight = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
var CursorWordPartRightSelect = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 512 | 1024 | 17
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
};
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());

// node_modules/monaco-editor/esm/vs/editor/contrib/readOnlyMessage/browser/contribution.js
init_htmlContent();
init_lifecycle();
init_editorExtensions();
init_nls();
var _ReadOnlyMessageController = class _ReadOnlyMessageController extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  _onDidAttemptReadOnlyEdit() {
    const messageController = MessageController.get(this.editor);
    if (messageController && this.editor.hasModel()) {
      let message = this.editor.getOptions().get(
        105
        /* EditorOption.readOnlyMessage */
      );
      if (!message) {
        if (this.editor.isSimpleWidget) {
          message = new MarkdownString(localize(1363, "Cannot edit in read-only input"));
        } else {
          message = new MarkdownString(localize(1364, "Cannot edit in read-only editor"));
        }
      }
      messageController.showMessage(message, this.editor.getPosition());
    }
  }
};
_ReadOnlyMessageController.ID = "editor.contrib.readOnlyMessageController";
var ReadOnlyMessageController = _ReadOnlyMessageController;
registerEditorContribution(
  ReadOnlyMessageController.ID,
  ReadOnlyMessageController,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);

// node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_contribution2 = __toESM(require_contribution());

// node_modules/monaco-editor/esm/vs/editor/contrib/floatingMenu/browser/floatingMenu.contribution.js
init_editorExtensions();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/contrib/floatingMenu/browser/floatingMenu.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/floatingMenu/browser/floatingMenu.js
init_dom();
init_lifecycle();
init_observable();
init_actions2();
init_instantiation();
init_observableCodeEditor();
var __decorate108 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param108 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a70;
var FloatingEditorToolbar = (_a70 = class extends Disposable {
  constructor(editor2, instantiationService, keybindingService, menuService) {
    super();
    const editorObs = this._register(observableCodeEditor(editor2));
    const menu = this._register(menuService.createMenu(MenuId.EditorContent, editor2.contextKeyService));
    const menuIsEmptyObs = observableFromEvent(this, menu.onDidChange, () => menu.getActions().length === 0);
    this._register(autorun((reader) => {
      const menuIsEmpty = menuIsEmptyObs.read(reader);
      if (menuIsEmpty) {
        return;
      }
      const container = h("div.floating-menu-overlay-widget");
      container.root.style.height = "28px";
      const toolbar = instantiationService.createInstance(MenuWorkbenchToolBar, container.root, MenuId.EditorContent, {
        actionViewItemProvider: (action, options) => {
          if (!(action instanceof MenuItemAction)) {
            return void 0;
          }
          const keybinding = keybindingService.lookupKeybinding(action.id);
          if (!keybinding) {
            return void 0;
          }
          return instantiationService.createInstance(class extends MenuEntryActionViewItem {
            updateLabel() {
              if (this.options.label && this.label) {
                this.label.textContent = `${this._commandAction.label} (${keybinding.getLabel()})`;
              }
            }
          }, action, { ...options, keybindingNotRenderedWithLabel: true });
        },
        hiddenItemStrategy: 0,
        menuOptions: {
          shouldForwardArgs: true
        },
        telemetrySource: "editor.overlayToolbar",
        toolbarOptions: {
          primaryGroup: () => true,
          useSeparatorsInPrimaryActions: true
        }
      });
      reader.store.add(toolbar);
      reader.store.add(autorun((reader2) => {
        const model = editorObs.model.read(reader2);
        toolbar.context = model?.uri;
      }));
      reader.store.add(editorObs.createOverlayWidget({
        allowEditorOverflow: false,
        domNode: container.root,
        minContentWidthInPx: constObservable(0),
        position: constObservable({
          preference: 1
          /* OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER */
        })
      }));
    }));
  }
}, _a70.ID = "editor.contrib.floatingToolbar", _a70);
FloatingEditorToolbar = __decorate108([
  __param108(1, IInstantiationService),
  __param108(2, IKeybindingService),
  __param108(3, IMenuService)
], FloatingEditorToolbar);

// node_modules/monaco-editor/esm/vs/editor/contrib/floatingMenu/browser/floatingMenu.contribution.js
registerEditorContribution(
  FloatingEditorToolbar.ID,
  FloatingEditorToolbar,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);

// node_modules/monaco-editor/esm/vs/editor/editor.all.js
init_standaloneStrings();

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js
init_dom();
init_lifecycle();
init_editorExtensions();
init_platform();
import "C:/Dev/WindowsWeb/node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.css";
var _IPadShowKeyboard = class _IPadShowKeyboard extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this.widget = null;
    if (isIOS) {
      this._register(editor2.onDidChangeConfiguration(() => this.update()));
      this.update();
    }
  }
  update() {
    const shouldHaveWidget = !this.editor.getOption(
      104
      /* EditorOption.readOnly */
    );
    if (!this.widget && shouldHaveWidget) {
      this.widget = new ShowKeyboardWidget(this.editor);
    } else if (this.widget && !shouldHaveWidget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
  dispose() {
    super.dispose();
    if (this.widget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
};
_IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
var IPadShowKeyboard = _IPadShowKeyboard;
var _ShowKeyboardWidget = class _ShowKeyboardWidget extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._domNode = document.createElement("textarea");
    this._domNode.className = "iPadShowKeyboard";
    this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
      this.editor.focus();
    }));
    this._register(addDisposableListener(this._domNode, "focus", (e) => {
      this.editor.focus();
    }));
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return _ShowKeyboardWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
      /* OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER */
    };
  }
};
_ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
var ShowKeyboardWidget = _ShowKeyboardWidget;
registerEditorContribution(
  IPadShowKeyboard.ID,
  IPadShowKeyboard,
  3
  /* EditorContributionInstantiation.Eventually */
);

// node_modules/monaco-editor/esm/vs/editor/edcore.main.js
var import_inspectTokens2 = __toESM(require_inspectTokens());

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
init_platform2();
init_standaloneStrings();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js
init_nls();
init_platform2();
init_lifecycle();
var __decorate109 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param109 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HelpQuickAccessProvider_1;
var _a71;
var HelpQuickAccessProvider = (_a71 = class {
  constructor(quickInputService, keybindingService) {
    this.quickInputService = quickInputService;
    this.keybindingService = keybindingService;
    this.registry = Registry.as(Extensions2.Quickaccess);
  }
  provide(picker) {
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept(() => {
      const [item] = picker.selectedItems;
      if (item) {
        this.quickInputService.quickAccess.show(item.prefix, { preserveValue: true });
      }
    }));
    disposables.add(picker.onDidChangeValue((value) => {
      const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider_1.PREFIX.length));
      if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider_1.PREFIX) {
        this.quickInputService.quickAccess.show(providerDescriptor.prefix, { preserveValue: true });
      }
    }));
    picker.items = this.getQuickAccessProviders().filter((p) => p.prefix !== HelpQuickAccessProvider_1.PREFIX);
    return disposables;
  }
  getQuickAccessProviders() {
    const providers = this.registry.getQuickAccessProviders().sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix)).flatMap((provider) => this.createPicks(provider));
    return providers;
  }
  createPicks(provider) {
    return provider.helpEntries.map((helpEntry) => {
      const prefix = helpEntry.prefix || provider.prefix;
      const label = prefix || "…";
      return {
        prefix,
        label,
        keybinding: helpEntry.commandId ? this.keybindingService.lookupKeybinding(helpEntry.commandId) : void 0,
        ariaLabel: localize(1730, "{0}, {1}", label, helpEntry.description),
        description: helpEntry.description
      };
    });
  }
}, HelpQuickAccessProvider_1 = _a71, _a71.PREFIX = "?", _a71);
HelpQuickAccessProvider = HelpQuickAccessProvider_1 = __decorate109([
  __param109(0, IQuickInputService),
  __param109(1, IKeybindingService)
], HelpQuickAccessProvider);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: HelpQuickAccessProvider,
  prefix: "",
  helpEntries: [{ description: QuickHelpNLS.helpQuickAccessActionLabel }]
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js
init_lifecycle();

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/editorNavigationQuickAccess.js
init_functional();
init_lifecycle();
init_model2();
init_editorColorRegistry();
init_themeService();
var AbstractEditorNavigationQuickAccessProvider = class {
  constructor(options) {
    this.options = options;
    this.rangeHighlightDecorationId = void 0;
  }
  //#region Provider methods
  provide(picker, token, runOptions) {
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!this.options?.canAcceptInBackground;
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    const pickerDisposable = disposables.add(new MutableDisposable());
    pickerDisposable.value = this.doProvide(picker, token, runOptions);
    disposables.add(this.onDidActiveTextEditorControlChange(() => {
      pickerDisposable.value = void 0;
      pickerDisposable.value = this.doProvide(picker, token);
    }));
    return disposables;
  }
  doProvide(picker, token, runOptions) {
    const disposables = new DisposableStore();
    const editor2 = this.activeTextEditorControl;
    if (editor2 && this.canProvideWithTextEditor(editor2)) {
      const context = { editor: editor2 };
      const codeEditor = getCodeEditor(editor2);
      if (codeEditor) {
        let lastKnownEditorViewState = editor2.saveViewState() ?? void 0;
        disposables.add(codeEditor.onDidChangeCursorPosition(() => {
          lastKnownEditorViewState = editor2.saveViewState() ?? void 0;
        }));
        context.restoreViewState = () => {
          if (lastKnownEditorViewState && editor2 === this.activeTextEditorControl) {
            editor2.restoreViewState(lastKnownEditorViewState);
          }
        };
        disposables.add(createSingleCallFunction(token.onCancellationRequested)(() => context.restoreViewState?.()));
      }
      disposables.add(toDisposable(() => this.clearDecorations(editor2)));
      disposables.add(this.provideWithTextEditor(context, picker, token, runOptions));
    } else {
      disposables.add(this.provideWithoutTextEditor(picker, token));
    }
    return disposables;
  }
  /**
   * Subclasses to implement if they can operate on the text editor.
   */
  canProvideWithTextEditor(editor2) {
    return true;
  }
  gotoLocation({ editor: editor2 }, options) {
    editor2.setSelection(
      options.range,
      "code.jump"
      /* TextEditorSelectionSource.JUMP */
    );
    editor2.revealRangeInCenter(
      options.range,
      0
      /* ScrollType.Smooth */
    );
    if (!options.preserveFocus) {
      editor2.focus();
    }
    const model = editor2.getModel();
    if (model && "getLineContent" in model) {
      status(`${model.getLineContent(options.range.startLineNumber)}`);
    }
  }
  getModel(editor2) {
    return isDiffEditor(editor2) ? editor2.getModel()?.modified : editor2.getModel();
  }
  addDecorations(editor2, range) {
    editor2.changeDecorations((changeAccessor) => {
      const deleteDecorations = [];
      if (this.rangeHighlightDecorationId) {
        deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
        deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
        this.rangeHighlightDecorationId = void 0;
      }
      const newDecorations = [
        // highlight the entire line on the range
        {
          range,
          options: {
            description: "quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        // also add overview ruler highlight
        {
          range,
          options: {
            description: "quick-access-range-highlight-overview",
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ];
      const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
      this.rangeHighlightDecorationId = { rangeHighlightId, overviewRulerDecorationId };
    });
  }
  clearDecorations(editor2) {
    const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
    if (rangeHighlightDecorationId) {
      editor2.changeDecorations((changeAccessor) => {
        changeAccessor.deltaDecorations([
          rangeHighlightDecorationId.overviewRulerDecorationId,
          rangeHighlightDecorationId.rangeHighlightId
        ], []);
      });
      this.rangeHighlightDecorationId = void 0;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoLineQuickAccess.js
init_nls();
var _AbstractGotoLineQuickAccessProvider = class _AbstractGotoLineQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
  constructor() {
    super({ canAcceptInBackground: true });
  }
  provideWithoutTextEditor(picker) {
    const label = localize(1325, "Open a text editor first to go to a line.");
    picker.items = [{ label }];
    picker.ariaLabel = label;
    return Disposable.None;
  }
  provideWithTextEditor(context, picker, token) {
    const editor2 = context.editor;
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item) {
        if (!this.isValidLineNumber(editor2, item.lineNumber)) {
          return;
        }
        this.gotoLocation(context, { range: this.toRange(item.lineNumber, item.column), keyMods: picker.keyMods, preserveFocus: event.inBackground });
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    const updatePickerAndEditor = () => {
      const position = this.parsePosition(editor2, picker.value.trim().substr(_AbstractGotoLineQuickAccessProvider.PREFIX.length));
      const label = this.getPickLabel(editor2, position.lineNumber, position.column);
      picker.items = [{
        lineNumber: position.lineNumber,
        column: position.column,
        label
      }];
      picker.ariaLabel = label;
      if (!this.isValidLineNumber(editor2, position.lineNumber)) {
        this.clearDecorations(editor2);
        return;
      }
      const range = this.toRange(position.lineNumber, position.column);
      editor2.revealRangeInCenter(
        range,
        0
        /* ScrollType.Smooth */
      );
      this.addDecorations(editor2, range);
    };
    updatePickerAndEditor();
    disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
    const codeEditor = getCodeEditor(editor2);
    if (codeEditor) {
      const options = codeEditor.getOptions();
      const lineNumbers = options.get(
        76
        /* EditorOption.lineNumbers */
      );
      if (lineNumbers.renderType === 2) {
        codeEditor.updateOptions({ lineNumbers: "on" });
        disposables.add(toDisposable(() => codeEditor.updateOptions({ lineNumbers: "relative" })));
      }
    }
    return disposables;
  }
  toRange(lineNumber = 1, column = 1) {
    return {
      startLineNumber: lineNumber,
      startColumn: column,
      endLineNumber: lineNumber,
      endColumn: column
    };
  }
  parsePosition(editor2, value) {
    const numbers = value.split(/,|:|#/).map((part) => parseInt(part, 10)).filter((part) => !isNaN(part));
    const endLine = this.lineCount(editor2) + 1;
    return {
      lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
      column: numbers[1]
    };
  }
  getPickLabel(editor2, lineNumber, column) {
    if (this.isValidLineNumber(editor2, lineNumber)) {
      if (this.isValidColumn(editor2, lineNumber, column)) {
        return localize(1326, "Go to line {0} and character {1}.", lineNumber, column);
      }
      return localize(1327, "Go to line {0}.", lineNumber);
    }
    const position = editor2.getPosition() || { lineNumber: 1, column: 1 };
    const lineCount = this.lineCount(editor2);
    if (lineCount > 1) {
      return localize(1328, "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
    }
    return localize(1329, "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
  }
  isValidLineNumber(editor2, lineNumber) {
    if (!lineNumber || typeof lineNumber !== "number") {
      return false;
    }
    return lineNumber > 0 && lineNumber <= this.lineCount(editor2);
  }
  isValidColumn(editor2, lineNumber, column) {
    if (!column || typeof column !== "number") {
      return false;
    }
    const model = this.getModel(editor2);
    if (!model) {
      return false;
    }
    const positionCandidate = { lineNumber, column };
    return model.validatePosition(positionCandidate).equals(positionCandidate);
  }
  lineCount(editor2) {
    return this.getModel(editor2)?.getLineCount() ?? 0;
  }
};
_AbstractGotoLineQuickAccessProvider.PREFIX = ":";
var AbstractGotoLineQuickAccessProvider = _AbstractGotoLineQuickAccessProvider;

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js
init_platform2();
init_codeEditorService();
init_standaloneStrings();
init_event();
init_editorExtensions();
init_editorContextKeys();
var __decorate110 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param110 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneGotoLineQuickAccessProvider = class StandaloneGotoLineQuickAccessProvider2 extends AbstractGotoLineQuickAccessProvider {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this.onDidActiveTextEditorControlChange = Event.None;
  }
  get activeTextEditorControl() {
    return this.editorService.getFocusedCodeEditor() ?? void 0;
  }
};
StandaloneGotoLineQuickAccessProvider = __decorate110([
  __param110(0, ICodeEditorService)
], StandaloneGotoLineQuickAccessProvider);
var _GotoLineAction = class _GotoLineAction extends EditorAction {
  constructor() {
    super({
      id: _GotoLineAction.ID,
      label: GoToLineNLS.gotoLineActionLabel,
      alias: "Go to Line/Column...",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 37,
        mac: {
          primary: 256 | 37
          /* KeyCode.KeyG */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(StandaloneGotoLineQuickAccessProvider.PREFIX);
  }
};
_GotoLineAction.ID = "editor.action.gotoLine";
var GotoLineAction = _GotoLineAction;
registerEditorAction(GotoLineAction);
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneGotoLineQuickAccessProvider,
  prefix: StandaloneGotoLineQuickAccessProvider.PREFIX,
  helpEntries: [{ description: GoToLineNLS.gotoLineActionLabel, commandId: GotoLineAction.ID }]
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js
init_async();
init_cancellation();
init_codicons();
init_themables();

// node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js
init_filters();
init_path();
init_platform();
var NO_SCORE2 = [void 0, []];
function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
  const preparedQuery = query;
  if (preparedQuery.values && preparedQuery.values.length > 1) {
    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);
  }
  return doScoreFuzzy2Single(target, query, patternStart, wordStart);
}
function doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {
  let totalScore = 0;
  const totalMatches = [];
  for (const queryPiece of query) {
    const [score2, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);
    if (typeof score2 !== "number") {
      return NO_SCORE2;
    }
    totalScore += score2;
    totalMatches.push(...matches);
  }
  return [totalScore, normalizeMatches(totalMatches)];
}
function doScoreFuzzy2Single(target, query, patternStart, wordStart) {
  const score2 = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });
  if (!score2) {
    return NO_SCORE2;
  }
  return [score2[0], createMatches(score2)];
}
var NO_ITEM_SCORE = Object.freeze({ score: 0 });
function normalizeMatches(matches) {
  const sortedMatches = matches.sort((matchA, matchB) => {
    return matchA.start - matchB.start;
  });
  const normalizedMatches = [];
  let currentMatch = void 0;
  for (const match of sortedMatches) {
    if (!currentMatch || !matchOverlaps(currentMatch, match)) {
      currentMatch = match;
      normalizedMatches.push(match);
    } else {
      currentMatch.start = Math.min(currentMatch.start, match.start);
      currentMatch.end = Math.max(currentMatch.end, match.end);
    }
  }
  return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
  if (matchA.end < matchB.start) {
    return false;
  }
  if (matchB.end < matchA.start) {
    return false;
  }
  return true;
}
function queryExpectsExactMatch(query) {
  return query.startsWith('"') && query.endsWith('"');
}
var MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
function prepareQuery(original) {
  if (typeof original !== "string") {
    original = "";
  }
  const originalLowercase = original.toLowerCase();
  const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);
  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;
  const expectExactMatch = queryExpectsExactMatch(original);
  let values = void 0;
  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
  if (originalSplit.length > 1) {
    for (const originalPiece of originalSplit) {
      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);
      const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);
      if (normalizedPiece) {
        if (!values) {
          values = [];
        }
        values.push({
          original: originalPiece,
          originalLowercase: originalPiece.toLowerCase(),
          pathNormalized: pathNormalizedPiece,
          normalized: normalizedPiece,
          normalizedLowercase: normalizedLowercasePiece,
          expectContiguousMatch: expectExactMatchPiece
        });
      }
    }
  }
  return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };
}
function normalizeQuery(original) {
  let pathNormalized;
  if (isWindows) {
    pathNormalized = original.replace(/\//g, sep);
  } else {
    pathNormalized = original.replace(/\\/g, sep);
  }
  const normalized = pathNormalized.replace(/[\*\u2026\s"]/g, "");
  return {
    pathNormalized,
    normalized,
    normalizedLowercase: normalized.toLowerCase()
  };
}
function pieceToQuery(arg1) {
  if (Array.isArray(arg1)) {
    return prepareQuery(arg1.map((piece) => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));
  }
  return prepareQuery(arg1.original);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/gotoSymbolQuickAccess.js
init_lifecycle();
init_strings();
init_range();
init_languages();
init_outlineModel();
init_nls();
init_languageFeatures();
init_arraysFind();
var __decorate111 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param111 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AbstractGotoSymbolQuickAccessProvider_1;
var _a72;
var AbstractGotoSymbolQuickAccessProvider = (_a72 = class extends AbstractEditorNavigationQuickAccessProvider {
  constructor(_languageFeaturesService, _outlineModelService, options = /* @__PURE__ */ Object.create(null)) {
    super(options);
    this._languageFeaturesService = _languageFeaturesService;
    this._outlineModelService = _outlineModelService;
    this.options = options;
    this.options.canAcceptInBackground = true;
  }
  provideWithoutTextEditor(picker) {
    this.provideLabelPick(picker, localize(1330, "To go to a symbol, first open a text editor with symbol information."));
    return Disposable.None;
  }
  provideWithTextEditor(context, picker, token, runOptions) {
    const editor2 = context.editor;
    const model = this.getModel(editor2);
    if (!model) {
      return Disposable.None;
    }
    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
      return this.doProvideWithEditorSymbols(context, model, picker, token, runOptions);
    }
    return this.doProvideWithoutEditorSymbols(context, model, picker, token);
  }
  doProvideWithoutEditorSymbols(context, model, picker, token) {
    const disposables = new DisposableStore();
    this.provideLabelPick(picker, localize(1331, "The active text editor does not provide symbol information."));
    (async () => {
      const result = await this.waitForLanguageSymbolRegistry(model, disposables);
      if (!result || token.isCancellationRequested) {
        return;
      }
      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
    })();
    return disposables;
  }
  provideLabelPick(picker, label) {
    picker.items = [{
      label,
      index: 0,
      kind: 14
      /* SymbolKind.String */
    }];
    picker.ariaLabel = label;
  }
  async waitForLanguageSymbolRegistry(model, disposables) {
    if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
      return true;
    }
    const symbolProviderRegistryPromise = new DeferredPromise();
    const symbolProviderListener = disposables.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
      if (this._languageFeaturesService.documentSymbolProvider.has(model)) {
        symbolProviderListener.dispose();
        symbolProviderRegistryPromise.complete(true);
      }
    }));
    disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));
    return symbolProviderRegistryPromise.p;
  }
  doProvideWithEditorSymbols(context, model, picker, token, runOptions) {
    const editor2 = context.editor;
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item && item.range) {
        this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });
        runOptions?.handleAccept?.(item, event.inBackground);
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({ item }) => {
      if (item && item.range) {
        this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });
        picker.hide();
      }
    }));
    const symbolsPromise = this.getDocumentSymbols(model, token);
    const picksCts = disposables.add(new MutableDisposable());
    const updatePickerItems = async (positionToEnclose) => {
      picksCts?.value?.cancel();
      picker.busy = false;
      picksCts.value = new CancellationTokenSource();
      picker.busy = true;
      try {
        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider_1.PREFIX.length).trim());
        const items = await this.doGetSymbolPicks(symbolsPromise, query, void 0, picksCts.value.token, model);
        if (token.isCancellationRequested) {
          return;
        }
        if (items.length > 0) {
          picker.items = items;
          if (positionToEnclose && query.original.length === 0) {
            const candidate = findLast(items, (item) => Boolean(item.type !== "separator" && item.range && Range.containsPosition(item.range.decoration, positionToEnclose)));
            if (candidate) {
              picker.activeItems = [candidate];
            }
          }
        } else {
          if (query.original.length > 0) {
            this.provideLabelPick(picker, localize(1332, "No matching editor symbols"));
          } else {
            this.provideLabelPick(picker, localize(1333, "No editor symbols"));
          }
        }
      } finally {
        if (!token.isCancellationRequested) {
          picker.busy = false;
        }
      }
    };
    disposables.add(picker.onDidChangeValue(() => updatePickerItems(void 0)));
    updatePickerItems(editor2.getSelection()?.getPosition());
    disposables.add(picker.onDidChangeActive(() => {
      const [item] = picker.activeItems;
      if (item && item.range) {
        editor2.revealRangeInCenter(
          item.range.selection,
          0
          /* ScrollType.Smooth */
        );
        this.addDecorations(editor2, item.range.decoration);
      }
    }));
    return disposables;
  }
  async doGetSymbolPicks(symbolsPromise, query, options, token, model) {
    const symbols = await symbolsPromise;
    if (token.isCancellationRequested) {
      return [];
    }
    const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider_1.SCOPE_PREFIX) === 0;
    const filterPos = filterBySymbolKind ? 1 : 0;
    let symbolQuery;
    let containerQuery;
    if (query.values && query.values.length > 1) {
      symbolQuery = pieceToQuery(query.values[0]);
      containerQuery = pieceToQuery(query.values.slice(1));
    } else {
      symbolQuery = query;
    }
    let buttons;
    const openSideBySideDirection = this.options?.openSideBySideDirection?.();
    if (openSideBySideDirection) {
      buttons = [{
        iconClass: openSideBySideDirection === "right" ? ThemeIcon.asClassName(Codicon.splitHorizontal) : ThemeIcon.asClassName(Codicon.splitVertical),
        tooltip: openSideBySideDirection === "right" ? localize(1334, "Open to the Side") : localize(1335, "Open to the Bottom")
      }];
    }
    const filteredSymbolPicks = [];
    for (let index = 0; index < symbols.length; index++) {
      const symbol = symbols[index];
      const symbolLabel = trim(symbol.name);
      const symbolLabelWithIcon = `$(${SymbolKinds.toIcon(symbol.kind).id}) ${symbolLabel}`;
      const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
      let containerLabel = symbol.containerName;
      if (options?.extraContainerLabel) {
        if (containerLabel) {
          containerLabel = `${options.extraContainerLabel} • ${containerLabel}`;
        } else {
          containerLabel = options.extraContainerLabel;
        }
      }
      let symbolScore = void 0;
      let symbolMatches = void 0;
      let containerScore = void 0;
      let containerMatches = void 0;
      if (query.original.length > filterPos) {
        let skipContainerQuery = false;
        if (symbolQuery !== query) {
          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, {
            ...query,
            values: void 0
            /* disable multi-query support */
          }, filterPos, symbolLabelIconOffset);
          if (typeof symbolScore === "number") {
            skipContainerQuery = true;
          }
        }
        if (typeof symbolScore !== "number") {
          [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
          if (typeof symbolScore !== "number") {
            continue;
          }
        }
        if (!skipContainerQuery && containerQuery) {
          if (containerLabel && containerQuery.original.length > 0) {
            [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
          }
          if (typeof containerScore !== "number") {
            continue;
          }
          if (typeof symbolScore === "number") {
            symbolScore += containerScore;
          }
        }
      }
      const deprecated = symbol.tags && symbol.tags.indexOf(
        1
        /* SymbolTag.Deprecated */
      ) >= 0;
      filteredSymbolPicks.push({
        index,
        kind: symbol.kind,
        score: symbolScore,
        label: symbolLabelWithIcon,
        ariaLabel: getAriaLabelForSymbol(symbol.name, symbol.kind),
        description: containerLabel,
        highlights: deprecated ? void 0 : {
          label: symbolMatches,
          description: containerMatches
        },
        range: {
          selection: Range.collapseToStart(symbol.selectionRange),
          decoration: symbol.range
        },
        uri: model.uri,
        symbolName: symbolLabel,
        strikethrough: deprecated,
        buttons
      });
    }
    const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));
    let symbolPicks = [];
    if (filterBySymbolKind) {
      let updateLastSeparatorLabel = function() {
        if (lastSeparator && typeof lastSymbolKind === "number" && lastSymbolKindCounter > 0) {
          lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
        }
      };
      let lastSymbolKind = void 0;
      let lastSeparator = void 0;
      let lastSymbolKindCounter = 0;
      for (const symbolPick of sortedFilteredSymbolPicks) {
        if (lastSymbolKind !== symbolPick.kind) {
          updateLastSeparatorLabel();
          lastSymbolKind = symbolPick.kind;
          lastSymbolKindCounter = 1;
          lastSeparator = { type: "separator" };
          symbolPicks.push(lastSeparator);
        } else {
          lastSymbolKindCounter++;
        }
        symbolPicks.push(symbolPick);
      }
      updateLastSeparatorLabel();
    } else if (sortedFilteredSymbolPicks.length > 0) {
      symbolPicks = [
        { label: localize(1336, "symbols ({0})", filteredSymbolPicks.length), type: "separator" },
        ...sortedFilteredSymbolPicks
      ];
    }
    return symbolPicks;
  }
  compareByScore(symbolA, symbolB) {
    if (typeof symbolA.score !== "number" && typeof symbolB.score === "number") {
      return 1;
    } else if (typeof symbolA.score === "number" && typeof symbolB.score !== "number") {
      return -1;
    }
    if (typeof symbolA.score === "number" && typeof symbolB.score === "number") {
      if (symbolA.score > symbolB.score) {
        return -1;
      } else if (symbolA.score < symbolB.score) {
        return 1;
      }
    }
    if (symbolA.index < symbolB.index) {
      return -1;
    } else if (symbolA.index > symbolB.index) {
      return 1;
    }
    return 0;
  }
  compareByKindAndScore(symbolA, symbolB) {
    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const result = kindA.localeCompare(kindB);
    if (result === 0) {
      return this.compareByScore(symbolA, symbolB);
    }
    return result;
  }
  async getDocumentSymbols(document2, token) {
    const model = await this._outlineModelService.getOrCreate(document2, token);
    return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
  }
}, AbstractGotoSymbolQuickAccessProvider_1 = _a72, _a72.PREFIX = "@", _a72.SCOPE_PREFIX = ":", _a72.PREFIX_BY_CATEGORY = `${_a72.PREFIX}${_a72.SCOPE_PREFIX}`, _a72);
AbstractGotoSymbolQuickAccessProvider = AbstractGotoSymbolQuickAccessProvider_1 = __decorate111([
  __param111(0, ILanguageFeaturesService),
  __param111(1, IOutlineModelService)
], AbstractGotoSymbolQuickAccessProvider);
var FALLBACK_NLS_SYMBOL_KIND = localize(1337, "properties ({0})");
var NLS_SYMBOL_KIND_CACHE = {
  [
    5
    /* SymbolKind.Method */
  ]: localize(1338, "methods ({0})"),
  [
    11
    /* SymbolKind.Function */
  ]: localize(1339, "functions ({0})"),
  [
    8
    /* SymbolKind.Constructor */
  ]: localize(1340, "constructors ({0})"),
  [
    12
    /* SymbolKind.Variable */
  ]: localize(1341, "variables ({0})"),
  [
    4
    /* SymbolKind.Class */
  ]: localize(1342, "classes ({0})"),
  [
    22
    /* SymbolKind.Struct */
  ]: localize(1343, "structs ({0})"),
  [
    23
    /* SymbolKind.Event */
  ]: localize(1344, "events ({0})"),
  [
    24
    /* SymbolKind.Operator */
  ]: localize(1345, "operators ({0})"),
  [
    10
    /* SymbolKind.Interface */
  ]: localize(1346, "interfaces ({0})"),
  [
    2
    /* SymbolKind.Namespace */
  ]: localize(1347, "namespaces ({0})"),
  [
    3
    /* SymbolKind.Package */
  ]: localize(1348, "packages ({0})"),
  [
    25
    /* SymbolKind.TypeParameter */
  ]: localize(1349, "type parameters ({0})"),
  [
    1
    /* SymbolKind.Module */
  ]: localize(1350, "modules ({0})"),
  [
    6
    /* SymbolKind.Property */
  ]: localize(1351, "properties ({0})"),
  [
    9
    /* SymbolKind.Enum */
  ]: localize(1352, "enumerations ({0})"),
  [
    21
    /* SymbolKind.EnumMember */
  ]: localize(1353, "enumeration members ({0})"),
  [
    14
    /* SymbolKind.String */
  ]: localize(1354, "strings ({0})"),
  [
    0
    /* SymbolKind.File */
  ]: localize(1355, "files ({0})"),
  [
    17
    /* SymbolKind.Array */
  ]: localize(1356, "arrays ({0})"),
  [
    15
    /* SymbolKind.Number */
  ]: localize(1357, "numbers ({0})"),
  [
    16
    /* SymbolKind.Boolean */
  ]: localize(1358, "booleans ({0})"),
  [
    18
    /* SymbolKind.Object */
  ]: localize(1359, "objects ({0})"),
  [
    19
    /* SymbolKind.Key */
  ]: localize(1360, "keys ({0})"),
  [
    7
    /* SymbolKind.Field */
  ]: localize(1361, "fields ({0})"),
  [
    13
    /* SymbolKind.Constant */
  ]: localize(1362, "constants ({0})")
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js
init_platform2();
init_codeEditorService();
init_standaloneStrings();
init_event();
init_editorExtensions();
init_editorContextKeys();
init_outlineModel();
init_languageFeatures();
var __decorate112 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param112 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider2 extends AbstractGotoSymbolQuickAccessProvider {
  constructor(editorService, languageFeaturesService, outlineModelService) {
    super(languageFeaturesService, outlineModelService);
    this.editorService = editorService;
    this.onDidActiveTextEditorControlChange = Event.None;
  }
  get activeTextEditorControl() {
    return this.editorService.getFocusedCodeEditor() ?? void 0;
  }
};
StandaloneGotoSymbolQuickAccessProvider = __decorate112([
  __param112(0, ICodeEditorService),
  __param112(1, ILanguageFeaturesService),
  __param112(2, IOutlineModelService)
], StandaloneGotoSymbolQuickAccessProvider);
var _GotoSymbolAction = class _GotoSymbolAction extends EditorAction {
  constructor() {
    super({
      id: _GotoSymbolAction.ID,
      label: QuickOutlineNLS.quickOutlineActionLabel,
      alias: "Go to Symbol...",
      precondition: EditorContextKeys.hasDocumentSymbolProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 45,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "navigation",
        order: 3
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX, { itemActivation: ItemActivation.NONE });
  }
};
_GotoSymbolAction.ID = "editor.action.quickOutline";
var GotoSymbolAction = _GotoSymbolAction;
registerEditorAction(GotoSymbolAction);
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneGotoSymbolQuickAccessProvider,
  prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
  helpEntries: [
    { description: QuickOutlineNLS.quickOutlineActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX, commandId: GotoSymbolAction.ID },
    { description: QuickOutlineNLS.quickOutlineByCategoryActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY }
  ]
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
init_platform2();
init_standaloneStrings();
init_codeEditorService();

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js
init_iconLabels();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
init_errors();
init_filters();
init_functional();
init_lifecycle();
init_map();

// node_modules/monaco-editor/esm/vs/base/common/tfIdf.js
function countMapFrom(values) {
  const map = /* @__PURE__ */ new Map();
  for (const value of values) {
    map.set(value, (map.get(value) ?? 0) + 1);
  }
  return map;
}
var TfIdfCalculator = class _TfIdfCalculator {
  constructor() {
    this.chunkCount = 0;
    this.chunkOccurrences = /* @__PURE__ */ new Map();
    this.documents = /* @__PURE__ */ new Map();
  }
  calculateScores(query, token) {
    const embedding = this.computeEmbedding(query);
    const idfCache = /* @__PURE__ */ new Map();
    const scores = [];
    for (const [key, doc] of this.documents) {
      if (token.isCancellationRequested) {
        return [];
      }
      for (const chunk of doc.chunks) {
        const score2 = this.computeSimilarityScore(chunk, embedding, idfCache);
        if (score2 > 0) {
          scores.push({ key, score: score2 });
        }
      }
    }
    return scores;
  }
  /**
   * Count how many times each term (word) appears in a string.
   */
  static termFrequencies(input) {
    return countMapFrom(_TfIdfCalculator.splitTerms(input));
  }
  /**
   * Break a string into terms (words).
   */
  static *splitTerms(input) {
    const normalize = (word) => word.toLowerCase();
    for (const [word] of input.matchAll(new RegExp("\\b\\p{Letter}[\\p{Letter}\\d]{2,}\\b", "gu"))) {
      yield normalize(word);
      const camelParts = word.replace(/([a-z])([A-Z])/g, "$1 $2").split(/\s+/g);
      if (camelParts.length > 1) {
        for (const part of camelParts) {
          if (part.length > 2 && new RegExp("\\p{Letter}{3,}", "gu").test(part)) {
            yield normalize(part);
          }
        }
      }
    }
  }
  updateDocuments(documents) {
    for (const { key } of documents) {
      this.deleteDocument(key);
    }
    for (const doc of documents) {
      const chunks = [];
      for (const text of doc.textChunks) {
        const tf = _TfIdfCalculator.termFrequencies(text);
        for (const term of tf.keys()) {
          this.chunkOccurrences.set(term, (this.chunkOccurrences.get(term) ?? 0) + 1);
        }
        chunks.push({ text, tf });
      }
      this.chunkCount += chunks.length;
      this.documents.set(doc.key, { chunks });
    }
    return this;
  }
  deleteDocument(key) {
    const doc = this.documents.get(key);
    if (!doc) {
      return;
    }
    this.documents.delete(key);
    this.chunkCount -= doc.chunks.length;
    for (const chunk of doc.chunks) {
      for (const term of chunk.tf.keys()) {
        const currentOccurrences = this.chunkOccurrences.get(term);
        if (typeof currentOccurrences === "number") {
          const newOccurrences = currentOccurrences - 1;
          if (newOccurrences <= 0) {
            this.chunkOccurrences.delete(term);
          } else {
            this.chunkOccurrences.set(term, newOccurrences);
          }
        }
      }
    }
  }
  computeSimilarityScore(chunk, queryEmbedding, idfCache) {
    let sum2 = 0;
    for (const [term, termTfidf] of Object.entries(queryEmbedding)) {
      const chunkTf = chunk.tf.get(term);
      if (!chunkTf) {
        continue;
      }
      let chunkIdf = idfCache.get(term);
      if (typeof chunkIdf !== "number") {
        chunkIdf = this.computeIdf(term);
        idfCache.set(term, chunkIdf);
      }
      const chunkTfidf = chunkTf * chunkIdf;
      sum2 += chunkTfidf * termTfidf;
    }
    return sum2;
  }
  computeEmbedding(input) {
    const tf = _TfIdfCalculator.termFrequencies(input);
    return this.computeTfidf(tf);
  }
  computeIdf(term) {
    const chunkOccurrences = this.chunkOccurrences.get(term) ?? 0;
    return chunkOccurrences > 0 ? Math.log((this.chunkCount + 1) / chunkOccurrences) : 0;
  }
  computeTfidf(termFrequencies) {
    const embedding = /* @__PURE__ */ Object.create(null);
    for (const [word, occurrences] of termFrequencies) {
      const idf = this.computeIdf(word);
      if (idf > 0) {
        embedding[word] = occurrences * idf;
      }
    }
    return embedding;
  }
};
function normalizeTfIdfScores(scores) {
  const result = scores.slice(0);
  result.sort((a, b) => b.score - a.score);
  const max = result[0]?.score ?? 0;
  if (max > 0) {
    for (const score2 of result) {
      score2.score /= max;
    }
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
init_nls();
init_commands();
init_configuration();
init_instantiation();
init_log();

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js
init_async();
init_cancellation();
init_lifecycle();
init_types();
var TriggerAction;
(function(TriggerAction2) {
  TriggerAction2[TriggerAction2["NO_ACTION"] = 0] = "NO_ACTION";
  TriggerAction2[TriggerAction2["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
  TriggerAction2[TriggerAction2["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
  TriggerAction2[TriggerAction2["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
})(TriggerAction || (TriggerAction = {}));
function isPicksWithActive(obj) {
  const candidate = obj;
  return Array.isArray(candidate.items);
}
function isFastAndSlowPicks(obj) {
  const candidate = obj;
  return !!candidate.picks && candidate.additionalPicks instanceof Promise;
}
var PickerQuickAccessProvider = class extends Disposable {
  constructor(prefix, options) {
    super();
    this.prefix = prefix;
    this.options = options;
  }
  provide(picker, token, runOptions) {
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!this.options?.canAcceptInBackground;
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    let picksCts = void 0;
    const picksDisposable = disposables.add(new MutableDisposable());
    const updatePickerItems = async () => {
      picksCts?.dispose(true);
      picker.busy = false;
      const picksDisposables = picksDisposable.value = new DisposableStore();
      picksCts = picksDisposables.add(new CancellationTokenSource(token));
      const picksToken = picksCts.token;
      let picksFilter = picker.value.substring(this.prefix.length);
      if (!this.options?.shouldSkipTrimPickFilter) {
        picksFilter = picksFilter.trim();
      }
      const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken, runOptions);
      const applyPicks = (picks, skipEmpty) => {
        let items;
        let activeItem = void 0;
        if (isPicksWithActive(picks)) {
          items = picks.items;
          activeItem = picks.active;
        } else {
          items = picks;
        }
        if (items.length === 0) {
          if (skipEmpty) {
            return false;
          }
          if ((picksFilter.length > 0 || picker.hideInput) && this.options?.noResultsPick) {
            if (isFunction(this.options.noResultsPick)) {
              items = [this.options.noResultsPick(picksFilter)];
            } else {
              items = [this.options.noResultsPick];
            }
          }
        }
        picker.items = items;
        if (activeItem) {
          picker.activeItems = [activeItem];
        }
        return true;
      };
      const applyFastAndSlowPicks = async (fastAndSlowPicks) => {
        let fastPicksApplied = false;
        let slowPicksApplied = false;
        await Promise.all([
          // Fast Picks: if `mergeDelay` is configured, in order to reduce
          // amount of flicker, we race against the slow picks over some delay
          // and then set the fast picks.
          // If the slow picks are faster, we reduce the flicker by only
          // setting the items once.
          (async () => {
            if (typeof fastAndSlowPicks.mergeDelay === "number") {
              await timeout(fastAndSlowPicks.mergeDelay);
              if (picksToken.isCancellationRequested) {
                return;
              }
            }
            if (!slowPicksApplied) {
              fastPicksApplied = applyPicks(
                fastAndSlowPicks.picks,
                true
                /* skip over empty to reduce flicker */
              );
            }
          })(),
          // Slow Picks: we await the slow picks and then set them at
          // once together with the fast picks, but only if we actually
          // have additional results.
          (async () => {
            picker.busy = true;
            try {
              const awaitedAdditionalPicks = await fastAndSlowPicks.additionalPicks;
              if (picksToken.isCancellationRequested) {
                return;
              }
              let picks;
              let activePick = void 0;
              if (isPicksWithActive(fastAndSlowPicks.picks)) {
                picks = fastAndSlowPicks.picks.items;
                activePick = fastAndSlowPicks.picks.active;
              } else {
                picks = fastAndSlowPicks.picks;
              }
              let additionalPicks;
              let additionalActivePick = void 0;
              if (isPicksWithActive(awaitedAdditionalPicks)) {
                additionalPicks = awaitedAdditionalPicks.items;
                additionalActivePick = awaitedAdditionalPicks.active;
              } else {
                additionalPicks = awaitedAdditionalPicks;
              }
              if (additionalPicks.length > 0 || !fastPicksApplied) {
                let fallbackActivePick = void 0;
                if (!activePick && !additionalActivePick) {
                  const fallbackActivePickCandidate = picker.activeItems[0];
                  if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {
                    fallbackActivePick = fallbackActivePickCandidate;
                  }
                }
                applyPicks({
                  items: [...picks, ...additionalPicks],
                  active: activePick || additionalActivePick || fallbackActivePick
                });
              }
            } finally {
              if (!picksToken.isCancellationRequested) {
                picker.busy = false;
              }
              slowPicksApplied = true;
            }
          })()
        ]);
      };
      if (providedPicks === null) {
      } else if (isFastAndSlowPicks(providedPicks)) {
        await applyFastAndSlowPicks(providedPicks);
      } else if (!(providedPicks instanceof Promise)) {
        applyPicks(providedPicks);
      } else {
        picker.busy = true;
        try {
          const awaitedPicks = await providedPicks;
          if (picksToken.isCancellationRequested) {
            return;
          }
          if (isFastAndSlowPicks(awaitedPicks)) {
            await applyFastAndSlowPicks(awaitedPicks);
          } else {
            applyPicks(awaitedPicks);
          }
        } finally {
          if (!picksToken.isCancellationRequested) {
            picker.busy = false;
          }
        }
      }
    };
    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
    updatePickerItems();
    disposables.add(picker.onDidAccept((event) => {
      if (runOptions?.handleAccept) {
        if (!event.inBackground) {
          picker.hide();
        }
        runOptions.handleAccept?.(picker.activeItems[0], event.inBackground);
        return;
      }
      const [item] = picker.selectedItems;
      if (typeof item?.accept === "function") {
        if (!event.inBackground) {
          picker.hide();
        }
        item.accept(picker.keyMods, event);
      }
    }));
    const buttonTrigger = async (button, item) => {
      if (typeof item.trigger !== "function") {
        return;
      }
      const buttonIndex = item.buttons?.indexOf(button) ?? -1;
      if (buttonIndex >= 0) {
        const result = item.trigger(buttonIndex, picker.keyMods);
        const action = typeof result === "number" ? result : await result;
        if (token.isCancellationRequested) {
          return;
        }
        switch (action) {
          case TriggerAction.NO_ACTION:
            break;
          case TriggerAction.CLOSE_PICKER:
            picker.hide();
            break;
          case TriggerAction.REFRESH_PICKER:
            updatePickerItems();
            break;
          case TriggerAction.REMOVE_ITEM: {
            const index = picker.items.indexOf(item);
            if (index !== -1) {
              const items = picker.items.slice();
              const removed = items.splice(index, 1);
              const activeItems = picker.activeItems.filter((activeItem) => activeItem !== removed[0]);
              const keepScrollPositionBefore = picker.keepScrollPosition;
              picker.keepScrollPosition = true;
              picker.items = items;
              if (activeItems) {
                picker.activeItems = activeItems;
              }
              picker.keepScrollPosition = keepScrollPositionBefore;
            }
            break;
          }
        }
      }
    };
    disposables.add(picker.onDidTriggerItemButton(({ button, item }) => buttonTrigger(button, item)));
    disposables.add(picker.onDidTriggerSeparatorButton(({ button, separator: separator2 }) => buttonTrigger(button, separator2)));
    return disposables;
  }
};

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
init_telemetry();
var __decorate113 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param113 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var AbstractCommandsQuickAccessProvider_1;
var CommandsHistory_1;
var _a73;
var AbstractCommandsQuickAccessProvider = (_a73 = class extends PickerQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
    super(AbstractCommandsQuickAccessProvider_1.PREFIX, options);
    this.keybindingService = keybindingService;
    this.commandService = commandService;
    this.telemetryService = telemetryService;
    this.dialogService = dialogService;
    this.commandsHistory = this._register(instantiationService.createInstance(CommandsHistory));
    this.options = options;
  }
  async _getPicks(filter, _disposables, token, runOptions) {
    const allCommandPicks = await this.getCommandPicks(token);
    if (token.isCancellationRequested) {
      return [];
    }
    const runTfidf = createSingleCallFunction(() => {
      const tfidf = new TfIdfCalculator();
      tfidf.updateDocuments(allCommandPicks.map((commandPick) => ({
        key: commandPick.commandId,
        textChunks: [this.getTfIdfChunk(commandPick)]
      })));
      const result = tfidf.calculateScores(filter, token);
      return normalizeTfIdfScores(result).filter((score2) => score2.score > AbstractCommandsQuickAccessProvider_1.TFIDF_THRESHOLD).slice(0, AbstractCommandsQuickAccessProvider_1.TFIDF_MAX_RESULTS);
    });
    const filteredCommandPicks = [];
    for (const commandPick of allCommandPicks) {
      const labelHighlights = AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.label) ?? void 0;
      const aliasHighlights = commandPick.commandAlias ? AbstractCommandsQuickAccessProvider_1.WORD_FILTER(filter, commandPick.commandAlias) ?? void 0 : void 0;
      if (labelHighlights || aliasHighlights) {
        commandPick.highlights = {
          label: labelHighlights,
          detail: this.options.showAlias ? aliasHighlights : void 0
        };
        filteredCommandPicks.push(commandPick);
      } else if (filter === commandPick.commandId) {
        filteredCommandPicks.push(commandPick);
      } else if (filter.length >= 3) {
        const tfidf = runTfidf();
        if (token.isCancellationRequested) {
          return [];
        }
        const tfidfScore = tfidf.find((score2) => score2.key === commandPick.commandId);
        if (tfidfScore) {
          commandPick.tfIdfScore = tfidfScore.score;
          filteredCommandPicks.push(commandPick);
        }
      }
    }
    const mapLabelToCommand = /* @__PURE__ */ new Map();
    for (const commandPick of filteredCommandPicks) {
      const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
      if (existingCommandForLabel) {
        commandPick.description = commandPick.commandId;
        existingCommandForLabel.description = existingCommandForLabel.commandId;
      } else {
        mapLabelToCommand.set(commandPick.label, commandPick);
      }
    }
    filteredCommandPicks.sort((commandPickA, commandPickB) => {
      if (commandPickA.tfIdfScore && commandPickB.tfIdfScore) {
        if (commandPickA.tfIdfScore === commandPickB.tfIdfScore) {
          return commandPickA.label.localeCompare(commandPickB.label);
        }
        return commandPickB.tfIdfScore - commandPickA.tfIdfScore;
      } else if (commandPickA.tfIdfScore) {
        return 1;
      } else if (commandPickB.tfIdfScore) {
        return -1;
      }
      const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
      const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
      if (commandACounter && commandBCounter) {
        return commandACounter > commandBCounter ? -1 : 1;
      }
      if (commandACounter) {
        return -1;
      }
      if (commandBCounter) {
        return 1;
      }
      if (this.options.suggestedCommandIds) {
        const commandASuggestion = this.options.suggestedCommandIds.has(commandPickA.commandId);
        const commandBSuggestion = this.options.suggestedCommandIds.has(commandPickB.commandId);
        if (commandASuggestion && commandBSuggestion) {
          return 0;
        }
        if (commandASuggestion) {
          return -1;
        }
        if (commandBSuggestion) {
          return 1;
        }
      }
      return commandPickA.label.localeCompare(commandPickB.label);
    });
    const commandPicks = [];
    let addOtherSeparator = false;
    let addSuggestedSeparator = true;
    let addCommonlyUsedSeparator = !!this.options.suggestedCommandIds;
    for (let i2 = 0; i2 < filteredCommandPicks.length; i2++) {
      const commandPick = filteredCommandPicks[i2];
      if (i2 === 0 && this.commandsHistory.peek(commandPick.commandId)) {
        commandPicks.push({ type: "separator", label: localize(1723, "recently used") });
        addOtherSeparator = true;
      }
      if (addSuggestedSeparator && commandPick.tfIdfScore !== void 0) {
        commandPicks.push({ type: "separator", label: localize(1724, "similar commands") });
        addSuggestedSeparator = false;
      }
      if (addCommonlyUsedSeparator && commandPick.tfIdfScore === void 0 && !this.commandsHistory.peek(commandPick.commandId) && this.options.suggestedCommandIds?.has(commandPick.commandId)) {
        commandPicks.push({ type: "separator", label: localize(1725, "commonly used") });
        addOtherSeparator = true;
        addCommonlyUsedSeparator = false;
      }
      if (addOtherSeparator && commandPick.tfIdfScore === void 0 && !this.commandsHistory.peek(commandPick.commandId) && !this.options.suggestedCommandIds?.has(commandPick.commandId)) {
        commandPicks.push({ type: "separator", label: localize(1726, "other commands") });
        addOtherSeparator = false;
      }
      commandPicks.push(this.toCommandPick(commandPick, runOptions));
    }
    if (!this.hasAdditionalCommandPicks(filter, token)) {
      return commandPicks;
    }
    return {
      picks: commandPicks,
      additionalPicks: (async () => {
        const additionalCommandPicks = await this.getAdditionalCommandPicks(allCommandPicks, filteredCommandPicks, filter, token);
        if (token.isCancellationRequested) {
          return [];
        }
        const commandPicks2 = additionalCommandPicks.map((commandPick) => this.toCommandPick(commandPick, runOptions));
        if (addSuggestedSeparator && commandPicks2[0]?.type !== "separator") {
          commandPicks2.unshift({ type: "separator", label: localize(1727, "similar commands") });
        }
        return commandPicks2;
      })()
    };
  }
  toCommandPick(commandPick, runOptions) {
    if (commandPick.type === "separator") {
      return commandPick;
    }
    const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
    const ariaLabel = keybinding ? localize(1728, "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;
    return {
      ...commandPick,
      ariaLabel,
      detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : void 0,
      keybinding,
      accept: async () => {
        this.commandsHistory.push(commandPick.commandId);
        this.telemetryService.publicLog2("workbenchActionExecuted", {
          id: commandPick.commandId,
          from: runOptions?.from ?? "quick open"
        });
        try {
          commandPick.args?.length ? await this.commandService.executeCommand(commandPick.commandId, ...commandPick.args) : await this.commandService.executeCommand(commandPick.commandId);
        } catch (error) {
          if (!isCancellationError(error)) {
            this.dialogService.error(localize(1729, "Command '{0}' resulted in an error", commandPick.label), toErrorMessage(error));
          }
        }
      }
    };
  }
  // TF-IDF string to be indexed
  getTfIdfChunk({ label, commandAlias, commandDescription }) {
    let chunk = label;
    if (commandAlias && commandAlias !== label) {
      chunk += ` - ${commandAlias}`;
    }
    if (commandDescription && commandDescription.value !== label) {
      chunk += ` - ${commandDescription.value === commandDescription.original ? commandDescription.value : `${commandDescription.value} (${commandDescription.original})`}`;
    }
    return chunk;
  }
}, AbstractCommandsQuickAccessProvider_1 = _a73, _a73.PREFIX = ">", _a73.TFIDF_THRESHOLD = 0.5, _a73.TFIDF_MAX_RESULTS = 5, _a73.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString), _a73);
AbstractCommandsQuickAccessProvider = AbstractCommandsQuickAccessProvider_1 = __decorate113([
  __param113(1, IInstantiationService),
  __param113(2, IKeybindingService),
  __param113(3, ICommandService),
  __param113(4, ITelemetryService),
  __param113(5, IDialogService)
], AbstractCommandsQuickAccessProvider);
var _a74;
var CommandsHistory = (_a74 = class extends Disposable {
  constructor(storageService, configurationService, logService) {
    super();
    this.storageService = storageService;
    this.configurationService = configurationService;
    this.logService = logService;
    this.configuredCommandsHistoryLength = 0;
    this.updateConfiguration();
    this.load();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => this.updateConfiguration(e)));
    this._register(this.storageService.onWillSaveState((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        this.saveState();
      }
    }));
  }
  updateConfiguration(e) {
    if (e && !e.affectsConfiguration("workbench.commandPalette.history")) {
      return;
    }
    this.configuredCommandsHistoryLength = CommandsHistory_1.getConfiguredCommandHistoryLength(this.configurationService);
    if (CommandsHistory_1.cache && CommandsHistory_1.cache.limit !== this.configuredCommandsHistoryLength) {
      CommandsHistory_1.cache.limit = this.configuredCommandsHistoryLength;
      CommandsHistory_1.hasChanges = true;
    }
  }
  load() {
    const raw = this.storageService.get(
      CommandsHistory_1.PREF_KEY_CACHE,
      0
      /* StorageScope.PROFILE */
    );
    let serializedCache;
    if (raw) {
      try {
        serializedCache = JSON.parse(raw);
      } catch (error) {
        this.logService.error(`[CommandsHistory] invalid data: ${error}`);
      }
    }
    const cache = CommandsHistory_1.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
    if (serializedCache) {
      let entries;
      if (serializedCache.usesLRU) {
        entries = serializedCache.entries;
      } else {
        entries = serializedCache.entries.sort((a, b) => a.value - b.value);
      }
      entries.forEach((entry) => cache.set(entry.key, entry.value));
    }
    CommandsHistory_1.counter = this.storageService.getNumber(CommandsHistory_1.PREF_KEY_COUNTER, 0, CommandsHistory_1.counter);
  }
  push(commandId) {
    if (!CommandsHistory_1.cache) {
      return;
    }
    CommandsHistory_1.cache.set(commandId, CommandsHistory_1.counter++);
    CommandsHistory_1.hasChanges = true;
  }
  peek(commandId) {
    return CommandsHistory_1.cache?.peek(commandId);
  }
  saveState() {
    if (!CommandsHistory_1.cache) {
      return;
    }
    if (!CommandsHistory_1.hasChanges) {
      return;
    }
    const serializedCache = { usesLRU: true, entries: [] };
    CommandsHistory_1.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));
    this.storageService.store(
      CommandsHistory_1.PREF_KEY_CACHE,
      JSON.stringify(serializedCache),
      0,
      0
      /* StorageTarget.USER */
    );
    this.storageService.store(
      CommandsHistory_1.PREF_KEY_COUNTER,
      CommandsHistory_1.counter,
      0,
      0
      /* StorageTarget.USER */
    );
    CommandsHistory_1.hasChanges = false;
  }
  static getConfiguredCommandHistoryLength(configurationService) {
    const config = configurationService.getValue();
    const configuredCommandHistoryLength = config.workbench?.commandPalette?.history;
    if (typeof configuredCommandHistoryLength === "number") {
      return configuredCommandHistoryLength;
    }
    return CommandsHistory_1.DEFAULT_COMMANDS_HISTORY_LENGTH;
  }
}, CommandsHistory_1 = _a74, _a74.DEFAULT_COMMANDS_HISTORY_LENGTH = 50, _a74.PREF_KEY_CACHE = "commandPalette.mru.cache", _a74.PREF_KEY_COUNTER = "commandPalette.mru.counter", _a74.counter = 1, _a74.hasChanges = false, _a74);
CommandsHistory = CommandsHistory_1 = __decorate113([
  __param113(0, IStorageService),
  __param113(1, IConfigurationService),
  __param113(2, ILogService)
], CommandsHistory);

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js
var AbstractEditorCommandsQuickAccessProvider = class extends AbstractCommandsQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
    super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);
  }
  getCodeEditorCommandPicks() {
    const activeTextEditorControl = this.activeTextEditorControl;
    if (!activeTextEditorControl) {
      return [];
    }
    const editorCommandPicks = [];
    for (const editorAction of activeTextEditorControl.getSupportedActions()) {
      let commandDescription;
      if (editorAction.metadata?.description) {
        if (isLocalizedString(editorAction.metadata.description)) {
          commandDescription = editorAction.metadata.description;
        } else {
          commandDescription = { original: editorAction.metadata.description, value: editorAction.metadata.description };
        }
      }
      editorCommandPicks.push({
        commandId: editorAction.id,
        commandAlias: editorAction.alias,
        commandDescription,
        label: stripIcons(editorAction.label) || editorAction.id
      });
    }
    return editorCommandPicks;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
init_instantiation();
init_commands();
init_telemetry();
init_editorExtensions();
init_editorContextKeys();
var __decorate114 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param114 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider2 extends AbstractEditorCommandsQuickAccessProvider {
  get activeTextEditorControl() {
    return this.codeEditorService.getFocusedCodeEditor() ?? void 0;
  }
  constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, dialogService) {
    super({ showAlias: false }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
    this.codeEditorService = codeEditorService;
  }
  async getCommandPicks() {
    return this.getCodeEditorCommandPicks();
  }
  hasAdditionalCommandPicks() {
    return false;
  }
  async getAdditionalCommandPicks() {
    return [];
  }
};
StandaloneCommandsQuickAccessProvider = __decorate114([
  __param114(0, IInstantiationService),
  __param114(1, ICodeEditorService),
  __param114(2, IKeybindingService),
  __param114(3, ICommandService),
  __param114(4, ITelemetryService),
  __param114(5, IDialogService)
], StandaloneCommandsQuickAccessProvider);
var _GotoLineAction2 = class _GotoLineAction2 extends EditorAction {
  constructor() {
    super({
      id: _GotoLineAction2.ID,
      label: QuickCommandNLS.quickCommandActionLabel,
      alias: "Command Palette",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 59,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      contextMenuOpts: {
        group: "z_commands",
        order: 1
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);
  }
};
_GotoLineAction2.ID = "editor.action.quickCommand";
var GotoLineAction2 = _GotoLineAction2;
registerEditorAction(GotoLineAction2);
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneCommandsQuickAccessProvider,
  prefix: StandaloneCommandsQuickAccessProvider.PREFIX,
  helpEntries: [{ description: QuickCommandNLS.quickCommandHelp, commandId: GotoLineAction2.ID }]
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js
init_editorExtensions();
init_codeEditorService();
init_configuration();
init_contextkey();
init_instantiation();
var __decorate115 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d = decorators[i2]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param115 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneReferencesController = class StandaloneReferencesController2 extends ReferencesController {
  constructor(editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
    super(true, editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
  }
};
StandaloneReferencesController = __decorate115([
  __param115(1, IContextKeyService),
  __param115(2, ICodeEditorService),
  __param115(3, INotificationService),
  __param115(4, IInstantiationService),
  __param115(5, IStorageService),
  __param115(6, IConfigurationService)
], StandaloneReferencesController);
registerEditorContribution(
  ReferencesController.ID,
  StandaloneReferencesController,
  4
  /* EditorContributionInstantiation.Lazy */
);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js
init_editorExtensions();
init_standaloneTheme();
init_standaloneStrings();
init_theme();
var ToggleHighContrast = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.toggleHighContrast",
      label: ToggleHighContrastNLS.toggleHighContrast,
      alias: "Toggle High Contrast Theme",
      precondition: void 0
    });
    this._originalThemeName = null;
  }
  run(accessor, editor2) {
    const standaloneThemeService = accessor.get(IStandaloneThemeService);
    const currentTheme = standaloneThemeService.getColorTheme();
    if (isHighContrast(currentTheme.type)) {
      standaloneThemeService.setTheme(this._originalThemeName || (isDark(currentTheme.type) ? VS_DARK_THEME_NAME : VS_LIGHT_THEME_NAME));
      this._originalThemeName = null;
    } else {
      standaloneThemeService.setTheme(isDark(currentTheme.type) ? HC_BLACK_THEME_NAME : HC_LIGHT_THEME_NAME);
      this._originalThemeName = currentTheme.themeName;
    }
  }
};
registerEditorAction(ToggleHighContrast);

// node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var monaco_editor_core_exports = {};
__reExport(monaco_editor_core_exports, editor_api_exports);
var languageDefinitions = {};
var lazyLanguageLoaders = {};
var LazyLanguageLoader = class _LazyLanguageLoader {
  static getOrCreate(languageId) {
    if (!lazyLanguageLoaders[languageId]) {
      lazyLanguageLoaders[languageId] = new _LazyLanguageLoader(languageId);
    }
    return lazyLanguageLoaders[languageId];
  }
  constructor(languageId) {
    this._languageId = languageId;
    this._loadingTriggered = false;
    this._lazyLoadPromise = new Promise((resolve, reject) => {
      this._lazyLoadPromiseResolve = resolve;
      this._lazyLoadPromiseReject = reject;
    });
  }
  load() {
    if (!this._loadingTriggered) {
      this._loadingTriggered = true;
      languageDefinitions[this._languageId].loader().then(
        (mod) => this._lazyLoadPromiseResolve(mod),
        (err) => this._lazyLoadPromiseReject(err)
      );
    }
    return this._lazyLoadPromise;
  }
};
function registerLanguage(def) {
  const languageId = def.id;
  languageDefinitions[languageId] = def;
  monaco_editor_core_exports.languages.register(def);
  const lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);
  monaco_editor_core_exports.languages.registerTokensProviderFactory(languageId, {
    create: async () => {
      const mod = await lazyLanguageLoader.load();
      return mod.language;
    }
  });
  monaco_editor_core_exports.languages.onLanguageEncountered(languageId, async () => {
    const mod = await lazyLanguageLoader.load();
    monaco_editor_core_exports.languages.setLanguageConfiguration(languageId, mod.conf);
  });
}

// node_modules/monaco-editor/esm/vs/basic-languages/abap/abap.contribution.js
registerLanguage({
  id: "abap",
  extensions: [".abap"],
  aliases: ["abap", "ABAP"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/abap/abap"], resolve, reject);
      });
    } else {
      return import("./abap-GL4IB3HM.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/apex/apex.contribution.js
registerLanguage({
  id: "apex",
  extensions: [".cls"],
  aliases: ["Apex", "apex"],
  mimetypes: ["text/x-apex-source", "text/x-apex"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/apex/apex"], resolve, reject);
      });
    } else {
      return import("./apex-J3S2JDTB.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/azcli/azcli.contribution.js
registerLanguage({
  id: "azcli",
  extensions: [".azcli"],
  aliases: ["Azure CLI", "azcli"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/azcli/azcli"], resolve, reject);
      });
    } else {
      return import("./azcli-TRTPA5GJ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/bat/bat.contribution.js
registerLanguage({
  id: "bat",
  extensions: [".bat", ".cmd"],
  aliases: ["Batch", "bat"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/bat/bat"], resolve, reject);
      });
    } else {
      return import("./bat-UJEBBYJG.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/bicep/bicep.contribution.js
registerLanguage({
  id: "bicep",
  extensions: [".bicep"],
  aliases: ["Bicep"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/bicep/bicep"], resolve, reject);
      });
    } else {
      return import("./bicep-HKSAFMJN.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cameligo/cameligo.contribution.js
registerLanguage({
  id: "cameligo",
  extensions: [".mligo"],
  aliases: ["Cameligo"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cameligo/cameligo"], resolve, reject);
      });
    } else {
      return import("./cameligo-FH5YL4QV.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/clojure/clojure.contribution.js
registerLanguage({
  id: "clojure",
  extensions: [".clj", ".cljs", ".cljc", ".edn"],
  aliases: ["clojure", "Clojure"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/clojure/clojure"], resolve, reject);
      });
    } else {
      return import("./clojure-DBCH6TJW.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/coffee/coffee.contribution.js
registerLanguage({
  id: "coffeescript",
  extensions: [".coffee"],
  aliases: ["CoffeeScript", "coffeescript", "coffee"],
  mimetypes: ["text/x-coffeescript", "text/coffeescript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/coffee/coffee"], resolve, reject);
      });
    } else {
      return import("./coffee-KUNS2AEA.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cpp/cpp.contribution.js
registerLanguage({
  id: "c",
  extensions: [".c", ".h"],
  aliases: ["C", "c"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cpp/cpp"], resolve, reject);
      });
    } else {
      return import("./cpp-OFK7INAW.js");
    }
  }
});
registerLanguage({
  id: "cpp",
  extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx"],
  aliases: ["C++", "Cpp", "cpp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cpp/cpp"], resolve, reject);
      });
    } else {
      return import("./cpp-OFK7INAW.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/csharp/csharp.contribution.js
registerLanguage({
  id: "csharp",
  extensions: [".cs", ".csx", ".cake"],
  aliases: ["C#", "csharp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/csharp/csharp"], resolve, reject);
      });
    } else {
      return import("./csharp-3DTHCQXS.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/csp/csp.contribution.js
registerLanguage({
  id: "csp",
  extensions: [".csp"],
  aliases: ["CSP", "csp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/csp/csp"], resolve, reject);
      });
    } else {
      return import("./csp-YZ2CL4GP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/css/css.contribution.js
registerLanguage({
  id: "css",
  extensions: [".css"],
  aliases: ["CSS", "css"],
  mimetypes: ["text/css"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/css/css"], resolve, reject);
      });
    } else {
      return import("./css-TG26O6EK.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cypher/cypher.contribution.js
registerLanguage({
  id: "cypher",
  extensions: [".cypher", ".cyp"],
  aliases: ["Cypher", "OpenCypher"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cypher/cypher"], resolve, reject);
      });
    } else {
      return import("./cypher-XTD5FHUX.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/dart/dart.contribution.js
registerLanguage({
  id: "dart",
  extensions: [".dart"],
  aliases: ["Dart", "dart"],
  mimetypes: ["text/x-dart-source", "text/x-dart"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/dart/dart"], resolve, reject);
      });
    } else {
      return import("./dart-LQX2342D.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/dockerfile/dockerfile.contribution.js
registerLanguage({
  id: "dockerfile",
  extensions: [".dockerfile"],
  filenames: ["Dockerfile"],
  aliases: ["Dockerfile"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/dockerfile/dockerfile"], resolve, reject);
      });
    } else {
      return import("./dockerfile-DFH2MJYQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ecl/ecl.contribution.js
registerLanguage({
  id: "ecl",
  extensions: [".ecl"],
  aliases: ["ECL", "Ecl", "ecl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/ecl/ecl"], resolve, reject);
      });
    } else {
      return import("./ecl-AN3DXYMW.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.contribution.js
registerLanguage({
  id: "elixir",
  extensions: [".ex", ".exs"],
  aliases: ["Elixir", "elixir", "ex"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/elixir/elixir"], resolve, reject);
      });
    } else {
      return import("./elixir-H6SS2PX5.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/flow9/flow9.contribution.js
registerLanguage({
  id: "flow9",
  extensions: [".flow"],
  aliases: ["Flow9", "Flow", "flow9", "flow"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/flow9/flow9"], resolve, reject);
      });
    } else {
      return import("./flow9-PIMQFJMW.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/fsharp/fsharp.contribution.js
registerLanguage({
  id: "fsharp",
  extensions: [".fs", ".fsi", ".ml", ".mli", ".fsx", ".fsscript"],
  aliases: ["F#", "FSharp", "fsharp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/fsharp/fsharp"], resolve, reject);
      });
    } else {
      return import("./fsharp-YISJQQZE.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.contribution.js
registerLanguage({
  id: "freemarker2",
  extensions: [".ftl", ".ftlh", ".ftlx"],
  aliases: ["FreeMarker2", "Apache FreeMarker2"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagAngleInterpolationDollar);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagAutoInterpolationDollar);
    }
  }
});
registerLanguage({
  id: "freemarker2.tag-angle.interpolation-dollar",
  aliases: ["FreeMarker2 (Angle/Dollar)", "Apache FreeMarker2 (Angle/Dollar)"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagAngleInterpolationDollar);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagAngleInterpolationDollar);
    }
  }
});
registerLanguage({
  id: "freemarker2.tag-bracket.interpolation-dollar",
  aliases: ["FreeMarker2 (Bracket/Dollar)", "Apache FreeMarker2 (Bracket/Dollar)"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagBracketInterpolationDollar);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagBracketInterpolationDollar);
    }
  }
});
registerLanguage({
  id: "freemarker2.tag-angle.interpolation-bracket",
  aliases: ["FreeMarker2 (Angle/Bracket)", "Apache FreeMarker2 (Angle/Bracket)"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagAngleInterpolationBracket);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagAngleInterpolationBracket);
    }
  }
});
registerLanguage({
  id: "freemarker2.tag-bracket.interpolation-bracket",
  aliases: ["FreeMarker2 (Bracket/Bracket)", "Apache FreeMarker2 (Bracket/Bracket)"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagBracketInterpolationBracket);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagBracketInterpolationBracket);
    }
  }
});
registerLanguage({
  id: "freemarker2.tag-auto.interpolation-dollar",
  aliases: ["FreeMarker2 (Auto/Dollar)", "Apache FreeMarker2 (Auto/Dollar)"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagAutoInterpolationDollar);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagAutoInterpolationDollar);
    }
  }
});
registerLanguage({
  id: "freemarker2.tag-auto.interpolation-bracket",
  aliases: ["FreeMarker2 (Auto/Bracket)", "Apache FreeMarker2 (Auto/Bracket)"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/freemarker2/freemarker2"], resolve, reject);
      }).then((m) => m.TagAutoInterpolationBracket);
    } else {
      return import("./freemarker2-SDWUF4WD.js").then((m) => m.TagAutoInterpolationBracket);
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/go/go.contribution.js
registerLanguage({
  id: "go",
  extensions: [".go"],
  aliases: ["Go"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/go/go"], resolve, reject);
      });
    } else {
      return import("./go-DE2YVTFP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/graphql/graphql.contribution.js
registerLanguage({
  id: "graphql",
  extensions: [".graphql", ".gql"],
  aliases: ["GraphQL", "graphql", "gql"],
  mimetypes: ["application/graphql"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/graphql/graphql"], resolve, reject);
      });
    } else {
      return import("./graphql-HNER4RMK.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/handlebars/handlebars.contribution.js
registerLanguage({
  id: "handlebars",
  extensions: [".handlebars", ".hbs"],
  aliases: ["Handlebars", "handlebars", "hbs"],
  mimetypes: ["text/x-handlebars-template"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/handlebars/handlebars"], resolve, reject);
      });
    } else {
      return import("./handlebars-WD73RXQP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/hcl/hcl.contribution.js
registerLanguage({
  id: "hcl",
  extensions: [".tf", ".tfvars", ".hcl"],
  aliases: ["Terraform", "tf", "HCL", "hcl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/hcl/hcl"], resolve, reject);
      });
    } else {
      return import("./hcl-6OP6ND3J.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/html/html.contribution.js
registerLanguage({
  id: "html",
  extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm"],
  aliases: ["HTML", "htm", "html", "xhtml"],
  mimetypes: ["text/html", "text/x-jshtm", "text/template", "text/ng-template"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/html/html"], resolve, reject);
      });
    } else {
      return import("./html-TQNWHJU7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ini/ini.contribution.js
registerLanguage({
  id: "ini",
  extensions: [".ini", ".properties", ".gitconfig"],
  filenames: ["config", ".gitattributes", ".gitconfig", ".editorconfig"],
  aliases: ["Ini", "ini"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/ini/ini"], resolve, reject);
      });
    } else {
      return import("./ini-Z3XZUXXR.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/java/java.contribution.js
registerLanguage({
  id: "java",
  extensions: [".java", ".jav"],
  aliases: ["Java", "java"],
  mimetypes: ["text/x-java-source", "text/x-java"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/java/java"], resolve, reject);
      });
    } else {
      return import("./java-OEZRCOR7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution.js
registerLanguage({
  id: "javascript",
  extensions: [".js", ".es6", ".jsx", ".mjs", ".cjs"],
  firstLine: "^#!.*\\bnode",
  filenames: ["jakefile"],
  aliases: ["JavaScript", "javascript", "js"],
  mimetypes: ["text/javascript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/javascript/javascript"], resolve, reject);
      });
    } else {
      return import("./javascript-WCNC36JP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/julia/julia.contribution.js
registerLanguage({
  id: "julia",
  extensions: [".jl"],
  aliases: ["julia", "Julia"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/julia/julia"], resolve, reject);
      });
    } else {
      return import("./julia-BVVNC7PY.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/kotlin/kotlin.contribution.js
registerLanguage({
  id: "kotlin",
  extensions: [".kt", ".kts"],
  aliases: ["Kotlin", "kotlin"],
  mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/kotlin/kotlin"], resolve, reject);
      });
    } else {
      return import("./kotlin-I3OFADHK.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/less/less.contribution.js
registerLanguage({
  id: "less",
  extensions: [".less"],
  aliases: ["Less", "less"],
  mimetypes: ["text/x-less", "text/less"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/less/less"], resolve, reject);
      });
    } else {
      return import("./less-WA53EJN7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/lexon/lexon.contribution.js
registerLanguage({
  id: "lexon",
  extensions: [".lex"],
  aliases: ["Lexon"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/lexon/lexon"], resolve, reject);
      });
    } else {
      return import("./lexon-LR4MBXBZ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/lua/lua.contribution.js
registerLanguage({
  id: "lua",
  extensions: [".lua"],
  aliases: ["Lua", "lua"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/lua/lua"], resolve, reject);
      });
    } else {
      return import("./lua-NGDBBEPM.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/liquid/liquid.contribution.js
registerLanguage({
  id: "liquid",
  extensions: [".liquid", ".html.liquid"],
  aliases: ["Liquid", "liquid"],
  mimetypes: ["application/liquid"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/liquid/liquid"], resolve, reject);
      });
    } else {
      return import("./liquid-RI7BCUPR.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/m3/m3.contribution.js
registerLanguage({
  id: "m3",
  extensions: [".m3", ".i3", ".mg", ".ig"],
  aliases: ["Modula-3", "Modula3", "modula3", "m3"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/m3/m3"], resolve, reject);
      });
    } else {
      return import("./m3-37HZCPY7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution.js
registerLanguage({
  id: "markdown",
  extensions: [".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext"],
  aliases: ["Markdown", "markdown"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/markdown/markdown"], resolve, reject);
      });
    } else {
      return import("./markdown-O654DOJV.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mdx/mdx.contribution.js
registerLanguage({
  id: "mdx",
  extensions: [".mdx"],
  aliases: ["MDX", "mdx"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/mdx/mdx"], resolve, reject);
      });
    } else {
      return import("./mdx-NKMY4VYD.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mips/mips.contribution.js
registerLanguage({
  id: "mips",
  extensions: [".s"],
  aliases: ["MIPS", "MIPS-V"],
  mimetypes: ["text/x-mips", "text/mips", "text/plaintext"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/mips/mips"], resolve, reject);
      });
    } else {
      return import("./mips-PWFEF4M5.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/msdax/msdax.contribution.js
registerLanguage({
  id: "msdax",
  extensions: [".dax", ".msdax"],
  aliases: ["DAX", "MSDAX"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/msdax/msdax"], resolve, reject);
      });
    } else {
      return import("./msdax-RI2PI6W5.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mysql/mysql.contribution.js
registerLanguage({
  id: "mysql",
  extensions: [],
  aliases: ["MySQL", "mysql"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/mysql/mysql"], resolve, reject);
      });
    } else {
      return import("./mysql-YEISF2IM.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/objective-c/objective-c.contribution.js
registerLanguage({
  id: "objective-c",
  extensions: [".m"],
  aliases: ["Objective-C"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/objective-c/objective-c"], resolve, reject);
      });
    } else {
      return import("./objective-c-QWWMY5D4.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.contribution.js
registerLanguage({
  id: "pascal",
  extensions: [".pas", ".p", ".pp"],
  aliases: ["Pascal", "pas"],
  mimetypes: ["text/x-pascal-source", "text/x-pascal"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pascal/pascal"], resolve, reject);
      });
    } else {
      return import("./pascal-SNI33QB6.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pascaligo/pascaligo.contribution.js
registerLanguage({
  id: "pascaligo",
  extensions: [".ligo"],
  aliases: ["Pascaligo", "ligo"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pascaligo/pascaligo"], resolve, reject);
      });
    } else {
      return import("./pascaligo-YUYZVB6O.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/perl/perl.contribution.js
registerLanguage({
  id: "perl",
  extensions: [".pl", ".pm"],
  aliases: ["Perl", "pl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/perl/perl"], resolve, reject);
      });
    } else {
      return import("./perl-YNNRJMDY.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pgsql/pgsql.contribution.js
registerLanguage({
  id: "pgsql",
  extensions: [],
  aliases: ["PostgreSQL", "postgres", "pg", "postgre"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pgsql/pgsql"], resolve, reject);
      });
    } else {
      return import("./pgsql-JOCP6R7N.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/php/php.contribution.js
registerLanguage({
  id: "php",
  extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"],
  aliases: ["PHP", "php"],
  mimetypes: ["application/x-php"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/php/php"], resolve, reject);
      });
    } else {
      return import("./php-VHQXQ33G.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pla/pla.contribution.js
registerLanguage({
  id: "pla",
  extensions: [".pla"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pla/pla"], resolve, reject);
      });
    } else {
      return import("./pla-U74LRGNV.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/postiats/postiats.contribution.js
registerLanguage({
  id: "postiats",
  extensions: [".dats", ".sats", ".hats"],
  aliases: ["ATS", "ATS/Postiats"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/postiats/postiats"], resolve, reject);
      });
    } else {
      return import("./postiats-HY23ETPR.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/powerquery/powerquery.contribution.js
registerLanguage({
  id: "powerquery",
  extensions: [".pq", ".pqm"],
  aliases: ["PQ", "M", "Power Query", "Power Query M"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/powerquery/powerquery"], resolve, reject);
      });
    } else {
      return import("./powerquery-JZY6FRAP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/powershell/powershell.contribution.js
registerLanguage({
  id: "powershell",
  extensions: [".ps1", ".psm1", ".psd1"],
  aliases: ["PowerShell", "powershell", "ps", "ps1"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/powershell/powershell"], resolve, reject);
      });
    } else {
      return import("./powershell-MZUHYXHQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/protobuf/protobuf.contribution.js
registerLanguage({
  id: "proto",
  extensions: [".proto"],
  aliases: ["protobuf", "Protocol Buffers"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/protobuf/protobuf"], resolve, reject);
      });
    } else {
      return import("./protobuf-Z2Z5E7Q3.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pug/pug.contribution.js
registerLanguage({
  id: "pug",
  extensions: [".jade", ".pug"],
  aliases: ["Pug", "Jade", "jade"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pug/pug"], resolve, reject);
      });
    } else {
      return import("./pug-CNTVL2TU.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/python/python.contribution.js
registerLanguage({
  id: "python",
  extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"],
  aliases: ["Python", "py"],
  firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/python/python"], resolve, reject);
      });
    } else {
      return import("./python-73CI7FB4.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/qsharp/qsharp.contribution.js
registerLanguage({
  id: "qsharp",
  extensions: [".qs"],
  aliases: ["Q#", "qsharp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/qsharp/qsharp"], resolve, reject);
      });
    } else {
      return import("./qsharp-N7OGUSCO.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/r/r.contribution.js
registerLanguage({
  id: "r",
  extensions: [".r", ".rhistory", ".rmd", ".rprofile", ".rt"],
  aliases: ["R", "r"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/r/r"], resolve, reject);
      });
    } else {
      return import("./r-UFLMY5PI.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/razor/razor.contribution.js
registerLanguage({
  id: "razor",
  extensions: [".cshtml"],
  aliases: ["Razor", "razor"],
  mimetypes: ["text/x-cshtml"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/razor/razor"], resolve, reject);
      });
    } else {
      return import("./razor-UKJ6SEYE.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/redis/redis.contribution.js
registerLanguage({
  id: "redis",
  extensions: [".redis"],
  aliases: ["redis"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/redis/redis"], resolve, reject);
      });
    } else {
      return import("./redis-5O3HVCZX.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/redshift/redshift.contribution.js
registerLanguage({
  id: "redshift",
  extensions: [],
  aliases: ["Redshift", "redshift"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/redshift/redshift"], resolve, reject);
      });
    } else {
      return import("./redshift-5MB3RJT6.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/restructuredtext/restructuredtext.contribution.js
registerLanguage({
  id: "restructuredtext",
  extensions: [".rst"],
  aliases: ["reStructuredText", "restructuredtext"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/restructuredtext/restructuredtext"], resolve, reject);
      });
    } else {
      return import("./restructuredtext-XUDICBHG.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.contribution.js
registerLanguage({
  id: "ruby",
  extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".pp"],
  filenames: ["rakefile", "Gemfile"],
  aliases: ["Ruby", "rb"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/ruby/ruby"], resolve, reject);
      });
    } else {
      return import("./ruby-FVGKNJM4.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/rust/rust.contribution.js
registerLanguage({
  id: "rust",
  extensions: [".rs", ".rlib"],
  aliases: ["Rust", "rust"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/rust/rust"], resolve, reject);
      });
    } else {
      return import("./rust-BL7VT77Y.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sb/sb.contribution.js
registerLanguage({
  id: "sb",
  extensions: [".sb"],
  aliases: ["Small Basic", "sb"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sb/sb"], resolve, reject);
      });
    } else {
      return import("./sb-764Q5URZ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scala/scala.contribution.js
registerLanguage({
  id: "scala",
  extensions: [".scala", ".sc", ".sbt"],
  aliases: ["Scala", "scala", "SBT", "Sbt", "sbt", "Dotty", "dotty"],
  mimetypes: ["text/x-scala-source", "text/x-scala", "text/x-sbt", "text/x-dotty"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/scala/scala"], resolve, reject);
      });
    } else {
      return import("./scala-VB2HXYZS.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scheme/scheme.contribution.js
registerLanguage({
  id: "scheme",
  extensions: [".scm", ".ss", ".sch", ".rkt"],
  aliases: ["scheme", "Scheme"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/scheme/scheme"], resolve, reject);
      });
    } else {
      return import("./scheme-ZWJLJJPJ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scss/scss.contribution.js
registerLanguage({
  id: "scss",
  extensions: [".scss"],
  aliases: ["Sass", "sass", "scss"],
  mimetypes: ["text/x-scss", "text/scss"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/scss/scss"], resolve, reject);
      });
    } else {
      return import("./scss-X5BNKAUL.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/shell/shell.contribution.js
registerLanguage({
  id: "shell",
  extensions: [".sh", ".bash"],
  aliases: ["Shell", "sh"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/shell/shell"], resolve, reject);
      });
    } else {
      return import("./shell-NJJ272BL.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/solidity/solidity.contribution.js
registerLanguage({
  id: "sol",
  extensions: [".sol"],
  aliases: ["sol", "solidity", "Solidity"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/solidity/solidity"], resolve, reject);
      });
    } else {
      return import("./solidity-M4MMA47T.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sophia/sophia.contribution.js
registerLanguage({
  id: "aes",
  extensions: [".aes"],
  aliases: ["aes", "sophia", "Sophia"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sophia/sophia"], resolve, reject);
      });
    } else {
      return import("./sophia-JEHPQ6E6.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sparql/sparql.contribution.js
registerLanguage({
  id: "sparql",
  extensions: [".rq"],
  aliases: ["sparql", "SPARQL"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sparql/sparql"], resolve, reject);
      });
    } else {
      return import("./sparql-2I52PVZY.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sql/sql.contribution.js
registerLanguage({
  id: "sql",
  extensions: [".sql"],
  aliases: ["SQL"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sql/sql"], resolve, reject);
      });
    } else {
      return import("./sql-EAUX2MMQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/st/st.contribution.js
registerLanguage({
  id: "st",
  extensions: [".st", ".iecst", ".iecplc", ".lc3lib", ".TcPOU", ".TcDUT", ".TcGVL", ".TcIO"],
  aliases: ["StructuredText", "scl", "stl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/st/st"], resolve, reject);
      });
    } else {
      return import("./st-UPMDHO4G.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/swift/swift.contribution.js
registerLanguage({
  id: "swift",
  aliases: ["Swift", "swift"],
  extensions: [".swift"],
  mimetypes: ["text/swift"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/swift/swift"], resolve, reject);
      });
    } else {
      return import("./swift-N5SQOYKY.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/systemverilog/systemverilog.contribution.js
registerLanguage({
  id: "systemverilog",
  extensions: [".sv", ".svh"],
  aliases: ["SV", "sv", "SystemVerilog", "systemverilog"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/systemverilog/systemverilog"], resolve, reject);
      });
    } else {
      return import("./systemverilog-4QA7NSZG.js");
    }
  }
});
registerLanguage({
  id: "verilog",
  extensions: [".v", ".vh"],
  aliases: ["V", "v", "Verilog", "verilog"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/systemverilog/systemverilog"], resolve, reject);
      });
    } else {
      return import("./systemverilog-4QA7NSZG.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/tcl/tcl.contribution.js
registerLanguage({
  id: "tcl",
  extensions: [".tcl"],
  aliases: ["tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/tcl/tcl"], resolve, reject);
      });
    } else {
      return import("./tcl-A4UIVYMC.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/twig/twig.contribution.js
registerLanguage({
  id: "twig",
  extensions: [".twig"],
  aliases: ["Twig", "twig"],
  mimetypes: ["text/x-twig"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/twig/twig"], resolve, reject);
      });
    } else {
      return import("./twig-X66TONPM.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js
registerLanguage({
  id: "typescript",
  extensions: [".ts", ".tsx", ".cts", ".mts"],
  aliases: ["TypeScript", "ts", "typescript"],
  mimetypes: ["text/typescript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/typescript/typescript"], resolve, reject);
      });
    } else {
      return import("./typescript-GHDRV6LN.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/typespec/typespec.contribution.js
registerLanguage({
  id: "typespec",
  extensions: [".tsp"],
  aliases: ["TypeSpec"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/typespec/typespec"], resolve, reject);
      });
    } else {
      return import("./typespec-QOLZ3JCQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/vb/vb.contribution.js
registerLanguage({
  id: "vb",
  extensions: [".vb"],
  aliases: ["Visual Basic", "vb"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/vb/vb"], resolve, reject);
      });
    } else {
      return import("./vb-OBBUBPET.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/wgsl/wgsl.contribution.js
registerLanguage({
  id: "wgsl",
  extensions: [".wgsl"],
  aliases: ["WebGPU Shading Language", "WGSL", "wgsl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/wgsl/wgsl"], resolve, reject);
      });
    } else {
      return import("./wgsl-XK3I7SWQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/xml/xml.contribution.js
registerLanguage({
  id: "xml",
  extensions: [
    ".xml",
    ".xsd",
    ".dtd",
    ".ascx",
    ".csproj",
    ".config",
    ".props",
    ".targets",
    ".wxi",
    ".wxl",
    ".wxs",
    ".xaml",
    ".svg",
    ".svgz",
    ".opf",
    ".xslt",
    ".xsl"
  ],
  firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
  aliases: ["XML", "xml"],
  mimetypes: ["text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/xml/xml"], resolve, reject);
      });
    } else {
      return import("./xml-ZAWA42T5.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution.js
registerLanguage({
  id: "yaml",
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml", "text/x-yaml"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/yaml/yaml"], resolve, reject);
      });
    } else {
      return import("./yaml-DHL5X7A4.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport2 = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
var monaco_editor_core_exports2 = {};
__reExport2(monaco_editor_core_exports2, editor_api_exports);
var LanguageServiceDefaultsImpl = class {
  constructor(languageId, options, modeConfiguration) {
    this._onDidChange = new monaco_editor_core_exports2.Emitter();
    this._languageId = languageId;
    this.setOptions(options);
    this.setModeConfiguration(modeConfiguration);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this.options;
  }
  get options() {
    return this._options;
  }
  setOptions(options) {
    this._options = options || /* @__PURE__ */ Object.create(null);
    this._onDidChange.fire(this);
  }
  setDiagnosticsOptions(options) {
    this.setOptions(options);
  }
  setModeConfiguration(modeConfiguration) {
    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
    this._onDidChange.fire(this);
  }
};
var optionsDefault = {
  validate: true,
  lint: {
    compatibleVendorPrefixes: "ignore",
    vendorPrefix: "warning",
    duplicateProperties: "warning",
    emptyRules: "warning",
    importStatement: "ignore",
    boxModel: "ignore",
    universalSelector: "ignore",
    zeroUnits: "ignore",
    fontFaceProperties: "warning",
    hexColorLength: "error",
    argumentsInColorFunction: "error",
    unknownProperties: "warning",
    ieHack: "ignore",
    unknownVendorSpecificProperties: "ignore",
    propertyIgnoredDueToDisplay: "warning",
    important: "ignore",
    float: "ignore",
    idSelector: "ignore"
  },
  data: { useDefaultDataProvider: true },
  format: {
    newlineBetweenSelectors: true,
    newlineBetweenRules: true,
    spaceAroundSelectorSeparator: false,
    braceStyle: "collapse",
    maxPreserveNewLines: void 0,
    preserveNewLines: true
  }
};
var modeConfigurationDefault = {
  completionItems: true,
  hovers: true,
  documentSymbols: true,
  definitions: true,
  references: true,
  documentHighlights: true,
  rename: true,
  colors: true,
  foldingRanges: true,
  diagnostics: true,
  selectionRanges: true,
  documentFormattingEdits: true,
  documentRangeFormattingEdits: true
};
var cssDefaults = new LanguageServiceDefaultsImpl(
  "css",
  optionsDefault,
  modeConfigurationDefault
);
var scssDefaults = new LanguageServiceDefaultsImpl(
  "scss",
  optionsDefault,
  modeConfigurationDefault
);
var lessDefaults = new LanguageServiceDefaultsImpl(
  "less",
  optionsDefault,
  modeConfigurationDefault
);
monaco_editor_core_exports2.languages.css = { cssDefaults, lessDefaults, scssDefaults };
function getMode() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/css/cssMode"], resolve, reject);
    });
  } else {
    return import("./cssMode-HX3RKFIK.js");
  }
}
monaco_editor_core_exports2.languages.onLanguage("less", () => {
  getMode().then((mode) => mode.setupMode(lessDefaults));
});
monaco_editor_core_exports2.languages.onLanguage("scss", () => {
  getMode().then((mode) => mode.setupMode(scssDefaults));
});
monaco_editor_core_exports2.languages.onLanguage("css", () => {
  getMode().then((mode) => mode.setupMode(cssDefaults));
});

// node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __copyProps3 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames3(from))
      if (!__hasOwnProp3.call(to, key) && key !== except)
        __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport3 = (target, mod, secondTarget) => (__copyProps3(target, mod, "default"), secondTarget && __copyProps3(secondTarget, mod, "default"));
var monaco_editor_core_exports3 = {};
__reExport3(monaco_editor_core_exports3, editor_api_exports);
var LanguageServiceDefaultsImpl2 = class {
  constructor(languageId, options, modeConfiguration) {
    this._onDidChange = new monaco_editor_core_exports3.Emitter();
    this._languageId = languageId;
    this.setOptions(options);
    this.setModeConfiguration(modeConfiguration);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get options() {
    return this._options;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  setOptions(options) {
    this._options = options || /* @__PURE__ */ Object.create(null);
    this._onDidChange.fire(this);
  }
  setModeConfiguration(modeConfiguration) {
    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
    this._onDidChange.fire(this);
  }
};
var formatDefaults = {
  tabSize: 4,
  insertSpaces: false,
  wrapLineLength: 120,
  unformatted: 'default": "a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',
  contentUnformatted: "pre",
  indentInnerHtml: false,
  preserveNewLines: true,
  maxPreserveNewLines: void 0,
  indentHandlebars: false,
  endWithNewline: false,
  extraLiners: "head, body, /html",
  wrapAttributes: "auto"
};
var optionsDefault2 = {
  format: formatDefaults,
  suggest: {},
  data: { useDefaultDataProvider: true }
};
function getConfigurationDefault(languageId) {
  return {
    completionItems: true,
    hovers: true,
    documentSymbols: true,
    links: true,
    documentHighlights: true,
    rename: true,
    colors: true,
    foldingRanges: true,
    selectionRanges: true,
    diagnostics: languageId === htmlLanguageId,
    // turned off for Razor and Handlebar
    documentFormattingEdits: languageId === htmlLanguageId,
    // turned off for Razor and Handlebar
    documentRangeFormattingEdits: languageId === htmlLanguageId
    // turned off for Razor and Handlebar
  };
}
var htmlLanguageId = "html";
var handlebarsLanguageId = "handlebars";
var razorLanguageId = "razor";
var htmlLanguageService = registerHTMLLanguageService(
  htmlLanguageId,
  optionsDefault2,
  getConfigurationDefault(htmlLanguageId)
);
var htmlDefaults = htmlLanguageService.defaults;
var handlebarLanguageService = registerHTMLLanguageService(
  handlebarsLanguageId,
  optionsDefault2,
  getConfigurationDefault(handlebarsLanguageId)
);
var handlebarDefaults = handlebarLanguageService.defaults;
var razorLanguageService = registerHTMLLanguageService(
  razorLanguageId,
  optionsDefault2,
  getConfigurationDefault(razorLanguageId)
);
var razorDefaults = razorLanguageService.defaults;
monaco_editor_core_exports3.languages.html = {
  htmlDefaults,
  razorDefaults,
  handlebarDefaults,
  htmlLanguageService,
  handlebarLanguageService,
  razorLanguageService,
  registerHTMLLanguageService
};
function getMode2() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/html/htmlMode"], resolve, reject);
    });
  } else {
    return import("./htmlMode-3HGNPNJ3.js");
  }
}
function registerHTMLLanguageService(languageId, options = optionsDefault2, modeConfiguration = getConfigurationDefault(languageId)) {
  const defaults = new LanguageServiceDefaultsImpl2(languageId, options, modeConfiguration);
  let mode;
  const onLanguageListener = monaco_editor_core_exports3.languages.onLanguage(languageId, async () => {
    mode = (await getMode2()).setupMode(defaults);
  });
  return {
    defaults,
    dispose() {
      onLanguageListener.dispose();
      mode?.dispose();
      mode = void 0;
    }
  };
}

// node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames4 = Object.getOwnPropertyNames;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __copyProps4 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames4(from))
      if (!__hasOwnProp4.call(to, key) && key !== except)
        __defProp4(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc4(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport4 = (target, mod, secondTarget) => (__copyProps4(target, mod, "default"), secondTarget && __copyProps4(secondTarget, mod, "default"));
var monaco_editor_core_exports4 = {};
__reExport4(monaco_editor_core_exports4, editor_api_exports);
var LanguageServiceDefaultsImpl3 = class {
  constructor(languageId, diagnosticsOptions, modeConfiguration) {
    this._onDidChange = new monaco_editor_core_exports4.Emitter();
    this._languageId = languageId;
    this.setDiagnosticsOptions(diagnosticsOptions);
    this.setModeConfiguration(modeConfiguration);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(options) {
    this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);
    this._onDidChange.fire(this);
  }
  setModeConfiguration(modeConfiguration) {
    this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
    this._onDidChange.fire(this);
  }
};
var diagnosticDefault = {
  validate: true,
  allowComments: true,
  schemas: [],
  enableSchemaRequest: false,
  schemaRequest: "warning",
  schemaValidation: "warning",
  comments: "error",
  trailingCommas: "error"
};
var modeConfigurationDefault2 = {
  documentFormattingEdits: true,
  documentRangeFormattingEdits: true,
  completionItems: true,
  hovers: true,
  documentSymbols: true,
  tokens: true,
  colors: true,
  foldingRanges: true,
  diagnostics: true,
  selectionRanges: true
};
var jsonDefaults = new LanguageServiceDefaultsImpl3(
  "json",
  diagnosticDefault,
  modeConfigurationDefault2
);
var getWorker = () => getMode3().then((mode) => mode.getWorker());
monaco_editor_core_exports4.languages.json = { jsonDefaults, getWorker };
function getMode3() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/json/jsonMode"], resolve, reject);
    });
  } else {
    return import("./jsonMode-O44FE4AH.js");
  }
}
monaco_editor_core_exports4.languages.register({
  id: "json",
  extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".har"],
  aliases: ["JSON", "json"],
  mimetypes: ["application/json"]
});
monaco_editor_core_exports4.languages.onLanguage("json", () => {
  getMode3().then((mode) => mode.setupMode(jsonDefaults));
});

// node_modules/monaco-editor/esm/vs/editor/editor.main.js
var __defProp5 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames5 = Object.getOwnPropertyNames;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __copyProps5 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames5(from))
      if (!__hasOwnProp5.call(to, key) && key !== except)
        __defProp5(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc5(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport5 = (target, mod, secondTarget) => (__copyProps5(target, mod, "default"), secondTarget && __copyProps5(secondTarget, mod, "default"));
var monaco_editor_core_exports5 = {};
__reExport5(monaco_editor_core_exports5, edcore_main_exports);
function createTrustedTypesPolicy2(policyName, policyOptions) {
  const monacoEnvironment = globalThis.MonacoEnvironment;
  if (monacoEnvironment?.createTrustedTypesPolicy) {
    try {
      return monacoEnvironment.createTrustedTypesPolicy(policyName, policyOptions);
    } catch (err) {
      console.error(err);
      return void 0;
    }
  }
  try {
    return globalThis.trustedTypes?.createPolicy(policyName, policyOptions);
  } catch (err) {
    console.error(err);
    return void 0;
  }
}
var ttPolicy2;
if (typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope" && globalThis.workerttPolicy !== void 0) {
  ttPolicy2 = globalThis.workerttPolicy;
} else {
  ttPolicy2 = createTrustedTypesPolicy2("defaultWorkerFactory", {
    createScriptURL: (value) => value
  });
}
function getWorker2(descriptor) {
  const label = descriptor.label;
  const monacoEnvironment = globalThis.MonacoEnvironment;
  if (monacoEnvironment) {
    if (typeof monacoEnvironment.getWorker === "function") {
      return monacoEnvironment.getWorker("workerMain.js", label);
    }
    if (typeof monacoEnvironment.getWorkerUrl === "function") {
      const workerUrl = monacoEnvironment.getWorkerUrl("workerMain.js", label);
      return new Worker(
        ttPolicy2 ? ttPolicy2.createScriptURL(workerUrl) : workerUrl,
        { name: label, type: "module" }
      );
    }
  }
  throw new Error(
    `You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker`
  );
}
function createWebWorker(opts) {
  const worker = Promise.resolve(
    getWorker2({
      label: opts.label ?? "monaco-editor-worker",
      moduleId: opts.moduleId
    })
  ).then((w) => {
    w.postMessage("ignore");
    w.postMessage(opts.createData);
    return w;
  });
  return monaco_editor_core_exports5.editor.createWebWorker({
    worker,
    host: opts.host,
    keepIdleModels: opts.keepIdleModels
  });
}
var existingCreateWebWorker = editor.createWebWorker;
editor.createWebWorker = function(options) {
  if (options.worker === void 0) {
    return createWebWorker(options);
  }
  return existingCreateWebWorker(options);
};
export {
  CancellationTokenSource2 as CancellationTokenSource,
  Emitter2 as Emitter,
  KeyCode,
  KeyMod,
  MarkerSeverity2 as MarkerSeverity,
  MarkerTag,
  Position2 as Position,
  Range2 as Range,
  Selection2 as Selection,
  SelectionDirection,
  Token,
  Uri,
  editor,
  languages
};
/*! Bundled license information:

monaco-editor/esm/vs/basic-languages/_.contribution.js:
monaco-editor/esm/vs/basic-languages/abap/abap.contribution.js:
monaco-editor/esm/vs/basic-languages/apex/apex.contribution.js:
monaco-editor/esm/vs/basic-languages/azcli/azcli.contribution.js:
monaco-editor/esm/vs/basic-languages/bat/bat.contribution.js:
monaco-editor/esm/vs/basic-languages/bicep/bicep.contribution.js:
monaco-editor/esm/vs/basic-languages/cameligo/cameligo.contribution.js:
monaco-editor/esm/vs/basic-languages/clojure/clojure.contribution.js:
monaco-editor/esm/vs/basic-languages/coffee/coffee.contribution.js:
monaco-editor/esm/vs/basic-languages/cpp/cpp.contribution.js:
monaco-editor/esm/vs/basic-languages/csharp/csharp.contribution.js:
monaco-editor/esm/vs/basic-languages/csp/csp.contribution.js:
monaco-editor/esm/vs/basic-languages/css/css.contribution.js:
monaco-editor/esm/vs/basic-languages/cypher/cypher.contribution.js:
monaco-editor/esm/vs/basic-languages/dart/dart.contribution.js:
monaco-editor/esm/vs/basic-languages/dockerfile/dockerfile.contribution.js:
monaco-editor/esm/vs/basic-languages/ecl/ecl.contribution.js:
monaco-editor/esm/vs/basic-languages/elixir/elixir.contribution.js:
monaco-editor/esm/vs/basic-languages/flow9/flow9.contribution.js:
monaco-editor/esm/vs/basic-languages/fsharp/fsharp.contribution.js:
monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.contribution.js:
monaco-editor/esm/vs/basic-languages/go/go.contribution.js:
monaco-editor/esm/vs/basic-languages/graphql/graphql.contribution.js:
monaco-editor/esm/vs/basic-languages/handlebars/handlebars.contribution.js:
monaco-editor/esm/vs/basic-languages/hcl/hcl.contribution.js:
monaco-editor/esm/vs/basic-languages/html/html.contribution.js:
monaco-editor/esm/vs/basic-languages/ini/ini.contribution.js:
monaco-editor/esm/vs/basic-languages/java/java.contribution.js:
monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution.js:
monaco-editor/esm/vs/basic-languages/julia/julia.contribution.js:
monaco-editor/esm/vs/basic-languages/kotlin/kotlin.contribution.js:
monaco-editor/esm/vs/basic-languages/less/less.contribution.js:
monaco-editor/esm/vs/basic-languages/lexon/lexon.contribution.js:
monaco-editor/esm/vs/basic-languages/lua/lua.contribution.js:
monaco-editor/esm/vs/basic-languages/liquid/liquid.contribution.js:
monaco-editor/esm/vs/basic-languages/m3/m3.contribution.js:
monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution.js:
monaco-editor/esm/vs/basic-languages/mdx/mdx.contribution.js:
monaco-editor/esm/vs/basic-languages/mips/mips.contribution.js:
monaco-editor/esm/vs/basic-languages/msdax/msdax.contribution.js:
monaco-editor/esm/vs/basic-languages/mysql/mysql.contribution.js:
monaco-editor/esm/vs/basic-languages/objective-c/objective-c.contribution.js:
monaco-editor/esm/vs/basic-languages/pascal/pascal.contribution.js:
monaco-editor/esm/vs/basic-languages/pascaligo/pascaligo.contribution.js:
monaco-editor/esm/vs/basic-languages/perl/perl.contribution.js:
monaco-editor/esm/vs/basic-languages/pgsql/pgsql.contribution.js:
monaco-editor/esm/vs/basic-languages/php/php.contribution.js:
monaco-editor/esm/vs/basic-languages/pla/pla.contribution.js:
monaco-editor/esm/vs/basic-languages/postiats/postiats.contribution.js:
monaco-editor/esm/vs/basic-languages/powerquery/powerquery.contribution.js:
monaco-editor/esm/vs/basic-languages/powershell/powershell.contribution.js:
monaco-editor/esm/vs/basic-languages/protobuf/protobuf.contribution.js:
monaco-editor/esm/vs/basic-languages/pug/pug.contribution.js:
monaco-editor/esm/vs/basic-languages/python/python.contribution.js:
monaco-editor/esm/vs/basic-languages/qsharp/qsharp.contribution.js:
monaco-editor/esm/vs/basic-languages/r/r.contribution.js:
monaco-editor/esm/vs/basic-languages/razor/razor.contribution.js:
monaco-editor/esm/vs/basic-languages/redis/redis.contribution.js:
monaco-editor/esm/vs/basic-languages/redshift/redshift.contribution.js:
monaco-editor/esm/vs/basic-languages/restructuredtext/restructuredtext.contribution.js:
monaco-editor/esm/vs/basic-languages/ruby/ruby.contribution.js:
monaco-editor/esm/vs/basic-languages/rust/rust.contribution.js:
monaco-editor/esm/vs/basic-languages/sb/sb.contribution.js:
monaco-editor/esm/vs/basic-languages/scala/scala.contribution.js:
monaco-editor/esm/vs/basic-languages/scheme/scheme.contribution.js:
monaco-editor/esm/vs/basic-languages/scss/scss.contribution.js:
monaco-editor/esm/vs/basic-languages/shell/shell.contribution.js:
monaco-editor/esm/vs/basic-languages/solidity/solidity.contribution.js:
monaco-editor/esm/vs/basic-languages/sophia/sophia.contribution.js:
monaco-editor/esm/vs/basic-languages/sparql/sparql.contribution.js:
monaco-editor/esm/vs/basic-languages/sql/sql.contribution.js:
monaco-editor/esm/vs/basic-languages/st/st.contribution.js:
monaco-editor/esm/vs/basic-languages/swift/swift.contribution.js:
monaco-editor/esm/vs/basic-languages/systemverilog/systemverilog.contribution.js:
monaco-editor/esm/vs/basic-languages/tcl/tcl.contribution.js:
monaco-editor/esm/vs/basic-languages/twig/twig.contribution.js:
monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js:
monaco-editor/esm/vs/basic-languages/typespec/typespec.contribution.js:
monaco-editor/esm/vs/basic-languages/vb/vb.contribution.js:
monaco-editor/esm/vs/basic-languages/wgsl/wgsl.contribution.js:
monaco-editor/esm/vs/basic-languages/xml/xml.contribution.js:
monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution.js:
monaco-editor/esm/vs/basic-languages/monaco.contribution.js:
monaco-editor/esm/vs/language/css/monaco.contribution.js:
monaco-editor/esm/vs/language/html/monaco.contribution.js:
monaco-editor/esm/vs/language/json/monaco.contribution.js:
monaco-editor/esm/vs/editor/editor.main.js:
  (*!-----------------------------------------------------------------------------
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Version: 0.54.0(7c2310116c57517348bbd868a21139f32454be22)
   * Released under the MIT license
   * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
   *-----------------------------------------------------------------------------*)
*/
//# sourceMappingURL=monaco-editor.js.map
